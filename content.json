{"meta":{"title":"Kuangcp Blog","subtitle":"Javaer","description":null,"author":"Kuangcp","url":"http://blog.kuangcp.top"},"pages":[{"title":"分类","date":"2018-12-13T08:24:19.664Z","updated":"2018-12-13T07:59:16.000Z","comments":true,"path":"categories/index.html","permalink":"http://blog.kuangcp.top/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-12-13T08:24:19.664Z","updated":"2018-12-13T07:59:28.000Z","comments":true,"path":"tags/index.html","permalink":"http://blog.kuangcp.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ProgramThinking","slug":"Memo-Java-AdvancedLearning-ProgramThinking","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-ProgramThinking/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-ProgramThinking/","excerpt":"","text":"目录 start 开发思想 抽象 命令式编程和响应式编程 命令式编程 响应式编程 面向过程 面向对象 OOP 面向过程和面向对象的对比 DDD 领域驱动设计 聚合 参考实践项目 数据的操作 CURD CQRS 组件模型 SOA MSA Other 国际化的配置 设计软件的方法 契约式设计 精益思想 编程习惯 晓风轻的经验 接口定义 日志建议 异常处理 工具类规范 代码质量分析 Checkstyle FindBugs 阿里巴巴的代码检查 配置文件 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 开发思想 有关开发的理论性思想,编写,测试,部署等 抽象 码农翻身:抽象：程序员必备的能力 稍微注意一下就会发现: 抽象层次越高，接口的语意就越模糊，适用的范围就越广，到最后就会变成数学模型或者概念。但是抽象成数学模型和算法通常是可遇而不可求的， 这种情况下，我们需要退而求其次，试图抽象成若干个正交的概念，来降低复杂度。你在处理x轴相关的事情时，不用考虑其他的y和z 相关的东西，因为你知道他们不会受到影响， 这样问题的复杂度就从3维一下子下降到1维！更容易把握了。如果你说了，我的整个系统还没法抽象成正交的概念， 那只好再退一步，在局部使用接口。其实 一组定义良好的接口一定是正交的，不然的话接口之间的依赖就会让实现非常麻烦。 在著名的《设计模式》一书中，其实在反复强调一点: 发现变化并且封装变化，针对接口编程而不是实现编程。 很多人看书是只关注具体的模式，而忽略了模式的本质目的。 抽象能力的高低，很大程度上反映了一个程序员的能力的高低 计算机科学中抽象的好处与问题—伪共享实例分析计算机科学中的任何问题都可以通过加上一层间接层来解决，这是很正确的，但是也正是因为一层一层的抽象和包装，导致出了问题后很难定位，你都不知道问题究竟是出现在哪一层。所以要想提高技术水平不仅要知其然（看得见最顶层的包装）也要知其所以然（看得见底层的包装），每一层如果都懂或者说了解一些，那么出了问题很大程度上都可以凭直觉定位，即使不能凭直觉也可以通过各种手段debug，只会最顶层的抽象很多时候就只能望bug兴叹了。 命令式编程和响应式编程命令式编程 编写改变状态的一条条命令 响应式编程 ReactiveX 组合异步的序列设计模式是 观察者模式的扩展, 数据结构是序列串流, 避免了并发, 是非阻塞的 数据流驱动 异步 非阻塞 不是 (同步非阻塞 : 当时不阻塞后续回调) 而是异步 多路复用 面向过程 只有数据和函数, 使用函数改变数据状态 面向对象 OO Object Oriented 参考博客: 再见面向对象编程？ 思考: 遇到需求时, 先分析需要哪些独立的实体, 然后分析用户的行为, 行为就是API 实体的基本属性和行为确定好, 并且确定好各自的生命周期(一般是属性, 状态的变化) 并且要注意设计时要尽量解耦, 即使需求上是和时间, 天气, 等一些外部状态影响的, 但是也应该在此之上抽象, 解耦, 方便测试和开发 例如 活动 具有 开始时间和结束时间 的需求, 如果只用时间去设计行为的话, 测试的时候就需要去模拟那些时间, 如果引入状态这个属性(开启,关闭) 就可以方便的调试了, 只需更改这个状态即可控制 活动 这个对象的行为, 当然, 变化的时间也是通过控制 状态 来控制 活动 的 编写出完成需求的代码不难, 难的是写出, 优雅, 简洁, 设计良好, 可读性, 扩展性高的代码 OOP 维基 OOP | 中文版 面向过程和面向对象的对比 示例 把大象塞进冰箱: 面向过程, 冰箱开门() 冰箱装进( 大象) 冰箱关门()面向对象 冰箱.开门().装入(大象).关门() 面向过程 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 缺点：没有面向对象易维护、易复用、易扩展 面向对象 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 缺点：性能比面向过程低 DDD 领域驱动设计 领域驱动设计(DDD:Domain-Driven Design)入门贴 领域驱动设计 软件核心复杂性应对之道 Eric J. Evans 在线阅读领域驱动设计精简版 参考博客 | 讨论 | 基础 参考博客: 危险的DDD聚合根 初步感受是DDD禁不起变化, 必须要在起初就设计好一个完备的体系参考博客: DDD应用的思考提出了关于领域设计的困惑 聚合聚合根的修改行为应该属于聚合根实体对象自己，用聚合根行为守护其内部状态的一致性是DDD设计核心，如果聚合根内部的状态直接暴露给外界（通过领域服务）任意修改，那么会导致状态变化混乱，难以调试和跟踪。 现在书写的这个项目就和这个理念相一致, 但是总说是OOP 没有提及DDD TODO 整个系统中涉及到的实体对象, 需要持久化的属就独立出来作为一个PO对象, 然后Spring Data JPA 接管DAO操作 然后在对象中建立 修改PO对象行为 的方法, 而不是以往 MVC 那样的设计, 业务全在Service里面, 对实体自身属性的基本操作也在Service里面 参考实践项目 enodeC#实现CQRS 数据的操作CURDCQRS www.cqrs.nuCQRS Guidesevent-sourcing| 中文版 微软关于azure的技术性文档 event-sourcing-in-practice参考博客: CQRS &amp; Event Sourcing 参考博客: 领域驱动设计的实践 – CQRS &amp; Event Sourcing 图文并茂的讲解CQRS思想 eventapisJava实现的CQRSCQRS journey 微软团队的项目 组件模型SOA 参考博客: SOA面向服务架构 Spring Web 应用的最大败笔 传统意义上的SOA 内部封装的是数据表的DTO 也被称为 失血模型,贫血模型, 从而导致SOA服务内部腐烂堵塞，违背SOA自治和可用性等原则约束 我现在使用Java的SpringMVC进行开发的东西, MVC架构, 然后JavaBean, Dao层或者JPA的Repository, Service层, Controller层, 而且还使用了好几年了 Web层负责处理用户输入，并返回正确的响应返回给用户。 web层与服务层通信。 服务层作为一个事务边界。它也负责授权和包含我们的应用程序的业务逻辑。服务层管理的域模型对象，并与其他服务和存储库层进行通信。 存储库/数据访问层负责与所使用的数据的存储进行通信。 正如这个毕业设计的项目 Graduate, 显然的都具有如上提到的各种缺陷, 每一个 DTO 只具有属性, 而没有方法, 一个DTO就要对应一个服务, 服务之间再相互注入, 就会有很有依赖, 甚至循环依赖 MSA 微服务 参考博客: SOA 与 MSA（微服务架构）码农翻身:从SOA到微服务 码农翻身:我是一个函数 详解了RPC, 也就是RMI(远程过程调用)规范的实现 微服务 MSA Other国际化的配置 将配置文件按语言分别配置 然后在加载时设定语言的配置, 然后加载对应文件夹下的配置文件 设计软件的方法契约式设计 Design by Contract (Dbc) 百度百科解释 精益思想 持续集成、持续交付、持续部署 编程习惯晓风轻的经验 知乎专栏-程序员你为什么这么累？ | 该专栏对应的源码 | 个人站点版, 更为方便 接口定义 Controller规范 日志建议 异常处理规范 参数校验和国际化规范 工具类规范 函数编写建议 配置文件的定义 [ ] 详细的阅读 接口定义 先有统一的接口定义规范，然后有AOP实现。先有思想再有技术。 现在知道为什么要返回统一的一个ResultBean了： 为了统一格式 为了应用AOP 为了包装异常信息 日志建议异常处理 所以，我对开发人员的要求就是，绝大部分场景，不允许捕获异常，不要乱加空判断。只有明显不需要关心的异常，如关闭资源的时候的io异常，可以捕获然后什么都不干，其他时候，不允许捕获异常，都抛出去，到controller处理。空判断大部分时候不需要，你如果写了空判断，你就必须测试为空和不为空二种场景，要么就不要写空判断。 强调，有些空判断是要的，如：参数是用户输入的情况下。但是，大部分场景是不需要的（我们的IT系统里面，一半以上不需要），如参数是其它系统传过来，或者其他地方获取的传过来的，99.99%都不会为空，你判断来干嘛？就抛一个空指针到前台怎么啦？何况基本上不会出现。 总结： 开发组长定义好异常，异常继承RuntimeException。 不允许开发人员捕获异常。（异常上对开发人员就这点要求！异常都抛出到controller上用AOP处理） 后台（如队列等）异常一定要有通知机制，要第一时间知道异常。 少加空判断，加了空判断就要测试为空的场景！ 工具类规范 方法参数要抽象(尽量往上找到父类和接口), 返回值要具体 隐藏实现: 不要在业务代码中直接调用三方工具, 应该自己写一个类, 然后调用三方库的方法, 方便以后修改 多使用重载编写功能齐全的对外接口和方法 单独存放, 单独维护, 优先使用组合而不是继承, 继承破坏了封装性, 因为父类的很多细节对子类是可见的, 父类的变化可能极大的影响子类面向接口编程, 而不是实现编程 代码质量分析 测试对代码的覆盖率 代码的格式是否清晰，有助于差异比较和可读性 是否很可能会出现NPE 是否忘记了域对象中的equals和hashCode方法 CheckstyleFindBugs阿里巴巴的代码检查 配置文件千万业务代码里面不要和读取配置的代码耦合在一起。切记！","categories":[{"name":"Engineering","slug":"Engineering","permalink":"http://blog.kuangcp.top/categories/Engineering/"}],"tags":[]},{"title":"AlibabaJavaStandard.md","slug":"Memo-Java-AlibabaJavaStandard","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Java-AlibabaJavaStandard/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AlibabaJavaStandard/","excerpt":"","text":"目录 start 阿里巴巴Java开发手册 编程规约 命名规约 常量定义 代码格式 OOP规约 集合处理 并发处理 控制语句 注释规约 其他 异常日志 异常处理 日志规约 单元测试 安全规约 MySQL规约 建表规约 索引规约 SQL规约 ORM映射 工程规约 应用分层 二方库依赖 服务器规约 专有名词 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 阿里巴巴Java开发手册 Github: p3c含该手册PDF GitBook等版本 | 《阿里巴巴Java开发手册》详尽 FindBugs、PMD和CheckStyle对比 编程规约命名规约强制 所有命名不能以美元符和下划线开始和结束 禁止拼音混合英文, 更不允许直接使用中文的方式。 正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。 类名用UpperCamelCase风格 但以下情形例外: DO / BO / DTO / VO / AO / PO / UID 例如: UserDO 方法名、参数名、成员变量、局部变量 都统一使用 lowerCamelCase风格 常量名全部大写, 下划线隔开, 力求语义表达完整清楚, 不要嫌名字长(枚举类中的也是)。 抽象类使用Abstract或者Base开头, 异常类使用Exception结尾 测试类命名以它要测试的类的名称开始，以Test结尾 数组定义 String[] name 而不是 String name[] POJO 类中布尔类型的变量不能is开头, 否则部分框架解析会引起序列化错误。 包名统一使用小写, 点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式, 但是类名如果有复数含义, 类名可以使用复数形式。 正例: 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（ 此规则参考spring 的框架结构） 杜绝完全不规范的缩写, 避免望文不知义。 反例: AbstractClass“ 缩写” 命名成 AbsClass; condition“ 缩写” 命名成 condi, 此类随意缩写严重降低了代码的可阅读性。 推荐 为了达到代码自解释的目标, 任何自定义编程元素在命名时, 使用尽量完整的单词组合来表达其意。 正例: 从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。 如果使用到了设计模式, 建议在类名中体现出具体模式。将设计模式体现在名字中, 有利于阅读者快速理解架构设计理念LoginProxy 接口类中的方法和属性不要加任何修饰符号（ public 也不要加） , 保持代码的简洁性, 并加上有效的 Javadoc 注释。 尽量不要在接口里定义变量, 如果一定要定义变量, 肯定是与接口方法相关, 并且是整个应用的基础常量。 接口和实现类的命名有两套规则 强制 对于 Service 和 DAO 类, 基于 SOA 的理念, 暴露出来的服务一定是接口, 内部的实现类用 Impl 的后缀与接口区别。 正例: CacheServiceImpl 实现 CacheService 接口。 推荐 如果是形容能力的接口名称, 取对应的形容词做接口名 （ 通常是–able 的形式）。 正例: AbstractTranslator 实现 Translatable。 参考 枚举类名建议带上 Enum 后缀, 枚举成员名称需要全大写, 单词间用下划线隔开。 说明: 枚举其实就是特殊的常量类, 域成员均为常量, 且构造方法被默认强制是私有。 正例: 枚举名字为 ProcessStatusEnum 的成员名称: SUCCESS或者UNKOWN_REASON MVC各层命名规约 Service/Dao层 获取单个对象 get 做前缀 获取多个对象 list, 复数形式结尾 获取统计值的方法 count 插入 save 删除 remove 修改 update 领域模型 数据对象 xxxDO xxx是数据表名 数据传输对象 xxxDTO xxx是业务领域相关的名称 展示对象 xxxVO xxx是网页名称 使用了模板框架 POJO是 DO DTO BO VO 统称, 禁止命名为 xxxPOJO 有关这些缩写的详细说明 详细定义和解释 Tomcat组织推荐的代码风格 使用空格进行缩进, 而不是制表符 用于 Java 源的100个字符行宽度, 用于文档源（.txt, .xml）的80个字符行宽度 Java 源代码: {在行末, 4个空格缩进 XML 源文件: 2个空格缩进 常量定义强制 不允许出现魔法值(未经定义的常量)直接出现 long 或者 Long 初始赋值时, 使用大写的 L , 不能是小写的 l, 小写容易跟数字 1 混淆, 造成误解 不要使用一个常量类维护所有的常量, 应该按常量的功能, 进行归类, 分开维护. 大而全的常量类, 只能用搜索 才能快速定位, 不利于理解和维护 例如 缓存相关常量放在类 CacheConsts 下; 系统配置相关常量放在类 ConfigConsts 下 常量的复用层次的安排 跨应用共享常量 : 二方库中 通常是client.jar中的constant目录下 应用内共享常量 : 一方库的modules中的constant目录下 易懂变量也要统一定义成 应用内共享变量, 比如两个开发者在两个模块定义了相同含义的常量, 但是值却不一样, 这样就很容易埋下隐患 子工程内共享常量 : 当前子工程的constant目录下 包内共享常量: 当前包下单独的constant目录下 类内共享常量: 直接在类内部 private static final 定义 推荐 如果变量值仅在一个范围内变化, 且带有名称之外的延伸属性, 定义为枚举类。下面正例中的数字就是延伸信息, 表示星期几。 public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6),SUNDAY(7);} 枚举类的定义 不能直接使用枚举的 ordinal() 作为枚举常量的值在程序中使用, 而应该自己定义一个变量, ordinal 方法的Javadoc上也有说明 Most programmers will have no use for this method. It is designed for use by sophisticated enum-based data structures, such as EnumSet and EnumMap 代码格式强制 大括号约定: 如果是大括号内为空, 则简洁地写成{}即可, 不需要换行; 如果是非空代码块则: 左大括号前不换行, 左大括号后换行。 右大括号前换行, 右大括号后还有 else 等代码则不换行; 表示终止的右大括号后必须换行。 小括号和字符之间不出现空格; 反例: if (空格 a == b 空格) if/for/while/switch/do等保留字与括号之间必须加空格. 任何二目、 三目运算符的左右两边都需要加一个空格。 缩进采用4个空格(Google的风格是两个空格), 而不是tab字符, 对应的IDE要调整一下 注释的双斜线与注释内容之间有且仅有一个空格。 // 注释 单行字符不超过120个, 超出需换行: 第二行比第一行缩进4个空格, 第三行以后就和第二行平齐就可以了 运算符与下文一起换行 方法调用的点符号与下文一起换行 调用方法 多个参数, 需在逗号后进行换行 括号之前不要换行 方法参数在定义和传入时, 多个参数逗号后边必须加空格 : method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); 文件编码统一采用UTF-8 IDE中换行符采用Unix格式(LF) 使用别的编码的话会开心死的 推荐 方法体内执行语句组, 变量的定义语句组, 不同的业务逻辑之间或者不同的语义之间插入一个空行, 相同业务逻辑和语义之间不需要插入空行 也没必要插入多个空行进行分隔 没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。(很傻的做法) 123public int a = 1; public String b = 2; public float c = 2.0; OOP规约强制 避免使用一个类的对象来引用该类的静态变量或静态方法。无谓增加编译器解析成本, 直接用类名来访问即可。 所有的覆写方法, 必须加 @Override 注解 例如 getObject() 与 get0bject() 的问题, 前者是字母o,后者是数字0 通过使用覆盖的注解, 可以准确判断是否覆盖成功 另外, 如果在抽象类中对方法签名进行修改, 其实现类 会立即编译报错 相同参数类型, 相同业务含义, 才可以使用Java的可变参数, 避免使用Object. 说明: 可变参数必须放置在参数列表的最后。 提倡尽量不用可变参数编程 正例: public User getUsers(String type, Integer... ids) {...} 外部正在调用或者二方库依赖的接口, 不允许修改方法签名, 避免对接口调用方产生影响。 接口过时必须加 @Deprecated 注解, 并清晰地说明采用的新接口或者新服务是什么。 不能使用过时的类或方法 说明: java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时, 应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口, 那么有义务同时提供新的接口; 作为调用方来说, 有义务去考证过时方法的新实现是什么。 Object 的 equals 方法容易抛空指针异常, 应使用常量或确定有值的对象来调用equals。 使用&quot;t&quot;.equals(test)方式 推荐使用java.util.Object.equals (jdk7引入的工具类) 所有的相同类型的包装类对象之间的 值的比较 , 全部使用equals方法比较, 注意: 对于 Integer var = ? 在 -128 至 127 范围内的赋值, Integer 对象是在IntegerCache.cache 产生, 会复用已有对象, 这个区间内的 Integer 值可以直接使用 == 进行判断, 但是这个区间之外的所有数据, 都会在堆上产生, 并不会复用已有对象, 所以 == 就会失效 这是一个大坑！, 推荐统一使用 equals 方法进行判断 关于基本数据类型与包装数据类型的使用标准如下: 所有的 POJO 类属性必须使用包装数据类型。 RPC 方法的 返回值 和 参数 必须使用包装数据类型 所有的局部变量 推荐使用基本数据类型 说明: POJO 类属性没有初值是提醒使用者在需要使用时, 必须自己显式地进行赋值, 任何NPE 问题, 或者入库检查, 都由使用者来保证。 数据库的查询结果可能是 null, 因为自动拆箱, 用基本数据类型接收有 NPE 风险。 反例: 比如显示成交总额涨跌情况, 即正负 x%, x 为基本数据类型, 调用的 RPC 服务, 调用不成功时, 返回的是默认值, 页面显示为 0%, 这是不合理的, 应该显示成中划线。所以包装数据类型的 null 值, 能够表示额外的信息 如: 远程调用失败, 异常退出。 定义 DO/DTO/VO等POJO类时, 不要给任何成员属性设定 默认值 反例: POJO 类的 createTime属性 默认值为 new Date(); 但是这个属性在数据提取时并没有置入具体值, 在更新其它字段时又附带更新了此字段, 导致创建时间被修改成当前时间。 序列化类新增属性时, 不要修改serialVersionUID字段, 避免反序列化失败 如果完全不兼容升级, 为了避免反序列化混乱, 就需要修改serialVersionUID的值 (idea可以配置使用快捷键自动生成) 说明: 当 serialVersionUID 不一致会抛出序列化运行时异常。 构造方法里面禁止加入任何业务逻辑, 如果有初始化逻辑, 请放在 init 方法中。 POJO 类必须写 toString 方法。 如果继承了另一个 POJO 类, 注意在前面加一下 super.toString() lombok解救众生 说明: 在方法执行抛出异常时, 可以直接调用 POJO 的 toString()方法打印其属性值, 便于排查问题 推荐 使用索引访问用 String 的 split 方法得到的数组时, 需做最后一个分隔符后有无内容的检查, 否则会有 IndexOutOfBoundsException 的风险。 System.out.println(&quot;a,b,c,,&quot;.split(&quot;,&quot;).length); 预期是大于3,结果却是3 当一个类有多个构造方法, 或者多个同名方法, 这些方法应该按顺序放置在一起, 优于下条规则 类内方法的定义顺序依次是 共有方法或保护方法 -&gt; 私有方法 -&gt; setter/getter方法(lombok可省) 公有方法是类的调用者和维护者最关心的方法, 首屏展示最好; 保护方法虽然只是子类关心, 也可能是 模板设计模式 下的核心方法; 而私有方法外部一般不需要特别关心, 是一个黑盒实现; 因为承载的信息价值较低, 所有 Service 和 DAO 的 getter/setter 方法放在类的最后, 用了lombok就省去了。 setter 方法中, 参数名称与类成员变量名称一致, this.成员名 = 参数名。 在getter/setter 方法中, 不要增加业务逻辑, 增加排查问题的难度。 循环体中的字符串的连接方式, 使用StringBuffer的append方法进行扩展 说明: 反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象, 然后进行 append 操作, 最后通过 toString 方法返回 String 对象, 造成内存资源浪费。 验证循环中String的拼接 12345678910public class test&#123; public void test()&#123; String target = \"1\"; for(int a=0; a&lt;10; a++)&#123; target += a; &#125; &#125;&#125;// 1. javac test.java 编译// 2. javap -c -l test 反编译, 就能大致看到new StringBuilder了 final 可以声明类、成员变量、方法、以及本地变量, 下列情况使用 final 关键字: 不允许被继承的类, 如: String 类。 不允许修改引用的域对象, 如: POJO 类的域变量。 不允许被重写的方法, 如: POJO 类的 setter 方法。 不允许运行过程中重新赋值的局部变量。 避免上下文重复使用一个变量, 使用 final 描述可以强制重新定义一个变量, 方便更好地进行重构。 这里就隐含了一个习惯, 不应该把一个变量到处传, 到处用,赋值, 很难追踪调试 慎用Object的clone方法来拷贝对象 详见API 说明: 对象的 clone 方法默认是浅拷贝, 最好重写该方法, 实现属性对象的拷贝。 类成员与方法访问控制从严: 如果不允许外部直接通过 new 来创建对象, 那么构造方法显式声明并 private 工具类 不允许有 public 或 default 的构造方法 类非static成员变量 或者 成员方法 若 只与 子类共享, 必须是 protected 成员属性或方法 若 仅 本类中使用, 必须是 private 若是static成员变量, 必须考虑是否final 类static 成员变量如果仅在本类使用, 必须是 private。 注意 说明: 任何类、方法、参数、变量, 都需要严控访问范围。过于宽泛的访问范围, 不利于模块解耦。 思考: 如果是一个 private 的方法, 想删除就删除, 可是一个 public 的 service 方法, 或者一个 public 的成员变量, 删除一下, 不得手心冒点汗吗？ 变量像自己的小孩, 尽量在自己的视线内, 变量作用域太大, 无限制的到处跑, 那么你会担心的。 集合处理强制 关于 hashCode 和 equals 的处理, 遵循如下规则: 只要重写 equals, 就必须重写 hashCode 因为 Set 存储的是不重复的对象, 依据 hashCode 和 equals 进行判断, 所以 Set 存储的方法必须重写这两个方法 如果自定义对象作为 Map 的键, 那么必须重写 hashCode 和 equals 说明: String 重写了 hashCode 和 equals 方法, 所以我们可以非常愉快地使用 String 对象作为 key 来使用。 ArrayList 的 subList 结果不可强转成 ArrayList 否则会抛出 ClassCastException异常, 即 java.util.RandomAccessSubList cannot be cast to java.util.ArrayList. 说明: subList返回的是 ArrayList 的内部类 SubList, 并不是ArrayList, 而是ArrayList的一个视图, 对于SubList的所有操作最终都会反映到原列表上 在 subList 场景中, 高度注意对原集合元素 个数的修改, 会导致子列表的 遍历、增加、删除 均会产生 ConcurrentModificationException 使用集合转数组的方法, 必须使用集合的 toArray(T[] array) , 传入的是类型完全一样的数组, 数组大小就是 list.size() 使用 toArray 带参方法, 入参分配的数组空间不够大时, toArray 方法内部将重新分配内存空间, 并返回新数组地址, 原数组不做更改; 如果数组元素大于实际所需, 下标超出的数组元素将被置为 null, 其它数组元素保持原值, 因此最好将方法入参数组大小定义与集合元素个数一致。 注意 直接使用 toArray 无参方法存在问题, 此方法返回值只能是 Object[]类, 若强转其它类型数组将出现 ClassCastException 错误。 把数组转换成集合: 使用工具类Arrays.asList()时, 不能使用其修改集合相关的方法, 其add/remove/clear方法会抛出UnsupportedOperationException异常。 因为 asList 的返回对象是一个继承于 AbstractList 的内部类 Arrays, 实现集合的那些修改方法时 都是直接抛出异常 Arrays.asList体现的是适配器模式, 只是转换接口, 后台的数据仍是固定长度的数组。 案例: String[] str = new String[] { &quot;a&quot;, &quot;b&quot; }; List list = Arrays.asList(str); 第一种情况: list.add(&quot;c&quot;); 运行时异常。 第二种情况: str[0]= &quot;gujin&quot;; 那么 list.get(0) 也会随之修改。 泛型通配符&lt;? extends T&gt;来接收返回的数据, 此写法的泛型集合不能使用 add 方法。 而&lt;? super T&gt;不能使用 get 方法, 做为接口调用赋值时易出错。 说明: 扩展说一下 PECS(Producer Extends Consumer Super)原则: 第一、 频繁往外读取内容的, 适合用&lt;? extends T&gt;。 第二、 经常往里插入的, 适合用&lt;? super T&gt;。 说明: 苹果装箱后返回一个&lt;? extends Fruits&gt;对象, 此对象就不能往里加任何水果, 包括苹果。 不要在 foreach 循环里进行元素的 remove/add 操作。 remove 元素请使用 Iterator方式, 如果并发操作, 需要对 Iterator 对象加锁。 正例: 1234567Iterator&lt;String&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; String item = iterator.next(); if (删除元素的条件) &#123; iterator.remove(); &#125;&#125; 反例: 12345678List&lt;String&gt; a = new ArrayList&lt;String&gt;();list.add(\"1\");list.add(\"2\");for (String item : list) &#123; if (\"1\".equals(item)) &#123; list.remove(item); &#125;&#125; 说明: 以上代码的执行结果肯定会出乎大家的意料, 那么试一下把“1”换成“2”, 会是同样的结果吗？ 在 JDK7 版本以上, Comparator 要满足自反性, 传递性, 对称性, 不然 Arrays.sort , Collections.sort 会报 IllegalArgumentException 1 ） 自反性: x , y 的比较结果和 y , x 的比较结果相反。 2 ） 传递性: x &gt; y , y &gt; z ,则 x &gt; z 。 3 ） 对称性: x = y ,则 x , z 比较结果和 y , z 比较结果相同。 反例: 下例中没有处理相等的情况, 实际使用中可能会出现异常: 123456new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getId() &gt; o2.getId() ? 1 : -1; &#125;&#125;; 推荐 集合初始化时, 尽量指定集合初始容量值。 HashMap 使用 HashMap(int initialCapacity) 初始化 正例: initialCapacity=(需要存储的元素个数/负载因子)+1。注意负载因子（即 loaderfactor）默认为0.75 如果暂时无法确定初始值大小, 请设置为 16（即默认值） 。 反例: HashMap 需要放置 1024 个元素, 由于没有设置容量初始大小, 随着元素不断增加, 容量7次被迫扩大, resize 需要重建 hash 表, 严重影响性能。 使用 entrySet 遍历 Map 类集合 KV , 而不是 keySet 方式进行遍历 keySet 其实是遍历了 2 次, 一次是转为 Iterator 对象, 另一次是从 hashMap 中取出key 所对应的 value 。 而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中, 效率更高。 如果是 JDK8, 使用 lambda 的 foreach 方法。 说明: values() 返回的是V值集合, 是一个 list 集合对象; keySet()返回的是K值集合, 是一个 Set集合对象;entrySet()返回的是 K - V 值组合集合。 高度注意 Map 类集合 K/V 能不能存储 null 值的情况, 如下表格: 反例: 由于 HashMap 的干扰, 很多人认为 ConcurrentHashMap 是可以置入 null 值, 而事实上, 存储 null 值时会抛出 NPE 异常。 | 集合类 | Key | Value | Super | 说明 || — | — | — | — | — ||Hashtable|! NULL|! NULL|Dictionary|线程安全||ConcurrentHashMap|! NULL|! NULL|AbstractMap|锁分段技术（ JDK8:CAS）||TreeMap|! NULL|NULL|AbstractMap|线程不安全||HashMap|NULL|NULL|AbstractMap|线程不安全| 合理利用好集合的有序性 (sort) 和稳定性 (order) , 避免集合的无序性 (unsort) 和不稳定性 (unorder) 带来的负面影响。 稳定性指集合每次遍历的元素次序是一定的。 有序性是指遍历的结果是按某种比较规则依次排列的。 如: ArrayList 是 order / unsort; HashMap 是 unorder/unsort; TreeSet 是 order / sort 。 利用 Set元素唯一的特性, 可以快速对一个集合进行去重操作, 避免使用 List的contains 方法进行遍历、对比、去重操作。 OrderSet也是一个很重要的类 并发处理强制 获取单例对象需要保证线程安全, 其中的方法也要保证线程安全。 资源驱动类、工具类、单例工厂类都需要注意。 创建线程或线程池时请指定有意义的线程名称, 方便出错时回溯。 线程资源必须通过线程池提供, 不允许在应用中自行显式创建线程。 使用线程池的好处是减少在创建和销毁线程上所花的时间, 以及系统资源的开销,解决资源不足的问题, 如果不使用线程池, 有可能造成系统创建大量同类线程而导致消耗完内存或者 过度切换 的问题 线程池不允许使用 Executors 去创建, 而是通过 ThreadPoolExecutor 的方式, 这样的处理方式让写的同学更加明确线程池的运行规则, 规避资源耗尽的风险。 Executors 返回的线程池对象的弊端如下: FixedThreadPool 和 SingleThreadPool : 允许的请求队列长度为 Integer.MAX_VALUE , 可能会堆积大量的请求, 从而导致 OOM 。 CachedThreadPool 和 ScheduledThreadPool : 允许的创建线程数量为 Integer.MAX_VALUE , 可能会创建大量的线程, 从而导致 OOM 。 SimpleDateFormat 是线程不安全的类, 一般不要定义为 static 变量, 如果定义为static , 必须加锁, 或者使用 DateUtils 工具类。 如果是 JDK 8 的应用, 可以使用 Instant 代替 Date , LocalDateTime 代替 Calendar , DateTimeFormatter 代替 Simpledateformatter , 官方给出的解释: simple beautiful strongimmutable thread - safe 。 或者如下处理实例化 123456private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123; @Override protected DateFormat initialValue() &#123; return new SimpleDateFormat(\"yyyy-MM-dd\"); &#125; &#125;; 高并发时, 同步调用应该去考量锁的性能损耗。 能用无锁数据结构, 就不要用锁 ; 能锁区块, 就不要锁整个方法体 ; 能用对象锁, 就不要用类锁。 尽可能使得加锁的代码块工作量尽可能的小, 避免在锁代码块中调用 RPC 方法; 对多个资源、数据库表、对象同时加锁时, 需要保持一致的加锁顺序, 否则可能会造成死锁。 线程一需要对表 A 、 B 、 C 依次全部加锁后才可以进行更新操作, 那么线程二的加锁顺序也必须是 A 、 B 、 C , 否则可能出现死锁。 并发修改同一记录时, 避免更新丢失, 要么在应用层加锁, 要么在缓存加锁, 要么在数据库层使用乐观锁, 使用 version 作为更新依据。 如果每次访问冲突概率小于 20%, 推荐使用乐观锁, 否则使用悲观锁。乐观锁的重试次数不得小于 3 次。 多线程并行处理定时任务时, Timer 运行多个 TimeTask 时, 只要其中之一没有捕获抛出的异常, 其它任务便会自动终止运行 使用 ScheduledExecutorService 则没有这个问题。 推荐 使用 CountDownLatch 进行异步转同步操作, 每个线程退出前必须调用 countDown方法, 线程执行代码注意 catch 异常, 确保 countDown 方法被执行到, 避免主线程无法执行至 await 方法, 直到超时才返回结果。 注意, 子线程抛出异常堆栈, 不能在主线程 try - catch 到。 避免 Random 实例被多线程使用, 虽然共享该实例是线程安全的, 但会因竞争同一 seed 导致的性能下降。 Random 实例包括 java.util.Random 的实例或者 Math.random() 实例。 在JDK7之后, 可以直接使用 TreadLocalRandom, 而在JDK7以前, 需要编码保证每个线程持有一个实例 在并发场景下, 通过双重检查锁 （double - checked locking） 实现延迟初始化的优化问题隐患 可参考 The “Double - Checked Locking is Broken” Declaration , 推荐问题解决方案中较为简单一种 （ 适用于 JDK 5 及以上版本 ） , 将目标属性声明为 volatile 型 。 volatile 解决多线程内存不可见问题。对于一写多读, 是可以解决变量同步问题 但是如果多写, 同样无法解决线程安全问题。如果是 count++ 操作, 使用如下类实现: AtomicInteger count = new AtomicInteger(); count . addAndGet( 1 ); 如果是 JDK 8, 推荐使用 LongAdder 对象, 比 AtomicLong 性能更好 （ 减少乐观锁的重试次数 ） 。 HashMap 在容量不够进行 resize 时由于高并发可能出现死链, 导致 CPU 飙升, 在开发过程中可以使用其他数据结构或加锁来规避此风险。 ThreadLocal 无法解决共享对象的更新问题, ThreadLocal 对象建议使用 static 修饰。 这个变量是针对一个线程内所有操作共有的, 所以设置为静态变量, 所有此类实例共享此静态变量, 也就是说在类第一次被使用时装载, 只分配一块存储空间, 所有此类的对象 ( 只要是这个线程内定义的 ) 都可以操控这个变量。 控制语句强制 在一个 switch 块内, 每个 case 要么通过 break/return 等来终止, 要么注释说明程序将继续执行到哪一个 case 为止 ; 在一个 switch 块内, 都必须包含一个 default 语句并且放在最后, 即使它什么代码也没有。 在 if/else/for/while/do 语句结构中必须使用大括号, 即使只有一行代码 推荐 表达异常的分支时, 少用 if-else 的方式, 这种方式可以改写: 逻辑上超过 3 层的 if-else 代码可以使用卫语句, 状态模式, 策略模式来实现123456789101112// 卫语句就是将错误情况提前返回public void today()&#123; if(isBusy())&#123; System.out.println(\"change time.\"); return; &#125; if(isFree())&#123; ... return; &#125; ....&#125; 除常用方法（如 getXxx/isXxx）等外, 不要在条件判断中执行其它复杂的语句 并且将复杂逻辑判断的结果赋值给一个有意义的布尔变量名, 以提高可读性。 很多 if 语句内的逻辑判断都是相当复杂, 不能一眼看出在判断什么, 需要停顿,分析一下表达式才能理解 if 语句存在的意义 如果有个boolean变量接收, 变量名就起到了注释的作用123456// 正例final boolean existed = (file.open(fileName, \"w\") != null) &amp;&amp; (...) || (...);if(existed)&#123;...&#125;// 反例if ((file.open(fileName, \"w\") != null) &amp;&amp; (...) || (...);)&#123;...&#125; 循环体中的语句要考量性能, 以下操作尽量移至循环体外处理, 如定义对象、变量、获取数据库连接 进行不必要的 try-catch 操作 (需要考虑这个 try-catch 是否可以移至循环体外而不影响逻辑)。 接口入参保护, 这种场景常见的是用于做批量操作的接口。 方法中 必须 进行参数校验的场景: 调用频次低的方法。 执行时间开销很大的方法. 此情形中,参数校验时间几乎可以忽略不计, 但如果因为参数错误导致中间执行回退, 或者错误, 那得不偿失。 需要极高稳定性和可用性的方法。 对外提供的开放接口, 不管是 RPC/API/HTTP 接口。 敏感权限入口。 方法中 不需要 参数校验的场景: 极有可能被循环调用的方法, 不建议对参数进行校验。但在方法说明里必须注明外部参数检查要求。 底层的方法调用频度都比较高。毕竟是像纯净水过滤的最后一道, 参数错误不太可能到底层才会暴露问题。 一般 DAO 层与 Service层都在同一个应用中, 部署在同一台服务器中, 所以 DAO 的参数校验, 可以省略。 被声明成 private 只会被自己代码所调用的方法, 如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题, 此时可以不校验参数。 注释规约强制 类、类属性、类方法的注释必须使用 Javadoc 规范, 使用 /* 内容 / 格式, 不得使用 // xxx 方式。 为了能在IDE中快速查看注释 所有的抽象方法 （包括接口中的方法） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外, 还必须指出该方法做什么事情, 实现什么功能。 并且声明 对子类的实现要求, 或者调用注意事项 所有的类都必须添加创建者和创建日期。 方法内部单行注释, 在被注释语句上方另起一行, 使用//注释(而不是行尾注释)。方法内部多行注释使用 / / 注释, 注意与代码对齐。 所有的枚举类型字段必须要有注释, 说明每个数据项的用途。 推荐 与其“半吊子”英文来注释, 不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。 反例: TCP连接超时 解释成 传输控制协议连接超时, 反而更难以理解 代码修改的同时, 注释也要进行相应的修改, 尤其是参数、返回值、异常、核心逻辑等的修改。 代码与注释更新不同步, 就像路网与导航软件更新不同步一样, 如果导航软件严重滞后, 就失去了导航的意义。 谨慎注释掉代码, 尽量要配合说明, 而不是简单的注释掉, 如果无用, 则删除即可 代码被注释掉有两种可能性: 后续会恢复此段代码逻辑, 若无注释,难以知晓注释动机 永久不用: 建议直接删除, 仓库有历史记录的 对于注释的要求: 第一、能够准确反应设计思想和代码逻辑 第二、能够描述业务含义, 使别的程序员能够迅速了解到代码背后的信息。 完全没有注释的大段代码对于阅读者形同天书, 注释是给自己看的, 即使隔很长时间, 也能清晰理解当时的思路 ; 注释也是给继任者看的, 使其能够快速接替自己的工作。 好的命名、代码结构是自解释的, 注释力求精简准确、表达到位。避免出现注释的一个极端:过多过滥的注释, 代码的逻辑一旦修改, 修改注释是相当大的负担。 特殊注释标记, 请注明标记人与标记时间。注意及时处理这些标记, 通过标记扫描, 经常清理此类标记。 线上故障有时候就是来源于这些标记处的代码。 待办事项 (TODO) : 标记人, 标记时间, [ 预计处理时间 ] 表示需要实现, 但目前还未实现的功能。这实际上是一个 Javadoc 的标签, 目前的 Javadoc还没有实现, 但已经被广泛使用。只能应用于类, 接口和方法 （ 因为它是一个 Javadoc 标签 ） 。 错误, 不能工作 （FIXME） : 标记人, 标记时间, [ 预计处理时间 ] 在注释中用 FIXME 标记错误的代码, 不能工作, 需要及时纠正的情况。 其他强制 在使用正则表达式时, 利用好其预编译功能, 可以有效加快正则匹配速度。 不要在方法体内定义: Pattern pattern = Pattern.compile( 规则 ); velocity 调用 POJO 类的属性时, 建议直接使用属性名取值即可, 模板引擎会自动按规范调用 POJO 的 getXxx() , 如果是 boolean 基本数据类型变量 （boolean 命名不需要加 is前缀 ） , 会自动调用 isXxx() 方法。 注意 如果是 Boolean 包装类对象, 优先调用 getXxx() 的方法。 后台输送给页面的变量必须加 $!{var} ——中间的感叹号。 如果 var 为 null 或者不存在, 那么 ${var} 会直接显示在页面上。 注意 Math.random() 这个方法返回是 double 类型, 注意取值的范围 0 &lt;= x &lt;1 （ 能够取到零值, 注意除零异常 ） , 如果想获取整数类型的随机数, 不要将 x 放大 10 的若干倍然后取整, 直接使用 Random 对象的 nextInt 或者 nextLong 方法。 获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime(); 如果想获取更加精确的纳秒级时间值, 用 System.nanoTime(), 在 JDK8 中, 针对统计时间等场景, 推荐使用 Instant 类。 推荐 尽量不要在视图模板中加入变量声明、逻辑运算符, 更不要加入任何复杂的逻辑。 根据MVC理论, 视图的原则是展示, 不要抢模板和控制器的活 任何数据结构的构造或初始化, 都应指定大小, 避免数据结构无限增长吃光内存。 及时清理不再使用的代码段或配置信息, 避免程序过度臃肿, 代码冗余 对于暂时被注释掉, 后续可能恢复使用的代码片段, 在注释代码上方, 统一规定使用三个斜杠来说明注释掉代码的理由 异常日志异常处理强制 Java类库中定义的一类 RuntimeException 可以通过预先检查进行规避, 而不应该通过 catch 来处理 比如 IndexOutOfBoundsException NullPointerException 等等. 无法通过预检查的异常除外, 如在解析一个外部传来的字符串形式的数字时, 通过 catch NumberFormatException 来实现 正例: if (obj != null){…} 反例: try{obj.method()} catch(NullPointerException e){…} 异常不要用来做流程控制, 条件控制, 因为异常的处理效率比条件分支低. 对大段代码进行 try-catch, 这是不负责任的表现。 catch 时请分清稳定代码和非稳定代码, 稳定代码指的是无论如何不会出错的代码。 对于非稳定代码的 catch 尽可能进行区分异常类型, 再做对应的异常处理。 但是! 新手来说,分不清稳不稳定, 最好用大 try 块, 避免有异常遗漏没有处理 捕获异常是为了处理它, 不要捕获了却什么都不处理而抛弃之, 如果不想处理它, 请将该异常抛给它的调用者。 最外层的业务使用者, 必须处理异常, 将其转化为用户可以理解的内容。 有 try 块放到了事务代码中, catch 异常后, 如果需要回滚事务, 一定要注意手动回滚事务。 finally 块必须对资源对象、流对象进行关闭, 有异常也要做 try-catch 。 对于 JDK7及以上, 可以使用 try-with-resources 方式。 不能在 finally 块中使用 return , finally 块中的 return 返回后方法结束执行, 不会再执行 try 块中的 return 语句。 ? try 还没走完就进了 finally ? 捕获与抛出的异常, 必须是完全匹配, 或者捕获的异常是抛出的异常的父类。 说明: 如果预期对方抛的是绣球, 实际接到的是铅球, 就会产生意外情况。 推荐 方法的返回值可以为 null, 不强制返回空集合, 或者空对象等, 必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。 本规约明确 防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象, 对调用者来说, 也并非高枕无忧, 必须考虑到远程调用失败, 运行时异常等场景返回 null 的情况。 防止 NPE, 是程序员的基本修养, 注意 NPE 产生的场景: 返回类型为基本数据类型, return包装类型的对象时, 自动拆箱有可能产生 NPE. 反例: public int f() { return Integer对象}; 如果为 null , 自动拆箱将抛出 NPE 数据库的查询结果可能为 null 集合里的元素即使 isNotEmpty , 取出的数据元素也可能为 null 远程调用返回对象时, 一律要求进行 NPE 检查 对于 Session 中获取的数据, 建议 NPE 检查 级联调用 obj.getA().getB().getC(); 一连串调用, 易产生 NPE 在代码中使用“抛异常”还是“返回错误码” 对于公司外的 http/api 开放接口必须使用“错误码”; 而应用内部推荐异常抛出; 跨应用间 RPC 调用优先考虑 使用 Result 方式, 封装 isSuccess()方法, “错误码”, “错误简短信息”。 关于 RPC 方法返回方式使用 Result 方式的理由: 使用抛异常返回方式, 调用方如果没有捕获到就会产生运行时错误。 如果不加栈信息, 只是 new 自定义异常, 加入自己的理解的 error message, 对于调用端解决问题的帮助不会太多 如果加了栈信息, 在频繁调用出错的情况下, 数据序列化和传输的性能损耗也是问题。 定义时区分 unchecked/checked 异常, 避免直接抛出 RuntimeException, 更不允许抛出 Exception 或者 Throwable, 应使用有业务含义的自定义异常 推荐业界已定义过的自定义异常, 如: DAOException / ServiceException 等。 避免出现重复的代码 （Don ’ t Repeat Yourself） , 即 DRY 原则。 随意复制和粘贴代码, 必然会导致代码的重复, 在以后需要修改时, 需要修改所有的副本, 容易遗漏。必要时抽取共性方法, 或者抽象公共类, 甚至是组件化. 正例: 一个类中有多个public方法, 都需要进行数行相同的参数校验操作, 这个时候请抽取: private boolean checkParam(DTO dto){...} 日志规约强制 应用中不可直接使用日志系统 （Log4j, Logback） 中的 API , 而应依赖使用日志框架 SLF4J 中的API, 使用门面模式的日志框架, 有利于维护和各个类的日志处理方式统一。 123import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(A.class); 日志文件推荐至少保存 15 天, 因为有些异常具备以“周”为频次发生的特点。 应用中的扩展日志 （ 如打点、临时监控、访问日志等 ） 命名方式: appName_logType_logName.log 。 logType: 日志类型 推荐分类有stats / desc / monitor / visit 等 logName: 日志描述 这种命名的好处: 通过文件名就可知道日志文件属于什么应用, 什么类型, 什么目的, 也有利于归类查找。 推荐对日志进行分类, 错误日志和业务日志尽量分开存放, 便于开发人员查看, 也便于通过日志对系统进行及时监控。 对 trace / debug / info 级别的日志输出, 必须使用条件输出形式或者使用占位符的方式。 logger.debug(&quot;Processing trade with id : &quot; + id + &quot; symbol : &quot; + symbol); 如果日志级别是 warn , 上述日志不会打印, 但是会执行字符串拼接操作 并且若 symbol 是对象, 会执行 toString() 方法, 浪费了系统资源, 执行了上述操作, 最终日志却没有打印。 避免重复打印日志, 浪费磁盘空间, 务必在 log4j.xml 中设置 additivity = false &lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt; 异常信息应该包括两类信息: 案发现场信息和异常堆栈信息。如果不处理,就要通过关键字 throws 上抛 logger.error(各类参数或者对象toString + &quot;_&quot; + e.getMessage(), e) 推荐 可以使用 warn 日志级别来记录用户输入参数错误的情况, 避免用户投诉时, 无所适从。 注意日志输出的级别, error 级别只记录系统逻辑出错、异常等重要的错误信息。 如非必要, 请不要在此场景打出 error 级别。 谨慎地记录日志。生产环境禁止输出 debug 日志 ; 有选择地输出 info 日志 ; 如果使用 warn 来记录刚上线时的业务行为信息, 一定要注意日志输出量的问题, 避免把服务器磁盘撑爆, 并记得及时删除这些观察日志。 大量地输出无效日志, 不利于系统性能提升, 也不利于快速定位错误点。 记录日志时请思考: 这些日志真的有人看吗？ 看到这条日志你能做什么？ 能不能给问题排查带来好处？ 单元测试强制 好的单元测试必须遵守 AIR 原则 单元测试在线上运行时, 就像空气 AIR 一样不存在, 但是测试质量的保障上, 却是非常关键的 好的单元测试宏观上来说, 具有自动化, 独立性, 可重复执行的特点 A: Automatic I: Independent R: Repeatable 单元测试应该是全自动执行的, 而且是非交互式的. 测试框架通常是定期执行的, 执行过程中必须完全自动化才有意义. 输出结果需要人工检查的测试不是一个好的单元测试, 单元测试中不准使用 System.out 来进行人工验证, 必须使用 assert. 保持单元测试的独立性. 为了保证单元测试稳定可靠且便于维护, 单元测试用例之间决不能互相调用, 也不能依赖执行的先后次序. method2 需要依赖 method1 的执行, 将执行结果作为method2 的输入. 单元测试是可以重复执行的, 不能受到外界环境的影响. 说明: 单元测试通常会放到持续集成中, 每次有代码 check in 时单元测试都会被执行. 如果测试对外部环境(网络, 服务, 中间件等)有依赖, 容易导致持续集成机制的不可用. 正例: 为了不受外界环境影响, 要求设计代码时就把SUT的依赖改成注入, 在测试时用Spring这样的DI框架注入一个本地(内存)实现或者Mock实现. 对于单元测试, 要保证测试粒度足够小, 有助于精确定位问题. 单测粒度至多是类级别, 一般是方法级别. 只有测试粒度小才能在出错时尽快定位到出错位置. 单测不负责检查跨类或者夸系统的交互逻辑, 那是集成测试的领域. 核心业务, 核心应用, 核心模块的增量代码确保单元测试通过. 新增代码及时补充单元测试, 如果新增代码影响了原有单元测试, 请及时修正. 单元测试代码必须写在如下工程目录: src/test/java 不允许写在业务代码目录下. 源码构建时会跳过此目录, 而单元测试框架默认是扫描此目录. 推荐 单元测试的基本目标: 语句覆盖率达到70%; 核心模块的语句覆盖率和分支覆盖率都要达到100%. 在工程规约的应用分层中提高的DAO层, Manager层, 可重用度高的Service, 都应该进行单元测试. 编写单元测试代码遵守BCDE原则, 以保证被测试模块的交付质量. B: Border, 边界值测试, 包括循环边界 特殊取值 特殊时间点 数据顺序等. C: Correct, 正确的输入, 并得到预期的结果. D: Design, 与设计文档相结合, 来编写单元测试. E: Error, 强制错误信息输入 (如: 非法数据 异常流程 非业务允许输入等), 并得到预期的结果. 对于数据库相关的查询, 更新, 删除等操作, 不能假设数据库里的数据是存在的, 或者直接操作数据库把数据插入进行, 请使用程序插入或者导入数据的方式来准备数据.(使用内存数据库就容易些) 和数据库相关的单元测试, 可以设定自动回滚机制, 不给数据库造成脏数据. 或者对单元测试产生的数据有明确的前后缀标识. 在RDC内部单元测试中, 使用 RDC_UNIT_TEST_ 的前缀标识数据 对于不可测的代码建议做必要的重构, 使代码变得可测, 避免为了达到测试要求而书写不规范测试代码. 在设计评审阶段, 开发人员需要和测试人员一起确定单元测试范围, 单元测试最好覆盖所有测试用例(UC). 单元测试作为一种质量保障手段, 不建议在项目发布后补充单元测试用例, 建议在项目提测前完成单元测试. 为了更方便地进行单元测试, 业务代码应避免以下情况: 构造方法中做的事情过多. 存在过多的全局变量和静态方法. 存在过多的外部依赖. 存在过多的条件语句 (多层条件语句建议使用卫语句,策略模式,状态模式等方式重构) 不要对单元测试存在如下误解: 那是测试要干的事情. 本文是开发手册, 凡是本文内容都是与开发强相关的. 单元测试代码是多余的 单元测试不需要维护 单元测试和线上故障没有辩证关系 安全规约强制 隶属于用户个人的页面或者功能必须进行权限控制校验。 防止没有做水平权限校验就可随意访问、修改 删除 别人的数据, 比如查看他人的私信内容, 修改他人的订单 用户敏感数据禁止直接展示, 必须对展示数据脱敏。 查看个人手机号码会显示成:158**9119, 隐藏中间 4 位, 防止隐私泄露。 用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定, 防止 SQL 注入, 禁止字符串拼接 SQL 访问数据库。 用户请求传入的任何参数必须做有效性验证。 忽略参数校验可能导致: page size 过大导致内存溢出 恶意 order by 导致数据库慢查询 任意重定向 SQL 注入 反序列化注入 正则输入源串拒绝服务 ReDoS Java 代码用正则来验证客户端的输入, 有些正则写法验证普通用户输入没有问题, 但是如果攻击人员使用的是特殊构造的字符串来验证, 有可能导致死循环的效果。 禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。 表单, AJAX 提交必须执行 CSRF 安全过滤 CSRF(Cross-site request forgery) 跨站请求伪造是一类常见编程漏洞。 对于存在CSRF 漏洞的应用/网站, 攻击者可以事先构造好 URL, 只要受害者用户一访问, 后台便在用户不知情情况下对数据库中用户参数进行相应修改。 个人理解 万一ajax接口的API暴露了, 被别有用心的人利用就能构造好页面, 用于钓鱼什么的 在使用平台资源, 譬如短信、邮件、电话、下单、支付, 必须实现正确的防重放限制, 如数量限制、疲劳度控制、验证码校验, 避免被滥刷、资损。 如注册时发送验证码到手机, 如果没有限制次数和频率, 那么可以利用此功能骚扰到其它用户, 并造成短信平台资源浪费。 发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。 MySQL规约建表规约强制 表达是与否概念的字段, 必须使用 is_xxx 的方式命名, 数据类型是 unsigned tinyint (1 表示是, 0 表示否) 任何字段如果为非负数, 必须是 unsigned 。 正例: 表达逻辑删除的字段名 is_deleted, 1表示删除, 0表示未删除. 个人理解: 是不是简单的整型枚举也可以这么用呢 表名、字段名必须使用小写字母或数字; 禁止出现数字开头, 禁止两个下划线中间只出现数字。数据库字段名的修改代价很大, 因为无法进行预发布, 所以字段名称需要慎重考虑。 MySQL 在 Windows 下不区分大小写, 但在 Linux 下默认是区分大小写, 因此 数据库名, 表名 字段名 都不允许出现任何大写字母. 表名不使用复数名词。 表名应该仅仅表示表里面的实体内容, 不应该表示实体数量, 对应于 DO 类名也是单数形式, 符合表达习惯。 禁用保留字, 如 desc 、 range 、 match 、 delayed 等, 请参考 MySQL 官方保留字。 主键索引名为 pk_字段名, 唯一索引名为 uk_字段名, 普通索引名则为 idx_字段名。 pk_ 即 primary key, uk_ 即 unique key, idx_ 即 index 的简称。 小数类型为 decimal , 禁止使用 float 和 double 。 float 和 double 在存储的时候, 存在精度损失的问题, 很可能在值的比较时, 得到不正确的结果。 如果存储的数据范围超过 decimal 的范围, 建议将数据拆成整数和小数分开存储。 如果某字段存储的字符串长度几乎是固定的, 使用 char 定长字符串类型。 varchar 是可变长字符串, 不预先分配存储空间, 长度不要超过 500, 如果存储长度大于此值, 定义字段类型为 text , 独立出来一张表, 用主键来对应, 避免影响其它字段索引效率。 表必备三字段: id, gmt_create, gmt_modified 。 其中 id 必为主键, 类型为 unsigned bigint 、单表时自增、步长为 1。 gmt_create ,gmt_modified 的类型均为 date_time 类型, 前者现在时表示主动创建, 后者过去分词表示被动更新. GMT 是指格林尼治时间, 这样的话, 就是会让表的数据和时间关联上, 具有一定数据分析价值 推荐 表的命名最好是加上“业务名称_表的作用”。 正例: alipay_task force_project trade_config 库名与应用名称尽量一致。 如果修改字段含义或对字段表示的状态追加时, 需要及时更新字段注释。 字段允许适当冗余, 以提高查询性能, 但必须考虑数据一致, 冗余字段应遵循: 不是频繁修改的字段。 不是 varchar 超长字段, 更不能是 text 字段。 正例: 商品类目名称使用频率高, 字段长度短, 名称基本一成不变, 可在相关联的表中冗余存储类目名称, 避免关联查询。 单表行数超过 500 万行或者单表容量超过 2 GB, 才推荐进行分库分表。 如果预计三年后的数据量根本达不到这个级别, 请不要在创建表时就分库分表。 合适的字符存储长度, 不但节约数据库表空间、节约索引存储, 更重要的是提升检索速度。 如下表, 其中无符号值可以避免误存负数, 且扩大了表示范围. | 对象 | 年龄区间 | 类型 | 字节 | 表示范围 ||:—-:|:—-:|:—-|:—-:|:—-|| 人 | 150岁之内 | unsigned tinyint | 1 | 0 - 255 || 龟 | 数百年 | unsigned smallint | 2 | 0 - 65535 || 恐龙化石 | 数千万年 | unsigned int | 4 | 0 - 约42.9亿 || 太阳 | 约50亿年 | unsigned bigint | 8 | 0 - 约10的19次幂 | 索引规约强制 业务上具有唯一特性的字段, 即使是多个字段的组合, 也必须建成唯一索引。 不要以为唯一索引影响了 insert 速度, 这个速度损耗可以忽略, 但提高查找速度是明显的 ; 另外, 即使在应用层做了非常完善的校验控制, 只要没有唯一索引, 根据墨菲定律, 必然有脏数据产生。 超过三个表禁止 join。需要 join 的字段, 数据类型必须保持绝对一致; 多表关联查询时, 保证被关联的字段需要有索引。 即使双表 join 也要注意表索引、SQL 性能。 在 varchar 字段上建立索引时, 必须指定索引长度, 没必要对全字段建立索引, 根据实际文本区分度决定索引长度即可。 索引的长度与区分度是一对矛盾体, 一般对字符串类型数据, 长度为 20 的索引, 区分度会高达 90% 以上, 可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。 页面搜索严禁左模糊或者全模糊, 如果需要请使用搜索引擎来解决。 索引文件具有 B-Tree 的最左前缀匹配特性, 如果左边的值未确定, 那么无法使用此索引。 推荐 如果有 order by 的场景, 请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分, 并且放在索引组合顺序的最后, 避免出现 file_sort 的情况, 影响查询性能。 正例: where a = ? and b = ? order by c; 索引: a_b_c 反例: 索引中有范围查找, 那么索引有序无法利用, 如: WHERE a &gt; 10 order by b; 索引 a_b 无法排序. 利用覆盖索引来进行查询操作, 来避免回表操作。 如果一本书需要知道第 11 章是什么标题, 会翻开第 11 章对应的那一页吗? 目录浏览一下就好, 这个目录就是起到覆盖索引的作用. 能够建立索引的种类: 主键索引、唯一索引、普通索引, 而覆盖索引是一种查询的一种效果, 用 explain 的结果, extra 列会出现: using index 。 覆盖索引是select的数据列只用从索引中就能够取得, 不必读取数据行, 换句话说查询列要被所建的索引覆盖。 理解方式一: 索引是高效找到行的一个方法, 但是一般数据库也能使用索引找到一个列的数据, 因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据; 当能通过读取索引就可以得到想要的数据, 那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引 理解方式二: 是非聚集复合索引的一种形式, 它包括在查询里的Select、Join和Where子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段, 也即, 索引包含了查询正在查找的数据）。 利用延迟关联或者子查询优化超多分页场景。 MySQL 并不是跳过 offset 行, 而是取 offset + N 行, 然后返回放弃前 offset 行, 返回 N 行, 那当 offset 特别大的时候, 效率就非常的低下, 要么控制返回的总页数, 要么对超过特定阈值的页数进行 SQL 改写. 正例: 先快速定位需要获取的id段, 然后再关联: select a.* from table_a a, (select id from table_a where 条件 limit 100000, 20) b where a.id = b.id SQL 性能优化的目标: 至少要达到 range 级别, 要求是 ref 级别, 如果可以是 consts最好。 consts 单表中最多只有一个匹配行 （ 主键或者唯一索引 ） , 在优化阶段即可读取到数据。 ref 指的是使用普通的索引 （normal index） 。 range 对索引进行范围检索。 反例: explain 表的结果, type = index , 索引物理文件全扫描, 速度非常慢, 这个 index 级别比较 range 还低, 与全表扫描是小巫见大巫。 建组合索引的时候, 区分度最高的在最左边。 正例: 如果 where a = ? and b = ?, a 列的几乎接近于唯一值, 那么只需要单建 idx_a 索引即可。 存在非等号和等号混合判断条件时, 在建索引时, 请把等号条件的列前置。 如: where a &gt; ? and b = ? 那么即使 a 的区分度更高, 也必须把 b 放在索引的最前列。 防止因字段类型不同造成的隐式转换, 导致索引失效. 创建索引时避免有如下极端误解: 宁缺毋滥. 认为一个查询就需要建一个索引。 宁缺毋滥. 认为索引会消耗空间、严重拖慢更新和新增速度。 抵制惟一索引. 认为业务的惟一性一律需要在应用层通过 “先查后插” 方式解决。 SQL规约强制 不要使用 count(列名) 或 count(常量) 来替代 count(), count( ) 就是 SQL 92 定义的标准统计行数的语法, 跟数据库无关, 跟 NULL 和非 NULL 无关。 count( * ) 会统计值为 NULL 的行, 而 count(列名) 不会统计此列为 NULL 值的行。 count(distinct col) 计算该列除 NULL 之外的不重复行数。注意 count(distinct col1, col2) 如果其中一列全为 NULL, 那么即使另一列有不同的值, 也返回为 0。 当某一列的值全是 NULL 时, count(col) 的返回结果为 0, 但 sum(col) 的返回结果为NULL , 因此使用 sum() 时需注意 NPE 问题。 正例: 可以使用如下方式来避免 sum 的 NPE 问题: SELECT IF(ISNULL(SUM(g)) ,0, SUM(g))FROM table; 使用 ISNULL() 来判断是否为 NULL 值。注意: NULL 与任何值的直接比较都为 NULL。 | 表达式 | 返回值 | |:—-|:—-:| | NULL&lt;&gt;NULL | NULL 而不是 false | | NULL=NULL | NULL 而不是 true | | NULL&lt;&gt;1 | NULL 而不是 true | 在代码中写分页查询逻辑时, 若 count 为 0 应直接返回, 避免执行后面的分页语句。 不得使用外键与级联, 一切外键概念必须在应用层解决。 说明: 以学生和成绩的关系为例, 学生表中的 student_id 是主键, 那么成绩表中的 student_id 则为外键。 如果更新学生表中的 student_id , 同时触发成绩表中的 student_id 更新, 则为级联更新。 外键与级联更新适用于单机低并发, 不适合分布式、高并发集群; 级联更新是强阻塞, 存在数据库更新风暴的风险; 并且外键影响数据库的插入速度。 禁止使用存储过程, 存储过程难以调试和扩展, 更没有移植性。 数据订正时, 删除和修改记录时, 要先 select, 避免出现误删除, 确认无误才能执行更新语句。 推荐 in 操作能避免则避免, 若实在避免不了, 需要仔细评估 in 后边的集合元素数量, 控制在 1000 个之内。 如果有全球化需要, 所有的字符存储与表示, 均以 utf-8 编码, 注意字符统计函数的区别 注意: SELECT LENGTH( “轻松工作” ); 返回为 12 SELECT CHARACTER _ LENGTH( “轻松工作” ); 返回为 4 如果需要存储表情, 那么使用 utfmb4(这才是真正的UTF-8) 来进行存储, MySQL 的 utf-8 编码只能存放3字节的字符 TRUNCATE TABLE 比 DELETE 速度快, 且使用的系统和事务日志资源少, 但 TRUNCATE 无事务且不触发 trigger, 有可能造成事故, 故不建议在开发代码中使用此语句。 TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 ORM映射强制 在表查询中, 一律不要使用 * 作为查询的字段列表, 需要哪些字段必须明确写明。 增加查询分析器解析成本。 增减字段容易与 resultMap 配置不一致。 POJO 类的 boolean 属性不能 is 开头, 而数据库字段必须加 is_, 要求在 resultMap 中进行字段与属性之间的映射。 参见定义POJO类以及数据库字段定义的规定, 在 &lt;resultMap&gt; 中增加映射是必须的, 在 Mybatis Generator 生成的代码中, 需要进行对应的修改. 不要用 resultClass 当返回参数, 即使所有类属性名与数据库字段一一对应, 也需要定义; 反过来, 每一个表也必然有一个与之对应。 说明: 配置映射关系, 使字段与DO类解耦, 方便维护. sql.xml 配置中参数注意使用: #{}, #param# 不要使用 ${} 此种方式容易出现 SQL 注入。 iBATIS 自带的 queryForList(String statementName , int start , int size) 不推荐使用。 其实现方式是在数据库取到 statementName 对应的SQL语句的所有记录, 再通过 subList 取 start, size 的子集合 线上因为这个原因曾经出现过 OOM 正例: Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(“start”, start); map.put(“size”, size); 不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。 resultClass=”Hashtable”, 会置入字段名和属性值, 但是值的类型不可控 更新数据表记录时, 必须同时更新记录对应的 gmt_modified 字段值为当前时间。 推荐 不要写一个大而全的数据更新接口, 传入为 POJO 类, 不管是不是自己的目标更新字段, 都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL时, 尽量不要更新无改动的字段, 一是易出错; 二是效率低 ; 三是 binlog 增加存储。 @Transactional 事务不要滥用。事务会影响数据库的 QPS, 另外使用事务的地方需要考虑各方面的回滚方案, 包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 &lt;isEqual&gt; 中的 compareValue 是与属性值对比的常量, 一般是数字, 表示相等时带上此条件; &lt;isNotEmpty&gt; 表示不为空且不为 null 时执行 ; &lt;isNotNull&gt; 表示不为 null 值时执行。 工程规约应用分层推荐 图中默认上层依赖于下层, 箭头关系表示可直接依赖, 如: 开放接口层可以依赖于Web 层, 也可以直接依赖于 Service 层, 依此类推: Application Level 开放接口层: 可直接封装 Service 接口暴露成 RPC(Remote Procedure Calls) 接口; 通过 Web 封装成 http 接口; 进行网关安全控制, 流量控制等. 终端显示层: 各个端的模板渲染并执行显示的层。当前主要是 Velocity 渲染, JS 渲染, JSP 渲染, 移动端展示层等。 Web 层: 主要是对访问控制进行转发, 各类基本参数校验, 或者不复用的业务简单处理等。 Service 层: 相对具体的业务逻辑服务层。 Manager 层: 通用业务处理层, 它有如下特征: 对第三方平台封装的层, 预处理返回结果及转化异常信息 ; 对 Service 层通用能力的下沉, 如缓存方案、中间件通用处理 ; 与 DAO 层交互, 对 DAO 的业务通用能力的封装, 对多个 DAO 的组合复用 DAO 层: 数据访问层, 与底层 MySQL、Oracle、 Hbase 等进行数据交互。 外部接口或第三方平台: 包括其它部门 RPC 开放接口, 基础平台, 其它公司的 HTTP 接口。 参考 分层异常处理规约 在 DAO 层, 产生的异常类型有很多, 无法用细粒度异常进行catch, 使用 catch(Exception e) 方式, 并 throw new DAOException(e), 不需要打印日志, 因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去, 如果同台服务器再打日志, 浪费性能和存储。 在 Service 层出现异常时, 必须记录出错日志信息到磁盘, 尽可能带上必要的参数信息(能够描述出场景的大致状态), 相当于保护案发现场。 如果 Manager 层与 Service 同机部署, 日志方式与 DAO 层处理一致; 如果是单独部署, 则采用与 Service 一致的处理方式。 Web 层绝不应该继续往上抛异常, 因为已经处于顶层, 无继续处理异常的方式, 如果意识到这个异常将导致页面无法正常渲染, 那么就应该直接跳转到友好错误页面, 尽量加上友好的错误提示信息。 开放接口层要将异常处理成错误码和错误信息方式返回。 分层领域模型规约: | 缩写 | 名称 | 作用 ||:—-|:—-|:—-|| DO | Data Object | 与数据库表结构一一对应, 通过DAO层向上传输数据源对象 || DTO | Data Transfer Object | 数据传输对象, Service或Manager向外传输的对象 || BO | Business Object | 由Service层输出的封装业务逻辑的对象 || AO | Application Object | 应用对象, 在Web层与Service层之间抽象的复用对象模型, 极为贴近展示层, 复用度不高 || VO | View Object | 显示层对象, 通常是Web向模板引擎传输的对象 || Qurey | | 数据查询对象, 各层接收上层的查询请求, 注意超过2个参数的查询封装, 禁止使用Map类来传输 | 二方库依赖强制 定义 GAV 遵从以下规则: GroupID 格式: com.{公司/BU}.业务线.[子业务线], 最多 4 级。 {公司/BU} 例如: alibaba/taobao/tmall/aliexpress 等 BU; 子业务线可选。 正例: com.taobao.jstorm 或 com.alibaba.dubbo.register ArtifactID 格式: 产品线名-模块名。语义不重复不遗漏, 先到仓库中心去查证一下。 正例: dubbo-client / fastjson-api / jstorm-tool Version : 详细规定参考下方。 二方库版本号命名方式: 主版本号.次版本号.修订号 主版本号: 产品方向改变, 或者大规模API不兼容, 或者架构不兼容升级. 次版本号: 保持相对兼容性, 增加主要功能特性, 影响范围极小的API不兼容修改. 修订号: 保持完全兼容性, 修复 bug, 新增次要功能特性等 说明: 注意起始版本号必须为: 1.0.0 , 而不是 0.0.1, 正式发布的类库必须先去中央仓库进行查证, 使版本号有延续性, 正式版本号不允许覆盖升级 如当前版本 1.3.3 那么下一个合理的版本号 1.3.4 或者 1.4.0 或 2.0.0 线上应用不要依赖 SNAPSHOT 版本（安全包除外）; 不依赖 SNAPSHOT 版本是保证应用发布的幂等性. 另外, 也可以加快编译时的打包构建. 二方库的新增或升级, 保持除功能点之外的其它 jar 包仲裁结果不变。 如果有改变, 必须明确评估和验证, 建议进行 dependency:resolve 前后信息比对, 如果仲裁结果完全不一致, 那么通过 dependency:tree 命令, 找出差异点, 进行&lt;excludes&gt;排除 jar 包。 二方库里可以定义枚举类型, 参数可以使用枚举类型, 但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。 依赖于一个二方库群时, 必须定义一个统一版本变量, 避免版本号不一致。 说明: 依赖 springframework-core, -context, -beans, 它们都是同一个版本 可以定义一个变量来保存版本: ${spring.version}, 定义依赖的时候, 引用该版本。 禁止在子项目的 pom 依赖中出现相同的 GroupId , 相同的 ArtifactId , 但是不同的Version 。 在本地调试时会使用各子项目指定的版本号, 但是合并成一个war, 只能有一个版本号出现在最后的lib目录中, 可能出现线下调试是正确的, 发布到线上却出故障的问题. 推荐 所有 pom 文件中的依赖声明放在 &lt;dependencies&gt; 语句块中, 所有版本仲裁放在&lt;dependencyManagement&gt; 语句块中。 &lt;dependencyManagement&gt; 里只是声明版本, 并不实现引入, 因此子项目需要显式的声明依赖, version 和 scope 都读取自父 pom 。 而 &lt;dependencies&gt; 所有声明在主 pom 的 &lt;dependencies&gt; 里的依赖都会自动引入, 并默认被所有的子项目继承。 二方库不要有配置项, 最低限度不要再增加配置项。 参考 为避免应用二方库的依赖冲突问题, 二方库发布者应当遵循以下原则: 精简可控原则 移除一切不必要的 API 和依赖, 只包含 Service API、必要的领域模型对象、 Utils类、常量、枚举等。 如果依赖其它二方库, 尽量是 provided 引入, 让二方库使用者去依赖具体版本号; 无 log 具体实现的依赖, 只依赖日志框架(例如不依赖Logback而是依赖SLF4J)。 稳定可追溯原则 每个版本的变化应该被记录, 二方库由谁维护, 源码在哪里, 都需要能方便查到。除非用户主动升级版本, 否则公共二方库的行为不应该发生变化。 服务器规约推荐 高并发服务器建议调小 TCP 协议的 time_wait 超时时间。 说明: 操作系统默认 240 秒后, 才会关闭处于 time_wait 状态的连接, 在高并发访问下, 服务器端会因为处于 time_wait 的连接数太多,可能无法建立新的连接, 所以需要在服务器上调小此等待值。 正例: 在 linux 服务器上请通过变更 /etc/sysctl.conf 文件去修改该缺省值 （ 秒 ） net.ipv4.tcp_fin_timeout = 30 调大服务器所支持的最大文件句柄数 （File Descriptor, 简写为 fd） 。 说明: 主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理, 即一个连接对应于一个 fd 。 主流的 linux 服务器默认所支持最大 fd 数量为 1024, 当并发连接数很大时很容易因为 fd 不足而出现“ open too many files ”错误, 导致新的连接无法建立。 建议将 linux服务器所支持的最大句柄数调高数倍 （与服务器的内存数值相关） 给 JVM 设置 -XX:+HeapDumpOnOutOfMemoryError 参数, 让 JVM 碰到 OOM 场景时输出dump 信息。 OOM 的发生是有概率的, 甚至有规律地相隔数月才出现一例, 出现时的现场信息对查错非常有价值。 在线上生产环境, JVM 的 Xms 和 Xmx 设置一样的内存容量, 避免在GC后调整堆大小带来的压力 服务器内部重定向使用 forward; 外部重定向地址使用 URL 拼装工具类来生成, 否则会带来 URL 维护不一致的问题和潜在的安全风险。 专有名词 POJO (Plain Ordinary Java Object): 在手册中, POJO专指只有 setter/getter/toString 的简单类, 包括 DO/DTO/BO/VO等. GAV (GroupId, AritifactId, Version): Maven 坐标, 是用来唯一标识 jar 包. OOP(Object Oriented Programming): 泛指类,对象的编程处理方式 ORM(Object Relation Mapping): 对象关系映射, 对象领域模型与底层数据之间的转换, 本文泛指 iBATIS Mybatis 等框架 NPE(java.lang.NullPointerException): 空指针异常 SOA(Service-Oriented Architecture): 面向服务架构, 它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署, 组合和使用, 有利于提升组件可重用性, 可维护性. 一方库: 本工程内部子项目模块依赖的库 jar包 二方库: 公司内部发布到中央仓库, 可供公司内部其他应用依赖的库 jar包 三方库: 公司之外的开源库 jar包","categories":[],"tags":[]},{"title":"Solution.md","slug":"Memo-Blog-Solution","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Blog-Solution/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Blog-Solution/","excerpt":"","text":"目录 start 解决方案 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 解决方案 关于问题的解决方案 站内信设计思路之己见（基于上百万用户）","categories":[],"tags":[]},{"title":"View.md","slug":"Memo-Blog-View","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Blog-View/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Blog-View/","excerpt":"","text":"目录 start 前端 基础 规范 CSS 相关库 Jquery Bootstrap LayUI 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 前端 半学半就 个人导航页 基础 我所理解的前端Javascript字典操作js数据结构和算法（五）字典和散列（hash） 规范 前端开发命名规范 CSS 酷炫按钮 相关库Jquery 10个超赞的jQuery图片滑块动画 BootstrapLayUI","categories":[],"tags":[]},{"title":"ZenOfPattern.md","slug":"Memo-Java-ZenOfPattern","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Java-ZenOfPattern/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-ZenOfPattern/","excerpt":"","text":"目录 start 设计模式之禅 软件设计的一些原则 思维原则 奥卡姆剃刀原理 首要原则 勿重复造轮子 减法优于加法 抽象优于实现 组合优于继承 查询与命令分离 够用原则 最少知识原则 面向对象的S.O.L.I.D 原则 单一职责原则 开闭原则 里氏代换原则 接口隔离原则 依赖倒置原则 其他原则 共同封闭原则 共同重用原则 好莱坞原则 高内聚低耦合 惯例优于配置原则 关注点分离 契约式设计 无环依赖原则 设计模式 基础 策略者模式 1.创建型设计模式 2.结构型设计模式 3.行为设计模式 【常见设计模式】 适配器模式 中介者模式 观察者模式 单例模式 装饰器模式 原型模式 生成器模式 实践 经验之谈 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 设计模式之禅软件设计的一些原则思维原则奥卡姆剃刀原理首要原则勿重复造轮子-DRY Don’t Repeat Yourself是一个最简单的法则，也是最容易被理解的。但它也可能是最难被应用的（因为要做到这样，我们需要在泛型设计上做相当的努力，这并不是一件容易的事）。它意味着，当我们在两个或多个地方的时候发现一些相似的代码的时候，我们需要把他们的共性抽象出来形一个唯一的新方法，并且改变现有的地方的代码让他们以一些合适的参数调用这个新的方法。 减法优于加法 KISS Keep It Simple, StupidKISS原则在设计上可能最被推崇的，在家装设计，界面设计 ，操作设计上，复杂的东西越来越被众人所BS了，而简单的东西越来越被人所认可，比如这些UI的设计和我们中国网页（尤其是新浪的网页）者是负面的例子。“宜家”（IKEA）简约、效率的家居设计、生产思路；“微软”（Microsoft）“所见即所得”的理念；“谷歌”（Google)简约、直接的商业风格，无一例外的遵循了“kiss”原则，也正是“kiss”原则，成就了这些看似神奇的商业经典。而苹果公司的iPhone/iPad将这个原则实践到了极至。 把一个事情搞复杂是一件简单的事，但要把一个复杂的事变简单，这是一件复杂的事。 抽象优于实现-Program to an interface, not an implementation 这是设计模式中最根本的哲学，注重接口，而不是实现，依赖接口，而不是实现。接口是抽象是稳定的，实现则是多种多样的。 以后面我们会面向对象的SOLID原则中会提到我们的依赖倒置原则，就是这个原则的的另一种样子。 组合优于继承【Composition over inheritance】 多使用组合而不是继承, 但是这个观点是存在一定的争议的, 还是要有度的,合理搭配最为重要 组合就是将原来继承方式中的父类放到子类作为属性? 组合1.（对象）组合是一种通过创建一个组合了其它对象的对象，从而获得新功能的复用方法。2.将功能委托给所组合的一个对象，从而获得新功能。3.有些时候也称之为”聚合”（aggregation）或”包容”（containment），尽管有些作者对这些术语赋予了专门的含义 再度思考 参考博客: 组合、委托与继承，面向对象中类之间的基本关系漫游参考博客: 优先使用（对象）组合，而非（类）继承 查询与命令分离【CQS Command-Query Separation】 查询命令分离原则 查询：当一个方法返回一个值来回应一个问题的时候，它就具有查询的性质； 命令：当一个方法要改变对象的状态的时候，它就具有命令的性质； 够用原则【YAGNI You Ain’t Gonna Need It 】 这个原则简而言之为——只考虑和设计必须的功能，避免过度设计。只实现目前需要的功能，在以后您需要更多功能时，可以再进行添加。 如无必要，勿增复杂性。 软件开发先是一场沟通博弈。 最少知识原则 【Law of Demeter – 迪米特法则】 迪米特法则(Law of Demeter)，又称“最少知识原则” （Principle of Least Knowledge），其来源于1987年荷兰大学的一个叫做Demeter的项目。 Craig Larman把Law of Demeter又称作“不要和陌生人说话”。在《程序员修炼之道》中讲LoD的那一章叫作“解耦合与迪米特法则”。 关于迪米特法则有一些很形象的比喻： 如果你想让你的狗跑的话，你会对狗狗说还是对四条狗腿说？ 如果你去店里买东西，你会把钱交给店员，还是会把钱包交给店员让他自己拿？ 正式表述如下: 对于对象 ‘O’ 中一个方法’M’，M应该只能够访问以下对象中的方法: 对象O； 与O直接相关的Component Object； 由方法M创建或者实例化的对象； 作为方法M的参数的对象。 参考博客: 迪米特法则与重构 面向对象的S.O.L.I.D 原则 一般来说这是面向对象的五大设计原则，但是，我觉得这些原则可适用于所有的软件开发。 单一职责原则Single Responsibility Principle (SRP) 关于单一职责原则，其核心的思想是：一个类，只做一件事，并把这件事做好，且只有一个引起它变化的原因。 Unix/Linux是这一原则的完美体现者。各个程序都独立负责一个单一的事。 Windows是这一原则的反面示例。几乎所有的程序都交织耦合在一起。 开闭原则Open/Closed Principle (OCP) 关于开发封闭原则，其核心的思想是：模块是可扩展的，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。 里氏代换原则Liskov substitution principle (LSP) 软件工程大师Robert C. Martin把里氏代换原则最终简化为一句话：“Subtypes must be substitutable for their base types”。 也就是，子类必须能够替换成它们的基类。 即：子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现if/else之类对子类类型进行判断的条件。里氏替换原则LSP是使代码符合开闭原则的一个重要保证。正是由于子类型的可替换性才使得父类型的模块在无需修改的情况下就可以扩展。 这么说来，似乎有点教条化，我非常建议大家看看这个原则个两个最经典的案例——“正方形不是长方形”和“鸵鸟不是鸟”。 通过这两个案例，你会明白《墨子小取》中说的——“娣，美人也，爱娣，非爱美人也….盗，人也；恶盗，非恶人也。”——妹妹虽然是美人，但喜欢妹妹并不代表喜欢美人。 盗贼是人，但讨厌盗贼也并不代表就讨厌人类。这个原则让你考虑的不是语义上对象的间的关系，而是实际需求的环境。 在很多情况下，在设计初期我们类之间的关系不是很明确，LSP则给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系。 接口隔离原则Interface Segregation Principle (ISP) 接口隔离原则意思是把功能实现在接口中，而不是类中，使用多个专门的接口比使用单一的总接口要好。 举个例子，我们对电脑有不同的使用方式，比如：写作，通讯，看电影，打游戏，上网，编程，计算，数据等，如果我们把这些功能都声明在电脑的抽类里面，那么，我们的上网本，PC机，服务器， 笔记本的实现类都要实现所有的这些接口，这就显得太复杂了。所以，我们可以把其这些功能接口隔离开来，比如：工作学习接口，编程开发接口，上网娱乐接口，计算和数据服务接口，这样，我们的不同功能的电脑就可以有所选择地继承这些接口。 这个原则可以提升我们“搭积木式”的软件开发。对于设计来说，Java中的各种Event Listener和Adapter，对于软件开发来说，不同的用户权限有不同的功能，不同的版本有不同的功能，都是这个原则的应用。 依赖倒置原则Dependency Inversion Principle (DIP)高层模块不应该依赖于低层模块的实现，而是依赖于高层抽象。举个例子，墙面的开关不应该依赖于电灯的开关实现，而是应该依赖于一个抽象的开关的标准接口，这样，当我们扩展程序的时候，我们的开关同样可以控制其它不同的灯，甚至不同的电器。也就是说，电灯和其它电器继承并实现我们的标准开关接口，而我们的开关产商就可不需要关于其要控制什么样的设备，只需要关心那个标准的开关标准。这就是依赖倒置原则。这就好像浏览器并不依赖于后面的web服务器，其只依赖于HTTP协议。这个原则实在是太重要了，社会的分工化，标准化都是这个设计原则的体现。 下面有几点指导意见，帮助你避免在面向对象设计中违反依赖倒置原则： 变量不能持有具体类的引用，就像订单方法代码中，你看不到new一样。不要让派生自具体类，要派生就派生抽象类abstract不要覆盖基类中已实现的方法，除非你要覆盖的是比较特殊的一部分代码。 其他原则共同封闭原则Common Closure Principle（CCP）一个包中所有的类应该对同一种类型的变化关闭。一个变化影响一个包，便影响了包中所有的类。一个更简短的说法是：一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。CCP原则就是把因为某个同样的原因而需要修改的所有类组合进一个包里。如果2个类从物理上或者从概念上联系得非常紧密，它们通常一起发生改变，那么它们应该属于同一个包。 CCP延伸了开闭原则（OCP）的“关闭”概念，当因为某个原因需要修改时，把需要修改的范围限制在一个最小范围内的包里。 共同重用原则Common Reuse Principle (CRP)包的所有类被一起重用。如果你重用了其中的一个类，就重用全部。换个说法是，没有被一起重用的类不应该被组合在一起。CRP原则帮助我们决定哪些类应该被放到同一个包里。依赖一个包就是依赖这个包所包含的一切。当一个包发生了改变，并发布新的版本，使用这个包的所有用户都必须在新的包环境下验证他们的工作，即使被他们使用的部分没有发生任何改变。因为如果包中包含有未被使用的类，即使用户不关心该类是否改变，但用户还是不得不升级该包并对原来的功能加以重新测试。 CCP则让系统的维护者受益。CCP让包尽可能大（CCP原则加入功能相关的类），CRP则让包尽可能小（CRP原则剔除不使用的类）。它们的出发点不一样，但不相互冲突。 好莱坞原则Hollywood Principle好莱坞原则就是一句话——“don’t call us, we’ll callyou.”。意思是，好莱坞的经纪人们不希望你去联系他们，而是他们会在需要的时候来联系你。也就是说，所有的组件都是被动的，所有的组件初始化和调用都由容器负责。组件处在一个容器当中，由容器负责管理。 简单的来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在： 不创建对象，而是描述创建对象的方式。 在代码中，对象与服务没有直接联系，而是容器负责将这些联系在一起。 控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。 好莱坞原则就是IoC（Inversion of Control）或DI（Dependency Injection）的基础原则。这个原则很像依赖倒置原则，依赖接口，而不是实例，但是这个原则要解决的是怎么把这个实例传入调用类中？你可能把其声明成成员，你可以通过构造函数，你可以通过函数参数。但是IoC可以让你通过配置文件，一个由Service Container读取的配置文件来产生实际配置的类。但是程序也有可能变得不易读了，程序的性能也有可能还会下降。 高内聚低耦合【 High Cohesion &amp; Low/Loose coupling &amp; – 高内聚， 低耦合 】 这个原则是UNIX操作系统设计的经典原则，把模块间的耦合降到最低，而努力让一个模块做到精益求精。 内聚：一个模块内各个元素彼此结合的紧密程度 耦合：一个软件结构内不同模块之间互连程度的度量 内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身 凝聚&gt;松耦合&gt;重用 参考博客: 为什么我停止使用Spring? 惯例优于配置原则Convention over Configuration（CoC）简单点说，就是将一些公认的配置方式和信息作为内部缺省的规则来使用。例如，Hibernate的映射文件，如果约定字段名和类属性一致的话，基本上就可以不要这个配置文件了。你的应用只需要指定不convention的信息即可，从而减少了大量convention而又不得不花时间和精力啰里啰嗦的东东。配置文件很多时候相当的影响开发效率。 Rails 中很少有配置文件（但不是没有，数据库连接就是一个配置文件），Rails 的fans号称期开发效率是 java 开发的 10倍，估计就是这个原因。Maven也使用了CoC原则，当你执行mvn-compile命令的时候，不需要指源文件放在什么地方，而编译以后的class文件放置在什么地方也没有指定，这就是CoC原则。 关注点分离Separation of Concerns (SoC) 是计算机科学中最重要的努力目标之一。这个原则，就是在软件开发中，通过各种手段，将问题的各个关注点分开。如果一个问题能分解为独立且较小的问题，就是相对较易解决的。问题太过于复杂，要解决问题需要关注的点太多，而程序员的能力是有限的，不能同时关注于问题的各个方面。正如程序员的记忆力相对于计算机知识来说那么有限一样，程序员解决问题的能力相对于要解决的问题的复杂性也是一样的非常有限。在我们分析问题的时候，如果我们把所有的东西混在一起讨论，那么就只会有一个结果——乱。 我记得在上一家公司有一个项目，讨论就讨论了1年多，项目本来不复杂，但是没有使用SoC，全部的东西混为一谈，再加上一堆程序员注入了各种不同的观点和想法，整个项目一下子就失控了。最后，本来一个1年的项目做了3年。 实现关注点分离的方法主要有两种，一种是标准化，另一种是抽象与包装。标准化就是制定一套标准，让使用者都遵守它，将人们的行为统一起来，这样使用标准的人就不用担心别人会有很多种不同的实现，使自己的程序不能和别人的配合。JavaEE就是一个标准的大集合。每个开发者只需要关注于标准本身和他所在做的事情就行了。就像是开发镙丝钉的人只专注于开发镙丝钉就行了，而不用关注镙帽是怎么生产的，反正镙帽和镙丝钉按标来就一定能合得上。不断地把程序的某些部分抽像差包装起来，也是实现关注点分离的好方法。一旦一个函数被抽像出来并实现了，那么使用函数的人就不用关心这个函数是如何实现的，同样的，一旦一个类被抽像并实现了，类的使用者也不用再关注于这个类的内部是如何实现的。诸如组件，分层，面向服务，等等这些概念都是在不同的层次上做抽像和包装，以使得使用者不用关心它的内部实现细节。说白了还是“高内聚，低耦合”。 参考博客: 理论篇：关注点分离(Separation of concerns, SoC) 契约式设计Design by Contract (DbC)DbC的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。例如： 供应商必须提供某种产品（责任），并且他有权期望客户已经付款（权利）。 客户必须付款（责任），并且有权得到产品（权利）。 契约双方必须履行那些对所有契约都有效的责任，如法律和规定等。 同样的，如果在程序设计中一个模块提供了某种功能，那么它要： 期望所有调用它的客户模块都保证一定的进入条件：这就是模块的先验条件（客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况）。 保证退出时给出特定的属性：这就是模块的后验条件——（供应商的义务，显然也是客户的权利）。 在进入时假定，并在退出时保持一些特定的属性：不变式。 契约就是这些权利和义务的正式形式。我们可以用“三个问题”来总结DbC，并且作为设计者要经常问： 它期望的是什么？ 它要保证的是什么？ 它要保持的是什么？ 根据BertrandMeyer氏提出的DBC概念的描述，对于类的一个方法，都有一个前提条件以及一个后续条件，前提条件说明方法接受什么样的参数数据等，只有前提条件得到满足时，这个方法才能被调用；同时后续条件用来说明这个方法完成时的状态，如果一个方法的执行会导致这个方法的后续条件不成立，那么这个方法也不应该正常返回。 现在把前提条件以及后续条件应用到继承子类中，子类方法应该满足： 前提条件不强于基类． 后续条件不弱于基类． 换句话说，通过基类的接口调用一个对象时，用户只知道基类前提条件以及后续条件。因此继承类不得要求用户提供比基类方法要求的更强的前提条件，亦即，继承类方法必须接受任何基类方法能接受的任何条件（参数）。同样，继承类必须顺从基类的所有后续条件，亦即，继承类方法的行为和输出不得违反由基类建立起来的任何约束，不能让用户对继承类方法的输出感到困惑。 这样，我们就有了基于契约的LSP，基于契约的LSP是LSP的一种强化。 无环依赖原则Acyclic Dependencies Principle (ADP)包之间的依赖结构必须是一个直接的无环图形，也就是说，在依赖结构中不允许出现环（循环依赖）。如果包的依赖形成了环状结构，怎么样打破这种循环依赖呢？有2种方法可以打破这种循环依赖关系：第一种方法是创建新的包，如果A、B、C形成环路依赖，那么把这些共同类抽出来放在一个新的包D里。这样就把C依赖A变成了C依赖D以及A依赖D，从而打破了循环依赖关系。第二种方法是使用DIP（依赖倒置原则）和ISP（接口分隔原则）设计原则。 无环依赖原则（ADP）为我们解决包之间的关系耦合问题。在设计模块时，不能有循环依赖。 设计模式 java design patterns 基础 设计模式基础参考博客: GoF解释参考博客: 设计模式专栏 23种经典设计模式UML类图汇总 参考博客: 23种设计模式UML表示形式参考博客: 23中设计模式类图和原理详解参考博客: 23种设计模式类图总结 策略者模式 定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。参考博客: 设计模式 ( 十八 ) 策略模式Strategy（对象行为型） 参考博客: Java消除ifelse 也就是说将一种需求的多种实现算法分别封装起来, 然后利用多态, 让调用方选择任一实现 1.创建型设计模式 单例模式(Singleton)原型模式(Prototype)建造者(Builder)抽象工厂(Abstract Factory)工厂方法(Factory Method) 抽象了实例化过程，它们帮助一个系统独立于如何创建，组合和表示它的那些对象。 一个类创建型模型使用继承改变被实例化的类，而一个对象创建型模型将实例化委托给另一个对象 将一组固定行为的硬编码转移为定义一个较小的基本行为集，这些行为可以被组合成任意数目的更复杂性的行为。这样创建有特定行为的对象要求的不仅仅是实例化一个类 Builder 生成器 Builder，是一种对象构建模式，模式通常包含Builder，ConcreteBuilder。Director 和 Product四部分 Abstract Factory 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 Factory Method 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类 Prototype 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 Singleton 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 2.结构型设计模式 适配器模式(Adapter)桥接模式(Bridge)组合模式(Compontent)代理模式(Proxy)享元模式(Flyweight)外观模式(Facade)装饰模式(Decorator) 结构型设计模式涉及如何组合类和对象以获得更大的结构 结构型模式采用继承机制来组合接口或实现。 结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能 Composite模式它将对象组合成树形结构以表示“部分-整体” Flyweight模式该模式为共享对象定义了一个结构，强调对象的空间效率，自由共享 Facade模式（外观模式）描述了如何用单个对象表示整个子系统（外部与其内部通信必须通过一个统一的对象进行交互），模式中的facade用来表示一组对象，外观设计模式提供一个高层次的接口是的子系统易于使用。适用情况: 1.为复杂的子系统提供一个简单的接口 2.客户程序与抽象类的实现部分有很大依赖性 3.构建一个层次结构的子系统时，适用外观模式定义子系统每层的入口 Bridge模式 将对象的抽象和实现分离，从而可以独立的改变他们。 Decorator模式描述如何动态地为对象添加职责，模式采用递归方式组合对象，从而允许添加任意多的对象职责。 3.行为设计模式 策略模式(Strategy)命令模式(Command)状态模式(State)解释器模式(Interpreter)模板方法(Template Method)责任链模式(Chain of Responsibility)迭代器模式(Iterator)中介者模式(Mediator)备忘录模式(Memento)观察者模式(Observe)访问者模式(Visitor) 行为设计模式涉及算法和对象间职责的分配，行为模式描述对象和类的模式以及其通信模式 行为模式使用继承机制在类间派发行为 【常见设计模式】适配器模式 适配器 模式（Adapter）：适配器是的一个接口与其他接口兼容，从而给出了多个不同接口的同一抽象。一般分类结构和对象结构两种： 类适配器：适配器类继承被适配类，实现某个接口，在客户端类中可以根据需求来建立子类 对象适配器：适配器不是继承，是使用直接关联，或称委托方式 中介者模式 中介者 模式：包装了一系列对象相互作用的方式，使得对象间的相互作用是独立变化，但是与中介者紧密联系 观察者模式 观察者 模式 Observer：一个目标物件管理相依于它的管理物件，并且在它本身的状态发生改变时发出通知，这种模式常用来实现事件处理系统。（也称发布-订阅，模型-视图，源-收听者模式） 观察者（接口）：更新信息，展示信息，给 被观察者（形参） 注册上观察者 被观察者（接口）：发出更新通知（遍历观察者集合并注册），当自身发生改动时发出通知消息 单例模式 Singleton 一个类只有一个实例易于外界访问 Spring将该模式运用的出神入化 单例模式与高并发当某个单例对象中含有不具有并发性的对象 就会发生并发问题, 由于只有一个对象, 为了确保数据一致, 就需要加锁, 这样就带来了严重的性能下降, 而Spring是怎么做的呢 参考博客 Spring如何处理线程并发 参考博客: springmvc是单例的，开发的时候会不会影响性能呢？ 参考博客: Spring并发访问的线程安全性问题 Controller或者Service层中定义共享对象, 但是使用线程安全对象 参考博客: 单例模式和Static的区别! static 有可能被实例化多个出来么 装饰器模式 装饰器模式 创建一个新类为某一个类动态添加新功能或增强原有的功能，避免代码重复或具体子类的数量增加 策略模式 优点：灵活添加同一问题的不同解决方案 状态模式 允许对象在内部状态时变更其行为，并且修改其类： 环境类（Context）：定义客户感兴趣的接口，维护一个子类的实例，这个实例就是当前状态 抽象状态类（State）：定义一个接口以封装与Context的一个特定状态相关的行为 具体状态类（concreteState）：每一子类实现与Context的一个状态相关的行为 例题：纸巾售卖机:有四个状态! 【状态图】 【类图】 例题：TCP连接状态: 命令模式 command： 行为请求者 与 请求实现者 之间 紧耦合 的关系 将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化，支持可撤销的操作 下例：使用了接口来实现多态，子类是多个的，方法同名并功能多样的 代码复用好，代码结构清晰【参数类表最好不要出现标志变量，最好分离出另一个方法】 桥接模式 ： 便于扩展，实现与抽象分离（解耦）对一个模块修改不影响别的模块 抽象工厂模式 ： 提供一个创建一系列相关实例相互依赖的对象。 当一个系统要独立于它的产品的创建，组合和表示时 当一个系统要由多个产品系列中的一个来配置时 当需强调一系列相关的产品对象的设计以便进行联合使用时 想提供一组对象而不显示他们的实现过程，只显示他们的接口 原型模式 struts2 就是采用该模式 原型模式 ： 对象创建模型： 允许一个对象创建另一个可定制的对象，封装实例化细节。 实现Cloneable接口（Java自带接口），重写clone方法（在这里实例化对象，new或反射，按需求来修改） 该例，组合关系，在对方使用clone来代替构造器来实例化对象，并做好了绑定操作，大量减少代码量 生成器模式 生成器模式： 实践经验之谈 IBM 社区 Java 设计模式专题 一个鸭子游戏引发的设计（多态，继承，抽象，接口，策略者模式） 不要再盲目的new了！你要学着针对接口编程！（具体方法，Factory，Abstract Factory 参考博客: 为什么我墙裂建议大家使用枚举来实现单例。 自己用Java重写一下这个例子, 并做出自己的总结 反模式末日金字塔: 多层嵌套","categories":[],"tags":[]},{"title":"GraphQL","slug":"Memo-Database-GraphQL","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Database-GraphQL/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Database-GraphQL/","excerpt":"","text":"目录 start GraphQL 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs GraphQL Official Site","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"http://blog.kuangcp.top/tags/GraphQL/"},{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"Oracle","slug":"Memo-Database-Oracle","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Database-Oracle/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Database-Oracle/","excerpt":"","text":"目录 start Oracle 安装 Linux Docker安装 Windows 使用 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Oracle 强大的数据库, 稍微理解一下他的设计都觉得精妙 安装LinuxDocker安装 详情&gt;&gt; Windows使用","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://blog.kuangcp.top/tags/Oracle/"}]},{"title":"Server.md","slug":"Memo-Blog-Server","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Blog-Server/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Blog-Server/","excerpt":"","text":"目录 start Server 终端 内存优化 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Server 服务器运维相关 终端 效率为王：终端管理工具 Tmux 内存优化 参考博客 大内存页配置实战 内存占用大, 访问随机就需要使用大内存页了Oracle官网的使用案例","categories":[],"tags":[]},{"title":"MultipleLanguage","slug":"Memo-Java-AdvancedLearning-MultipleLanguage","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-MultipleLanguage/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-MultipleLanguage/","excerpt":"","text":"目录 start JVM上的多语言使用 语言生态学 重新实现的语言和原生语言 JVM上的多语言编程 Groovy Scala Clojure 为什么非要用Java语言 JVM对备选语言的支持 编译器小说 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs JVM上的多语言使用语言生态学 大致讨论 解释型和编译型， 动态和静态， 命令式和函数式 Java是运行时编译，静态类型的命令式语言。强调安全性，代码清晰，性能，并表现出一定程度的繁琐和死板（例如部署） 解释型和编译型 在80 90 年代，边界较为清晰，类C语言是编译型，Perl和Python是解释型。但Java是两者都有 基于JVM来划分的边界是：该语言是否将源码编译为类文件并且执行，不产生类文件的语言会由解释器逐行执行。有些语言既有编译器又有解释器，有些是既有解释器又有产生字节码的即时编译器JIT 动态和静态类型 动态类型语言，变量在不同的时间可能会有不同的类型 动态类型语言是跟踪变量的值的类型信息，静态类型语言是跟踪变量的类型信息 静态类型适合做编译型语言 命令式和函数式 Java是典型的命令式语言，命令式语言把程序的运行状态建模为可修改的数据，用一系列的指令来改变状态。因此在命令式语言中，程序状态是核心概念 命令式语言主要分为两类，一种是面向过程语言，一种是面向对象语言 面向过程：Basic Fortran 这种语言将代码和数据完全分离开，有简单的代码操作数据范式 面向对象：数据和代码（方法形式）封装在对象中，面向对象语言中或多或少会存在元数据（比如：类信息）引入的额外结构 函数式语言他把计算本身当成最重要的概念。函数式语言和过程式语言一样对值进行操作，但他不会修改输入，而是像数学函数一样返回新值 函数被看成是一个小处理机，输入值并输出值，他们没有自己的状态，并且将他们和任何外部状态绑定在一起也没有意义 Groovy带一点函数式风格，Scala对FP的利用更为充分，Clojure是纯粹的函数式语言，没有丁点儿面向对象特性 重新实现的语言和原生语言 一般来说，以JVM为目标的语言较重新实现的语言能将自己的类型系统和JVM的类型系统结合的更紧密 重新实现已有语言的JVM语言： JRuby：Ruby是一个动态类型的面向对象语言，有些函数式特性，在JVM上基本算解释型的 Jython：动态的面向对象语言。运行方式是先生成Python字节码再转化成JVM字节码。这使得他能以看起来像是Python的典型解释型模式下运行 Rhino：他在JVM上提供了一个JavaScript实现，既支持编译模式，也支持解释模式 JVM上的多语言编程 非Java技术的作用可以分为三个层次 特定领域层，动态层，稳定层，多语言编程金字塔： p178金字塔 静态类型语言更倾向于稳定层的任务，能力不是那么强，通用性较低的技术在金字塔的顶部更好用 Java 、Groovy、 Scala 的未来会怎样？Java &amp; Groovy &amp; Scala &amp; Kotlin - 16.方法，Lambda 与闭包 喜欢Ruby =&gt; 用Groovy 喜欢LISP，喜欢STM功能 =&gt; 用Clojure 喜欢C++ =&gt; 用Kotlin Scala有两个流派：FP和Better Java。FP派喜欢scalaz，喜欢shapeless，喜欢type level programming。这一派特点是程序高度抽象但可读性奇差。适合PL研究者验证概念，适合业余项目自嗨，也适合学习PL概念。不适合多人协作的工程项目。Better Java派以前之所以存在，单纯是因为Java语法设计太烂，烂到无法忍受。而JVM上当时也没有其它更好的选择。那些告诉你“写了n年Java以后，我切换到Scala，现在每天都活在幸福中”的人，基本都是这一派。但Scala as a better Java的工程性也不好，因为特性太多太复杂，除非有高手带队，否则很难只用到它“better java”的那个子集。解决一个问题的同时，往往引入更多的问题。所以会有Java8发布以后Linkedin所有新项目全部回归Java这种事情。 Groovy是动态语言，工程性比Scala还差。但是因为有Gradle这种被广泛采用的项目，所以会存活下去。但是请记住爱因斯坦曾经说过：“任何超过两百行的新项目，都不应该采用动态语言开发，无论是Ruby，Python，Perl，Groovy还是Clojure”。哦，对了，也不要用Clojure。因为它是动态语言，而且是Lisp系的动态语言。“Lisp系”意味着，读书的时候可以靠它开眼界。毕业工作以后，对于这一类语言，能躲多远就躲多远。 刚刚发布的Kotlin看上去靠谱。它不讲究FP有多纯，目标就一个：“a better java”。Kotlin在“到底引入多少FP特性”上面做得恰到好处。 看到Kotlin，我马上就想起了这个演讲：“Please stop polluting our imperative languages with pure concepts”。Kotlin有以下好处： 强大的IDE。而且是JetBrains第一方支持，不是3年更新一次的第三方插件； 库多生态强。Kotlin的设计者非常重视和Java的互操作，所以Kotlin号称可以无缝衔接所有Java库。 宇宙第一运行时：JVM。 Android上不能用Java8的新语法，Kotlin恰逢其时的出现，抓了一波完美的timing。如果Kotlin依靠Android开发爆发，那服务器端，大数据界，也会收益，最后多面开花，势不可挡。但是Kotlin刚出来，到底有没有它自称的那么好用还待观察。另外，Kotlin社区现在集中力量攻坚Android，在服务器和大数据方向没什么靠谱项目。所以还是得用Java8。总之，“魔镜啊魔镜，谁是JVM上最好的语言”之最后决战，将是Java10 vs Kotlin（Java9在语法特性上已经输了）。而在这场最终决战之前，C#已经靠着CoreCLR统一世界了。 最后送上人生经验两则：123match comment with| &quot;X怎么不能Y？人家Z就是这样做的。&quot; -&gt; reply &quot;卡马克能用haskell移植Wolf 3D，你能？&quot;| _ -&gt; reply &quot;Thank you&quot; 123match location with| Office -&gt; use whatever your boss chose| Home -&gt; use F# Groovy James Strachan 于2003年发明，可以看作动态层语言，擅长DSL构建 Scala Martin Odersky 于2003年意外产生，一门支持函数式编程的面向对象语言有一个非常好的ScalaTest测试框架，比Junit更简洁， Clojure Rich Hickey设计的属于Lisp家族的语言，动态类型的函数式语言，编译型语言但是通常以源码发布 为什么非要用Java语言 Java 作为一种通用，静态类型的编译型语言，实现稳定层方便，但是放到金字塔上层就成为负担 编译耗时 静态类型不够灵活，重构时间长 部署麻烦 语法不适合生产DSL（领域专用语言 domain specific language） p180 分类 JVM对备选语言的支持 一种语言要在JVM上运行的两种方式： 一个产生类文件的编译器 一个用JVM字节码实现的解释器 p183.jpg 有一种评估语言运行时环境复杂度的简单方法，看运行实现中Jar的大小，Clojure相对较轻量，JRuby就显得重 编译器小说 语言的某些特性是由编程环境和高层语言合成的，在底层JVM中不存在，这种特性就称为编译器小说 Java中的编译器小说还包括检查型异常和内部类（通常内部类都会转换成带有特殊合成访问方法的顶层类），如果jar -cvf看jar包，能看到很多含$的类，这些就是被取出转换成常规类的内部类备选语言的编译器小说 p184.jpg 函数一等值： 这个就是说可以将函数当成其他普通值一样操作，Java只能把类当做最小的代码和功能单元。解决这种差异的方法是，因为对象只是把数据和操作数据的方法绑定在一起，只要有一个没有状态只有一个方法的对象。 这似乎就是Java8的lambda表达式的存在条件，单方法的实现用操作符 -&gt; 多继承： 在Java和JVM中无法实现多继承，只能使用接口，但是接口又没有任何具体的方法 在Scala中特性机制 trait 允许将方法的实现混合到类中，所以提供了不同的继承视图，这种行为必须由Scala编译器和运行时合成，在VM层面不提供这种特性","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[]},{"title":"JavaWeb","slug":"Memo-Java-AdvancedLearning-Web","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-Web/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Web/","excerpt":"","text":"目录 start Java Web 【JSP/Servlet】 Servlet JSP 九大内置对象 四个作用域 Spring系 缓存 Tips 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Java Web【JSP/Servlet】ServletJSP 参考博客: JSP面试题及答案 九大内置对象123456789request 请求对象 类型 javax.servlet.ServletRequest 作用域 Requestresponse 响应对象 类型 javax.servlet.SrvletResponse 作用域 PagepageContext 页面上下文对象 类型 javax.servlet.jsp.PageContext 作用域 Page session 会话对象 类型 javax.servlet.http.HttpSession 作用域 Session application 应用程序对象 类型 javax.servlet.ServletContext 作用域 Application out 输出对象 类型 javax.servlet.jsp.JspWriter 作用域 Page config 配置对象 类型 javax.servlet.ServletConfig 作用域 Page page 页面对象 类型 javax.lang.Object 作用域 Page exception 例外对象 类型 javax.lang.Throwable 作用域 page 来源: 四个作用域 参考博客: JSP的四大作用域1234application 在所有应用程序中有效session 在当前会话中有效request 在当前请求中有效page 在当前页面有效 Spring系缓存如何做Etag缓存 自定义了EtagCache注解 通过拦截器判断带EtagCache注解的Controller 通过Spring Data Jpa自带的乐观锁 version, 针对每个资源就可以做到EtagCache 将其值放在http的header中 还有另一种做法就是 自己针对内容进行hash code编码 Tips 1、JSP页面上的SQL标签以及EL标签是优先于文件头的那些JavaServlet语句运行的，所以要保证非法进入页面时重定向的问题 2、如果想要获取异常来据此返回参数到页面弹窗提示，那么就要对一层层的方法调用，进行查找，所有的try catch 块 都要检查 因为一般我的习惯就是把异常当场就处理了，而要实现这个要求就必须将异常层层上抛！！！！ 3、中文乱码问题： 接收 使用get方法，需要转换成gbk :newString(s.getBytes(&quot;ISO-88511-1&quot;,&quot;gbk&quot;); post方法需要转换成UTF-8 回应 均使用UTF-8 4、查询数据： 使用set集合，查询对象是否存在，使用contians 5、Servlet 是单例多线程的 6、eclipse中将java项目转成web项目 经常在eclipse中导入web项目时，出现转不了项目类型的问题，导入后就是一个java项目，有过很多次经历，今天也有同事遇到类似问题，就把这个解决方法记下来吧，免得以后再到处去搜索。解决步骤： 1、进入项目目录，可看到.project文件，打开。 2、找到&lt;natures&gt;...&lt;/natures&gt;代码段。 3、在第2步的代码段中加入如下标签内容并保存： &lt;nature&gt;org.eclipse.wst.common.project.facet.core.nature&lt;/nature&gt; &lt;nature&gt;org.eclipse.wst.common.modulecore.ModuleCoreNature&lt;/nature&gt; &lt;nature&gt;org.eclipse.jem.workbench.JavaEMFNature&lt;/nature&gt; 4、在eclipse的项目上点右键，刷新项目。 5、在项目上点右键，进入属性（properties） 6、在左侧列表项目中点击选择“Project Facets”，在右侧选择“Dynamic Web Module”和”Java”，点击OK保存即可。 RPC RMI RPC Remote Process Calls RMI Remote Methos Invocation","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://blog.kuangcp.top/tags/Web/"}]},{"title":"Java线程","slug":"Memo-Java-AdvancedLearning-Thread","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-Thread/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Thread/","excerpt":"","text":"目录 start 线程的基础学习 TODO 基础 线程的意义 线程的生命周期 创建 控制 销毁 线程的优先级 线程池 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 线程的基础学习 个人相关代码 TODO 线程的多种创建方式 线程池的创建方式 线程的状态转化 基础 码农翻身:我是一个线程 | 码农翻身:编程世界的那把锁 | 码农翻身:加锁还是不加锁，这是一个问题 线程的意义线程的生命周期 参考博客 | Blog: 线程详解 | 参考Java-learning仓库 创建 创建线程有三种创建方式： 继承，实现接口，实例化匿名内部方法。-&gt; 示例代码 查看Thread类源码 看看Thread类源码，捋清Runnable，target,run,start关系 Runnable是一个接口 target是Thread类中类型为Runnable，名为target的属性 run是Thread类实现了Runnable的接口，重写的方法。 start是启动线程的方法 在Thread类中，调用关系为：start-&gt;start0-&gt;run-&gt;target.run Thread类的run方法源码12345public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; Thread类的target属性12/* What will be run. */private Runnable target; target属性由 private void init(ThreadGroup g, Runnable target, String name,long stackSize, AccessControlContext acc)方法初始化。 init方法在Thread类的构造方法里被调用 控制 当调用 Thread.join() 时，调用线程将阻塞，直到目标线程完成为止。 销毁 线程的优先级 多个线程同时运行时,由线程调度器来决定哪些线程运行,哪些等待以及线程切换的时间点. 由于各个操作系统的线程调度器的实现各不相同, 所以依赖JDK来设置线程优先级策略是错误和非平台可移植性的. 线程池 线程池 BlockingQueue synchronized volatile参考博客: Java(Android)线程池参考博客: Java ThreadPoolExecutor线程池使用的一个误区参考博客: 聊聊并发（三）Java线程池的分析和使用参考博客: 线程池","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"http://blog.kuangcp.top/tags/Thread/"}]},{"title":"Java网络编程","slug":"Memo-Java-AdvancedLearning-Socket","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-Socket/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Socket/","excerpt":"","text":"目录 start Socket 基础 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Socket基础 其实就是Socket 码农翻身:张大胖的socket 得到URL文件的输入流 new URL(url).openStream() 使用Linux编程开启web容器时java.net.SocketException: 权限不够 参考博客 快速解决，不使用小于1024的端口即可，或者提权","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"Socket","slug":"Socket","permalink":"http://blog.kuangcp.top/tags/Socket/"}]},{"title":"Java反射","slug":"Memo-Java-AdvancedLearning-Reflect","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-Reflect/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Reflect/","excerpt":"","text":"目录 start 反射 获取属性 获得方法 性能问题 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 反射 Java反射异常处理之InvocationTargetException 参考博客: java8–类加载机制与反射(java疯狂讲义3复习笔记)参考博客: Java8替代传统反射动态获取成员变量值的一个示例 参考博客: java反射的性能问题 获取属性通过属性名得到对象属性的值123PropertyDescriptor propertyDescriptor = new PropertyDescriptor(meta.getField().getName(), target);Method method = propertyDescriptor.getReadMethod();Object result = method.invoke(model); 或者如下方式更为简洁123456789// setA a = new A();Field field = a.getClass().getDeclaredField(\"x\");field.setAccessible(true);field.set(a, 1);// getField f = a.getClass().getDeclaredField(\"x\");f.setAccessible(true);System.out.println(f.get(a)); 获得方法性能问题 参考博客: java反射的性能问题","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"Reflect","slug":"Reflect","permalink":"http://blog.kuangcp.top/tags/Reflect/"}]},{"title":"JVM","slug":"Memo-Java-AdvancedLearning-JVM","date":"2018-12-17T13:25:18.711Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-JVM/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-JVM/","excerpt":"","text":"目录 start JVM Hotspot JVM OpenJ9 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs JVM Oracle 默认采用的是 Hotspot JVM Hotspot JVMOpenJ9IBM主导开发, 捐赠给Eclipse基金会 Officail Site | IBM原文 Github: 参考博客: IBM开源JVM实现OpenJ9，并提交Eclipse基金会托管)参考博客: Eclipse Open J9：Eclipse OMR项目提供的开源JVM","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://blog.kuangcp.top/tags/JVM/"}]},{"title":"GradleAdvance.md","slug":"Memo-Java-Tool-GradleAdvance","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Tool-GradleAdvance/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-GradleAdvance/","excerpt":"","text":"目录 start Gradle进阶知识 Gradle 使用和配置 主配置目录 Gradle 构建块 task task的依赖关系 终结器 task Groovy的POGO类管理配置文件上的版本号 task 的inputs 和 outputs 编写和使用自定义task 声明task规则 增量式构建特性 测试模块 单元测试 使用JUnit 使用其他框架 TestNG Spock 配置测试执行 多语言编程 处理javascript 压缩javascript Java 和 Groovy的联合编译 Java 和 Scala Jenkin 使用 下载安装和配置 发布自己的构件 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Gradle进阶知识 gradle api 所有{}结构 以及配置 davenkin的学习仓库个人学习Gradle的记录仓库 Gradle 使用和配置主配置目录 ~/.gradle 12345678910111213141516171819├── caches│ ├── 4.8│ ├── 4.9│ ├── jars-3│ ├── modules-2│ │ ├── files-2.1 依赖的Jar 缓存目录│ │ ├── metadata-2.58│ │ └── modules-2.lock│ └── transforms-1├── daemon│ ├── 4.8│ └── 4.9├── native│ ├── 25│ └── jansi├── notifications│ ├── 4.8│ └── 4.9└── workers ~/.gradle/caches/modules-2/files-2.1 等价于Maven的 ~/.m2/repository 目录不得不说, 这个目录很丑, 字母加字符短杠..强迫症很难受 那么问题来了, 以前一直以为是和Maven共用一个仓库 他和Maven本地仓库没有半毛钱关系, 他只是去复制了一下而已! 详情 Gradle 构建块 三个基本块 project task property， 使用DDD（领域驱动设计） 一个真实的项目包含多个project 而 Project又包含多个task ，task之间通过依赖来确保执行顺序 build.gradle 和 pom.xml 作用是一致的，但是gradle可以使用一份源码 构建出多种想要的目标程序 task doc:task task的依赖关系1234567891011121314151617 version = '0.1-SNAPSHOT' task first &#123; println 'First Run !' &#125; task second &#123; println 'Second Run !' &#125; task printVersion (dependsOn:[second,first])&#123; doLast &#123; println \"Version : $version\" logger.quiet \"Version : $version\" &#125; &#125; task third &lt;&lt;&#123;println 'Third Run!' &#125; third.dependsOn('printVersion') 如果把second的定义放在First前面，就会先运行second 这个例子就说明了，被依赖方的运行，不是按照声明的顺序，而是定义的顺序 （因为依赖是只要被依赖方执行即可，和顺序关系不是很大） 还可以使用SLF4J的logger实现 日志级别 DEBUG,ERROR,INFO,TRACE,WARN ,还有QUIET… 如果 是 gradle -b tasksL.gradle -q third 就会运行所有的task，因为这是最后一层依赖 如果 是gradle -b tasksL.gradle -q printVersion 就会只运行 printVersion 如果整个文件有编译错误也是不运行的 终结器 task12345task f&lt;&lt;&#123;println 'first'&#125;task s&lt;&lt;&#123;println 'second'&#125;f.finalizedBy s//当运行 gradle f 就会自动触发 s//如果gradle s 就和f没有任何关系了 Groovy的POGO类管理配置文件上的版本号 taskL.gradle gradle -b tasksL.gradle -q printVersion 虽然只是 运行了这个task 但是读取文件的task也被自动调用了 因为Gradle的构建生命周期阶段如下: 初始化、配置和执行 读取文件就属于配置阶段 注意 : 项目的每一次构建都会运行属于配置阶段的代码，即使你只是运行了 gradle tasks task 的inputs 和 outputs 流程 : inputs -&gt; |task| -&gt; outputs gradle通过比较两个task的inputs和outputs来决定task是否最新 如果inputs和outputs没有改变 就不会执行该task 输入和输出可以是，一个文件，多个文件，一个目录，一个property属性 示例代码:turnVersion.gradle makeRealeseVersion : 将一个项目的版本切换为发布版本 IOReleaseVersion : 通过inputs/outputs来添加增量式构建支持 发现并不能得到书上的预期效果，书上是说改动了properties文件才会让这个task运行，没有改就会说 up-to-date 但是实际得到的是，改动了properties或者是构建文件都会引起task运行，两者都不改动就不会运行task，而且不会有输出提示up-to-date，要自己手动logger 编写和使用自定义task 自定义task包含两个组件： 自定义的task类，封装了逻辑行为，也被称为任务类型 真实的task 提供了用于配置行为的task类所暴露的属性值 这个task就是做到了改配置文件，确保是RELEASE版本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//先要实例化version属性对象的存在 version = new ProjectVersion(0,1,true) //继承DefaultTask类型的自定义task类 class ReleaseVersionTask extends DefaultTask&#123; @Input Boolean release @OutputFile File destFile ReleaseVersionTask()&#123; group = 'versioning' description = 'Make Project a release version' &#125; //task的行为逻辑 @TaskAction void start ()&#123; project.version.release = true; ant.propertyfile(file:destFile)&#123; entry(key:'release',type:'string',operation:'=',value:'true') &#125; println \"$project.version\" &#125;&#125;//version的POGO类class ProjectVersion&#123; Integer major Integer minor Boolean release ProjectVersion (Integer major ,Integer minor)&#123; this.major = major this.minor = minor &#125; ProjectVersion (Integer major ,Integer minor,Boolean release)&#123; this(major,minor) this.release = release &#125; @Override String toString()&#123; \"$major.$minor$&#123;release?'-RELEASE':'-SNAPSHOT'&#125;\" &#125;&#125;//真实的task，用来操作自定义类暴露的几个属性//使用命令来运行，本质是运行真实的task但是行为逻辑在自定义类中编写//gradle -b UserDefineTask.gradle -q makeReleaseVersion//如果要改动一些数据可以直接更改暴露的task而不用去改自定义的task类task makeReleaseVersion(type:ReleaseVersionTask)&#123; release = 'true' destFile = file('version.properties')&#125; 声明task规则123456789101112131415161718192021222324252627282930313233343536373839404142434445 //All used property must define and initial first version = new ProjectVersion(0,1,true) ext.versionFile = file('version.properties') class ProjectVersion&#123; Integer major Integer minor Boolean release ProjectVersion (Integer major ,Integer minor)&#123; this.major = major this.minor = minor &#125; ProjectVersion (Integer major ,Integer minor,Boolean release)&#123; this(major,minor) this.release = release &#125; @Override String toString()&#123; \"$major.$minor$&#123;release?'-RELEASE':'-SNAPSHOT'&#125;\" &#125; &#125; // task规则的定义 tasks.addRule(\"Pattern: increment&lt;Classifier&gt;Version - Increment the project version classifier.\" )&#123; //根据预定义模式来检查task的名称 String taskName -&gt; if(taskName.startsWith('increment') &amp;&amp; taskName.endsWith('Version'))&#123; //根据符合命名模式的task动态添加一个doLast的方法 task(taskName)&lt;&lt;&#123; //从完整的task名称中提取类型字符串， //字面意思是将字符串中increment和Version两个串去除掉然后转小写再赋值 String classifier = (taskName - 'increment' - 'Version').toLowerCase() String currentVersion = version.toString() switch (classifier)&#123; case 'major':++version.major break case 'minor':++version.minor break default : throw new GradleException(\"Invalid version type '$classifier' . Allow types :['Major','Minor']\") &#125; String newVersion = version.toString() logger.info \"Increment $classifier project version: $currentVersion -&gt; $newVersion\" ant.propertyfile(file:versionFile)&#123; entry(key:classifier,type:'int',operation:'+',value:1) &#125; &#125; &#125;&#125; 运行 gradle -b RulesTask.gradle -q incrementMinorVersion就可以增加版本号了，就是一个动态的执行命令的机制 使用 incrementMajorVersion就可以增加主版本号 如果运行 gradle -b RulesTask.gradle -q tasks 就会得到一个具体的tasks的组Rules 增量式构建特性 如果Java源文件与最后一次运行的构建不同的话，运行 compileJava task 将充分提高构建的性能 测试模块 凡是依赖于本地环境的测试，使用完就注释Test注解，还有那些会CRUD，影响到数据的测试方法也是以防以后线上测试通不过 打包失败, 跳过测试 gradle build -x test 或者是 --exclude-task test 参数 单元测试使用JUnit 使用Junit4 使用其他框架 TestNG Spock配置测试执行 多语言编程处理javascript压缩javascript 调用Google Closure Compiler 的task 来压缩javascript文件 将所有的javascript压缩成一个javascript文件 执行该task gradle :web :taskname 执行之后就能得到一个优化的js文件，现在就要在页面中修改原来的js引用 Java 和 Groovy的联合编译 src 下 main 下 java 和groovy 的一个目录结构，直接编译就会发生Java无法依赖groovy的类 错误：需要配置 sourceSets.main.java.srcDirs=[] sourceSets.main.groovy.srcDirs=[&#39;src/main/java&#39;,&#39;src/main/groovy&#39;] 正确： sourceSets.main.java.srcDirs=[&#39;src/main/java&#39;,&#39;src/main/groovy&#39;] 上面的会报错 配置好后就能把groovy当普通Java类直接使用了 Java 和 Scala 联合双向编译 Java和scala sourceSets.main.scala.srcDirs sourceSets.main.groovy.srcDirs=[&#39;src/main/java&#39;,&#39;src/main/scala&#39;] 那么问题来了，如果是有了java groovy scala 呢怎么配置编译，直接就加上就好了嘛？ Jenkin 使用下载安装和配置 官网下载war包后，直接使用Java命令运行 或者放在web容器中运行 配置下载插件（位置在C盘用户目录下， 其实第一次运行后也是会解压在.jenkin 目录下 插件就在plugin目录下） 发布自己的构件如何发布Jar包到Maven Central Repository","categories":[],"tags":[]},{"title":"SpringbootDatabase.md","slug":"Memo-Java-Spring-SpringbootDatabase","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-SpringbootDatabase/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringbootDatabase/","excerpt":"","text":"目录 start 数据库模块 Relational Database 多数据源配置 连接池 c3p0 druid HikariPool JPA Configuration Mybatis 自定义查询 HQL 原生SQL Mysql 映射关系 一对一 一对多 多对多 Restful设计 【特别注意】 Jpa数据分页 数据库上的事务支持 Non Relational database JPA Redis的简单使用 关于StringRedisTemplate的方法使用 消息订阅和发布 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 数据库模块 主要是采用的JPA，极大的缩减了代码量，但是要注意不要过度依赖框架，丧失了基本的能力 Relational Database多数据源配置 为什么要有多数据源? 思考 Spring Boot多数据源配置与使用 连接池c3p0 参考博客 druid druid连接池的配置 HikariPool 性能最好的数据库连接池 听说代码很精简, 阅读源码学习 JPA 连接池:1.x 默认是tomcat-jdbc连接池 2.x 是 HikariPool 参考博客: spring boot2 整合（二）JPA Configuration Official Docddl-auto JPA 默认是该配置 spring.jpa.hibernate.ddl-auto 但是如上配置没有生效的话就要用 这个 spring.jpa.properties.hibernate.hbm2ddl.auto none 什么都不做 create-only create 先删除, 然后建立新的表 create-drop 先删除, 然后建立新的表, 然后在SessionFactory实例关闭后再删除 update 创建和修改 validate 校验是否一致, 不一致就报错,启动失败 Blog: 原生SQL的写法 [ ] 怎么映射视图到实体上? Mybatis IDEA下创建Springboot，thymeleaf，Mybatis，Postgresql，Gradle项目 自定义查询HQL 使用Hibernate语法模式,将对象和数据库的表看成一个实体,方便书写SQL,但是在Controller层和Service层 进行写代码的时候,参数的传递全是实体对象,要不停的new,这样真的没问题么(当有各种复杂的关联关系的时候,单个对象的CURD基本没有什么问题) TODO 所以还不如直接写原生SQL! 那么JPA就真的没有使用的必要性了,直接用Mybatis结合插件生成自动的CRUD的代码,这样更为轻量 待后续使用后再回来填坑 原生SQL 涉及到数据的修改,就要加上前两个前缀,查询就直接写Query注解即可123@Modifying@Transactional@Query(value = \"update a set b=?1\", nativeQuery = true) Mysql 1.引入依赖 123compile('org.springframework.boot:spring-boot-starter-data-jpa')compile('org.springframework.boot:spring-boot-starter-jdbc')runtime('mysql:mysql-connector-java') 2.继承接口，打好实体类的注解 @Entity 3.切记 属性名不能使用下划线（数据库风格）不然写声明方法就会报错，jpa只是看下划线前半部分，会说找不到属性 jpa在创建表时会把驼峰命名改成数据库风格的形式 4.jpa是声明特定方法的接口，让jpa来实现并自动注入，如果是没有的方法，就可以使用@Query注解 默认使用的是HQL（HQL是基于类的所以使用的是类的名字不是表的名字），可以设置下使用原生SQL 映射关系一对一 据说这是性能最好的方式, 但是有一点让人不舒服, A的id是名存实亡的, 数据库都没有这个字段, 实际上就是B的id, 但是对象又一定要保留这个id, 不然约束通不过也就是说, 创建的时候要设置A的id的值, 但是后面却用不到这个值 123456789101112131415161718@Entity@Datapublic class A &#123; @Id private String id; private String name; @OneToOne(fetch = FetchType.LAZY) @MapsId private B b;&#125;@Data@Entitypublic class B implements Serializable &#123; @Id private String id; private String name;&#125; 一对多 一方的配置是当前类的id，多方则按基本ER的规则来，注解中配置的是外键的名字, 所以当前类中的属性,外键名是不能重复的 12345678910111213141516 // 一方public class TestOne&#123; @Id private String testOneId; @OneToMany @JoinColumn(name = \"testOneId\")//这个名字可以重复，最终会有一个随机码生成 private Set&lt;TestMany&gt; testManySet;&#125; // 多方public class TestMany &#123; @Id private String testManyId; @ManyToOne @JoinColumn(name = \"testOneId\") private TestOne testOneId;&#125; [ ] 问题: 当两个表互相引用了, 需要修改表结构 ,怎么删除重建两张表结构, 简单的命令会陷入死锁 多对多 Restful设计 1.添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;&lt;/dependency&gt; 2.引入自动配置类 123456789101112131415@Configurationpublic class RestConfiguration extends RepositoryRestMvcConfiguration &#123; @Override public RepositoryRestConfiguration config() &#123; return super.config(); &#125; @Override public ProfileResourceProcessor profileResourceProcessor(RepositoryRestConfiguration config) &#123; // 设置rest根目录是应用路径下的路径 : localhost:8080/rest config.setBasePath(\"/rest\"); // 允许输出id config.exposeIdsFor(Goods.class); return super.profileResourceProcessor(config); &#125;&#125; 3.配置repository的名字例如：（只要配置repository就能用REST了） 12@RepositoryRestResource(path = \"book\")public interface BookDao extends JpaRepository&lt;Book,Long&gt;&#123;&#125; 4.启动应用，控制台有如下输出 输出 所有路径的使用方法： GET 查询单个 /repo/id 成功：200 失败404 GET 查询所有 /repo 成功200 失败404 POST 新增 /repo json数据发送 成功 201 失败404 DELETE 删除 /repo/id json数据 成功204 失败404 PUT 更新 /repo/id json 更新成功200 没有该id就插入201 失败404（使用主键自动增长就不会遇到404） 【特别注意】 rest得到的数据没有id 添加配置 config.exposeIdsFor(Goods.class); 即可查看到id 参考博客 Jpa数据分页 参考博客 分页 page 从0开始 size是个数 sort可以不需要（如果本来就是id排序就没必要了） 原理就是 预编译SQL然后查询总数，然后再执行 必须有两条SQL执行 查询的结果不包含实体的id属性 数据库上的事务支持 JPA对所有默认方法都开启了事务支持，查询类事务默认启用readOnly=true Non Relational databaseJPARedis的简单使用配置连接信息12345678910111213141516171819# REDIS (RedisProperties)# Redis数据库索引（默认为0）spring.redis.database=0# Redis服务器地址spring.redis.host=127.0.0.1# Redis服务器连接端口spring.redis.port=6379# Redis服务器连接密码（默认为空）spring.redis.password=# 连接池最大连接数（使用负值表示没有限制）spring.redis.pool.max-active=8# 连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.pool.max-wait=-1# 连接池中的最大空闲连接spring.redis.pool.max-idle=8# 连接池中的最小空闲连接spring.redis.pool.min-idle=0# 连接超时时间（毫秒）0不超时spring.redis.timeout=0 在一个配置类中复制如下代码即可使用 StringRedisTemplate RedisTemplate 的实例123456789101112131415161718192021222324252627282930 @Bean public RedisTemplate&lt;Object,Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;Object,Object&gt; template = new RedisTemplate&lt;&gt;(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); template.setConnectionFactory(factory); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 值序列化采用 jackson2JsonRedisSerializer template.setValueSerializer(jackson2JsonRedisSerializer); // 键序列化采用 StringRedisSerializer template.setKeySerializer(new StringRedisSerializer()); template.afterPropertiesSet(); return template; &#125; @Bean StringRedisTemplate template(RedisConnectionFactory connectionFactory) &#123; return new StringRedisTemplate(connectionFactory); &#125;``` `两个对象的简单使用````java stringRedisTemplate.opsForValue().set(\"aaa\", \"hello\"); String result = stringRedisTemplate.opsForValue().get(\"aaa\"); //获取所有 Set&lt;String&gt; keysList = stringRedisTemplate.keys(\"*\"); for(String temp :keysList)&#123; log.info(temp); &#125; 以上配置的template都是只是建立在最简单的键值对上，String-String，所以对象使用的是json来存储 但是使用的时候如同使用MySQL一样，是ORM框架自动处理数据的转换 关于StringRedisTemplate的方法使用 常见数据类型的中间对象 opsForValue() 操作简单键值对数据 hasKey() opsForHash() 操作含有hash的数据 opsForList() 操作含有list的数据 opsForZSet() 操作含有zset（有序）的数据 range()方法返回指定范围的数据 Java中Set类型的（诡异的是顺序保持了一致） opsForSet() 操作含有set的数据 设置超时时间 redisTemplate.expire(&quot;max&quot;,tempTime,TimeUnit.SECONDS); 消息订阅和发布参考博客: Spring Boot使用Redis进行消息的发布订阅","categories":[],"tags":[]},{"title":"Maven.md","slug":"Memo-Java-Tool-Maven","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Tool-Maven/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-Maven/","excerpt":"","text":"目录 start Maven 1.安装 1.1.Maven常用命令 从jar安装到本地库 1.2.settings.xml配置 配置镜像源 阿里云 配置本地仓库 2.maven配置 2.1.eclipse中配置 2.2.配置插件 2.3.POM配置文件详解 2.4.配置代码编译版本 3.构建 3.1.使用maven构建多模块的项目 3.2.Maven多配置环境 3.3.部署 4.maven的依赖 4.1 依赖的范围 依赖的传递 4.2.处理项目间依赖方法 4.3.依赖冲突 排除依赖 4.4.继承 5.使用maven新建Web3.0项目 5.1.添加web容器 5.1.2.Jetty 5.1.3.Tomcat 5.2.加入Servlet的API包 6.常用插件 6.1.lombok 6.2 protobuf 7.构建工具对比 7.1.Maven和Ant的区别一 7.2.Maven的优势 8.发布构件到公共仓库 9.配置私服 nexus 码云 创建仓库 引用仓库中的构件 Gradle Maven 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Maven 官网 | 官网手册 | http://takari.io/ 在线练习网关于Maven的完整博客 1.安装 下载zip包解压，将bin目录配置至PATH（最好是配置MAVEN_HOME然后引用） 1.1.Maven常用命令 mvn [插件]:[目标] [参数]mvn [阶段] mvn archetype:generate ：创建 Maven 项目 -DgroupId=组织名/公司网址的反写+项目名 -DartifactId=项目名-模块名 -Dversion=版本号 -Dpackage=代码所在的包 compile ：编译源代码 test-compile ：编译测试代码 test ： 运行应用程序中的单元测试 site ： 生成项目相关信息的网站 clean ：清除目标目录中的生成结果 package ： 依据项目生成 jar 文件 install ：在本地 Repository 中安装 jar deploy：将jar包发布到远程仓库 使用id为ChatServer的Profile -PChatServer 跳过测试 -Dmaven.test.skip=true 不执行测试用例，也不编译测试用例类。 -DskipTests=true 不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下 -Dmaven.javadoc.skip=true 跳过文档生成 配置文件中配置1234567&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt;&lt;/plugin&gt; 从jar安装到本地库123456mvn install:install-file -Dfile=D:\\mvn\\spring-context-support-3.1.0.RELEASE.jar \\ -DgroupId=org.springframework \\ -DartifactId=spring-context-support \\ -Dversion=3.1.0.RELEASE \\ -Dpackaging=jar 1.2.settings.xml配置 要特别注意 settings.xml 后者覆盖前者 加载顺序是: maven目录/conf/setting.xml用户目录下/.m2/setting.xml 配置镜像源 在 用户目录下 .m2/setttings.xml 中 找到 mirrors 标签 进行添加mirror节点即可 阿里云123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 配置本地仓库localRepository节点 2.maven配置2.1.eclipse中配置 高版本自带maven，需要注意的是eclipse的JRE运行环境目录要选择jdk下的JRE目录 2.2.配置插件 插件地址 2.3.POM配置文件详解 版本说明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;反写的公司域名+项目名&lt;/groupId&gt; &lt;artifactId&gt;项目名+模块名&lt;/artifactId&gt; &lt;!-- 第一个 0 是大版本号 第二个 0 是分支版本号 第三个 0 是小版本号 snapshot 快照 alpha 内部测试 beta 公测 RC 发行候选版本 Release/GA 正式发布 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!--jar war zip pom--&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--项目描述名--&gt; &lt;name&gt;test&lt;/name&gt; &lt;!--项目地址--&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!--项目描述--&gt; &lt;description&gt;&lt;/description&gt; &lt;developers&gt;&lt;/developers&gt; &lt;licenses&gt;&lt;/licenses&gt; &lt;orgnazation&gt;&lt;/orgnazation&gt; &lt;!-- 配置属性 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- 统一定义版本 --&gt; &lt;springframework.version&gt;1.5.6&lt;/springframework.version&gt;&lt;/properties&gt; &lt;!--依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- test 表明这个构件只在test目录下可以被引用 compile 默认的 provided 只在编译中引用 runtime 编译和运行都有效 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--设置依赖是否可选，默认是false--&gt; &lt;optional&gt;&lt;/optional&gt; &lt;!--排除依赖传递列表--&gt; &lt;exclusions&gt;&lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 构件三要素 --&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--继承--&gt; &lt;parent&gt;&lt;/parent&gt; &lt;modules&gt; &lt;module&gt;&lt;/module&gt; &lt;/modules&gt; 2.4.配置代码编译版本12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.构建3.1.使用maven构建多模块的项目.gitignore文件1234.idea/*.imltarget/*.log 父项目pom文件12345678910111213&lt;groupId&gt;com.github.kuangcp&lt;/groupId&gt;&lt;artifactId&gt;Modules&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;modules&gt; &lt;module&gt;repository&lt;/module&gt; &lt;module&gt;service&lt;/module&gt; &lt;module&gt;website&lt;/module&gt;&lt;/modules&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt; 子项目pom文件12345678&lt;artifactId&gt;website&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;parent&gt; &lt;groupId&gt;com.github.kuangcp&lt;/groupId&gt; &lt;artifactId&gt;Modules&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 3.2.Maven多配置环境 Maven 如何为不同的环境打包 开发、测试和产品环境 子项目编译打包各自独立，怎么整合成一个 3.3.部署 Java项目部署方式整理 4.maven的依赖4.1 依赖的范围 依赖范围就是用来控制依赖和三种classpath(编译classpath，测试classpath、运行classpath)的关系 compile:编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。 典型的例子是spring-core,在编译、测试和运行的时候都需要使用该依赖。 test: 测试依赖范围。使用次依赖范围的Maven依赖，只对于测试classpath有效 在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。 provided:已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。 典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要Maven重复地引入一遍。 runtime:运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。 典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。 依赖范围 Scope 对于编译classpath 对于测试classpath 对于运行classpath Demo compile Y Y Y spring-boot-starter-web test Y Junit provided Y Y servlet-api runtime Y Y JDBC的实现Jar system Y Y Maven仓库之外的类库文件 依赖的传递 比如一个account-email项目为例 account-email有一个compile范围的spring-code依赖， spring-core有一个compile范围的commons-logging依赖， 那么commons-logging就会成为account-email的compile的范围依赖，commons-logging是account-email的一个传递性依赖 4.2.处理项目间依赖方法12345项目A依赖BA项目 pom.xml中配置依赖 （构件三要素）B项目 先clean package 然后build 的 installA 项目 compile 4.3.依赖冲突 依赖路径短优先 1 A-&gt;B-&gt;C-&gt;X(jar文件) 2 A-&gt;C-&gt;X(jar文件) 会选择 2 中的X的jar版本 先声明的优先 排除依赖对应的&lt;dependency&gt;标签中添加123456&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt;&lt;/exclusions&gt; 4.4.继承 新建一个项目作为父项目然后在需要引用父项目的子项目pom文件中, 加上parent 标签里面写上 父项目的三要素 5.使用maven新建Web3.0项目 网络maven仓库 新建maven 选择webapp 然后输入三要素 但是因为模板默认的是web2.3，所以要手动修改成3.0 pom文件中添加插件 编译部分12345678&lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt;&lt;/plugin&gt; 2.navigator目录模式下 修改相关文件，把2.3改成3.0 3.eclipse中右击改动Facets 然后maven-update一下就可以了 5.1.添加web容器5.1.2.Jetty http://mvnrepository.com/ 里找到想要的版本，加入即可特别注意 NIO的原因，静态文件在服务器启动的时候不能更改，需要找到maven仓库下的org/eclipse/jettyjetty-webapp/下的jar包中的default配置文件，把useFileBuffer标签的 true 改成false 123456789101112131415161718192021222324252627282930&lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;8.1.16.v20140903&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在打包成功后使用jetty:run来运行 --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;stopKey&gt;stop&lt;/stopKey&gt; &lt;stopPort&gt;9999&lt;/stopPort&gt; &lt;scanIntervalSeconds&gt;1&lt;/scanIntervalSeconds&gt; &lt;contextXml&gt;$&#123;project.basedir&#125;/src/main/resources/jetty-context.xml&lt;/contextXml&gt; &lt;webApp&gt; &lt;!--这里配置主机后的目录，现在表示根目录，最好加上项目名例如： /Project --&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/webApp&gt; &lt;connectors&gt; &lt;connector implementation=\"org.eclipse.jetty.server.nio.SelectChannelConnector\"&gt; &lt;port&gt;80&lt;/port&gt; &lt;maxIdleTime&gt;60000&lt;/maxIdleTime&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;/configuration&gt;&lt;/plugin&gt; 部署成功后，使用jetty:run 即可运行起服务器 5.1.3.Tomcat 去Tomcat官网 找到maven plugins进入找到想要的版本即可 1234567891011121314151617181920&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat6-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在打包成功后使用tomcat6:deploy来运行 --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;!-- 注意此处的url --&gt; &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; &lt;server&gt;tomcat6&lt;/server&gt; &lt;!-- 此处的名字必须和setting.xml中配置的ID一致 --&gt; &lt;path&gt;/mavenProject&lt;/path&gt; &lt;!-- 此处的名字是项目发布的工程名 --&gt; &lt;/configuration&gt;&lt;/plugin&gt; 部署完成后 tomcat7:deploy 运行服务器 5.2.加入Servlet的API包123456 &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 6.常用插件6.1.lombok 极大的简化了bean的代码量 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 6.2 protobuf maven 插件 本质还是要使用系统安装的protoc, 然后插件实现了自动编译文件 7.构建工具对比 码农翻身:小李的Build之路(上) | 码农翻身:小李的Build之路(下) 这个小故事讲述了ant到maven的演化 7.1.Maven和Ant的区别一 ant脚本是可以直接运行在maven中的。maven和ant最大的差别就是在于maven的编译以及所有的脚本都有一个基础，就是POM（project object model）。这个模型定义了项目的方方面面，然后各式各样的脚本在这个模型上工作，而ant完全是自己定义，显然maven更胜一筹。 maven对所依赖的包有明确的定义，如使用那个包，版本是多少，一目了然。而ant则通常是简单的inclde 所有的jar。导致的最终结果就是，你根本无法确定JBoss中的lib下的common－logging 是哪个版本的，唯一的方法就是打开 META－INF 目录下MANIFEST.MF。 maven是基于中央仓库的编译，即把编译所需要的资源放在一个中央仓库里，如jar，tld，pom，等。当编译的时候，maven会自动在仓库中找到相应的包，如果本地仓库没有，则从设定好的远程仓库中下载到本地。这一切都是自动的，而ant需要自己定义了。这个好处导致的结果就是，用maven编译的项目在发布的时候只需要发布源码，小得很，而反之，ant的发布则要把所有的包一起发布，显然maven又胜了一筹。 maven有大量的重用脚本可以利用，如生成网站，生成javadoc，sourcecode reference，等。而ant都需要自己去写。 maven目前不足的地方就是没有象ant那样成熟的GUI界面，不过mavengui正在努力中。目前使用maven最好的方法还是命令行，又快又方便 7.2.Maven的优势 协同开发的基本规范，为大家提供方便的协作的模式，能增加代码的复用，提高生产率。 提供方便，规范化的打包方法，是公司完成自动构建系统的核心部分，能帮助提高敏捷开发的效率(敏捷开发提倡尽早集成)。 减少冗余，减少出错的可能。 中心资源库管理，能减低源码库的大小，中心资源库可以统一定期备份。 目录结构规范，让开发者从一个maven项目过度到另一maven项目很容易。 大量的开源项目使用了maven。 8.发布构件到公共仓库 Jforg mvnrepository 将项目发布到 maven 中央仓库踩过的坑 发布Maven构件到中央仓库 9.配置私服 不用去跑审核流程, 私有, 快速, 便捷 nexus 需要运行软件, 一般公司内部局域网使用, 如果自己有服务器也能开放给公众使用 参考博客: maven私服搭建及gradle上传 码云 利用公开仓库来搭建私服 | 参考博客: 使用git仓库搭建maven私服 创建仓库 当然了在各个托管平台都可以的, 只不过码云是国内的, 毕竟要快 github gitlab bitbucket 就…. 创建好一个空的公开仓库 使用统一的groupId, 这样就会放到默认目录 ~/.m2/repository/ 下 只要在groupId对应的目录下 git init 只需在项目中执行install, 然后在此目录进行提交即可 引用仓库中的构件Gradlebuild.gradle 中添加12345repositories &#123; maven&#123; url \"https://gitee.com/你的用户名/创建的仓库/raw/master\" &#125;&#125; Mavenpom.xml中添加1234567&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;mvnrepo&lt;/id&gt; &lt;name&gt;mvn repository&lt;/name&gt; &lt;url&gt;https://gitee.com/用户名/仓库/raw/master&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;","categories":[],"tags":[]},{"title":"SpringSecurity.md","slug":"Memo-Java-Spring-SpringSecurity","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-SpringSecurity/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringSecurity/","excerpt":"","text":"目录 start SpringSecurity 配置 配置静态口令使用 使用该配置即可自定义用户名密码 SpringBoot的集成Demo 创建单用户单角色的安全控制 多用户多角色的实现思路 每个身份都使用一个登录实体类 另一种思路： JWT 跨域问题 Oauth 实现细节 关于注解的几种使用方式 @Secured @RolesAllowed SpringSecurity3.0 开始提供了 SpEL表达式 保护方法应用 社交登录 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs SpringSecurity Spring Security 5.0.6 doc 参考博客: Spring Security 入门系列 配置配置静态口令使用当添加了Security依赖之后, 只会生成一个默认的随机密码, 如下简单配置:123# 使用该配置即可自定义用户名密码spring.security.user.name=adminspring.security.user.password=secret 如果要用 curl 访问则是 curl -i -u admin:secret http://tomcat.kcp/hi 注意 : 前提是要关闭 crsf 校验1234567@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable(); &#125;&#125; SpringBoot的集成Demo创建单用户单角色的安全控制 Gradle : compile(&#39;org.springframework.boot:spring-boot-starter-security&#39;) Security主要配置类 登录实体类 Jpa实现的Dao层 public interface ReaderRepository extends JpaRepository&lt;Reader, String&gt; {} 多用户多角色的实现思路 使用多个实体类（实现了UserDetails接口），一个权限类，再一个多对多连接，就得到了多用户，多权限的控制 在页面上加上角色的判断来控制数据显示，业务操作等功能 根据书上案例代码，可以得出结论，用户表，角色表，用户角色关联表，用户表是可以多张的，角色公用一张即可，然后关联表也对应的多张，就能实现具体的业务需求 例如：一个网上在线阅读书城，作家和读者以及编辑，网站后台管理员等角色的不同权限对应的页面甚至页面上细分的各个模块 Author Admin Reader 三个类 继承了UserDetails接口的实体类的配置 代码片段 每个身份都使用一个登录实体类 然后使用不同的dao层查询，显然的实体类登录查询的效率及其低且不易扩展 设置好spirng.jpa.hibernate.ddl-auto=update 第一次运行还会有没有实体对应的表这样的提示,说明了他正在根据多对多映射创建实体表，也体现了这个多种用户模式下需要实体等量的连接表 所以这个是要查询多张表了 （除非UserDetailService接口的loadUserByUsername能收到表类别的参数） 也可以考虑使用一个字符串，然后用特殊字符把类型放进去，然后正则取出来 登录页面就需要自定义一个函数进行拼接（或者使用校验来拼接？） 另一种思路： 使用一个登录用户表（序列id，用户名，密码，用户编码（对应多张表）） 角色表（序列id，用户编码，角色） 这样的话扩展就只要加表，使用同一个主键生成策略就可以了 思考： 其实这个安全框架使用的是角色控制，而不是权限控制，目前的了解，达不到Oracle那样的权限加角色的精细化控制 JWT JWT相关原理 | Github SpringBoot2使用Security整合Jwt案例项目 个人代码片段 | 集成JWT到Spring Boot项目 | 使用JWT保护你的Spring Boot应用重拾后端之Spring Boot（四）：使用JWT和Spring Security保护REST API开箱即用 - jwt 无状态分布式授权 跨域问题 跨域(CORS) 解决方案中，为什么 Access-Control-Allow-Methods 不起作用？WEB应用前后端分离实践 关键词：rest架构+跨域访问+JWT校验 csrf Oauth oauth 实现细节关于注解的几种使用方式@Secured 这是基于Spring特定的注解@RolesAllowed JSR-250的@RolesAllowed Java标准定义的注解，与上面的注解是差不多的 但是都是有局限性，只能判断请求是否有权限，不能进行更多的自定义判断 SpringSecurity3.0 开始提供了 SpEL表达式需要先配置这个配置类，后面的注解才会生效 123@Configuration@EnableGlobalMethodSecurity(prePostEnabled = true)public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration&#123;&#125; @PreAuthorize 方法调用前，基于表达式的计算结果来限制方法的访问 @PostAuthorize 允许方法调用，如果表达式是false 抛出安全异常 @PostFilter 允许方法调用，按照表达式来过滤方法的结果 @PreFilter 允许方法调用，必须进入方法前过滤输入值 方法调用前验证权限，示例: @PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;) 只允许该权限的用户访问 方法入参user，限定读者用户的text长度小于140，或者是作家用户无限制 @PreAuthorize(&quot;(hasRole(&#39;ROLE_READER&#39;) and #user.text.length()&lt;=140 ) or hasRole(&#39;ROLE_AUTHOR&#39;)&quot;) 方法调用之后验证权限，示例; @PostAuthorize(&quot;returnObject.spitter.username == principal.username&quot;) public Spittle getSpittleById(long id){} 保护方法，只有当返回的对象就是当前登录的用户时，才返回，不然抛出安全异常以上是保护方法的调用，但是有时候保护的是数据的输入输出： 过滤方法的输入输出 事后对方法的返回值进行过滤 @PreAuthorize(&quot;hasAnyRole({&#39;ROLE_ADMIN&#39;,&#39;ROLE_USER&#39;})&quot;) @PostFilter(&quot;hasRole(&#39;ROLE_ADMIN&#39;) || filterObject.user.username == principal.name&quot;) public List&lt;User&gt; getUsers(){} 该示例就是限制了如果是管理员可以获取到所有数据，普通用户只能看到自己 但是这种实现是不好的，只是一个例子，只获取自己，重载方法加个id参数就好了，上面的实现，把数据全拿出来再判断，性能上。。。 事先对方法的参数进行过滤 @PreAuthorize(&quot;hasAnyRole({&#39;ROLE_ADMIN&#39;,&#39;ROLE_USER&#39;})&quot;) @PreFilter(&quot;hasRole(&#39;ROLE_ADMIN&#39;) || targetObject.user.username == principal.name&quot;) public void deleteUsers(){List&lt;User&gt; users} 示例实现了传入一个集合，要删除的用户，但是当前用户只能删除自己，管理员才能删除集合里所有的用户 定义许可计算器 @PreFilter(&quot;hasPermission(targetObject,&#39;delete&#39;)&quot;) 用户是否有权限删除目标对象？ 使用了自定义的计算器类来实现这个判断，表达式简洁，但是自定义类不好写 实现PermissionEvaluator接口，新建hasPermission方法，功能就是判断是否有权限，其实就是对比目标对象是不是当前用户 创建好类后，重载GlobalMethodSecurityConfiguration配置类的createExpressionHalder方法，注册进去 DefaultMethodSecurityExperssionHandler ex = new De...(); ex.setPermissionEvaluator(new 自定义类); return ex; 保护方法应用 @Secured 注解限制方法调用 社交登录 SpringForAll社区:Spring Security源码分析（三）：Spring Social实现QQ社交登录 SpringForAll社区:Spring Security 源码分析（四）：Spring Social实现微信社交登录","categories":[],"tags":[]},{"title":"SpringMVC.md","slug":"Memo-Java-Spring-SpringMVC","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-SpringMVC/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringMVC/","excerpt":"","text":"目录 start SpringMVC MVC思想 原理 API 传统项目配置完整流程 配置依赖 Maven Gradle web.xml ApplicationContext.xml 全局异常处理 自定义错误页面 中文编码问题 创建Controller 使用 自定义拦截器 Q&amp;A 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs SpringMVC Spring MVC 4.2.4.RELEASE 中文文档 MVC思想 参考博客 图 原理 统一使用一个Servlet 进行请求的收发, 通过配置的URL对应的方法, 进行调用, 然后返回视图解析器进行渲染 API 简洁的API设计 传统项目配置完整流程 也就是Maven的Web结构，甚至是Eclipse那样的DynamicWeb项目结构， 参考 博客 配置依赖Maven12345678910111213141516171819202122232425262728293031&lt;properties&gt; &lt;spring.version&gt;4.3.9.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;......&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 如果使用JSP作为视图层,还需 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; Gradle12compile('org.springframework:spring-web:4.3.9.RELEASE')compile('org.springframework:spring-webmvc:4.3.9.RELEASE') web.xml1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;mysql&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;mysql&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ApplicationContext.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.sprinControllergframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;!--启用spring的一些annotation --&gt;&lt;context:annotation-config/&gt;&lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;&lt;context:component-scan base-package=\"com.test.controller\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;&lt;/context:component-scan&gt;&lt;!--HandlerMapping 无需配置，springmvc可以默认启动--&gt;&lt;!--静态资源映射--&gt;&lt;!--本项目把静态资源放在了WEB-INF的statics目录下，资源映射如下--&gt;&lt;!--&lt;mvc:resources mapping=\"/css/**\" location=\"/WEB-INF/statics/css/\"/&gt;--&gt;&lt;!--&lt;mvc:resources mapping=\"/js/**\" location=\"/WEB-INF/statics/js/\"/&gt;--&gt;&lt;!--&lt;mvc:resources mapping=\"/image/**\" location=\"/WEB-INF/statics/image/\"/&gt;--&gt;&lt;!--但是项目部署到linux下发现WEB-INF的静态资源会出现无法解析的情况，但是本地tomcat访问正常，因此建议还是直接把静态资源放在webapp的statics下，映射配置如下--&gt;&lt;!--&lt;mvc:resources mapping=\"/css/**\" location=\"/statics/css/\"/&gt;--&gt;&lt;!--&lt;mvc:resources mapping=\"/js/**\" location=\"/statics/js/\"/&gt;--&gt;&lt;!--&lt;mvc:resources mapping=\"/image/**\" location=\"/statics/images/\"/&gt;--&gt;&lt;!-- 配置注解驱动 可以将request参数与绑定到controller参数上 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀(如果最后一个还是表示文件夹,则最后的斜杠不要漏了) 使用JSP--&gt;&lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt;&lt;!--&lt;bean id=\"defaultViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;--&gt; &lt;!--&lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt;--&gt; &lt;!--&lt;property name=\"prefix\" value=\"/WEB-INF/views/\"/&gt;&amp;lt;!&amp;ndash;设置JSP文件的目录位置&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name=\"suffix\" value=\".jsp\"/&gt;--&gt;&lt;!--&lt;/bean&gt;--&gt;&lt;!-- springmvc文件上传需要配置的节点--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"20971500\"/&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt; &lt;property name=\"resolveLazily\" value=\"true\"/&gt;&lt;/bean&gt;&lt;/beans&gt; 全局异常处理1234567891011121314151617181920public class ExceptionHandler implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; Map&lt;String, Object&gt; model = new HashMap&lt;&gt;(); model.put(\"ex\", ex); ex.printStackTrace();//打印异常信息 // 根据不同错误转向不同页面 if (ex instanceof CSRFException) &#123;//受到csrf攻击 return new ModelAndView(\"/errorPage/error\", model); &#125; if (ex instanceof BusinessException) &#123;//业务逻辑处理出错 return new ModelAndView(\"errorPage/businessError\", model); &#125; else if (ex instanceof ParameterException) &#123;//参数处理出错。 return new ModelAndView(\"errorPage/parameterError\", model); &#125; else &#123; //其他数据类型错误 return new ModelAndView(\"errorPage/error\", model); &#125; return new ModelAndView(\"error\", model); &#125;&#125; 但如果是前后端分离的话， 就只能统一处理异常然后然后对应的错误码和提示信息了参考博客ResponseBody方案 自定义错误页面12345678910// 自定义错误页面 需要放在静态资源下面@Beanpublic EmbeddedServletContainerCustomizer containerCustomizer() &#123; return (container -&gt; &#123; ErrorPage error401Page = new ErrorPage(HttpStatus.FORBIDDEN, \"/500.html\"); ErrorPage error404Page = new ErrorPage(HttpStatus.NOT_FOUND, \"/404.html\"); ErrorPage error500Page = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, \"/500.html\"); container.addErrorPages(error401Page, error404Page, error500Page); &#125;);&#125; 中文编码问题 参考博客 但是奇怪的是某些方法用第二种正常，有些还是要用第一种 单个方法：@GetMapping(value = &quot;/target/all&quot;, produces = &quot;application/json; charset=utf-8&quot;) 或者整个应用 注意：&lt;/mvc:annotation-driven&gt; 只能有一个，要将上面的覆盖掉1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;!-- 如果是前后端使用JSON作为主要数据交换格式就把JSON列为第一个， 否则就会被认为是Text --&gt; &lt;value&gt;application/json; charset=UTF-8&lt;/value&gt; &lt;value&gt;text/plain; charset=UTF-8&lt;/value&gt; &lt;value&gt;text/html; charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 创建Controller包 com.test.controller 下创建一个类12345678@RestController@RequestMapping(\"/hi\")public class Hi &#123; @RequestMapping(\"/hi\") public String hi()&#123; return \"Hi\"; &#125;&#125; 使用上 ResponseEntity 让响应结果规范12345678@RequestMapping(\"/handle\")public ResponseEntity&lt;String&gt; handle() &#123; URI location = ...; HttpHeaders responseHeaders = new HttpHeaders(); responseHeaders.setLocation(location); responseHeaders.set(\"MyResponseHeader\", \"MyValue\"); return new ResponseEntity&lt;String&gt;(\"Hello World\", responseHeaders, HttpStatus.CREATED);&#125; 使用 在Springboot框架中，static templates 文件夹下分别代表了tomcat管理的静态文件和MVC负责跳转的HTML文件或JSP文件在static中对于路径的使用一定要带上应用路径，而在templates中就只要写相对路径即可 自定义拦截器 相关博客|相关博客 定义拦截器类123456789101112131415public class MythInterceptor extends HandlerInterceptorAdapter&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Long startTime = System.currentTimeMillis(); request.setAttribute(\"startTime\",startTime); return true;// true就继续跳转，false就停止 &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; long startTime = (Long)request.getAttribute(\"startTime\"); request.removeAttribute(\"startTime\"); Long endTime = System.currentTimeMillis(); log.info(request.getRequestURL()+\"发起请求耗时:[ \"+ (endTime - startTime) +\" ms]\"); &#125;&#125; 配置MVC的配置类123456789101112131415@Configurationpublic class WebMvcConfig extends WebMvcConfigurerAdapter&#123; //自定义拦截器bean @Bean public MythInterceptor mythInterceptor()&#123; return new MythInterceptor(); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //拦截器的URL正则 registry.addInterceptor(mythInterceptor()).addPathPatterns(\"/**\"); super.addInterceptors(registry); &#125;&#125; Q&amp;A URL 中带了 jsessionid 参数，导致页面各种问题 一种原因：禁用cookie导致的 最终解决： chrome中在设置里清除localhost的所有cookie和缓存 解决问题参考博客 jsessionid的作用 [ ] ModelAndView中的addObject 的值能用js获取到么","categories":[],"tags":[]},{"title":"SpringBoot.md","slug":"Memo-Java-Spring-SpringBoot","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-SpringBoot/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringBoot/","excerpt":"","text":"目录 start SpringBoot 思考 参考教程 系列 开始使用 安装SpringBootCLI 测试模块 配置文件 多种配置文件并切换 yml方式 yml和Properties结合 应用配置文件 日志模块 Web模块 Lisener ServletContextListener 上传下载文件 错误页面跳转配置 跨域 全局异常处理 HTTPS的配置 线程池 项目部署 生成指定文件 war jar 构建docker镜像 手动方式 gradle结合docker 热部署 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs SpringBoot 首页 一个简化Spring开发的框架,微服务SpringCloud的基础1.5.14 官方文档 Github:Springboot 思考 SpringBoot优缺点 大大降低编程门槛, 但是, 将大量细节隐藏在默认配置中, 需要详细阅读文档和源码才能更好的玩转SpringBoot, 不然到处是坑 SpringBoot启动流程解析原理才是王道 spring boot应用启动原理分析 Spring 是单例模式, 全部使用IOC容器进行管理, 那么怎么处理并发呢, 答案是 ? 多线程 然后 ThreadLocal 分别存储了各自的数据, 所以才说, 不能在Controller层 放置属性, 使其具有状态, 从而导致并发问题 那么WebSocket服务器, 处理并发会不会有并发问题? 为什么说 Java 程序员到了必须掌握 Spring Boot 的时候？ Guide 参考教程 SpringBoot中文索引 参考博客: Spring Boot 入门系列 Springboot探索 SpringBoot入门 系列 一系列专栏 个人博客专栏: SpringBoot干货系列 SpringBoot系列文章 恒宇少年大量Boot博客 开始使用 使用Idea的话就可以直接创建项目 使用别的可以下载zip进行导入 | 官方初始项目构建 下载地址 目录结构最好如下 *Application类要处于所有用了Springboot注解的类的顶级目录, 这样默认才能扫描到12345678├── config/├── controller/├── dao/├── domain/├── GraduateApplication.java├── service/├── ServletInitializer.java└── util/ 安装SpringBootCLI 使用 SDKMAN 进行安装 使用git bash运行 curl -s get.sdkman.io | bash source &quot;/Users/{yourname}/.sdkman/bin/sdkman-init.sh&quot;根据实际目录去运行 spring –version 官方下载地址 所有版本 测试模块 了解这些测试注解 的作用和使用场景 12345678// 依赖于Springboot环境的测试类的必备注解@RunWith(SpringRunner.class)@SpringBootTest// 使用内存数据库测试@ComponentScan(\"com.github.kuagncp\") // 如果有类没注入需要手动设置扫面@RunWith(SpringJUnit4ClassRunner.class)@DataJpaTest 可以使用MockMvc来测试Controller层的代码 可以使用MockMvc的SpringSecurity支持来测试安全模块 使用 WebIntegraionTest 测试运行中的Web容器 启动嵌入式的Servlet容器来进行测试，下断言 使用随机端口启动服务器 配置local.server.port=0 使用Selenium来测试HTML页面，模拟浏览器的动作，查看系统运行状态 配置文件 配置文件(application.properties或者yml)加载顺序 官方文档说明 1.当前Jar/War目录下的/config目录 file:./config/2.当前目录 file:./3.classpath 里的/config目录 classpath:/config/4.classpath 根目录 classpath:/ 自定义配置文件名就要运行时加参数 java -jar myproject.jar --spring.config.name=myprojectjava -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties 配置文件的使用 Spring boot配置文件 application.properties SpringBoot常用配置 使用Gradle整合SpringBoot+Vue.js-开发调试与打包 配置文件加密 自定义配置文件将应用配置外置并注入成bean 配置文件外置 多种配置文件并切换yml方式 单文件配置文件 application.yml 1234567891011spring: profiles: active: development # 选用开发模式 --- spring: profiles: development //一系列配置 --- spring: profiles: production //一系列配置 或者 多文件放 application-{profile}.yml yml和Properties结合 格式：application-{profile}.properties 将上面的开发部分，发行部分的配置创建两个配置文件 application-dev.properties 和 application-prod.properties 在主配置文件application.yml中指明123spring: profiles: active: dev或者是prod 应用配置文件 依赖于 org.springframework.boot:spring-boot-configuration-processor配置对应的实体类123456@Data@Component@ConfigurationProperties(prefix = \"graduate.main\")public class MainConfig &#123; private String delimiter;&#125; 应用配置类1234@Configuration@EnableConfigurationProperties(MainConfig.class)public class AutoCustomConfig &#123;&#125; application.yml123graduate: main: delimiter: , 日志模块默认可以通过 application.properties 配置框架的日志,以及应用具体到包和类的日志等级,日志文件等等 参考博客: Spring boot——logback 基础使用篇（一） 参考博客: springboot use logback能根据Profile配置,还能写if 使用 logback 则需要配置 logback.xml 或者 logback-spring.xml 建议使用后者 Web模块LisenerServletContextListener123456789101112@WebListenerpublic class ApplicationContext implements ServletContextListener &#123;@Overridepublic void contextInitialized(ServletContextEvent event) &#123; System.out.println(\"Servlet容器初始化\");&#125;@Overridepublic void contextDestroyed(ServletContextEvent event) &#123; System.out.println(\"Servlet容器销毁\");&#125;&#125; 上传下载文件 第一种直接上传到应用的webroot或者resources目录下，第二种上传到数据库中，第三种使用ftp。 Springboot上传文件 上传文件有大小限制，使用如下方法进行配置 参考博客123456789@Beanpublic MultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); //单个文件最大 factory.setMaxFileSize(\"80MB\"); //KB,MB // 设置总上传数据总大小 factory.setMaxRequestSize(\"102400KB\"); return factory.createMultipartConfig();&#125; 错误页面跳转配置123456789101112@Configurationpublic class MvcConfig extends WebMvcConfigurerAdapter &#123; @Bean public EmbeddedServletContainerCustomizer containerCustomizer() &#123; return (container -&gt; &#123; ErrorPage error401Page = new ErrorPage(HttpStatus.FORBIDDEN, \"/403.html\"); ErrorPage error404Page = new ErrorPage(HttpStatus.NOT_FOUND, \"/404.html\"); ErrorPage error500Page = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, \"/500.html\"); container.addErrorPages(error401Page, error404Page, error500Page); &#125;); &#125;&#125; 跨域 不同的域名（主机）端口都会导致跨域问题 12345678910111213141516@Configurationpublic class CorsConfig &#123; private CorsConfiguration buildConfig() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(\"*\"); // 允许任何域名使用 corsConfiguration.addAllowedHeader(\"*\"); // 允许任何头 corsConfiguration.addAllowedMethod(\"*\"); // 允许任何方法（post、get等） return corsConfiguration; &#125; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\"/**\", buildConfig()); // 4 return new CorsFilter(source); &#125;&#125; 全局异常处理 新建类, 加上注解 ControllerAdvice 方法上使用注解 ExceptionHandler(Exception.class) 处理所有异常 然后返回值的写法和普通Controller一样, 返回JSON就ResponseBody HTTPS的配置 参考博客 签发证书：1keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650 12345678910server: context-path: /myth ssl: key-store: classpath:keystore.p12 key-store-password: demo1429336 key-store-type: PKCS12 key-alias: tomcat port: 8888 session: timeout: 3000 任意的一个@Configuration注解类里添加123456789101112131415161718192021222324252627@Beanpublic TomcatEmbeddedServletContainerFactory servletContainerFactory() &#123; TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedServletContainerFactory() &#123; @Override protected void postProcessContext(Context context) &#123; //SecurityConstraint必须存在，可以通过其为不同的URL设置不同的重定向策略。 SecurityConstraint securityConstraint = new SecurityConstraint(); securityConstraint.setUserConstraint(\"CONFIDENTIAL\"); SecurityCollection collection = new SecurityCollection(); collection.addPattern(\"/*\"); securityConstraint.addCollection(collection); context.addConstraint(securityConstraint); &#125; &#125;; factory.addAdditionalTomcatConnectors(createHttpConnector()); return factory;&#125;private Connector createHttpConnector() &#123; Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\"); connector.setScheme(\"http\"); connector.setSecure(false); connector.setPort(8887);//http端口（这是要新增加的一个端口） connector.setRedirectPort(8888);// https 端口配置文件中tomcat启动的默认端口 return connector;&#125; 另一种方式 参考博客方式不一样，没有成功123456789101112131415161718############ 证书颁发机构# CA机构私钥openssl genrsa -out ca.key 2048# CA证书openssl req -x509 -new -key ca.key -out ca.crt############ 服务端# 生成服务端私钥openssl genrsa -out server.key 2048# 生成服务端证书请求文件openssl req -new -key server.key -out server.csr# 使用CA证书生成服务端证书 关于sha256，默认使用的是sha1，在新版本的chrome中会被认为是不安全的，因为使用了过时的加密算法。openssl x509 -req -sha256 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650 -out server.crt # 打包服务端的资料为pkcs12格式(非必要，只是换一种格式存储上一步生成的证书) 生成过程中，需要创建访问密码，请记录下来。openssl pkcs12 -export -in server.crt -inkey server.key -out server.pkcs12# 生成服务端的keystore（.jks文件, 非必要，Java程序通常使用该格式的证书） 生成过程中，需要创建访问密码，请记录下来。keytool -importkeystore -srckeystore server.pkcs12 -destkeystore server.jks -srcstoretype pkcs12# 把ca证书放到keystore中（非必要）keytool -importcert -keystore server.jks -file ca.crt 线程池 参考博客 多线程以及异常处理 参考博客 因为多线程的特性，所以异常只能在子线程中处理不能抛出到主线程里，但是 Spring实现的线程池可以返回一个异常信息对象 项目部署生成指定文件war 部署为war必须的类，一般在创建项目时选war就会自动生成，选jar就要手动添加 123456public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(DemoApplication.class); &#125;&#125; maven： mvn war 即可 mvn package -DskipTests gradle: gradle war 然后 gradle bootRepackage 即可 jar 没有特殊的配置，打包即用 maven: mvn package 即可生成可执行的jar gradle:gradle jar 然后 gradle bootRepackage 也生成可执行jar 构建docker镜像 方便监控应用状态，cpu 内存 流量, 官方文档 手动方式 先构建得到war或jar，然后根据dockerfile构建一个镜像123FROM frolvlad/alpine-oraclejdk8:slimADD weixin-1.0.0.war app.warENTRYPOINT [\"java\",\"-jar\",\"/app.war\"] gradle结合docker热部署 参考博客: SpringBoot热部署","categories":[],"tags":[]},{"title":"SpringAOP.md","slug":"Memo-Java-Spring-SpringAOP","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-SpringAOP/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringAOP/","excerpt":"","text":"目录 start AOP 动态代理 asm cglib 基本概念 基本配置 注意 1 Spring AOP还是完全用AspectJ？ 2 Spring AOP中使用@AspectJ还是XML？ 3 混合切面类型 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs AOP Aspect Oriented Programming 面向切面编程 动态代理 这是AOP的起源, 最初是JDK的动态Proxy -&gt; cglib/asm 参考博客: Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM） asmcglib 基于asm 基本概念 英文 解释 JoinPoint 切入面、连接点、切入点（所有方法） PointCut 切点（特殊的连接点，需要增强的连接点） Advice 增强（切入点的逻辑，待添加的功能） Aspect 切面（切点和增强的合集） Target 目标对象（被增强的实例） Weave 织入（增强切点的过程） Proxy 代理（增强后的类，一般是使用了代理类） 装饰器模式 Introduction 引介（为类添加属性和方法） 用的较少因为破坏了OOP思想 基本配置XML文件头1234567891011&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\"&gt; &lt;/beans&gt; 方法级别的添加代理，Servlet中的过滤器也类似（但是那个是类级别的） 12345678910111213141516&lt;!-- 基本类 提供切点 --&gt;&lt;bean id=\"student\" class=\"cn.spring.aop.Student\"&gt;&lt;/bean&gt;&lt;!-- 增强部分 --&gt;&lt;bean id=\"adder\" class=\"cn.spring.aop.NewDeal\"&gt;&lt;/bean&gt;&lt;!-- 使用aop的自动提示也要配置上面的头文件声明 --&gt;&lt;aop:config&gt; &lt;!--aspect表示切面 ref 标明增强方法的类来源 --&gt; &lt;aop:aspect id=\"myAop\" ref=\"adder\"&gt; &lt;!-- execution 是表达式（正则一样的功能）匹配的是具体的切点 --&gt; &lt;aop:pointcut expression=\"execution(* cn.spring.aop.Student.run(..))\" id=\"needAdd\"/&gt; &lt;!-- 织入 的过程 将增强和切入点结合 --&gt; &lt;aop:before method=\"add\" pointcut-ref=\"needAdd\"/&gt; &lt;aop:after method=\"af\" pointcut-ref=\"needAdd\"/&gt; &lt;aop:around method=\"around\" pointcut-ref=\"needAdd\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 注意 要注意环绕的写法 public void around(ProceedingJoinPoint m)throws Throwable{ Spring AOP中的around 然后在test类中直接getBean（基类）但是实际上是获取到的是装饰好的代理对象 Spring AOP配置(转) aop:config详解 善用debug 调试看是否获取到的是代理对象 $proxy 在Spring的配置文件中，所有的切面和通知器都必须定义在&lt;aop:config&gt; 元素内部。 一个application context可以包含多个 &lt;aop:config&gt;。 一个&lt;aop:config&gt; 可以包含 pointcut， advisor 和 aspect 元素（注意它们必须按照这样的顺序进行声明）。 1 Spring AOP还是完全用AspectJ？做能起作用的最简单的事。Spring AOP比完全使用AspectJ更加简单，因为它不需要引入AspectJ的编译器／织入器到你开发和构建过程中。如果你仅仅需要在Spring bean上通知执行操作，那么Spring AOP是合适的选择。如果你需要通知domain对象或其它没有在Spring容器中管理的任意对象，那么你需要使用AspectJ。如果你想通知除了简单的方法执行之外的连接点（如：调用连接点、字段get或set的连接点等等），也需要使用AspectJ。当使用AspectJ时，你可以选择使用AspectJ语言（也称为“代码风格”）或@AspectJ注解风格。如果切面在你的设计中扮演一个很大的角色，并且你能在Eclipse中使用AspectJ Development Tools (AJDT)， 那么首选AspectJ语言 :-因为该语言专门被设计用来编写切面，所以会更清晰、更简单。如果你没有使用Eclipse，或者在你的应用中只有很少的切面并没有作为一个主要的角色，你或许应该考虑使用@AspectJ风格并在你的IDE中附加一个普通的Java编辑器，并且在你的构建脚本中增加切面织入（链接）的段落。 2 Spring AOP中使用@AspectJ还是XML？如果你选择使用Spring AOP，那么你可以选择@AspectJ或者XML风格。总的来说，如果你使用Java 5， 我们建议使用@AspectJ风格。显然如果你不是运行在Java 5上，XML风格是最佳选择。XML和@AspectJ 之间权衡的细节将在下面进行讨论。XML风格对现有的Spring用户来说更加习惯。它可以使用在任何Java级别中（参考连接点表达式内部的命名连接点，虽然它也需要Java 5）并且通过纯粹的POJO来支持。当使用AOP作为工具来配置企业服务时（一个好的例子是当你认为连接点表达式是你的配置中的一部分时，你可能想单独更改它）XML会是一个很好的选择。对于XML风格，从你的配置中可以清晰的表明在系统中存在那些切面。XML风格有两个缺点。第一是它不能完全将需求实现的地方封装到一个位置。DRY原则中说系统中的每一项知识都必须具有单一、无歧义、权威的表示。当使用XML风格时，如何实现一个需求的知识被分割到支撑类的声明中以及XML配置文件中。当使用@AspectJ风格时就只有一个单独的模块 -切面-信息被封装了起来。 第二是XML风格同@AspectJ风格所能表达的内容相比有更多的限制：仅仅支持”singleton”切面实例模型，并且不能在XML中组合命名连接点的声明。 例如，在@AspectJ风格中我们可以编写如下的内容： 123456@Pointcut(execution(* get*())) public void propertyAccess() &#123;&#125; @Pointcut(execution(org.xyz.Account+ *(..)) public void operationReturningAnAccount() &#123;&#125; @Pointcut(propertyAccess() &amp;&amp; operationReturningAnAccount()) public void accountPropertyAccess() &#123;&#125; 在XML风格中能声明开头的两个连接点： 12&lt;aop:pointcut id=\"propertyAccess\" expression=\"execution(* get*())\"/&gt; &lt;aop:pointcut id=\"operationReturningAnAccount\" expression=\"execution(org.xyz.Account+ *(..))\"/&gt; 但是不能通过组合这些来定义accountPropertyAccess连接点 @AspectJ风格支持其它的实例模型以及更丰富的连接点组合。它具有将将切面保持为一个模块单元的优点。 还有一个优点就是@AspectJ切面能被Spring AOP和AspectJ两者都理解 所以如果稍后你认为你需要AspectJ 的能力去实现附加的需求，那么你非常容易转移到基于AspectJ的途径。总而言之，我们更喜欢@AspectJ风格只要你有切面 去做超出简单的“配置”企业服务之外的事情。 3 混合切面类型我们完全可以混合使用以下几种风格的切面定义：使用自动代理的@AspectJ 风格的切面，schema-defined &lt;aop:aspect&gt; 的切面，和用 &lt;aop:advisor&gt; 声明的advisor，甚至是使用Spring 1.2风格的代理和拦截器。由于以上几种风格的切面定义的都使用了相同的底层机制，因此可以很好的共存。","categories":[],"tags":[]},{"title":"Spring.md","slug":"Memo-Java-Spring-Spring","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-Spring/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-Spring/","excerpt":"","text":"目录 start Spring 配置使用 通过构建工具 注解方式 xml文件配置 常用的注解 xml方式 xml方式和注解方式的比较 Spring技巧 获取Context上下文环境 在JSP或Servlet中获取 Spring 和 ServletContextList 基础 生命周期 IOC/DI 控制反转 Scheduling Websocket maven配置 Web开发上的一些优秀的习惯 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Spring Spring官网 | spring4all社区 Spring For All 社区 -&gt; Spring 官方教程翻译 Spring Tutorial 配置使用 通过原始的复制jar方式 : 官网下载对应的jar, 添加到ide中 通过构建工具Maven 中 pom.xml 中, Gradle是 build.gradle 添加以下等依赖: 核心依赖 spring-core spring-beans spring-context 其他,可选 spring-aop spring-websocket spring-jdbc spring-tx spring-web spring-webmvc spring-test 注解方式 需要在配置文件 xml配置文件 中配置包扫描 才能生效 xml文件配置123456789101112&lt;!-- 头部分要添加Context --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;!-- 对使用了注解的包进行扫描 --&gt; &lt;context:component-scan base-package=\"com.github.kuangcp\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 注意 只需要这个配置文件就可以使用注解来使用Spring框架 常用的注解 标注为bean @Component([value=]&quot;id&quot;)不写则默认是当前类名 @Entity @Service @Repository @Controller 和 @RestController 自动注入 @Resource([value=]&quot;id&quot;) 按名字注入 @Autowried 根据类型自动注入（只对单例起作用）和 Resource(类名首字母小写) 等价 @Qualifier(&quot;id&quot;)自动注入后的进一步精确（多个的情况：） 注意 : 关于自动注入, 在属性上打 @Autowried 注解是不建议的, 作者建议采用构造器方式: Why field injection is evil AOP @Aspect 注明是切面类 @Before(“execution(public void com.wjt276.dao.impl.UserDaoImpl.save(com.wjt276.model.User))”) 和xml方式的before对应 bean扫描 ComponentScan 扫描指定包下Spring注解的类 参考博客: Why field injection is evil xml方式 只用到bean的头，主要配置内容：&lt;bean&gt;&lt;property&gt;&lt;/property&gt;&lt;/bean&gt; 123456789101112131415161718192021222324252627282930313233 &lt;!-- 对使用了注解的包进行扫描 --&gt;&lt;context:component-scan base-package=\"cn.spring.aop\"&gt;&lt;/context:component-scan&gt; &lt;!-- 一般而言，bean都是单实例的 --&gt; &lt;bean id=\"person\" class=\"cn.spring.entity.Person\"&gt; &lt;property name=\"name\" value=\"myth\"/&gt; &lt;property name=\"addr\" value=\"vol\"/&gt; &lt;/bean&gt; &lt;bean id=\"construct\" class=\"cn.spring.entity.ConstructorEntity\"&gt; &lt;!-- 如果是不同的类型的参数 顺序可以随意，但是数据类型一样的话就要严格按顺序了--&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"String_1\"&gt;&lt;/constructor-arg&gt; &lt;!-- 注意引用类型是要写全路径，基本数据类型是可以直接写小写 --&gt; &lt;constructor-arg type=\"int\" value=\"2\"&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg type=\"java.lang.String\" value=\"String_2\"&gt;&lt;/constructor-arg&gt; --&gt; &lt;/bean&gt; &lt;bean id=\"TestConstruct\" class=\"cn.spring.entity.TestConstruct\"&gt; &lt;property name=\"entity\" ref=\"construct\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 加载属性文件 --&gt; &lt;bean id=\"property_config\" class=\"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;cn/spring/entity/db.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 测试获取属性文件 --&gt; &lt;bean id=\"show_db\" class=\"cn.spring.entity.TestProperties\"&gt; &lt;!-- 特别注意大小写问题 --&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;/bean&gt; xml方式和注解方式的比较 当你确定切面是实现一个给定需求的最佳方法时，你如何选择是使用Spring AOP还是AspectJ，以及选择 Aspect语言（代码）风格、@AspectJ声明风格或XML风格？ 这个决定会受到多个因素的影响，包括应用的需求、 开发工具和小组对AOP的精通程度。 个人理解：使用bean的时候使用注解，AOP使用xml方式，更直观 Spring技巧获取Context上下文环境在JSP或Servlet中获取1ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(config.getServletContext()); Spring 和 ServletContextList 想要启动Tomcat之后，初始化运行一些方法，把数据从数据库拿出放入redis中，然后使用了ServletContextListener 然后还是按照往常一样的使用Spring自动注入的便利，来使用service层获取数据，但是忽略了启动顺序 context-param -&gt; listener -&gt; filter -&gt; servlet 所以在启动这个初始化方法的时候，其实Spring的环境是还没有加载的，所以没有扫描，也就没有了自动注入，也就有了空指针异常 所以要使用如下方法得到Spring的Context（上下文），获取bean，再操作 1234567891011121314151617181920212223242526272829303132 public void contextInitialized(ServletContextEvent event) &#123; ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(event.getServletContext()); //.... &#125;``` # 基础## 生命周期@PreDestroy@PostConstruct- [ ] 完善## IOC/DI 控制反转- DI 译为依赖注入 所有的bean都在IOC容器中（单例的）多例的不在该容器中进行管理- 通过注入 可以注入基本属性 对象属性，集合属性，构造器，properties等- 不采用Spring的IOC容器使用Java基础来实现： - **静态代理** - 针对每个具体类分别编写代理类 - 针对一个接口编写一个代理类 - **动态代理** - 针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类 属性上 @Autowired 即可, 但是现在不建议直接在属性上使用注解, 而是建议在构造器上, 为了避免 手动使用new 实例化Bean, 然后里面本该注入的属性全部为null可以用lombok来协助```java@Component@RequiredArgsConstructor(onConstructor = @__(@Autowired))public class A&#123; @NonNull private B b; &#125; look up 方法注入 Scheduling Official Doc 参考博客: The @Scheduled Annotation in Spring参考博客: Spring Scheduler的使用与坑参考博客: [Spring]支持注解的Spring调度器参考博客: spring scheduled的动态线程池调度和任务进度的监控 其主体是 TaskExecutor 和 TaskScheduler 组成的, 也就是调度和执行 cron maker Websocketmaven配置12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; Spring方式, 现在用boot用多了, 都忘了怎么配置Spring了 Web开发上的一些优秀的习惯 使用AOP来简化开发MVC的代码 繁杂的代码如何简化","categories":[],"tags":[]},{"title":"RPC","slug":"Memo-Distributed-RPC","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Distributed-RPC/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Distributed-RPC/","excerpt":"","text":"目录 start RPC 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs RPC Remote Process Calls 参考博客: 良好的RPC接口设计，需要注意这些方面","categories":[{"name":"分布式","slug":"分布式","permalink":"http://blog.kuangcp.top/categories/分布式/"}],"tags":[{"name":"RPC","slug":"RPC","permalink":"http://blog.kuangcp.top/tags/RPC/"}]},{"title":"Mybatis.md","slug":"Memo-Java-Ecosystem-Mybatis","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-Mybatis/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-Mybatis/","excerpt":"","text":"目录 start Mybatis Mybatis xml文件配置： 主配置文件： 操作配置文件： 导入JAR包： 创建SqlSessionFactory类 内容： maven Spring-mybaits 配置 SessionFactory类，使用Spring注入一个工厂类，然后使用本地线程组，节省Session开销 流程控制 foreach 循环语句 collection 有 arry list map 几种 还有item是必写，其他的是可选的 if 判断语句: set 方便书写update语句 choose 相当于switch语句 $和的区别： 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Mybatis 一个灵活的数据库中间件框架 Mybatisxml文件配置： 创建mybatis-config.xml文件 该文件是主配置文件，配置了sessionFactory 创建generatorConfig.xml文件 是各种操作的配置，一个操作对应一个SQL的配置 主配置文件：12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;!-- 配置别名 为了方便配置操作文件--&gt; &lt;typeAliases&gt; &lt;typeAlias type=\"cn.mybatis.test.Human\" alias=\"Human\" /&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境变量 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;&lt;!-- 配置mappers --&gt; &lt;mappers&gt; &lt;mapper resource=\"cn/mybatis/test/HumanDao.xml\" /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 操作配置文件：1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"cn.mybatis.test\"&gt; &lt;!-- 按id查询 --&gt; &lt;select id=\"queryUsersById\" parameterType=\"Human\" resultType=\"Human\"&gt; &lt;!-- useCache=\"false\" --&gt; &lt;![CDATA[ select * from inserts t where t.id=#&#123;id&#125; ]]&gt; &lt;/select&gt; &lt;!-- 查询全部 --&gt; &lt;select id=\"queryUsers\" resultType=\"Human\"&gt; select * from inserts &lt;/select&gt; &lt;!-- 插入记录 --&gt; &lt;insert id=\"insertUser\" parameterType=\"Human\" &gt; &lt;!-- 该字段是必须要在数据库中自增长的 可能会有并发问题 useGeneratedKeys=\"true\" keyProperty=\"id\" 所以用查询方式好点， 写语句就不要考虑主键了 --&gt; &lt;selectKey resultType=\"int\" keyProperty=\"id\"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into inserts (name) values(#&#123;name&#125;) &lt;/insert&gt; &lt;!-- 删除记录 --&gt; &lt;delete id=\"deleteUser\" parameterType=\"String\"&gt; delete from inserts where id=#&#123;id&#125; &lt;/delete&gt; &lt;!-- 更新记录 --&gt; &lt;update id=\"updateUserById\" parameterType=\"Human\"&gt; update inserts set name=#&#123;name&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 导入JAR包： 核心包 mybatis-3.4.1.jar 主包 dom4j-1.6.1.jar 日志记录 log4j-1.2.15.jar slf4j-api-1.5.8.jar slf4j-log4j12.jar 创建SqlSessionFactory类 内容：123456789101112131415161718private static SqlSessionFactory sessionFactory;static&#123; try&#123; String resource = \"cn/mybatis/test/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125;catch (Exception e) &#123; System.out.println(\"获取Session失败\"); &#125;&#125;/** * 获取Session */public static SqlSession getSession()&#123; SqlSession session = null; session = sessionFactory.openSession(); return session;&#125; maven Spring-mybaits 配置 使用Spring自动注入对象,方便别名和SessionFactory的管理 pom引入必须的JAR包就可以了 123456789101112131415161718192021222324&lt;!--基本属性--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;property name=\"initialPoolSize\" value=\"$&#123;initialSize&#125;\"/&gt; &lt;property name=\"maxPoolSize\" value=\"$&#123;maxSize&#125;\"/&gt; &lt;/bean&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--操作配置文件的路径--&gt; &lt;property name=\"mapperLocations\" value=\"classpath:bean/*.xml\"/&gt; &lt;!--bean的路径，进行别名的自动扫描--&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.book.bean\"/&gt; &lt;/bean&gt; &lt;bean id=\"mybatisSessionFactory\" class=\"com.book.dao.MybatisSessionFactory\"&gt; &lt;property name=\"sessionFactory\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;!--定义数据源--&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; SessionFactory类，使用Spring注入一个工厂类，然后使用本地线程组，节省Session开销123456789101112131415161718192021222324252627282930313233343536373839@Componentpublic class MybatisSessionFactory &#123; @Autowired private SqlSessionFactory sessionFactory; // 日志 private static org.slf4j.Logger Log = LoggerFactory.getLogger(MybatisSessionFactory.class); //使用本地线程组能避免不必要的Session开支，加强性能 private static final ThreadLocal&lt;SqlSession&gt; THREAD_LOCAL = new ThreadLocal&lt;SqlSession&gt;(); /** * 获取Session * @return */ public SqlSession getSession()&#123; SqlSession session = (SqlSession)THREAD_LOCAL.get(); if(session==null )&#123; session = this.sessionFactory.openSession(); THREAD_LOCAL.set(session); &#125; Log.info(\"__获取了一个Session__\"+session); return session; &#125; /* 关闭连接 */ public void closeSession()&#123; SqlSession session = (SqlSession)THREAD_LOCAL.get(); THREAD_LOCAL.set(null); if(session!=null)&#123; session.close(); &#125; &#125; public SqlSessionFactory getSessionFactory() &#123; return sessionFactory; &#125; public void setSessionFactory(SqlSessionFactory sessionFactory) &#123; this.sessionFactory = sessionFactory; &#125;&#125; 流程控制foreach 循环语句123&lt;foreach collection=\"param_list 自定义的话就是Map中的key，或者使用 @Param(\"\")来指定 \" item=\"params\" index=\"currentIndex 当前索引\" separator=\"循环分隔符\" open=\"在循环前加上字符\" close=\"循环结束后加上字符\"&gt; $&#123;params&#125;&lt;/foreach&gt; collection 有 arry list map 几种 还有item是必写，其他的是可选的if 判断语句: &lt;if test=&quot;&quot;&gt;&lt;/if&gt; set 方便书写update语句 &lt;set&gt;&lt;if test=&quot;col!=null&quot;&gt;col=#{col},&lt;/if&gt;&lt;/set&gt; mybatis会自动去除多余的逗号，但是每一行书写要写逗号 choose 相当于switch语句 &lt;choose&gt;&lt;when test=&quot;&quot;&gt;&lt;/when&gt;&lt;/choose&gt; $和#的区别： \\$ 会有SQL注入的漏洞，#则没有 使用$ 是SQL进行String的拼接，使用#是preparstatement的预处理然后注入 使用#的时候出现这个问题2017-01-22 11:16:11.046 [main] DEBUG myth.book.getAll_Param_BookType - ==&gt; Preparing: select * from book_type where ? and ? and 1=1;2017-01-22 11:16:11.136 [main] DEBUG myth.book.getAll_Param_BookType - ==&gt; Parameters: book_type&lt;10 (String), ‘father_type=’2 (String) 条件不能使用数值， 条件是单独使用时也是String但是是有效的","categories":[],"tags":[]},{"title":"Hibernate.md","slug":"Memo-Java-Ecosystem-Hibernate","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-Hibernate/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-Hibernate/","excerpt":"","text":"目录 start Hibernate Hibernate基础配置 JDBC和Hibernate比较 配置流程 Hibernate必需JAR 编写数据库表对应框架持久层的对象 hibernate.cfg.xml文件 日志文件的配置 SessionFactory和Session比较 OID的作用： id生成策略 非普通类型 Hibernate实体关联配置 一对多的配置 注意 ： 多对多的配置 学生方配置 课程方配置 一对一的配置 使用多对一的技巧 添加记录 删除记录 继承关系的配置 Hibernate异常 could not find a getter for 个人总结 Hibernate对象的状态 Session的方法 特别注意 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs HibernateHibernate基础配置JDBC和Hibernate比较 JDBC 使用其简洁精悍，最快，但是使用时接收数据以及多方面的比较麻烦 Hibernate 单表操作是很便捷的，但是涉及到多表复杂操作时比较麻烦 配置流程 如果后续需要添加表的话，就这个顺序 1 : 先有数据库和表，建立cfg.xml文件配置好数据库的基本参数 2 : 使用工具建立POJO持久类 3 : 导入Hibernate所必需JAR包，最好使用Myeclipse的配置，自己导包总有一堆错误 4 : 使用MyEclipse自动创建hbm.xml文件，还有各种文件。配置好hbm文件里关于表间关系的映射，或者在Myeclipse配置时手动选择 5 : 配置好DAO类中事务开启和关闭，以及各种所必需的配置，若表没有设立主键，那么POJO类需要继承自动生成的抽象类（含有主键） 6 : 调用DAO或者自己的Utils类，通过Hibernate来操作数据库 Hibernate必需JAR Hibernate 3.6 required目录下所有JAR都要导入 jpa的JAR包（做注解用） 日志包： slf4j-api-* .jar 该包是一个日志接口，需要一个JAR包的实现： slf4j-log4j12.jar 该包是转换的JAR包 log4j-1.2.11.jar 实现的JAR包 数据库驱动包 mysql-connector-java-5.1.7-bin.jar 在src同级目录下新建一个lib目录，把JAR包复制进去，然后右击将jar文件 Add to build path 加入到类搜索路径里 编写数据库表对应框架持久层的对象 使用自己的工具类创建到对应的包下，或者用相关工具生成，类型要自己多加注意 hibernate.cfg.xml文件 作为默认的主配置文件 数据库连接属性 驱动，url，用户名，密码 数据库方言 辅助配置 POJO类配置文件的映射 etc/hibernate.properties里可以看到更多配置，数据库连接池，SQL优化等 在：project/core/src/main/resources/org/hibernate/下有各种dtd文件， 可以为eclipse的xml配置自动提示功能 日志文件的配置 默认是Log4j,在etc下复制log4j.properties到src下，就可以了，本人ssh下复制log4j.xml就可以了 SessionFactory和Session比较 【SessionFactory】 重量级容器：消耗大量资源，不能有太多实例,二级缓存通常将该工厂类是单例模式，一个工厂类实例表示一个数据库所以Hibernate一般是不能跨数据库来做事务操作。但是EJB和JPA可以实现 这个配置选项：hibernate.hbm2ddl.auto create-drop 在一个数据库中创建，然后使用完关闭实例时就删除所有建立的表hibernate.hbm2ddl.auto create 清除数据库的表及数据，重新创建表hibernate.hbm2ddl.auto update 更改配置文件，能够在数据库进行操作（更新，建立）hibernate.hbm2ddl.auto validate 【session】 轻量级的容器，一级缓存是非线程安全的对象 OID的作用： 在Hibernate中唯一标识对象的属性，每个实体都是必须要有OID的 id生成策略 assigned：要求用户去手动指定对象的OID；该对象ID的类型可以是任意的 identity：MySQL的自动生成 native：数据类型是数值型，id的生成策略为数据库底层自增长（数据库自己去决定使用哪种方式，MySQL用identity，Oracle用序列等） sequence：Oracle数据库推荐，数值型（Long） seqhilo oracle :推荐使用的策略，使用序列来搭配高低机制 uuid.hex :32位字符 uuid: hilo：类型为数值型（long） [实际开发中推荐使用] id = hi+lo (高位和低位进行组合)sessionFactory实例化，高位就会加一，生成算法是：hi*(max lo +1)+lo; 12345678&lt;generator class=\"hilo\" &gt;&lt;param name=\"table\"&gt;stu_hilo&lt;/param&gt;&lt;!-- 放高值的表名 最好是一个对象对应于一个高低值的表避免了并发--&gt;&lt;param name=\"cloumn\"&gt;next_hi&lt;/param&gt;&lt;!-- 高的值放在表的哪个字段 --&gt;&lt;param name=\"max_lo\"&gt;100&lt;/ param&gt;&lt;!-- 每个轮回值的上限是多少 虚拟机启动频繁就设小一些，避免编码的浪费--&gt;&lt;/generator&gt; 非普通类型 Set集合： 1234&lt;set name=\"Nos\" table=\"表\"&gt; &lt;key column=\"外码\"&gt;&lt;/key&gt;&lt;!-- 外码 是必须的 --&gt; &lt;element column=\"号码\" type=\"string\"/&gt;&lt;/set&gt; List集合: 12345&lt;list&gt; &lt;key&gt;&lt;/key&gt; &lt;index&gt;&lt;/index&gt; &lt;element&gt;&lt;/element&gt;&lt;/list&gt; 查询列 属性：&lt;property name=&quot;&quot; formula=&quot;(select sum() from 选修表 as u where u.id=id)&quot;&gt;&lt;/property&gt; Hibernate实体关联配置一对多的配置 注意：一定要两个都有oid的情况才能配置一对多的映射,不能是依赖于另一个主键类 一方： 1234&lt;set name=\"\" [cascade=\"\"]&gt; &lt;key column=\"这是外键\"&gt;&lt;/key&gt; &lt;one-to-many class=\"多方的类\"&gt;&lt;/one-to-many&gt;&lt;/set&gt; 多方：&lt;many-to-one name=&quot;&quot; class=&quot;一方的类&quot; column=&quot;外键，key要一致&quot; /&gt; 双向的关联，会有update的SQL语句的执行来维护关系，影响效率 多方维护：一方中set标签加inverse=”true”一方就不会维护，代码一定要多方执行set*() 一方维护：一方代码一定要执行*.add() 注意 ： 1.在一的一方，修改xml文件，添加一个set 属性，表示 多方 的一个集合 1234&lt;set name=\"类中属性名（集合）\" inverse=\"true\"&gt; &lt;key&gt;&lt; column name=\"数据库列名\"/&gt;&lt;/key&gt; &lt;one-to-many class=\"多方类路径\"/&gt;&lt;/set&gt; 2.在一的一方，修改POJO持久类文件，添加一个hashset，用来存储多方，添加setget方法，名字就是配置文件里添加的那个名字 注意修改构造器 3.在多的一方，修改xml文件，置换掉那个外键，换成many-to-one标签，里面写上外键的列&lt;many-to-one name=&quot;类中属性名（对象）&quot; class=&quot;一方的类路径&quot; column=&quot;数据库中列名&quot;&gt;&lt;/many-to-one&gt; 4.在多的一方，修改POJO持久类文件，添加一个一方的对象添加setget方法，名字就是配置文件里添加的那个名字 注意修改构造器 一方的set集合中有inverse属性，多方是没有的，Hibernate中inverse是和外键对应的，一方配置了inverse是false，一方就不会维护关系（外键），一般是给多方维护，因为效率高 cascade是对象和对象之间的操作，和外键没有关系 处于持久化状态的对象在Session中，客户端不需要做Session的save/update 操作，Hibernate会自动的去检查处于持久化的对象的状态的属性是否发生改变，改变了就发送update语句。 如果该对象是一方，在一的一方映射文件中有cascade=all时，Hibernate内部还会检查该持久化对象关联的集合，对此集合进行update操作，但是该操作和外键没有关系，只有当通过多方建立关系后，才能使外键有值。 多对多的配置 关系在第三方表中，和两张表本身没有关系 多对多维护关系，谁都能维护关系（效率是一样的）维护一般是在页面上进行的 table 是多对多的中间表（存放了一个关系） key中的column一般是填当前配置文件中的id 多对多的配置是需要两个外键的 如果使用了反转并使用了级联，就只会保存实体，但是关系是没有维护的（就是不会插入到第三方表），和一对多一样的（一对多是外键列没有值）。 ！！如果双方都级联了，必须要有一方inverse，不然会有重复维护的错误发生 学生方配置1234&lt;set name=\"students\" table=\"student_course\"&gt; &lt;key column=\"cid\"&gt;&lt;/key&gt; &lt;many-to-many class=\"Student\" column=\"stu_id\"&gt;&lt;/many-to-many&gt;&lt;/set&gt; 课程方配置1234&lt;set name=\"courses\" table=\"student_course\"&gt; &lt;key column=\"stu_id\"&gt;&lt;/key&gt; &lt;many-to-many class=\"Course\" column=\"cid\"&gt;&lt;/many-to-many&gt;&lt;/set&gt; 一对一的配置 单向 只要配置单向的配置文件添加： &lt;many-to-one name=&quot;&quot;class=&quot;映射的类&quot; column=&quot;数据库字段&quot; unique=&quot;true&quot;&gt;&lt;/many-to-one&gt; 双向 一方 甲：&lt;many-to-one name=&quot;&quot; class=&quot;乙方类&quot;column=&quot;数据库字段&quot; unique=&quot;true&quot;&gt;&lt;/many-to-one&gt; 一方 乙：&lt;one-to-one name=&quot;&quot; class=&quot;甲方类&quot; property-ref=&quot;甲方配置的标签的name&quot;&gt;&lt;/one-to-one&gt; 使用多对一的技巧添加记录 当需要添加一个多方时，一看成课程，多看成成绩。当然的首先得有相关课程，再添加成绩记录。 那就先实例化一个课程对象，配置好信息 实例化多个成绩实例，再 课程对象.get**Set().add(成绩对象); 将成绩对象添加到集合中， session.save(课程对象)； 注意：既然实现了这样的操作，那就说明了在实例化成绩的时候，不需要指定课程的值，那就需要添加一个构造器 删除记录 如果删除一方，那就会将一删除，如果没有配置级联，就会将多方的外键置空，不会删除多方表 如何通过一方修改多方的一条, 把一方的set中的要修改的一条，（查找之前需要对象 = session.load(对象.class,主键名)将多方的数据加载进来） 注意多方不能有空列必须指定一个默认值（是和构造器有关么？） 再查找出来，修改再update，新增也是如此增加多的一方的时候，就是在一方的set中新增一条记录，多方的操作都体现在了一方那里 继承关系的配置 两种方式，一般采用前者1234567891011121314&lt;!-- 将子类插入到父类的配置文件 需要使用key来关联的--&gt; &lt;joined-subclass name=\"cn.hibernate.extend.Student\" table=\"extend_student\"&gt; &lt;key column=\"id\"&gt;&lt;/key&gt; &lt;property name=\"sru_id\" type=\"long\"&gt;&lt;/property&gt; &lt;/joined-subclass&gt;&lt;!-- union是相当于将父类的所有属性复制到子类里，是共享父类的OID， 所以父类的OID是不能和子类的OID重复的 不然 查询的时候就会报错, 所以就需要改父类的主键生成策略是高低值（或者是手动set），可以手动配置高低值的表的生成--&gt; &lt;union-subclass name=\"cn.hibernate.extend.Student\" table=\"union_student\"&gt; &lt;property name=\"sru_id\" type=\"long\"&gt;&lt;/property&gt; &lt;/union-subclass&gt; Hibernate异常could not find a getter for原因：1 可能真的没写get方法，或者get方法不合规范 setget方法中不允许两个连续大写字母 2 *.hmb.xml文件中的属性名和pojo持久类中属性名不一致（一定不能在表名中添加下划线） 3 方法名写错（基本不可能，都是自动生成的） 个人总结当使用了没有 主键的表，使用Myeclipse自动创建配置文件，使用自己的Table2Class来生成POJO持久类，就要继承对应的自动创建的抽象类，因为没有主键的表默认是将所有列看成一个主键，并且还会有添加一个id属性，这样也说明还有一点就是，这种表的字段不能有叫做id的列 是不是可以不用手动去使用那个类，好像这里自动生成的一切都有， 自动生成会生成： 对应POJO的抽象类，hbm配置文件，以及默认的几个类，HibernateSessionFactory，IBaseHibernateDao， 对应的Dao（添加的时候默认是没有使用事务，所以需要手动修改）,添加，删除，都是依据主键的， 至少要初始化主键，当然还得满足数据库的要求 Hibernate对象的状态 主要是对象内存和Session中的状态区别，而不是Session和数据库 临时态：刚实例化对象。对象在数据库中不存在，Session中也不存在 游离态：刚实例化的对象，但是该对象手动指定了OID并且OID在数据库中已经存在，并且是没有绑定Session的（特殊的临时态） 保存两个有关联关系的对象，update时，如果配置文件中配置了级联，就会一起保存，一般建议在一方级联 持久态：该对象在数据库中存在，该对象绑定在Session（一级缓存）中 删除态：session.delete(对象)，删除后对象从数据库和Session中都移除了，但是OID还在内存中。 游离态delete后就成了删除态 持久态delete后就成了删除态 Session的方法 save update delete saveOrUpdate 由入参的OID来自动选择是要save还是update merge 形参：临时态的对象。形参和Session没有任何关系，返回对象Object2（持久化对象），所以在Session关闭的时候Object2的更改会同步到数据库中 get 将数据库中指定对象获取为持久态，查不到就是返回null load 懒加载。使用代理对象，延迟加载。用到了别的属性就去查数据库。查不到就抛异常 flush 刷新Session evict 定点清除 将指定的对象从Session中移除，变成游离态 clear 全部清除 close 特别注意 一个对象（内存）不能存在于多个Session中，一个存，一个改的情况是会错误的 但是数据库中同一条记录可以实例化为多个对象（内存），那么这些对象（内存）放在不同的Session中是可以的 get： 只延迟加载有外键关联的那部分属性，没有使用就不会查询，只有用到了才会查询 多方：立即加载就要在配置文件中将对应的属性中添加 fetch=”join” 一方：配置文件中set标签 加上lazy=”false”（两条SQL），再添加 fetch=”join”后就只有一条SQL语句，但是这个一方是不能做分页查询的 load： 在你确定OID是一定有的时候使用load提高效率，但是实际开发过程中用的少，因为实际上没有这么确定。 懒加载如果Session关闭了或者是对象游离态。就会有懒加载初始化的异常","categories":[],"tags":[]},{"title":"IDEA.md","slug":"Memo-Java-Tool-IDEA","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Tool-IDEA/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-IDEA/","excerpt":"","text":"目录 start IDEA 使用笔记 常识 常用技巧 Tomcat的使用 导出为可运行的JAR包 普通Java项目 Springboot热加载 Debug 常用配置 个人IDEA配置 IDEA快捷键 默认快捷键 个人习惯 File Coding Extract Jump Search View Setting 常用插件 启动配置 Tips Error:Cannot compile Groovy files: no Groovy library is defined for module “XXX” 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs IDEA 使用笔记 学生授权申请方式 | clickrover12421博客 | IDEA主题 常识 project 就是一个工作空间，一个Module就是一个项目 新建一个empty项目可以作为一个工作空间，放很多module,新建的时候不要选中任何目录，光标选中JRE库，再菜单栏点击File然后new， 不然项目结构很乱, 会在光标停留的文件夹下新建module 一个项目一个空间也是可以的，就是跨项目查看代码会有点麻烦，而且每个项目的IDEA的配置都是不一样的，同样的配置可能要配置很多遍 在新版中提供的load unload 模块功能,必须要重启idea, 才能让maven生效 emmm 常用技巧 鼠标方法上悬停显示javadoc 勾选 General -&gt; show quick documentation on mouse move 自定义 TODO 等标签 Editor -&gt; TODO, 照已有的 TODO FIXME 新建一个即可 W3C idea 教程 Tomcat的使用 直接配置解压的即可, 然后Idea会在 用户目录下的Idea主目录中配置一个专门放Tomcat的配置和日志等文件, 和原Tomcat进行了隔离, 这样就不会影响到该Tomcat. 导出为可运行的JAR包 普通Java项目 File -&gt; project structure -&gt;artifact 里面设置好 引入的库，设置Main类，引用的jar包的相对classpath Build artifact -&gt; Build Maven或者Gradle的话直接就能得到，不过也要配置一下main Springboot热加载 每个project都是一个新的工作区，所以要重新配置 | howto-hotswapping Ctrl Shift A 快捷搜索 automatically 在Build下的 Compiler，勾选 Build project automatically 自动构建 (如果旁边有提示说不会在运行和debug执行, 那么就要勾选并行) Compile independent modules in parallel **Ctrl Shift A 快捷搜索 Registry 进入后找到 compiler.automake.allow.when.app.running 勾选 加入devtools依赖 | DevTools的官方文档 Debug debug还是比较强大的, 会在行末显示这一行的变量值 在Intellij IDEA中使用Debug 横排的八个按钮 Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。Drop Frame (默认无)：回退断点，后面章节详细说明。Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，点击按钮,代码会运行至光标行，而不需要打断点。Evaluate Expression (Alt + F8)：计算表达式，后面章节详细说明。 竖向的七个按钮 Rerun ‘xxxx’：重新运行程序，会关闭服务后重新启动程序。Update ‘tech’ application (Ctrl + F5)：更新程序，一般在你的代码有改动后可执行这个功能。而这个功能对应的操作则是在服务配置里，如图2.3。Resume Program (F9)：恢复程序，比如，你在第20行和25行有两个断点，当前运行至第20行，按F9，则运行到下一个断点(即第25行)，再按F9，则运行完整个流程，因为后面已经没有断点了。Pause Program：暂停程序，启用Debug。目前没发现具体用法。Stop ‘xxx’ (Ctrl + F2)：连续按两下，关闭程序。有时候你会发现关闭服务再启动时，报端口被占用，这是因为没完全关闭服务的原因，你就需要查杀所有JVM进程了。View Breakpoints (Ctrl + Shift + F8)：查看所有断点，后面章节会涉及到。Mute Breakpoints：哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled 个人思考 当断点 F8 步过 到一行代码后, 这个方法没有抛出异常什么的, idea的面板上的那些属性, 断点什么的都没了, 只有一个 app is running , 这个意思就是这行代码还在执行中, 很有可能就是死循环… 没有断点的时候, 也就是说这个死循环一直挂在这边, 不会被回收, 后面的代码也被阻塞了, 所以代码才诡异的不符合自己构想的调用链执行 常用配置自定义类文件头 依次找到配置项: File-&gt;settings-&gt;Editor-&gt;File and Code Templates-&gt; 如果自己要每个文件都单独设置头部, 就依次点击Class Interface Enum …进行设置 参考博客 如果要统一设置 就点击Includes标签, 选择File Header例如修改为如下12345/** * Created by https://github.com/kuangcp * @author kuangcp * @date $&#123;DATE&#125; $&#123;TIME&#125; */ 自定义缩写模板在 Setting -&gt; Editor -&gt; Live Templates 设置项下可以看到已有的配置, 新建一个即可 个人IDEA配置 字体Fira Code Retina 14 0.9 IDEA快捷键 参考博客: Intellij IDEA神器居然还有这些小技巧如果一时不习惯idea, 可以在 设置中 的keymap 选择eclipse系列即可 默认快捷键 可以在 Help -&gt; Keymap Reference 看到内置PDF文档个人觉得最简单就是打开 Setting -&gt; keymap -&gt; Find Action by shortcut, 任意的按键, 然后查看对应的内容 Ctrl Shift Alt Key Action C E 可以显示最近编辑的文件列表 S 鼠标左击 可以关闭文件 C S Backspace 可以跳转到上次编辑的地方 C F12 可以弹窗显示当前文件中类的结构(快速跳转方法和属性) C F7 可以查询当前元素在当前文件中的引用，然后按F3可以选择 C N 可以快速打开类 C S N 可以快速打开文件 A Q 可以看到光标处的元素的Javadoc C W 可以选择单词继而语句继而行继而函数 A F1 可以将正在编辑的元素在各个面板中定位 C P 可以显示参数信息 C S Insert 可以选择剪贴板内容并插入 A Insert 可以生成构造器/Getter/Setter等 C A V 重构代码, 将选中的代码抽离出称为一个变量 Variable C A T 可以把代码包在一块内，例如try/catch A Up/Down 可在方法间快速移动 S Escape 不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口。 C S 左/右 调节以上窗口分隔线 C S Enter 就能自动补全代码的分号,括号 C Space 代码提示 C A Space 代码提示 包括类,变量,方法等内容 C S Space 智能提示 C P 方法参数提示 A F1 查找当前文件所在位置(项目,结构,maven等等) C S F7 要先选中文本然后按键 高亮显示所有该文本，按Esc高亮消失。 A F3 要先选中文本然后按键，然后 F3逐个往下查找相同文本，并高亮显示。 C B 快速打开光标处的类或方法的 声明或调用 C A B 查看抽象类或接口的实现方法 等价的,B键 可以换成鼠标左键单击 C S A N 可以快速打开符号(方法名, 变量名等等,全局搜索) C O 可以选择父类的方法进行重写 S Shift 也就是双击, 就可以快速搜索类了 C S F 全局搜索, 不含Shift 就是简单当前文件搜索- 快速打开类/文件/符号时，可以使用通配符，也可以使用缩写 C J Live Templates! 例如 fori 等快速模板代码 C S F7 可以高亮当前元素在当前文件中的使用 C A Up/Down 可以快速跳转搜索结果 C S J 可以整合两行 A F8 是计算变量值 Ctrl Enter, 如果光标在一行的中间, 可以迅速让光标跳转到下一行 在调试程序时查看任何表达式值的一个容易的方法就是在编辑器中选择文本（可以按几次 Ctrl-W 组合键更有效地执行这个操作）然后按 Alt-F8 。 要打开编辑器脱字符处使用的类或者方法 Java 文档的浏览器，就按 Shift-F1 （右键菜单的 External JavaDoc ）。 要使用这个功能须要把加入浏览器的路径，在“ General ”选项中设置（ Options | IDE Settings ），另外还要把创建的 Java 文档加入到工程中（ File | Project Properties ）。 个人习惯 从eclipse风格继承而来和原生Idea快捷键结合, 自己修改的风格, 如果需要, 则在个人配置文件夹下找到对应的jar导入即可个人的习惯特点是左手完成大部分快捷键的任务, 因为还没习惯脱离鼠标工作 Ctrl Shift Alt Key Action A Enter 自动修复 C Q 显示javadoc C B 显示定义处或者调用处 C S T 自动创建或跳转 Test C S F7 高亮显示光标所在元素所有出现过的地方(就是搜索) C A L 快速格式化代码 C A O 优化导入的类和包 C Esc 格式化并优化导入 A Esc 停止正在运行的运行项 A 1 运行上次的运行项 A 2 Debug上次的运行项 F10 运行光标所在处的运行项 S A F10 运行选择的运行项 S A F9 Debug选择的运行项 File Ctrl Shift Alt Key Action C W 选中代码 C E 显示最近打开的文件 A E 显示最近打开的文件 A S C 最近更改的文件 C N 快速搜索类 C S N 搜索所有文件 C S A N 按文件内容字符的搜索,也能按类名首字母搜索 A 左/右 左右切换打开的文件 C 鼠标左键 在文件标签页上单击, 即可在文件管理器中打开该文件 Coding Doc: 2018.2 Ctrl Shift Alt Key Action A C build 项目 C S V 显示最近的粘贴板记录 C O 选择要重写的方法 C I 选择要实现的方法 C A Insert 生成代码(如get,set方法,构造函数等) S A K 重命名 C X 剪切一行 C D 删除一行 C Y 复制一行到下一行 C Q 显示注释文档 或者 Alt+鼠标中键 C S Space 智能提示代码的补全 S A 上/下 代码上/下移动 C S 上/下 代码上/下移动 光标在一行上就是移动一行, 光标在代码块的首行就是移动整个代码块 C J 提示代码片段 也就是 Live Template A J 选中字符 C Space 智能补全 C S Space 结合上下文补全 C W 选中代码，连续按会有其他效果 C S U 选中字符大小写转换 Extract Ctrl Shift Alt Key Action C A T 根据选中代码(或者光标前的代码片段)包裹 在块中 例如try/catch if for … C A J 根据选中代码(或者光标前的代码片段)包裹在自定义的模板中 C A M 根据选中代码(或者光标前的代码片段)抽离成 函数 C A V 根据选中代码(或者光标前的代码片段)抽离成 变量 自定义为 C A S J C A C 根据选中代码(或者光标前的代码片段)抽离成 常量 C A F 根据选中代码(或者光标前的代码片段)抽离成 属性 C A P 根据选中代码(或者光标前的代码片段)抽离成 方法参数 C S A P 根据选中代码(或者光标前的代码片段)抽离成 函数式方法参数 Jump Ctrl Shift Alt Key Action A 上/下 在方法间快速移动定位 C A 左/右 后退/前进 至光标的上一个位置 F2 高亮错误或警告快速定位 组合 Shift 前进 C [ ] 可以跳到大括号的开头结尾 A S 跳转类的方法或属性 Search Ctrl Shift Alt Key Action C N 查找类(所有类范围,包括引用的包) A L 查找类 原默认是 Ctrl N A I 查找文件名 C R 替换文本 C F 查找文本 C S F 全局搜索字符串 A K 查找任意文件原默认是双击Shift View Ctrl Shift Alt Key Action C S 左/右 调节以上工具窗口与编辑器窗口的分隔线位置 S A H 显示/隐藏 所有工具窗口 C H 生成类结构图并显示 A H 类结构图窗口 A A 目录结构窗口 A X Run窗口 A D Debug窗口 A T TODO的窗口 Ctrl +/- 显示和折叠TODO A G Gradle窗口 A M Maven窗口 A Z Spring窗口 A V VCS窗口 A N 导航至文件所在目录等… A 3 数据库工具窗口 A . 终端窗口 S A V 数据库 Console 窗口 在任一工具窗口, 按ESC都会让焦点回到编辑器 Shift ESC 就能关闭工具窗口并让焦点回到编辑器以上的窗口都是默认显示小bar的, 我为了窗口更大就设置为了默认隐藏, 如果想显示, 可以双击Alt, 在第二下按住不动, 鼠标就能进行点击了 Setting Ctrl Shift Alt Key Action C S A 搜索设置项的位置 C S A ? 进行一些关键设置 Tips 代码模板 Live Template (fori notnull…) 输入完成后，按Tab或者Enter，生成代码。 常用插件 Alibaba Java Code Guidelineshuo 阿里巴巴的代码规范插件 《阿里巴巴Java开发规约》IDEA插件与Eclipse插件使用指南 TestMe 快速创建测试类 TestNG TestNG 测试框架的集成 lombok 插件商店中搜索 lombok 安装重启idea即可 配置 Build,Execution &gt; Compiler &gt; Annotation Processors 勾选上即可使用lombok的注解 Jrebel 热部署插件, 需要付费 GoogleTranslation Ctrl Alt 1 快速翻译选中的单词和语句 http-client https://www.jetbrains.com/help/idea/http-client-in-product-code-editor.html Docker Kubernates Maven helper rainbow brackets 将括号变成彩色, 更方便查看 内置插件 为了节省内存, 禁用无关插件, 把插件列表中所有插件全看一遍 haml haml语言, HTML的抽象化语言 Gherkin Gherkin是Cucumber用于定义测试用例的语言。 cucumber java cucumber groovy 启动配置 官网文档IntelliJ IDEA 内存优化最佳实践 TipsError:Cannot compile Groovy files: no Groovy library is defined for module “XXX” Project Structure -&gt; 找到 XXX 项目 右击 -&gt; Add -&gt; 选择 Groovy","categories":[],"tags":[]},{"title":"JavaScript.md","slug":"Memo-FrontEnd-JavaScript","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-FrontEnd-JavaScript/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-FrontEnd-JavaScript/","excerpt":"","text":"目录 start JavaScript 数据类型 字符串 函数 函数传值 JSON 常用功能小模块 输入校验 Ajax 事件 鼠标 滚轮 常用库和框架 Jquery Ajax form插件 echarts 资源文件 图片 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs JavaScript数据类型 虽然是弱类型,但还是要注意一下 字符串 字符串转码: 参考博客:JS字符串相关转码函数 函数函数传值12345678910111213141516function handlerGet(url, role, success, fail) &#123; var request = $.ajax(&#123; method: 'GET', url : 'xxx'+url &#125;); request.done(success); request.fail(fail);&#125;function testRole() &#123; handlerGet('/world', 'student', function (data) &#123; layer.msg('获取成功'); &#125;, function (data) &#123; layer.msg('身份认证已过期， 请重新登录'); &#125;)&#125; JSON json 数据 添加 删除 排序 直接点引用属性或者a[‘b’]的方式, 迭代集合:自带foreach循环 data.forEach(function(value){}) 但是有时候不能使用，会undefined，eval(‘(‘+data+’)’)解析后才能用 原因在于Response Headers 的 Content-Type:application/json;charset=UTF-8 如果回应的类型是 text/plain 就需要使用 eval(‘(‘+data+’)’)才能用 如果设置成JSON就可以直接点引用和循环迭代, 并且不需要强制的JSON规范, 值为数字时不加双引号也是正常解析的 12345678910111213141516171819202122var array = &#123; \"a\": \"abc\", \"b\": [1, 2, 3, 4, 5, 6], \"c\": 3, \"d\": &#123; \"name\": \"james\", \"age\": 28 &#125;, \"e\": null, \"f\": true&#125;;//遍历array方式1for (var x in array) &#123; if (typeof array[x] == 'object' &amp;&amp; array[x] != null) &#123; for (var y in array[x]) &#123; console.log(\"&gt;&gt;key = \" + y + \" value = \" + array[x][y]); &#125; &#125; else &#123; console.log(\"key = \" + x + \" value = \" + array[x]); // 非array object &#125;&#125; 常用功能小模块输入校验 Blog:关于Input的输入校验数字,字母汉字等限制 Ajax js 原生 post请求 参考博客: 使用 Fetch 事件鼠标滚轮 JavaScript 鼠标滚轮事件 常用库和框架 lozad.js 懒加载网页底部的浏览 Jquery jquery有是slim版(没有ajax的精简版 ) JQuery官网 | Jquery教程 事件绑定 $(&#39;#Button&#39;).on(&#39;click&#39;, function(){}) 在HTML的DOM上绑定数据:设置 data-* 属性 然后jq拿到元素直接调用 $(this).data(&#39;id&#39;)拿到值就可以避免函数传值 原生方式异步提交1234$(\"#set-form\").submit(function(e)&#123; e.preventDefault(); console.log('prepare submit')&#125;); Ajax ajax文档 form插件1234567891011121314// 使用jquery 的 form插件进行异步提交$(\".submit\").on('click', function () &#123; console.log('dfs') // var jk = $(\"#contents\").submit() var options = &#123; // target:'#contents', //后台将把传递过来的值赋给该元素 url:'../teacher/topic/add', //提交给哪个执行 type:'POST', success: function(data)&#123; console.log(data) &#125; //显示操作提示 &#125;; $('#contents').ajaxSubmit(options);&#125;) echarts 官网 | 做图表展示很简单 资源文件图片 参考博客: JS 图片转Base64","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.kuangcp.top/categories/JavaScript/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"Gradle.md","slug":"Memo-Java-Tool-Gradle","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Tool-Gradle/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-Gradle/","excerpt":"","text":"目录 start Gradle 书籍 发行版本列表 安装配置 SDKMAN方式 Chocolate 命令行选项 守护进程 Docker安装 配置镜像源 关键配置文件 build.gradle 初始化一个新项目 依赖定义 统一依赖管理 配置Wrapper 插件 常用插件 setting.gradle Gradle多模块的构建 另一种方式 部署 War包 Jar包 上传至构建仓库 构建Docker镜像 第二种插件方式 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Gradle 官方 guide | 其他 tutorial参考博客: 零散知识点总结(1) - Gradle 使用配置总结 个人看法 参考: Gradle在大型Java项目上的应用 优缺点 Gradle大吐槽官方对比Gradle和Maven 优点 相对于Maven, 配置文件简洁了很多, 所以才入坑学习使用的 对于一些需要自定义的任务,因为核心为Groovy,所以实现能力高 例如:将一个SpringBoot项目构建成一个镜像,并tag上当前构建的镜像为release,然后删除旧有容器,使用新的镜像启动容器 缺点 内存占用巨大,存在内存泄露问题, 以至于在IDEA上不敢使用自动导入, 不然每动一下build.gradle 就会卡半天, 8G内存都不够用!! 编译速度慢, 如果和Maven进行对比, 编译速度和资源占用确实慢 书籍 Gradle in Action 中译 如果没有一点Groovy基础, 阅读自定义Task等一些高自定义的地方还是比较困惑 发行版本列表 官方网址 有各个版本的下载以及版本发行说明Github地址查看简洁的 Release Note 更方便 安装配置 和maven使用同一个本地库 只要加上 M2_HOME 环境变量即可, 值和 MAVEN_HOME 一样, 并没有用 SDKMAN方式 先安装sdkman 使用Bash运行curl -s &quot;https://get.sdkman.io&quot; | bash sdk install gradle 即可安装 Chocolate windows 上安装 chocolate PowerShell中运行 wr https://chocolatey.org/install.ps1 -UseBasicParsing | iex 若操作系统默认禁止执行脚本，执行一次set-executionpolicy remotesigned后脚本顺利执行 Chocolatey在安装包的时候，默认路径是按照系统的默认路径来的，如果想修改安装路径可以这样处理： 执行“开始/运行”命令（或者WIN + R），输入“regedit”，打开注册表。 展开注册表到下面的分支[HKEY＿LOCAL＿MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion]，在右侧窗口中找到名为“ProgramFilesDir”的字符串，双击把数值“C:\\Program Files”修改为“D：\\ProgramFiles”，确定退出后,即可更改常用软件的安装路径了。 命令行选项 gradle 构建文件中的task名： 直接运行task -b，--build-file test.gradle 指定运行脚本文件 --offline 离线模式 -P ,--project-prop:配置参数 -Pmyprop=value -i,--info : 打印info级别的输出 -s,--stacktrace: 输出错误栈 -q,--quiet:减少构建出错时打印的错误信息 tasks : 输出所有建立的task properties : 输出所有可用的配置属性 守护进程 命令加上 --daemon就会开启一个守护进程，只会开启一次， 守护进程会在空闲3小时后销毁 手动关闭 gadle --stop 构建时不采用守护进程 --no--daemon Docker安装 Docker 文档 配置镜像源阿里云 参考博客: 配置Gradle的镜像为阿里云镜像 当前项目的build.gradle1234567891011121314repositories &#123; def aliyun = \"http://maven.aliyun.com/nexus/content/groups/public/\" def abroad = \"http://central.maven.org/maven2/\" maven &#123; url = aliyun artifactUrls abroad &#125; // 马云上自己的库 maven &#123; url = \"https://gitee.com/gin9/MavenRepos/raw/master\" &#125; mavenCentral() jcenter()&#125; 全局的配置~/.gradle/init.gradle1234567891011121314151617181920212223allprojects&#123; repositories &#123; def ALIYUN_REPOSITORY_URL = 'http://maven.aliyun.com/nexus/content/groups/public' def ALIYUN_JCENTER_URL = 'http://maven.aliyun.com/nexus/content/repositories/jcenter' all &#123; ArtifactRepository repo -&gt; if(repo instanceof MavenArtifactRepository)&#123; def url = repo.url.toString() if (url.startsWith('https://repo1.maven.org/maven2')) &#123; project.logger.lifecycle \"Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.\" remove repo &#125; if (url.startsWith('https://jcenter.bintray.com/')) &#123; project.logger.lifecycle \"Repository $&#123;repo.url&#125; replaced by $ALIYUN_JCENTER_URL.\" remove repo &#125; &#125; &#125; maven &#123; url ALIYUN_REPOSITORY_URL url ALIYUN_JCENTER_URL &#125; &#125;&#125; 关键配置文件build.gradleHello World123456789task helloworld&#123; doLast &#123; printf 'Hello World!' &#125;&#125;// 或者是 使用 &lt;&lt; 代表doLast：task helloworld&lt;&lt;&#123; println 'Hello world!'&#125; 运行：gradle -q helloworld 初始化一个新项目 doc:building java application 依赖定义 和Maven用的是同一种方式 groupId artifactId version 使用本地依赖 compile files(&#39;lib/ojdbc-14.jar&#39;) 相对的根目录是src同级目录 Official doc: dependency management4.10 Deprecated: compile runtime testCompile testRuntime compile(Deprecated) Compile time dependencies. Superseded by implementation. implementation extends compile Implementation only dependencies. compileOnly Compile time only dependencies, not used at runtime. compileClasspath extends compile, compileOnly, implementation Compile classpath, used when compiling source. Used by task compileJava. annotationProcessor Annotation processors used during compilation. runtime(Deprecated) extends compile Runtime dependencies. Superseded by runtimeOnly. runtimeOnly Runtime only dependencies. runtimeClasspath extends runtimeOnly, runtime, implementation Runtime classpath contains elements of the implementation, as well as runtime only elements. testCompile(Deprecated) extends compile Additional dependencies for compiling tests. Superseded by testImplementation. testImplementation extends testCompile, implementation Implementation only dependencies for tests. testCompileOnly Additional dependencies only for compiling tests, not used at runtime. testCompileClasspath extends testCompile, testCompileOnly, testImplementation Test compile classpath, used when compiling test sources. Used by task compileTestJava. testRuntime(Deprecated) extends runtime, testCompile Additional dependencies for running tests only. Used by task test. Superseded by testRuntimeOnly. testRuntimeOnly extends runtimeOnly Runtime only dependencies for running tests. Used by task test. testRuntimeClasspath extends testRuntimeOnly, testRuntime, testImplementation Runtime classpath for running tests. archives Artifacts (e.g. jars) produced by this project. Used by tasks uploadArchives. default extends runtime The default configuration used by a project dependency on this project. Contains the artifacts - and dependencies required by this project at runtime. 依赖排除以及指定依赖版本123456789101112131415161718192021222324252627282930// 依赖排除compile('')&#123; exclude group: '' // 按group排除 exclude module: '' // 按 artifact 排除 exclude grop: '', module: '' // 按 group artifact 排除&#125;// 全局依赖排除all*.exclude group:'org.unwanted', module: 'iAmBuggy'// 禁用依赖传递compile('com.zhyea:ar4j:1.0') &#123; transitive = false&#125;configurations.all &#123; transitive = false&#125;// 强制使用指定版本的依赖compile('com.zhyea:ar4j:1.0') &#123; force = true&#125;// 始终使用最新的依赖, 若 1.+ 则是 1.xx版本的最新版compile 'com.zhyea:ar4j:+'configurations.all &#123; resolutionStrategy &#123; force 'org.hamcrest:hamcrest-core:1.3' &#125;&#125; 统一依赖管理新建一个文件 dependency.gradle12345678ext &#123; ver = [ junit : '4.12', ] libs = [ \"junit\" : \"junit:junit:$ver.junit\", ]&#125; 在 build.gradle 中引入 apply from: &#39;dependency.gradle&#39; 使用依赖时 只需 compile libs[&#39;junit&#39;] 即使在子模块中也是如此使用 配置Wrapper 在使用IDE生成项目的时候，可以选择gradle的执行目录，可以选gradle wrapper 也可以选自己下载解压的完整包如果使用的不是这个wrapper，那么别人在下载项目后，运行gradle命令就要先安装gradle，使用wrapper更好12345task wrapper(type: Wrapper)&#123; gradleVersion = '4.8' distributionUrl = '限定访问内网的URL' distributionPath = '包装器被解压缩放的相对路径'&#125; 运行 gradle wrapper 一次即可开始使用包装器的脚本来构建项目了 生成gradle包管理器：gradle wrapper --gradle-version 2.0 插件有多种方式: 12345678910// 1apply plugin: 'java'// 2apply&#123; 'java'&#125;// 3plugins&#123; id 'java'&#125; 常用插件 lombok 使用Lombok的正确方式 | gradle lombok plugin 官方文档1234annotationProcessor 'org.projectlombok:lombok:1.18.2'compileOnly 'org.projectlombok:lombok:1.18.2'testAnnotationProcessor 'org.projectlombok:lombok:1.18.2'testCompileOnly 'org.projectlombok:lombok:1.18.2' maven apply plugin: &quot;maven&quot; 然后就能执行 install等命令了 gradle 4.8 用不了 需要这种方式 shadowJar 含依赖的jar进行打包 docker 提供Docker操作 apply plugin: &#39;docker&#39; buildscript dependencies 中添加classpath(&#39;se.transmode.gradle:gradle-docker:1.2&#39;) setting.gradle 项目的配置信息, 一般存在这个文件的时候, Gradle就会认为当前目录是作为一个完整的根项目的, 并在当前目录添加 .gradle 目录一般默认内容为 rootProject.name = &#39;&#39; Gradle多模块的构建 官网文档 creating multi project builds 采用一个文件统一管理依赖, 然后各个子项目独立引用 | 完整示例 JavaBase统一配置依赖, 管理多模块 如果要添加一个项目也简单 直接新建一个目录 test 目录下新建空的文件 build.gradle 在根项目的 setting.gradle 中的include 加入 test (可以和文件夹不同名, build.gradle配置下就行了, 建议同名) gradle build 整个项目, 就完成了 最后就是手动的新建项目结构 另一种方式 参考博客:重拾后端之Spring Boot（六） – 热加载、容器和多项目直接在build.gradle中配置 123456789101112131415161718// 一个典型的根项目的构建文件结构buildscript &#123; // 构建脚本段落可以配置整个项目需要的插件，构建过程中的依赖以及依赖类库的版本号等&#125;allprojects &#123; // 在这个段落中你可以声明对于所有项目（含根项目）都适用的配置，比如依赖性的仓储等&#125;subprojects &#123; // * 在这个段落中你可以声明适用于各子项目的配置（不包括根项目哦） version = \"0.0.1\"&#125;// * 对于子项目的特殊配置project(':common') &#123;&#125;project(':api') &#123;&#125;project(':report') &#123;&#125; 1234567891011121314151617181920212223project(':common') &#123; dependencies &#123; compile(\"org.springframework.boot:spring-boot-starter-data-rest\") compile(\"org.springframework.boot:spring-boot-starter-data-mongodb\") compile(\"org.projectlombok:lombok:$&#123;lombokVersion&#125;\") &#125;&#125;project(':api') &#123; dependencies &#123; compile project(':common') compile(\"org.springframework.boot:spring-boot-devtools\") &#125;&#125;project(':report') &#123; dependencies &#123; compile project(':common') compile(\"org.springframework.boot:spring-boot-devtools\") compile files([\"lib/simsun.jar\"]) compile(\"org.springframework.boot:spring-boot-starter-web\") &#125;&#125; 有关多模块的构建详情参考这里 参考更为规范的多项目构建 部署War包Jar包 Gradle默认是只会打包源码，并不会打包依赖（为了更方便依赖的作用） shadow插件官网文档 添加 apply plugin: &quot;maven&quot; 然后就能和mvn install 一样的执行 gradle install 了 上传至构建仓库 特别注意使用gpg, 如果按这下面的一堆文档跟着做的话你要保证你的gpg小于等于2.0版本, 不然就卡在这里了 参考项目 参考官方文档参考博客最简单的方式就是利用码云等平台创建私服 构建Docker镜像 用 Docker、Gradle 来构建、运行、发布一个 Spring Boot 应用 build.gradle1234567891011121314151617181920212223242526apply plugin: 'docker'buildscript &#123; ext &#123; springBootVersion = '2.0.1.RELEASE' &#125; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath(\"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;\") classpath('se.transmode.gradle:gradle-docker:1.2') &#125;&#125;task buildDocker(type: Docker, dependsOn: build) &#123; //设置自动上传的话，命名就不能乱取了，仓库名/镜像名：tag// push = true test.enabled=false applicationName = jar.baseName dockerfile = file('src/main/docker/Dockerfile') doFirst &#123; copy &#123; from war into stageDir &#125; &#125;&#125; Dockerfile123456FROM frolvlad/alpine-oraclejdk8:slimVOLUME /tmp# 配置通配符是为了不受版本影响ADD weixin*.war app.war# ENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.war\"]ENTRYPOINT [\"java\",\"-jar\",\"/app.war\"] gradle buildDocker 即可构建镜像 运行 docker run --name web --link postgre:db -p 5678:8889 -it 镜像 注意其中要关联PostgreSQL的容器 第二种插件方式 参考 通过Gradle使用Docker部署 Spring Boot项目","categories":[],"tags":[]},{"title":"ResponseCode.md","slug":"Memo-FrontEnd-ResponseCode","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-FrontEnd-ResponseCode/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-FrontEnd-ResponseCode/","excerpt":"","text":"目录 start HTTP状态码大全 标准扩展码 1xx-Informational-信息化 2xx-Success-成功 3xx-Redirection-重定向 4xx-ClientError-客户端错误 5xx-ServerError-服务器错误 非官方扩展码 互联网信息服务扩展状态码 NGINX-扩展状态码 七牛扩展状态码 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs HTTP状态码大全 HTTP状态码HTTP状态码百度百科 标准扩展码1xx-Informational-信息化123100 Continue 继续101 Switching Protocols 交换协议102 Processing 继续处理 2xx-Success-成功12345678910200 OK201 Created 创建202 Accepted 已接受203 Non-Authoritative Information 非授权信息204 No Content 无内容205 Reset Content 重置内容206 Partial Content 部分内容207 Multi-Status 多状态208 Already Reported 已报告226 IMIM Used 使用的 3xx-Redirection-重定向 HTTP返回码中301与302的区别 123456789300 Multiple Choices 多种选择301 Moved Permanently 永久移动302 Found 发现 代表暂时性转移(Temporarily Moved )。303 See Other 查看其它304 Not Modified 未修改,使用缓存305 Use Proxy 使用代理306 Switch Proxy 开关代理307 Temporary Redirect 临时重定向308 Permanent Redirect 永久重定向 4xx-ClientError-客户端错误12345678910111213141516171819202122232425262728400 Bad Request 错误的请求401 Unauthorized 未授权402 Payment Required 需要付费403Forbidden 拒绝访问404 Not Found 未找到405 Method Not Allowed 不允许的方法406 Not Acceptable 不可接受407 Proxy Authentication Required 代理服务器需要身份验证408 Request Timeout 请求超时409 Conflict 冲突410 Gone 完成411 Length Required 需要长度412 Precondition Failed 前提条件失败413 Payload Too Large 负载过大414 URI Too Long 太长415 Unsupported Media Type 不支持的媒体类型416 Range Not Satisfiable 的范围不合适417 Expectation Failed 预期失败418 I&apos;m a teapot 我是一个茶壶421 Misdirected Request 误导请求422 Unprocessable Entity 无法处理的实体423 Locked 锁定424 Failed Dependency 失败的依赖426 Upgrade Required 升级所需428 Precondition Required 所需的先决条件429 Too Many Requests 太多的请求431 Request Header Fields Too Large 请求头字段太大451 Unavailable For Legal Reasons 不可出于法律原因 5xx-ServerError-服务器错误1234567891011500 Internal Server Error 内部服务器错误501 Not Implemented 未执行502 Bad Gateway 错误的网关503 Service Unavailable 服务不可用504 Gateway Timeout 网关超时505 HTTP Version Not Supported 不支持HTTP版本506 Variant Also Negotiates 变体也进行协商507 Insufficient Storage 存储空间不足508 Loop Detected 检测到循环510 Not Extended 不延长511 Network Authentication Required 网络需要身份验证 非官方扩展码123456789103 Checkpoint 检查点420 Method Failure (Spring Framework) 故障的方法（Spring框架）420 Enhance Your Calm (Twitter) 增强您的平静（微博）450 Blocked by Windows Parental Controls (Microsoft) 被Windows阻止家长控制（微软）498 Invalid Token (Esri) 无效的令牌（ESRI的）499 Token Required (Esri) 令牌必需（ESRI的）499 Request has been forbidden by antivirus 请求已被禁止反病毒509 Bandwidth Limit Exceeded (Apache Web Server/cPanel) 超出带宽限制（Apache的Web服务器/的cPanel）530 Site is frozen 网站被冻结 互联网信息服务扩展状态码123440 Login Timeout 登录超时449 Retry With 重新发送带451 Redirect 重定向 NGINX-扩展状态码12345444 No Response 没有响应495 SSL Certificate Error 证书错误496 SSL Certificate Required证书要求497 HTTP Request Sent to HTTPS Port 发送到HTTPS端口请求499 Client Closed Request 客户端请求关闭 七牛扩展状态码12345678910111213298 部分操作执行成功。419 用户账号被冻结。478 镜像回源失败。 主要指镜像源服务器出现异常。573 单个资源访问频率过高579 上传成功但是回调失败。 包括业务服务器异常；七牛服务器异常；服务器间网络异常。599 服务端操作失败。608 资源内容被修改。612 指定资源不存在或已被删除。614 目标资源已存在。630 已创建的空间数量达到上限，无法创建新空间。631 指定空间不存在。640 调用列举资源 (list) 接口时，指定非法的marker参数。701 在断点续上传过程中，后续上传接收地址不正确或ctx信息已过期。","categories":[{"name":"Web","slug":"Web","permalink":"http://blog.kuangcp.top/categories/Web/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"Java基础语法","slug":"Memo-Java-AdvancedLearning-GrammarAndType","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-GrammarAndType/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-GrammarAndType/","excerpt":"","text":"目录 start 基础语法 代码风格 结构 判断 循环 用户输入输出 数据类型 基础数据类型 byte char boolean short int long float double 包装类型 String StringBuffer和StringBuilder Float Double Integer Long Boolean Void 枚举类型 自动拆装箱 内部类 类型强转 时间类型 类的结构 修饰符 权限修饰符 其他 成员属性 方法 Object VO PO TO BO POJO DAO 关键字 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 基础语法代码风格 Google Style Guide | 阿里巴巴开发手册 结构判断 if switch 循环 while while(true){} do{}while(true); for 循环 for(int a=0; i&lt;10; i++){} for each循环 for(Object item:list){} 其中list对象如果是通过调用一个对象的方法返回的，那么只会调用一次 用户输入输出 System.out.println(&quot;&quot;) 输出并在末尾追加换行 .print() 输出, 行末不换行 .printf() 格式化输出, 和C语法类似 数据类型 official guide 基础数据类型 八种基本数据类型 byte char boolean short int long float double 参考博客: Java 有值类型吗？ 确实, 这样来看Java没有值类型才是更统一的, 不过有没有对程序都是一样的, 因为Java没有解引用, 基本数据类型又没有成员, 所以值还是引用, 没差 byte 字节 Java8以前是使用 char数组 来存放String, Java8开始就是 byte数组 了 charboolean 参考 你真的知道Java中boolean类型占用多少个字节吗？ shortint 数值范围 +- 2147483647 = 2^31-1 也就说明了int是占四个字节 32位 一位是符号位 (操作系统的不同也会有差异) long 数值范围 +- 9223372036854775807 = 2^63-1 也就是八个字节 64位 一位是符号位 floatdouble 包装类型 wrapper class基本类型和包装类型不能混为一谈 本质上的 class是不同的, 只不过自动拆装箱才让人感觉没差别 Integer.TYPE == int.classByte.TYPE == byte.classBoolean.TYPE == boolean.classDouble.TYPE == double.classVoid.TYPE == void.class String 该类是final修饰的, 原因:知乎问题 常量池的实现 常见编码转换 一般Windows文件默认编码：str = new String(str.getBytes(&quot;iso8859-1&quot;), &quot;gb2312&quot;); properties文件中获取中文 str = new String(str.getBytes(&quot;utf-8&quot;), &quot;utf-8&quot;); StringBuffer和StringBuilder 参考博客 FloatDoubleIntegerLongBooleanVoid void 的包装类型, 常用于反射时对应上 返回值为void的方法(总得有个类型 Void.TYPE) 该类型在 jdk1.1就有了, 1.5出了泛型后, 又多了一个用途(因为泛型不支持原始类型) The Void class is an uninstantiable placeholder class to hold a reference to the Class object representing the Java keyword void. 参考博客: What is the need of Void class in Java 参考博客: Uses for the Java Void Reference Type? 在AOP中, 增强根据切点的返回值类型, 做出不同的逻辑, 有可能用到Void Void 强调 the nothing, null 强调 nothing Void 作为方法的返回值时,只能返回 null 案例: Future ResponseEntity A Consumer&lt;T&gt; can be viewed as a Function&lt;T, Void&gt;. A Supplier&lt;T&gt; can be viewed as a Function&lt;Void, T&gt; official api When you use the visitor pattern it can be cleaner to use Void instead of Object when you want to be sure that the return value will be null. Example:1234public interface LeavesVisitor&lt;OUT&gt;&#123; OUT visit(Leaf1 leaf); OUT visit(Leaf2 leaf);&#125; When you will implement your visitor you can explicitly set OUT to be Void so that you know your visitor will always return null, instead of using Object 12345678910public class MyVoidVisitor implements LeavesVisitor&lt;Void&gt;&#123; Void visit(Leaf1 leaf)&#123; //...do what you want on your leaf return null; &#125; Void visit(Leaf2 leaf)&#123; //...do what you want on your leaf return null; &#125;&#125; 枚举类型 official doc: enum 枚举类的构造器必须是private 或者 package private (也就是缺省) 参考博客: Java 语言中 Enum 类型的使用介绍从上面的定义形式来看，似乎 Java 中的枚举类型很简单，但实际上 Java 语言规范赋予枚举类型的功能非常的强大，它不仅是简单地将整形数值转换成对象，而是将枚举类型定义转变成一个完整功能的类定义。 简单定义 public enum Color {RED, GREEN, GRAY, BLUE, YELLOW, WHITE, PURPLE, BLACK} 简单单例 123456789101112public enum Tool&#123; INSTANCE(12); private int num; Tool(int num)&#123; this.num = num; &#125; public getNum()&#123; return num; &#125;&#125;// 使用的时候Tool.INSTANCE.getNum(); 自动拆装箱 基本数据类型和包装类型在Java中是可以视为等价的, 就是因为自动拆装箱的存在 内部类 其域可以和其他常见类型一样, 作为类的成员, 也可作为方法的局部变量, 其中包含的各种变量的域都是按原规则生效的 但是内部类的属性不能用static修饰归根结底，还是类与对象的区别，静态属性不依赖于对象，因为它保存在jvm的静态区，所以访问修改的时候不需要依赖当前有没有存活的对象，在虚拟机加载的时候也是优先于实例生成的。而实例对象则是保存在jvm的堆内存中，想要访问内部类，必须先实例化外部类，然后通过外部类才能访问内部类。内部类其实也可以认为是外部类的一个成员变量，只要是成员变量，各个对象都是不依赖的，静态属性的出现破坏了这一逻辑，所以java语言在语义层面不允许我们那么做，这其实不是技术问题，是一个语言的逻辑和语义问题。 参考博客: 关于Java内部类字段和方法不能使用static修饰的原因 类型强转 Double -&gt; int 直接(int)num; 时间类型 最早常用是 Date 然后 Calendar 然后 Instant LocalDateTime … 获取指定时间 获取指定时间的时间戳 类的结构修饰符 参考博客: java 权限修饰符 权限修饰符 public 任意范围; protected 子类 与 同包; 子类可以是任意包下 缺省(package private) 同包; 限定了同一个包下, 才能访问 所修饰的属性 private 只能 当前类 或者 内部类 访问 其他成员属性作为Java的bean, 或者大多数情况下, 属性都是私有的, 然后提供setter getter 方法,而且 一般来说, setter和getter方法是不能包含逻辑的, 也就是简单的赋值 取值乍一看相比于C语言, 似乎这是多此一举, 但是注意面向对象思想, 一个对象对外提供的应该只是行为, 具有较强的语义性, 什么对象执行了什么方法, 而直接引用就可能将对象属性和静态属性混淆 方法方法的签名: 方法签名的详解 Object 参考博客: java的(PO,VO,TO,BO,DAO,POJO)解释| VO DAO BO 等缩写的意义 VO (value object) 值对象 使用new关键字创建的, 由GC回收的, VO是值对象, 业务对象, 存活在业务层的, 是业务逻辑使用的 它存在的目的就是为数据提供一个生存的地方 VO的属性是根据当前业务的不同而不同的 也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 PO (persistant object) 持久对象 PO则是向数据库中添加新数据时创建，删除数据库中数据时削除的。 并且它只能存活在一个数据库连接中，断开连接即被销毁。 PO是持久化对象, 是有状态的, 每个属性代表其当前状态, 他是物理数据的对象表示 使用它能够让我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。 PO的属性是跟数据库表的字段一一对应的。 PO对象需要实现序列化接口 首先说PO和VO吧，它们的关系应该是相互独立的，一个VO可以只是PO的部分，也可以是多个PO构成，同样也可以等同于一个PO（当然我是指他们的属性）。正因为这样，PO独立出来，数据持久层也就独立出来了，它不会受到任何业务的干涉。又正因为这样，业务逻辑层也独立开来，它不会受到数据持久层的影响，业务层关心的只是业务逻辑的处理，至于怎么存怎么读交给别人吧！不过，另外一点，如果我们没有使用数据持久层，或者说没有使用hibernate，那么PO和VO也可以是同一个东西，虽然这并不好。 TO (transfer Object) 数据传输对象 在应用程序不同tie(关系)之间传输的对象 BO (business object) 业务对象 从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。 它装满了业务逻辑的处理，在业务逻辑复杂的应用中有用。 POJO Wikipedia: POJO Plain Old Java Object (plain ordinary java object) 简单无规则java对象 纯的传统意义的java对象。就是说在一些Object/Relation Mapping工具中，能够做到维护数据库表记录的persisent object完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。我的理解就是最基本的Java Bean，只有属性字段及setter和getter方法！ DAO (data access object) 数据访问对象 通常和PO结合使用，DAO中包含了各种数据库的操作方法 关键字 Java关键字和保留字12345678abstract class extends implements null strictfp trueassert const false import package super tryboolean continue final instanceof private switch voidbreak default finally int protected synchronized volatilebyte do float interface public this whilecase double for long return throwcatch else goto native short throwschar enum if new static transient transient 序列化时不进行序列化","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"语法","slug":"语法","permalink":"http://blog.kuangcp.top/tags/语法/"}]},{"title":"ViewSolution.md","slug":"Memo-FrontEnd-ViewSolution","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-FrontEnd-ViewSolution/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-FrontEnd-ViewSolution/","excerpt":"","text":"目录 start 与前端有关的问题 资源文件 图片 使用图片还是BASE64 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 与前端有关的问题资源文件图片使用图片还是BASE64 知乎提问 前端开发中，使用base64图片的弊端是什么？","categories":[{"name":"知识整理","slug":"知识整理","permalink":"http://blog.kuangcp.top/categories/知识整理/"}],"tags":[]},{"title":"Manjaro","slug":"Memo-Linux-Arch-Manjaro","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Linux-Arch-Manjaro/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Linux-Arch-Manjaro/","excerpt":"","text":"目录 start Manjaro 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Manjaro Gitlab source code pacman 文档 https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) Manjaro 安装配置简要参考博客: Manjaro Deepin安装使用分享 由于是基于arch的, 滚动更新的特性, 所以需要在每次在安装软件前 pacman -Syu 更新整个系统 这次下载解压运行 VSCode 就是这样, 报错为 error while loading shared libraries: libgconf-2.so.4: cannot open shared object file: No such file or directory 尝试安装 libgconf libgconf2 … 其实真正的包是 gconf , 而这个也是尝试过的, 但是还是说找不到package, 更新了下系统,才找到了这个包 安装时候 默认用户名和密码是 manjaro","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"Arch","slug":"Arch","permalink":"http://blog.kuangcp.top/tags/Arch/"},{"name":"Manjaro","slug":"Manjaro","permalink":"http://blog.kuangcp.top/tags/Manjaro/"}]},{"title":"Arch","slug":"Memo-Linux-Arch-Arch","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Linux-Arch-Arch/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Linux-Arch-Arch/","excerpt":"","text":"目录 start Arch 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Arch 参考博客: 为什么 Archlinux 不适合服务器使用参考博客: Arch Linux的用户都有理想主义倾向吗？参考博客: ArchLinux你可能需要知道的操作与软件包推荐参考博客: 长期使用Arch，Gentoo等滚动更新的发行版是怎样的一种体验？ 什么Linux发行版软件最多？ Arch Linux 安装、配置、美化和优化","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"Arch","slug":"Arch","permalink":"http://blog.kuangcp.top/tags/Arch/"}]},{"title":"Alpine基础","slug":"Memo-Linux-Alpine-AlpineBase","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Linux-Alpine-AlpineBase/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Linux-Alpine-AlpineBase/","excerpt":"","text":"目录 start Alpine 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Alpine 精简的linux 适合用于Docker 基础镜像","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"Alpine","slug":"Alpine","permalink":"http://blog.kuangcp.top/tags/Alpine/"}]},{"title":"MavenAdvance.md","slug":"Memo-Java-Tool-MavenAdvance","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Tool-MavenAdvance/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-MavenAdvance/","excerpt":"","text":"目录 start Maven Advance Maven plugin 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Maven AdvanceMaven plugin official doc github: maven plugin 参考博客: custom plugin","categories":[],"tags":[]},{"title":"Lombok.md","slug":"Memo-Java-Tool-Lombok","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Tool-Lombok/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-Lombok/","excerpt":"","text":"目录 start Lombok 何为Lombok 为什么要用 为什么不要用 个人见解 配置 Maven 普通Java项目 Groovy和Java项目使用Lombok 使用 注解使用 POJO常用 日志相关 异常相关 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Lombok何为Lombok Lombok Project 官网 | Github : 为什么要用 简化JavaBean 更为直观 省去了Setter Getter toString hashCode 构造器等方法一定有人就会跳出来说 在IDE中几个快捷键的事情,何必这么复杂, 那他们一定是没有遇到修改的时候吧, 改个属性的名字,类型, 对应的方法你需要改吧, 但是使用lombok就不用担心了 为什么不要用 暂时还没有想到 个人见解 Lombok在IDE中安装插件是为了编译和构建中能够动态的添加Getter Setter 等方法, 而在Maven或者Gradle中添加是为了注解能够引用得到?? 配置Maven 官方文档 普通Java项目12345678910111213141516171819202122232425262728293031 &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.16.8.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;delombok&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt;&lt;/plugins&gt; 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt;&lt;/dependency&gt; 而static有还是有可能被new出多个实例的 Groovy和Java项目使用Lombok配置编译插件123456789101112131415161718192021222324252627282930313233&lt;!--lombok--&gt;&lt;plugin&gt;&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&lt;version&gt;3.7.0&lt;/version&gt;&lt;configuration&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;compilerId&gt;groovy-eclipse-compiler&lt;/compilerId&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;compilerArguments&gt; &lt;javaAgentClass&gt;lombok.launch.Agent&lt;/javaAgentClass&gt; &lt;/compilerArguments&gt;&lt;/configuration&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt; &lt;artifactId&gt;groovy-eclipse-compiler&lt;/artifactId&gt; &lt;version&gt;2.9.3-01&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt; &lt;artifactId&gt;groovy-eclipse-batch&lt;/artifactId&gt; &lt;version&gt;2.5.0-01&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;/plugin&gt; 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt;&lt;/dependency&gt; 使用 Lombok 注解在线帮助文档：http://projectlombok.org/features/index. 注解使用POJO常用 @Data ：注解在类上；提供类所有属性的 getter 和 setter 方法，此外还提供了equals、canEqual、hashCode、toString 方法 @Setter：注解在属性上；为属性提供 setter 方法 @Getter：注解在属性上；为属性提供 getter 方法 @NoArgsConstructor：注解在类上；为类提供一个无参的构造方法 @AllArgsConstructor：注解在类上；为类提供一个全参的构造方法 日志相关 @Log4j @Log4j2 @Slf4j 用上logback, 但是这个不是一个接口规范么 TODO 异常相关 @SneakyThrows","categories":[],"tags":[]},{"title":"Jetty.md","slug":"Memo-Java-Tool-Jetty","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Tool-Jetty/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-Jetty/","excerpt":"","text":"目录 start Jetty 配置 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Jetty参考博客: Jetty使用教程（一）——开始使用Jetty 配置自身log配置 相关resources/jetty-logging.properties 内容如下开启DEBUG123org.eclipse.jetty.util.log.class=org.eclipse.jetty.util.log.StrErrLogorg.eclipse.jetty.LEVEL=DEBUGjetty.logs=logs","categories":[],"tags":[]},{"title":"EE.md","slug":"Memo-Java-EE","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-EE/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-EE/","excerpt":"","text":"目录 start JavaEE 2.【几大框架简述】 9 【SpringMVC】 9.1 必要JAR包： 9.2 实现逻辑 9.3 controller的配置 9.3.1类型转换（也可以使用Hibernate的convert） SpringMVC的内置代理 Hibernate的covert包 Controller层的异常处理（一般处理自定义异常） 拦截器机制 视图解析 上传下载 JSON的解析 10.【SSH框架的整合】 11.【SSM框架的整合】 12.【Redis的使用】 12.1 【Java 使用 redis 配置】 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs JavaEE 2.【几大框架简述】 MVC设计模式： M hibernarte （相应操作的SQL语句由Hibernate框架生成） mybatis（SQL用户根据需要去写的） JPA 和Hibernate是相同的内核，由Hibernate派生而来 C struts1.x struts2.x springmvc spring 模块的整合 V: 视图层 再度理解 Dao service模式的概念 dao : 基础单笔业务的功能模块 service : 将单个的dao组合一起，得到复杂的业务逻辑 如果要实现AOP或者规范化，dao和service分别要有接口的存在（为了多态，代理，严谨） 9 【SpringMVC】 一般使用注解方式更方便书写9.1 必要JAR包： Spring的核心JAR包 spring-web-3.2.6.RELEASE.jar spring-webmvc-3.2.6.RELEASE.jar spring-webmvc-portlet-3.2.6.RELEASE.jar 9.2 实现逻辑 核心类是DispatchServlet 由它来接收各种请求 发出request请求，到controller解析器，得到Model和view等的名字 发送到controller执行，返回view名字 发送到视图解析器 执行视图返回到dispatchServlet 9.3 controller的配置 类： @Controller @RequestMapping(“/WebApplicationRootURL”) 方法 @RequestMapping(“/ActionURL”) @RequestMapping(“/action/{id}”) 方法要使用(@PathVariable(“id”) String id) @ResponseBody 返回对象，自动解析成JSON 9.3.1类型转换（也可以使用Hibernate的convert）12345678910&lt;mvc:annotation-driven conversion-service=\"conversionService\" /&gt;&lt;!--配置ConversionService --&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;ref bean=\"DateConverter\" /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; SpringMVC的内置代理Hibernate的covert包Controller层的异常处理（一般处理自定义异常）12345678910处理所有接收到的的异常@ControllerAdvicepublic class ExceptionHandle&#123;@EXceptionHandler(&#123;Exception.class&#125;)public ModelAndView dealException(Exception e)&#123; ModelAndView view = new ModelAndView(\"exception\"; Exception e = new Exception(\"错误信息\"); view.addObject(\"\",e.getMessage()); return view;&#125; 拦截器机制1234567891011121314implements HandleInterceptor 有三个方法preHandle 返回true就继续往后，false就被拦截PostHandle 在渲染视图之前，afterCompletion 渲染视图之后调用，释放资源配置文件，需要配置：？如果这个路径大于springmvc拦截的路径？ &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;bean class=\"\"&gt;&lt;/bean&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;/mvc:interceptor&gt; 视图解析1234ModelAndView view = ModelAndView(\"index\"); 使用这种写法是进入配置好的视图解析器，进行路径的拼接然后转发ModelAndView(\"redirect:/l/login.jsp\");就是使用重定向方式，注意路径要写全，因为不会拼接 上传下载jar包： common-upload common-io 配置文件 JSON的解析 第三方的JSON工具包： jsonlib jackson ： 三个包 annotion core databind gson 发送JSON 只要有返回值，方法前加上这个注解就会自动返回JSON格式的数据而不是对象 @responseBody @ReqeustMapping(“”) 接收JSON 参数前 也加上@equestBody 就可以把JSON数据转成对象 10.【SSH框架的整合】11.【SSM框架的整合】12.【Redis的使用】12.1 【Java 使用 redis 配置】 Java使用Redis","categories":[],"tags":[]},{"title":"LittleKnowledgePoint.md","slug":"Memo-Java-LittleKnowledgePoint","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-LittleKnowledgePoint/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-LittleKnowledgePoint/","excerpt":"","text":"目录 start 字符串处理 时间处理 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 字符串处理时间处理 SimpleDateFormat : YYYY-MM-dd HH:MM:SS","categories":[],"tags":[]},{"title":"MIS.md","slug":"Memo-Java-MIS","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-MIS/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-MIS/","excerpt":"","text":"目录 start 完整的MIS构建经验 MVC 持久化层 数据库设计 Domain对象设计 控制层 权限控制 Session和Token的对比 统一授权 视图层 分布式 CAP定理 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 完整的MIS构建经验 OAuth 2.0授权框架 MVC持久化层数据库设计 一种极端是将业务也放在了数据库里, 使用大量的存储过程和函数一种是将约束都放在了业务层, 数据库没有外键约束 Domain对象设计 首先名称不能使用Java或者数据库中的的关键字 class group table from 等等 班级就用ClassGroup吧 实体间的关系映射注意死循环 控制层 只是映射好URL, 调用对应的Service 权限控制Session和Token的对比 码农翻身:干掉状态：从session到token token优势是前后端分离做起来比较简单,session在于实现快,但是容易有CSRF问题,其实token也是会有的 如果登录和页面的跳转路由还是由后端控制的，那么Token的实现就有点没有那么必要了。（不过为了安全性能够防范CSRF） 统一授权 码农翻身:从密码到token，一个授权的故事 | 自己收集到的相关文档 视图层一种比较安全的iframe思路 在主页面上写form iframe页面用来展示,这样的话,截图截不了长图,也不能保存文件,也不能打印出来(试了好多种方式去修改教务系统得到的结论) 分布式CAP定理 码农翻身:张大胖和CAP定理","categories":[],"tags":[]},{"title":"RESTful.md","slug":"Memo-Java-RESTful","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-RESTful/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-RESTful/","excerpt":"","text":"目录 start RESTful风格 Rest 资源 Resources 表现层 Representation 状态转化 State Transfer 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs RESTful风格 要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。 Rest Representational State Transfer 表现层状态转化如果一个架构符合REST原则，就称它为RESTful架构。 参考自 使用 Python 和 Flask 设计 RESTful API 六条设计规范定义了一个 REST 系统的特点: 客户端-服务器: 客户端和服务器之间隔离，服务器提供服务，客户端进行消费。 无状态: 从客户端到服务器的每个请求都必须包含理解请求所必需的信息。换句话说， 服务器不会存储客户端上一次请求的信息用来给下一次使用。 可缓存: 服务器必须明示客户端请求能否缓存。 分层系统: 客户端和服务器之间的通信应该以一种标准的方式，就是中间层代替服务器做出响应的时候，客户端不需要做任何变动。 统一的接口: 服务器和客户端的通信方法必须是统一的。 按需编码: 服务器可以提供可执行代码或脚本，为客户端在它们的环境中执行。这个约束是唯一一个是可选的。 参考博客: 理解RESTful架构“QuestionSeconds”:1,“Question”:”请按顺序查找数字”, RESTful Best Practices理解本真的REST架构风格RESTful风格的springMVC 资源 ResourcesREST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。 表现层 Representation“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 状态转化 State Transfer访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 阮一峰 RESTful API 设计指南很细致的说明该规范 需要整理和计划如何规范化实现这个接口","categories":[],"tags":[]},{"title":"Jacoco.md","slug":"Memo-Java-Tool-Jacoco","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Tool-Jacoco/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-Jacoco/","excerpt":"","text":"目录 start Jacoco 安装 Maven插件方式 目录 end|2018-12-17 20:46| 码云 | CSDN | OSChina | cnblogs Jacoco 一款Java平台的代码覆盖率工具 安装Maven插件方式 添加插件 1234567891011121314151617181920212223242526272829303132333435&lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.8.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;prepare-agent&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;report&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;post-unit-test&lt;/id&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;!-- Sets the path to the file which contains the execution data. --&gt; &lt;dataFile&gt;target/jacoco.exec&lt;/dataFile&gt; &lt;!-- Sets the output directory for the code coverage report. --&gt; &lt;outputDirectory&gt;target/jacoco-ut&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;/configuration&gt; &lt;/plugin&gt; 执行: mvn test Jenkins集成 Official Doc","categories":[],"tags":[]},{"title":"Eclipse.md","slug":"Memo-Java-Tool-Eclipse","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Tool-Eclipse/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-Eclipse/","excerpt":"","text":"目录 start Eclipse Eclipse Che Install 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs EclipseEclipse Che Next Generation IDE Github|Official Site Quick Start Install Install By Docker docker pull eclipse/che docker run -ti -v /var/run/docker.sock:/var/run/docker.sock -v /home/kcp/App/eclipse/che:/data eclipse/che start","categories":[],"tags":[]},{"title":"Thymeleaf.md","slug":"Memo-Java-TemplateEngine-Thymeleaf","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-TemplateEngine-Thymeleaf/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-TemplateEngine-Thymeleaf/","excerpt":"","text":"目录 start Thymeleaf 流程控制 if 集合处理 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Thymeleaf 辣鸡 流程控制if lt 小于 eq 等于 gt 大于 le 小于等于 ge 大于等于 拼接参数：th:href=&quot;@{/student/ChooseTopic/{id} (id=${pageNum}-2)}&quot; 判断块&lt;th:block th:if=&quot;${pageNum lt pageTotal}&quot; &gt;&lt;/th:block&gt; 集合处理 判断list大小：1th:if=&quot;$&#123;#lists.size(topicList) == 0&#125;&quot;","categories":[],"tags":[]},{"title":"Transactional.md","slug":"Memo-Java-Spring-Transactional","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-Transactional/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-Transactional/","excerpt":"","text":"目录 start 事务 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 事务","categories":[],"tags":[]},{"title":"SpringWebFlux.md","slug":"Memo-Java-Spring-SpringWebFlux","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-SpringWebFlux/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringWebFlux/","excerpt":"","text":"目录 start WebFlux 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs WebFlux 参考博客: 译：尝试使用Spring WebFlux","categories":[],"tags":[]},{"title":"SpringTest.md","slug":"Memo-Java-Spring-SpringTest","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-SpringTest/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringTest/","excerpt":"","text":"目录 start Spring Test 注解 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Spring Test 参考博客: Getting Started with Mockito @Mock, @Spy, @Captor and @InjectMocks参考博客: Mockito – Using Spies 注解 学习 @MockBean","categories":[],"tags":[]},{"title":"SpringMessageQue.md","slug":"Memo-Java-Spring-SpringMessageQue","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-SpringMessageQue/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringMessageQue/","excerpt":"","text":"目录 start 消息队列 简单的Websocket方式 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 消息队列简单的Websocket方式 Springboot中使用Websocket进行消息推送 SpringBoot 使用WebSocket SpringBoot系列 - 集成WebSocket实时通信","categories":[],"tags":[]},{"title":"SpringCloud.md","slug":"Memo-Java-Spring-SpringCloud","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-SpringCloud/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringCloud/","excerpt":"","text":"目录 start SpringCloud 集成docker 微服务 通信方式 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs SpringCloud 参考博客: Spring Cloud 入门系列 集成docker boot in Alpine LinuxSpringBoot+Docker 基于此镜像构建小于Ubuntufrolvlad/alpine-oraclejdk8:slim maven 和 gradle两种集成 微服务 《Spring Cloud实战》一书的配套示例代码《Spring Cloud与Docker微服务架构实战》1-11章配套代码使用SpringBoot开启微服务之旅 通信方式 知乎:既然有http 请求，为什么还要用rpc调用？","categories":[],"tags":[]},{"title":"SpringBoot2.md","slug":"Memo-Java-Spring-SpringBoot2","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-SpringBoot2/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringBoot2/","excerpt":"","text":"目录 start SringBoot2 从1迁移到2 新特性 Web模块 Web容器 Tomcat Jetty 跨域 SpringBoot上下文事件监听 数据库模块 Relation Database 多数据源 No Relation Database 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs SringBoot2官方文档 springboot gradle 从1迁移到2 变化比较大 官方说明对比1所更改的文档 spring boot 2.0 半月的实战_阶段性总结1SpringBoot2.0 jpa多数据源配置 Springboot2.0 升级（Gradle工程) 使用精简版jdk9在docker上运行springboot2 Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南 新特性 Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解 参考博客: Spring Boot 2.0 新特性和发展方向 Web模块Web容器Tomcat org.springframework.boot:spring-boot-starter-web 依赖中默认包含了Tomcat Jetty Spring Boot – Configure Jetty Server 跨域 SpringBoot2的跨域配置最终是采用的Nginx进行反向代理，将后台服务放在前台服务子路径下 SpringBoot上下文事件监听 直接看 源码中 ApplicationContextEvent 类的 继承结构, 就能发现 有四个子类 ContextCloseEvent ContextRefreshEvent ContextStopEvent ContextStartEvent 在任意的Component中添加如下类似的方法就能监听到如上事件 1234@EventListenerpublic void handleContextClosedEvent(ContextClosedEvent event) &#123; // todo &#125; 12345678910111213141516171819 @Configurationpublic class Listener implements ApplicationListener &#123; @Override public void onApplicationEvent(ApplicationEvent event) &#123; // 在这里可以监听到Spring Boot的生命周期 if (event instanceof ContextRefreshedEvent) &#123; System.out.println(\"应用刷新\"); &#125; if (event instanceof ContextStartedEvent) &#123; System.out.println(\"应用启动\"); &#125; else if (event instanceof ContextStoppedEvent) &#123; System.out.println(\"应用停止\"); &#125; else if (event instanceof ContextClosedEvent) &#123; System.out.println(\"应用关闭\"); &#125; &#125;&#125; 但是只有应用刷新, 应用启动完成, 应用关闭是能够正常监听到的 数据库模块Relation Database多数据源 参考博客: Spring Boot 2.0 多数据源编程 原 | 源码 No Relation Database","categories":[],"tags":[]},{"title":"Spring5.md","slug":"Memo-Java-Spring-Spring5","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Spring-Spring5/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-Spring5/","excerpt":"","text":"目录 start Spring5 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Spring5 Spring Framework 5 中的新特性","categories":[],"tags":[]},{"title":"Vertx.md","slug":"Memo-Java-Ecosystem-Vertx","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-Vertx/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-Vertx/","excerpt":"","text":"目录 start Vert.x 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Vert.x 参考博客: 用惯了高大上SpringBoot不妨试试小清新Vert.x参考博客: 基于Vert.x和SpringBoot实现响应式开发参考博客: Vert.x开发指南使用Vertx构建微服务","categories":[],"tags":[]},{"title":"Solr.md","slug":"Memo-Java-Ecosystem-Solr","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-Solr/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-Solr/","excerpt":"","text":"目录 start Solr 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Solr 参考博客: 用容器快速上手Apache Solr","categories":[],"tags":[]},{"title":"POI.md","slug":"Memo-Java-Ecosystem-POI","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-POI/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-POI/","excerpt":"","text":"目录 start POI Excel Word 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs POI Java操作ExcelWord等软件 ExcelWord 参考博客: POI 操作word","categories":[],"tags":[]},{"title":"Netty.md","slug":"Memo-Java-Ecosystem-Netty","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-Netty/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-Netty/","excerpt":"","text":"目录 start Netty 原理 编解码相关 Protobuf 使用 源码 配置环境 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Netty trustlinNetty mina 的作者 Netty4.x官方文档Netty权威指南 为什么选择Netty作为基础通信组件？ Reactive Extension (Rx) Adaptor for Netty 《Netty 实战》 Netty In Action 中文版 原理 Netty核心组件Netty 编解码技术 数据通信和心跳监控案例Netty 拆包粘包和服务启动流程分析Netty序章之BIO NIO AIO演变 Netty构建游戏服务器(一) 有原理图Netty高性能开发备忘录 编解码相关 更多 Protobuf Protobuf基础 |Netty中的使用案例 要搭配处理半包的解码器 使用 ProtobufVarint32FrameDecoder 继承自 LengthFieldBasedFrameDecoder 继承自 ByteToMessageDecoder 自己处理 使用 部分内容参考自 Netty权威指南第二版 手淘、微博一直钟情的 Netty框架是个什么鬼？对于Netty的十一个疑问 NettyServer与SpringBoot集成Netty NIO 框架性能压测-短链接-对比Tomcat 源码 官方DemoNetty实战配套源码Netty权威指南2 源码 配置环境","categories":[],"tags":[]},{"title":"Kafaka.md","slug":"Memo-Java-Ecosystem-Kafaka","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-Kafaka/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-Kafaka/","excerpt":"","text":"目录 start Kafaka 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Kafaka Apache顶级项目 参考博客: 初探Kafka Streams ksql","categories":[],"tags":[]},{"title":"JavaRedis.md","slug":"Memo-Java-Ecosystem-JavaRedis","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-JavaRedis/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-JavaRedis/","excerpt":"","text":"目录 start Java使用redis Jedis jedis遇到的异常 SpringBoot使用Redis Lettuce 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Java使用redisJedis Github:简单直接, 但是项目很久没有更新了 maven依赖(Spring 4.1.7)：1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.6.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt;&lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt; Spring配置文件12345678910111213141516171819202122232425&lt;!-- 加载redis配置文件 如果已经加载了一个文件，那么第一个就要写这个配置项， &lt;property name=\"ignoreUnresolvablePlaceholders\" value=\"true\"/&gt; 第二个要加 后面的配置 不然就只会加载前面那个文件--&gt;&lt;context:property-placeholder location=\"classpath:redis.properties\" ignore-unresolvable=\"true\"/&gt;&lt;!-- redis连接池的配置 --&gt;&lt;bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"maxActive\" value=\"$&#123;redis.pool.maxActive&#125;\"/&gt; &lt;property name=\"maxIdle\" value=\"$&#123;redis.pool.maxIdle&#125;\"/&gt; &lt;property name=\"minIdle\" value=\"$&#123;redis.pool.minIdle&#125;\"/&gt; &lt;property name=\"maxWait\" value=\"$&#123;redis.pool.maxWait&#125;\"/&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;redis.pool.testOnBorrow&#125;\"/&gt; &lt;property name=\"testOnReturn\" value=\"$&#123;redis.pool.testOnReturn&#125;\"/&gt;&lt;/bean&gt;&lt;!-- redis的连接池pool，不是必选项：timeout/password --&gt;&lt;bean id = \"jedisPool\" class=\"redis.clients.jedis.JedisPool\"&gt; &lt;constructor-arg index=\"0\" ref=\"jedisPoolConfig\"/&gt; &lt;constructor-arg index=\"1\" value=\"$&#123;redis.host&#125;\"/&gt; &lt;constructor-arg index=\"2\" value=\"$&#123;redis.port&#125;\" type=\"int\"/&gt; &lt;constructor-arg index=\"3\" value=\"$&#123;redis.timeout&#125;\" type=\"int\"/&gt; &lt;constructor-arg index=\"4\" value=\"$&#123;redis.password&#125;\"/&gt;&lt;/bean&gt; java实际测试类JedisUtilsTest.java jedis 使用后要disconnect释放连接,最新版本close就不用了，使用连接池就不用 jedis 的事务 使用exec释放事务 jedis遇到的异常 Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter 版本对不上，要Spring和Spring-data-redis 和 redis和commons-lang3对应 目前是4.1.7 + 1.6.0 + 2.9.0 + 3.3.2 编译通过了 SpringBoot使用Redis SpringBoot配置Redis Lettuce Official | Github: 和 Spring Netty 结合紧密， 适合 Spring 系， 没有Jedis简洁","categories":[],"tags":[]},{"title":"JXls.md","slug":"Memo-Java-Ecosystem-JXls","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-JXls/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-JXls/","excerpt":"","text":"目录 start Jxls 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Jxls 官方文档","categories":[],"tags":[]},{"title":"JPA.md","slug":"Memo-Java-Ecosystem-JPA","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-JPA/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-JPA/","excerpt":"","text":"目录 start JPA JPA和Mybatis 配置 使用 注解 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs JPAJPA和Mybatis 技术专题讨论第二期总结：如何对 JPA 或者 MyBatis 进行技术选型 配置使用 参考博客: spring boot(五)：spring data jpa的使用 注解 Java、Hibernate(JPA)注解大全jpa注解大全Spring Data JPA 入门系列","categories":[],"tags":[]},{"title":"Guava.md","slug":"Memo-Java-Ecosystem-Guava","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-Guava/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-Guava/","excerpt":"","text":"目录 start Guava 基础部分 EventBus 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Guava Github地址官方手册 | git地址:https://github.com/google/guava.wiki.git翻译版 Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中。 包结构1234567com.google.common.annotationscom.google.common.basecom.google.common.collectcom.google.common.iocom.google.common.netcom.google.common.primitivescom.google.common.util.concurrent 123456789101112131415161718192021222324252627282930[Google Guava] 7-原生类型[Google Guava] 12-数学运算[Google Guava] 排序: Guava强大的”流畅风格比较器”[Google Guava] 2.1-不可变集合[Google Guava] 10-散列[Google Guava] 9-I/O[Google Guava] 1.2-前置条件[Google Guava] 4-函数式编程[Google Guava] 6-字符串处理：分割，连接，填充[Google Guava] 1.1-使用和避免null[Google Guava] 8-区间[Google Guava] 2.4-集合扩展工具类[Google Guava] 1.3-常见Object方法 @Beanpublic RedisTemplate&lt;Object,Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;Object,Object&gt; template = new RedisTemplate&lt;&gt;(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); template.setConnectionFactory(factory); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 值序列化采用 jackson2JsonRedisSerializer template.setValueSerializer(jackson2JsonRedisSerializer); // 键序列化采用 StringRedisSerializer template.setKeySerializer(new StringRedisSerializer()); template.afterPropertiesSet(); return template;&#125;google Guava包的ListenableFuture解析[Google Guava] 11-事件总线 基础部分 Optional的设计和Java8的Optional是差不多的, 只是方法的命名不一样而已 EventBus 官方文档 | Guava学习笔记：EventBus并发编程网 event bus | 走进Guava","categories":[],"tags":[]},{"title":"Elasticsearch.md","slug":"Memo-Java-Ecosystem-Elasticsearch","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-Elasticsearch/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-Elasticsearch/","excerpt":"","text":"目录 start Elasticsearch 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Elasticsearch 参考博客: 用容器快速上手Elasticsearch","categories":[],"tags":[]},{"title":"Blade.md","slug":"Memo-Java-Ecosystem-Blade","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-Blade/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-Blade/","excerpt":"","text":"目录 start Blade 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Blade Blade项目首页 | Github 地址 | 官方 demos 参考博客: Blade：一款简洁优雅、微内核设计的Java Web框架","categories":[],"tags":[]},{"title":"Activiti.md","slug":"Memo-Java-Ecosystem-Activiti","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-Activiti/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-Activiti/","excerpt":"","text":"目录 start Activiti 相关书籍 相关仓库 基础概念 什么是流程 流程引擎 BPMN流程图 数据库的设计 1.资源库流程规则表 2.运行时数据库表 3.历史数据库表 4.组织机构表 5.通用数据表 核心配置文件 大致原理讲解 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Activiti 参考笔记 相关书籍 Activiti实战 activiti示例作者:书籍的源码activiti实战源码 这本书的每个章节的实战源码 Activiti权威指南 相关仓库 springboot-activiti 整合activiti的Springboot示例 spring-boot-activiti跑起来的小案例 基础概念 什么是流程 流程引擎 BPMN流程图案例视频 最简单示例图 bpmn是最原始的单纯的流程定义文件，与Springboot整合就是bpmn20.xml文件(区别在于动态注入) bpmn文件2.0结点是definitions节点，这个元素中可以定义多个流程定义（建议每个文件只包含一个流程定义,可简化维护难度).definitions元素最少也要包含xmlns和targetNamespace的声明，targetNamespace可以是任意值，它用来对流程实例进行分类最简单的示例 FirstDemo.bpmn20.xml 数据库的设计 所有表都以ACT开头 1.资源库流程规则表 ACT_RE开头 2.运行时数据库表 ACT_RU开头 3.历史数据库表 ACT_HI开头 4.组织机构表 ACT_ID开头 5.通用数据表 ACT_GE开头 核心配置文件 activiti.cfg.xml 含数据库配置,默认的JDBC是默认Mybatis连接池 大致原理讲解[ 来源](https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/activiti/simple.png)","categories":[],"tags":[]},{"title":"Java泛型","slug":"Memo-Java-AdvancedLearning-Generics","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-Generics/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Generics/","excerpt":"","text":"目录 start 泛型 入门 简单使用 类型擦除 约束和局限性 泛型类型的继承规则 通配符类型 子类型限定的通配符 extends 超类型限定的通配符 super 应用 无限定通配符 通配符捕获 反射和泛型 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 泛型 开始学习的兴趣来源 参考博客: Java总结篇系列：Java泛型泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。参考博客: Java深度历险（五）——Java泛型 入门 泛型程序设计划分为三个熟练级别 基本级别就是仅仅使用泛型类,典型的是像ArrayList这样的集合–不必考虑他们的工作方式和原因,大多数人会停留在这个级别.直到出现了什么问题. 当把不同的泛型类混合在一起的时候,或是对类型参数一无所知的遗留代码进行对接时,可能会看到含糊不清的错误消息.如果这样的话,就需要系统的进行学习Java泛型来系统地解决问题.泛型类可以看作普通类的工厂 – Java核心技术卷 2004(1.5) 简单使用 简单泛型类示例 例如该行定义 : public abstract class RoomCache&lt;P extends PlayerBO, M extends MemberBO, V extends VideoDataBO&lt;M&gt;, R extends RoomBO&lt;M, V&gt;&gt; extends AbstractCache&lt;PlatformRoomId, R&gt; {} 类型变量使用大写的一个字母这是代表: E 集合的元素类型 K V 表示表的关键字和值的类型 T U S 等就表示任意类型 类型擦除 不同于C++的泛型,C++是将模板类组合出来的生成一个新的类,Java则是进行类型擦除,然后再类型强转 例如 public static &lt;T extends Comparable&gt; T min (T[] list) 擦除后就只剩下一个方法 public static Comparable min(Comparable[] list) 泛型类擦除示例 例如该方法签名 public static &lt;T extends Comparable &amp; Serializable&gt; T getMax(T[]list) 限制了必须是实现了两个接口的类才能使用, 估计为了少创关键字所以使用的是extends关键字来表示T要实现两个接口 同样的可以加在类的签名上,进行限制类的泛型类型 public class Pair &lt;T extends Comparable&gt;{} 在Java的继承中,可以根据需要拥有多个接口超类型,但限定中至多只有一个类,如果用一个类作为限定,他必须是限定列表中的第一个 约束和局限性 以下代码示例:涉及的类Pair在上述的代码中已经定义, Human和Student是继承关系并且因为看的 Java核心技术卷 比较老 jdk是1.5的所以没有用7的菱形语法简化泛型 7可以省去右边的类型: Pair&lt;Double&gt; pair = new Pair&lt;&gt;(); | 不能使用基本类型实例化类型参数 也就是说没有Pair&lt;double&gt;只有Pair&lt;Double&gt; 因为类型擦除后,类型是Object并不能放double的值, 但是这样做与Java语言中基本类型的独立状态相一致. 当包装器类型(wrapper type)不能接受替换时,可以使用独立的类和方法处理他们 | 运行时类型查询(eq或者instanceof)只适用于原始类型 比如Pair&lt;T&gt; 和Pair&lt;String&gt;是等价的,因为类型擦除 Pair&lt;String&gt; pair1 Pair&lt;Date&gt; pair2 pair1.getClass()和pair2.getClass()是等价的都是返回Pair.class | 不能抛出也不能捕获泛型类实例 错误的示例: public class Problem&lt;T&gt; extends Exception{} public static &lt;T extends Throwable&gt; void doWork(){try{}catch(T t){}} 正确示例: 在异常声明中使用类型变量 public static &lt;T extends Throwable&gt; void doWork() throws T{.. catch(){throw t;}} | 参数化类型的数组不合法 例:Pair&lt;String&gt;[] list = new Pair&lt;String&gt;[10]; 因为擦除后 list是Pair[]类型,然后就能转成Object[], 就失去了泛型的作用 如果要使用的话最好直接使用集合 ArrayList:ArrayList&lt;Pair&lt;String&gt;&gt;,安全又高效123Object[] array = list;array[0] = \"hi\";// 编译错误array[0] = new Pair&lt;Date&gt;(); //通过数组存储的检测,但实际上类型错误了,所以禁止使用参数化类型的数组 | 不能实例化类型变量(T) 非法 new T(){}1234567891011121314151617public Pair()&#123; first = new T(); second = new T();&#125;first = T.class.newInstance() //非法 T.class是不合法的//要实例化一个Pair&lt;T&gt;的对象就要如下:public static &lt;T&gt; Pair&lt;T&gt; initPair(Class&lt;T&gt; c)&#123; try&#123; return new Pair&lt;T&gt;(c.newInstance(), c.newInstance()); &#125;catch (Exception e)&#123; return null; &#125;&#125;// 如下调用Pair&lt;String&gt; pair = Pair.initPair(String.class);// 因为Class本身是泛型, String.class其实是Class&lt;String&gt;的实例// 也不能实例化为一个数组 new T[5] | 泛型类的静态上下文中类型变量无效 不能在静态域中使用类型变量 如下: 如果这段代码能执行,那就可以声明一个 Singleton 共享随机数生成类, 但是声明之后,类型擦除,就只剩下了Singleton类,并不能做对应的事情,所以禁止这样的写法1234private static T first; // 错误public static T getFirst()&#123; // 错误 return first;&#125; | 注意泛型擦除后的冲突 当类型擦除时,不能创建引发冲突的相关条件 例如 新实现一个类型变量约束的equals方法就会和Object原方法冲突 补救方法就是重命名该方法了 12345public class Pair&lt;T&gt;&#123; public boolean equals (T value)&#123; return .. &#125;&#125; 泛型规范说明 要想支持擦除的转换,就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类,而这两个接口是同一接口的不同参数化 以下代码就是非法的, GregorianCalendar 实现了两个接口,两个接口是Comparable接口的不同参数化,这是不允许的12class Calendar implements Comparable&lt;Calendar&gt;&#123;&#125;class GregorianCalendar extends Calendar implements Comparable&lt;GregorianCalendar&gt;&#123;&#125; // 错误 但是如下又是合法的 12class Calendar implements Comparable&#123;&#125;class GregorianCalendar extends Calendar implements Comparable&#123;&#125; 很有可能是桥方法有关,不可能有两个一样的桥方法(因为两个接口其实是一个接口的不同参数化,桥方法的方法签名是一致的) 泛型类型的继承规则 例如 父子类: Human Student 那么 Pair Pair 是继承(inherit)关系么,答案是否定的!! 12345678910Pair&lt;Human&gt; humans = new Pair&lt;Human&gt;(man, woman);Pair&lt;Student&gt; classmates = humans;// illegal, but suppose it wasn'tclassmates.setSecond(junior) // 如果上面合法,那么这里是肯定可以执行的, 因为泛型类型变成了Student//那么就有了问题了,原有的人类类型限制的对象中,出现了小学生//所以不允许这样的类型变量约束的类进行多态// 但是数组可以这样写是因为数组会有自己的检查保护Human[] humans = &#123;man, woman&#125;;Student[] students = humans;students[0] = junior ;// 虚拟机将抛出 ArrayStoreException 异常 永远可以将参数化类型转换为一个原始类型, Pair 是原始类型Pair的一个子类型,转换成原始类型也会产生错误相关测试类12345Pair&lt;Human&gt; humans = new Pair&lt;Human&gt;(man, woman);Pair other = humans;other.setFirst(new String(\"wtf\"))// 只是会有一个编译时的警告(类型未检查),但实际上都看得出这明显是错误的// 那么在后续代码中继续当做Human对象进行引用,必然就会有ClassCastException// 所以这样的写法尽量避免,这里的设计 就失去了泛型程序设计提供的附加安全性.(挖的坑) 泛型类可以扩展或实现其他的泛型类,就这一点而言,和普通类没有什么区别 例如 ArrayList 实现List接口, 这意味着一个ArrayList可以转换为List 但是一个ArrayList不是ArrayList或者List. 通配符类型子类型限定的通配符 extends 通配符上限 顾名思义,就是限定为该类及其子类, 例如: Pair&lt;? extends Human&gt; 表示任何Pair泛型类型并且他的类型变量要为Human的子类 例如编写一个方法 public static void printMessage(Pair&lt;Human&gt; human){}正如上面所说, Pair类型的变量是不能放入这个方法的,因为泛型变量是没有继承关系, 这时候就可以使用这个通配符: public static void printMessage(Pair&lt;? extends Human&gt;) 可以get不能set123456789Pair&lt;Human&gt; humans = new Pair&lt;Human&gt;(man, woman);Pair&lt;? extends Human&gt; classmates = humans;// 编译通过classmates.setSecond(junior) // 编译错误,泛型约束起作用了// 分析其泛型类实现可以理解为:? extends Human getFirst()void setFirst(? extends Human)// 这样的话是不可能调用setFirst方法, 对于编译器来说,只是知道入参是Human的子类,但是类型并不明确,所以不能正常调用// 使用get方法就不会有问题, 泛型起作用了.将get返回值赋值给Human的引用也是完全合法的,这就是引入该统通配符的关键之处 超类型限定的通配符 super 通配符下限 顾名思义就是限定为父类, 通配符限定和类型变量限定十分相似, 但是可以指定一个超类型限定(supertype bound)? super Student 这个通配符就限定为Student的所有超类型(super关键字已经十分准确的描述了这种关系) 带有超类型限定的通配符的行为和前者相反,可以为方法提供参数,但不能使用返回值即 可以 set 但是不能get 12345// Pair&lt;? super Student&gt; 例如这种定义void setFirst(? super Student)? super Student getFirst()// 编译器不知道setFirst方法的确切类型,但是可以用任意Student对象(或子类型) 调用他, 而不能使用Human对象调用.// 然而,如果调用getFirst,泛型没有起作用,只能将返回值用Object接收 以上两种情况的相关测试类 总结: 类定义上的泛型变量: 子类型限定: &lt;? extends Human&gt; 是限定了不能set,但是保证了get超类型限定: &lt;? super Student&gt; 限定了不能正确get,但是保证了set. 应用 参考博客: 使用通配符简化泛型使用 示例1:public static &lt;T extends Comparable&lt;T&gt;&gt; T min(T[] list); 限定了入参和返回值是 是实现了Comparable接口的某个类型 因为Comparable也是一个泛型类, 所以也进行限定类型 这样的写法要比 T extends Comparable 更为彻底 例如计算一个String数组的最小值 T 就是 String类型的, String是Comparable的子类型 但是当处理GregorianCalendar, GregorianCalendar是Calendar的子类, 并且Calendar实现了Comparable&lt;Calendar&gt; 因此GregorianCalendar实现的是Comparable&lt;Calendar&gt;, 而不是Comparable 这种情况下 public static &lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] list) 就是安全的 示例2: public static &lt;T extends ExcelTransform&gt; List&lt;T&gt; importExcel(Class&lt;T&gt; target) 该方法实现了, 传入继承了ExcelTransform接口的类对象, 得到该类的List集合 &lt;T extends ExcelTransform&gt; boolean 这样写编译没报错, 那么就是说, 就是一个泛型的定义, 后面进行引用, 省的重复写 简单的写法就是 public static &lt;T&gt; List&lt;T&gt; importExcel(Class&lt;T&gt; target) 示例3: Spring4.x 添加的泛型依赖注入 , 使用的JPA就是依赖该技术 spring学习笔记（14）——泛型依赖注入 对于应用程序员, 可能很快的学会掩盖这些声明, 想当然地认为库程序员做的都是正确的, 如果是一名库程序员, 一定要习惯于通配符否则还要用户在代码中随意地添加强制类型转换直至可以通过编译. 无限定通配符 TODO 对其使用场景 尚有疑问,以后再解 1234// 例如 Pair&lt;?&gt;? getFirst() // 方法的返回值只能赋值给一个Objectvoid setFirst(?) // 方法不能被调用,甚至不能用Object调用.// Pair&lt;?&gt; 和 Pair 本质的不同在于: 可以用任意Object对象调用原始的Pair类的setObject(set方法,因为类型擦除 入参是Object, 简称setObject)方法 例如 这个hasNull()方法用来测试一个pair是否包含了指定的对象, 他不需要实际的类型. 通配符捕获 TODO 学习和理解使用场景 如果编写一个交换的方法 12345public static void swap (Pair&lt;?&gt; p)&#123; ? temp = p.getFirst(); // 错误, 不允许将?作为类型 p.setFirst(p.getSecond()); p.setSecond(temp);&#125; 但是可以编写一个辅助方法 12345public static &lt;T&gt; void swapHelper(Pair&lt;T&gt; p)&#123; T temp = p.getFirst(); p.setFirst(p.getSecond()); p.setSecond(temp);&#125; swapHelper是一个泛型方法, 而swap不是, 它具有固定的Pair&lt;?&gt;类型的参数, 那么现在就可以这样写: public static void swap(Pair&lt;?&gt; p){swapHelper(p);} 这种情况下, swapHelper方法的参数T捕获通配符, 它不知道是哪种类型的通配符,但是这是一个明确的类型 并且swapHelper 在T指出类型时,才有明确的含义 当然,这种情况下并不是一定要用通配符, 而且我们也实现了没有通配符的泛型方法 但是下面这个通配符类型出现在计算结果中间的示例 123456public static void maxMinBonus(Student[] students, Pair&lt;? super Student&gt; result)&#123; minMaxBonus(students, result); swapHelper(result);&#125;// 在这里,通配符捕获机制是不可避免的, 但是这种捕获只有在许多限制情况下才是合法的.// 对于编译器而言, 必须能够确信通配符表达的是单个, 确定的类型. 反射和泛型 官方Java7的Class文档 | 现在Class类是泛型的, 例如String.class实际上是Class类的对象(事实上是唯一的对象)类型参数十分有用, 这是因为他允许Class方法的返回类型更加具有针对性.下面Class的方法就使用了类型参数123456T newInstance()T cast(Object obj)T[] getEnumConstants()Class&lt;? super T&gt; getSuperclass()Constructor&lt;T&gt; getConstructor(Class... paramterTypes)Constructor&lt;T&gt; getDeclaredConstructor(Class... paramterTypes) newInstance方法返回一个示例, 这个实例所属的类由默认的构造器获得, 它的返回类型目前被声明为T, 其类型与Class描述的类相同, 这样就免除了类型转换. 如果给定的类型确实是T的一个子类型, cast方法就会返回一个现在声明为类型T的对象, 否则, 抛出一个BadCastException异常 如果这个类不是enum类或类型T的枚举值的数组, getEnumConstants方法将返回Null. 最后, getConstructor与getDeclaredConstructor方法返回一个Constructor对象.Constructor类也已经变成泛型, 以便 newInstance方法有一个正确的返回类型. TODO 还要继续看书 1234// 传入一个Class对象, 得到Class对应类型的实例public &lt;T&gt; T get(Class&lt;T&gt; target, String name);// 加上约束public &lt;T extends Runable&gt; T get(Class&lt;T&gt; target, String name);","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"http://blog.kuangcp.top/tags/泛型/"}]},{"title":"HTML5.md","slug":"Memo-FrontEnd-HTML5","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-FrontEnd-HTML5/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-FrontEnd-HTML5/","excerpt":"","text":"目录 start HTML5 参考资料 特俗字符 基础结构标签 head meta title base link style script 常用结构 form label 关于引用 插入和删除 数据存储 cookie LocalStorage和SessionStorage 清除 XML XML文件头含义 XML的元素 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs HTML5参考资料 HTML5 教程 | 菜鸟教程HTML5 教程 | W3School 特俗字符1234567空格:&amp;nbsp;代表一个半角空格&lt; :&amp;lt;&gt; :&amp;gt;&amp; ：&amp;amp;￥ :&amp;yen;× :&amp;times÷ ：&amp;divide; 基础结构标签head12&lt;head&gt; 元素是所有头部元素的容器。&lt;head&gt; 内的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息，等等。以下标签都可以添加到 head 部分：&lt;title&gt;、&lt;base&gt;、&lt;link&gt;、&lt;meta&gt;、&lt;script&gt; 以及 &lt;style&gt;。 meta123456789101112元数据（metadata）是关于数据的信息。&lt;meta&gt; 标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。&lt;meta&gt; 标签始终位于 head 元素中。元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。针对搜索引擎的关键词一些搜索引擎会利用 meta 元素的 name 和 content 属性来索引您的页面。下面的 meta 元素定义页面的描述：&lt;meta name=\"description\" content=\"Free Web tutorials on HTML, CSS, XML\" /&gt;下面的 meta 元素定义页面的关键词：&lt;meta name=\"keywords\" content=\"HTML, CSS, XML\" /&gt;name 和 content 属性的作用是描述页面的内容。 title123456&lt;title&gt; 标签定义文档的标题。title 元素在所有 HTML/XHTML 文档中都是必需的。title 元素能够： 定义浏览器工具栏中的标题 提供页面被添加到收藏夹时显示的标题 显示在搜索引擎结果中的页面标题 base1&lt;base&gt; 标签为页面上的所有链接规定默认地址或默认目标（target）： link12&lt;link&gt; 标签定义文档与外部资源之间的关系。&lt;link&gt; 标签最常用于连接样式表： style &lt;style&gt; 标签用于为 HTML 文档定义样式信息。您可以在 style 元素内规定 HTML 元素在浏览器中呈现的样式：123456&lt;head&gt; &lt;style type=\"text/css\"&gt; body &#123;background-color:yellow&#125; p &#123;color:blue&#125; &lt;/style&gt;&lt;/head&gt; script&lt;script&gt; 标签用于定义客户端脚本，比如 JavaScript。 以上的link script style 等引用外部资源的标签要注意路径问题 / 开头则是相对于项目的根路径来定位的 开头为空,就是相对于该页面的的相对路径.被URL尾部多输入一个/坑过,所以最好采用第一种稳妥 ..开头就是相对于该页面的相对父路径 常用结构form123456789&lt;form action=\"save.php\" method=\"post\" &gt; &lt;label&gt;爱好:&lt;/label&gt; &lt;select&gt; &lt;option value=\"看书\"&gt;看书&lt;/option&gt; &lt;option value=\"旅游\"&gt;旅游&lt;/option&gt; &lt;option value=\"运动\"&gt;运动&lt;/option&gt; &lt;option value=\"购物\"&gt;购物&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; labellabel标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。注意：标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。 关于引用12&lt;blockquote&gt;这是长的引用。&lt;/blockquote&gt;&lt;q&gt;这是短的引用。&lt;/q&gt; 使用 blockquote 元素的话，浏览器会插入换行和外边距，而 q 元素不会有任何特殊的呈现。 插入和删除1&lt;p&gt;一打有 &lt;del&gt;二十&lt;/del&gt; &lt;ins&gt;十二&lt;/ins&gt; 件。&lt;/p&gt; 数据存储cookieLocalStorage和SessionStorage 基础详细的一篇博客 清除 HTML5中的localStorage什么时候会被清空?翻译：清除各个浏览器中的数据研究 自己在火狐中尝试了下,清除 网络内容缓存 对localStorage没有影响 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573581.为了确保浏览器能够正确读取字符的编码，整个字符编码必须放置在文档的前512个字符中2.HTML中不需要声明JavaScript的type属性刷新iframe 的父页面 iframe页面是内嵌到父页面的，当点击iframe页面的服务器控件时，默认只刷新iframe页面，父页面是不会刷新的。若想刷新父页面，可以使用js来实现，如 1. parent.location.reload(); 这种方法会重新加载整个页面。但如果要在原页面的基础上传递参数，则可以使用下面的方法： 2.top.document.location.href='xxx.aspx?id=xx'。 但这两种方法都有一个共同的缺点，就是iframe内嵌页面的状态不会保存了，刷新后会重新回到第一次加载的状态。=========================1、输入框点击清空==============&lt;input name=\"textfield\" type=\"text\" id=\"textfield\" value=\"请输入内容\" onclick=\"this.value=''\" /&gt;2、输入框点击显示提示内容操作：鼠标点击输入框出现提示内容，再次点击清空内容可以进行输入。&lt;input type=\"text\" name=\"textfield2\" id=\"textfield2\" onblur=\"note_click(this);\" onclick=\"note_click(this)\" /&gt; &lt;script type=\"text/javascript\"&gt; function note_click(target) &#123; if(target.value=='') &#123; target.style.color=\"#B0B0B0\"; target.value=\"请输入数字\"; &#125; else if(target.value==\"请输入数字\") &#123; target.style.color=\"#000000\"; target.value=\"\"; &#125; &#125; &lt;/script&gt; ====================================【HTML标签笔记】========================================== &lt;i&gt;&lt;/i&gt;：斜体&lt;u&gt;&lt;/u&gt;：下划线&lt;b&gt;&lt;/b&gt;:粗体&lt;strong&gt;&lt;/strong&gt;:更粗&lt;s&gt;&lt;/s&gt;:删除线&lt;sup&gt;&lt;/sup&gt;上标&lt;sub&gt;&lt;/sub&gt;下标face:字体设置&lt;p align=\"right\"&gt;&lt;/p&gt; //align：设置水平对齐方式&lt;hr&gt;：水平线noshade:去掉阴影部分&lt;pre&gt;&lt;/pre&gt;:预排版标记HTML项目符号&lt;ul&gt;&lt;li&gt; &lt;/li&gt;&lt;/ul&gt;常用属性type，取值：disc代表小黑点，circle代表空心圆，square代表实心方块注意：&lt;ul&gt;和&lt;li&gt;是块元素HTML是编号列表（有序列表）&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;常用属性：type和start滚动字幕标记&lt;marquee&gt;常用属性：direction:滚动方向，取值：up,down,left,right width:滚动宽度 height:滚动高度 bgcolor:滚动背景色 scrollamount:滚动步长值 scrolldelay:两步之间的停留时间，以毫秒为单位，1s=1000毫秒 loop:循环滚动次数图片标记&lt;img 属性=\"值\"&gt;常用属性:height width align:left/center/right src（图片路径/相对路径） Hspace:图片与左右文字之间的距离（水平距离） Vspace:图片与上下文字之间的距离（垂直距离）超级链接 (行内元素)&lt;a 属性=\"值\"&gt;.......&lt;/a&gt; href：目标文件的地址URL，该URL可以是相对地址，也可以是绝对地址 target:目标文件的显示窗口 _blank:在新窗口中打开目标文件 _self:在当前窗口中打开（默认打开），相当于“替换”操作。 -parent:在父级窗口来打开目标文件 _top：在顶级窗口来打开目标文件。 1.（1）远程的绝对地址 访问远程的文件，总是以域名、开机名开头 &lt;a href=\"http://xxx.com\"&gt;协议是http://的就是远程的绝对地址 (2)本地的绝对路径 访问本地的绝对路径，是以file:///开头的绝对地址2.相对地址URL （1）当前文件和目标文件是同级关系 （２）当前文件与目标文件所在的文件夹是同级关系，先找“文件夹名”，然后再找“文件名”，也就是目标文件位于下一级。 (3)目标文件位于上一层目录中，往上找对应的目录，再找目录中的文件。往上找使用../符号表示 ../代表上一层目录 ../../代表上两层目录 ............ ---------特殊的链接--------- &lt;a 属性=\"xx/Winrar.rar\"&gt;&lt;/a&gt;下载Winrar解压缩文件 邮箱链接 &lt;a 属性=“mailto:邮箱地址”&gt;&lt;/a&gt; 普通空链接 &lt;a 属性=\"#\"&gt;&lt;/a&gt; js链接 &lt;a 属性=\"javascript:window.close()\"&gt;关闭窗口的意思&lt;/a&gt; ------锚点链接------- 含义：锚点链接，是在一个网页的不同区域进行跳转，锚点理解为“定义记号”。 定义锚点：&lt;a name=\"锚点名称\"&gt;&lt;/a&gt; 跳转到锚点（记号） 语法：&lt;a href=\"锚点名称\"&gt;........&lt;/a&gt; 例如：&lt;a href=\"#锚点名称\"&gt;.........&lt;/a&gt; --------&lt;meta&gt;标记------------ &lt;meta&gt;的主要作用，是提供网页的元信息，比如，指定网页的搜索关键字。 &lt;meta&gt;标记有两个属性1.http-equiv和name （1）设置网页的字符集 &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=\"utf-8\"/&gt; （2）网页自动刷新 &lt;meta http-equiv=\"refresh\" content=\"2\"&gt; &lt;meta http-equiv=\"refresh\" content=\"2;url=http://www.baidu.com\"&gt;//二秒钟后，跳转到百度 2.name属性 name属性主要用于设置网页的搜索关键字、版权信息、作者等。 (1)设置网页搜索关键字 &lt;meta name=\"keywords\" content=\"关键字内容\"/&gt; (2)设置网页描述信息 &lt;title&gt;&lt;/title&gt; &lt;meta name=\"description\" content=\"描述信息内容\"&gt; ------XHTML简介---------- XHTML的目地是为了取代HTML XHTML的标记和HTML一模一样 XHTML的语法要比HTML严格的多 XHTML是可扩展超文本标注预言 ----------XHTML编写规范-------------- 所有标记和属性要全小写 单边标记必须关闭如&lt;br/&gt; 所有的属性都必须有值，如：&lt;hr noshade&gt;-----&gt;&lt;hr noshade=\"noshade\"/&gt; 标记之间要顺序嵌套，外层套内层，一层套一层。 XHTML网页必须要有DTD文档类型定义代码。 ------DTD文档类型定义------------ DTD文档类型定义的目地：是一种验证机制，也就是说检验一下你写的XHTML标记语言是否合法。 DTD一共有三大类型 （1）严格型的DTD 在严格的DTD中，不能再使用各种表现的标记，如:&lt;font&gt;、&lt;b&gt;、&lt;body bgcolor&gt;等，(要求必须使用CSS来取代各种表现标记。) 严格型DTD表现方式：&lt;!DOCTYPE html PUBLIC\"-//W3C//DTD XHTML 1.0 Strict//EN\"\"http://www.w3.org/TR/xhtml1/DTD/xhtml-strict.dtd&gt; (2)过渡型DTD 在过渡型的DTD中，可以继续使用HTML中的表现的写法。 这些表现标记，还可以使用。如：&lt;font&gt;、&lt;b&gt;、&lt;body bgcolor&gt; 过渡型的DTD的表达方式：&lt;!DOCTYPE html PUBLIC\"-//W3C//DTD XHTML 1.0 Transitional//EN\"\"http://www.w3.org/TR/xhtml1/DTD/xhtml-Transitional.dtd&gt; (3)框架的DTD 框架的DTD表现方式:&lt;!DOCTYPE html PUBLIC\"-//W3C//DTD XHTML 1.0 Frameset//EN\"\"http://www.w3.org/TR/xhtml1/DTD/xhtml-frameset.dtd&gt; ----------表格学习-------------- 表格标签-------块元素 1.表格的结构 &lt;table&gt; &lt;tr&gt; //代表的行，这里代表一行 &lt;td&gt;&lt;/td&gt; //代表单元格 &lt;/tr&gt; &lt;/table&gt; 2.&lt;table&gt;属性 1.width:宽度 2.height:高度 3.Align:表格水平对其方式,left、center、right 4.Border:边框粗细 5.bgcolor:表格背景色 6.background:背景图片URL 7.cellpadding:单元格边线到内容间的距离（填充距离） 8.cellspacing:单元格与单元格之间的距离（间距） 9.bordercolor:边框颜色 10.rules:合并单元格边框线，取值：all //友情提醒因为学习的html没有接触css所以才用rules，rules兼容性不好，一般都用CSS取代他。 3.&lt;tr&gt;属性----行标记 1.bgcolor: 2.height: 3.align: 4.valign:垂直居中，取值top（上）、middle(中)、bottom(下) 4.&lt;td&gt;或&lt;th&gt;属性 1.width: 2.height: 3.bgcolor: 4.background: 5.align: 6.valign: 7.rowspan:上下单元格合并 8.colspan:左右单元格合并 -------表单学习------ 1.表单的概念 表单主要用来获取客户端用户数据（信息）的，如注册表单、查询表单、登录表单等。 2.&lt;form&gt;标记属性------块元素 name: method:表单的提交方式,取值：get/post action:制定表单的处理程序，一般是PHP文件 enctype:制定表单数据的编码方式（解密方式），这个属性只能用在method=\"post\"的情况下. （1）application/x-www-form-urldecoded //默认的传递 (2) multipart/form-data //如果你上传文件，该值必须它自己 注意：上传文件一定要有enctype=\"multipart/form-data\" 3.GET方法和POST方法 （1）GET提交方式 GET方式，是将表单数据追加到action指定的处理程序的后面，然后向服务器发送请求。 注意：地址栏传数据的方式，默认就是GET方式。， GET方式的特点：1.GET方式不能提交敏感数据，如：密码。。 2.GET方式值提交少量数据，因为地址栏的长度有限制，大约100外字符 3.GET方式下不能上传附件 (2)POST表单提交方式 POST提交方式，它不是将表单数据追加到地址上，而是直接传给表单处理程序。 POST方式的特点： 1.POST提交的数据相对安全。 2.POST可以提交海量数据。 3.POST方式可以上传附件。 单行文本域 语法格式&lt;input type=\"text\" 属性 =\"值\"/&gt; 常用属性： name:文本框的名字，只能以字母开头 type:表单元素的类型 value:文本框中的值 size：文本框的长度，以“字符”为单位。 maxLength：最多可以输入多少个字符，超出的就输不进去了。 readonly：只读属性。可以选中，但不能修改，如readonly=\"readonly\" disabled:禁用属性，不能选中，不能修改，如:disabled=\"disabled\" 单行密码域 语法格式&lt;input type=\"password\" 属性 =\"值\"&gt; 常用属性和单行文本域属性一样。 单选按钮 语法格式&lt;input type=\"radio\" name=\"sex\" 属性 =\"值\" /&gt; 常用属性： Name:元素的名称 Value：元素的值，该value中数据将发往服务器。 Cheaked:默认选择哪一项，如:cheacked=\"checked\" 注意：一组单选按钮，只能选择一个，但name的值必须一致。 复选框 语法格式：&lt;input type=\"checkbox\" 属性=\"值\"/&gt; 常用属性： name：元素名称 value：元素的值 checked:默认选中，如checked=\"checked\" 下拉列表 语法格式：&lt;select name=\"\"&gt; &lt;option&gt;xxx内容&lt;/option&gt; &lt;/select&gt; 常用属性：name option属性：value和selected selected：默认选中，如selected=\"selected\" 文本区域 &lt;textarea name=\"名称\" cols=\"宽度\" row=\"高度\"&gt;&lt;/textarea&gt; 常用属性：name: cols:宽度，是指多少个字符串 rows:高度，是指几行高 提示：&lt;textarea&gt;和&lt;/textarea&gt;之间是默认文本 各种按钮学习 提交按钮：&lt;input type=\"submit\" value=\"提交表单\"/&gt; 重置按钮：&lt;input type=\"reset\" value=\"重置填写\"/&gt; 图片按钮: &lt;input type=\"image\" src=\"图片后缀\"/&gt; 普通按钮：要与js结合使用，如下代码：&lt;input type=\"button\" onclick=\"javascript:windows.close()\" value=\"关闭窗口\"/&gt; 上传文件域 语法格式：&lt;input type=\"file\" 属性=“属性”/&gt; 常用属性： name：表单元素的名称 value：表单元素的值，这个值其实就是上传的文件名。 语法格式例子：&lt;input type=\"file\" name=\"uploadfile\"&gt; 隐藏域 功能：隐藏域就是看不见的一个框。传递一些值，而这个值又不想让别人看见。 用处：主要用于php后台程序。 语法格式：&lt;input type=\"hidden\" name=\"\" value=\"\"/&gt;实战运用：制作网页http://www.chinayarn.com/mart/index2011.asp/http://www.nanshanski.com/index-cn.asp/http://www.jingying.com.cn/参考如下 html的注释：&lt;!--内容--&gt; //注意注释的内容是不会显示的，注释的目地是为了维护方便。 -----网页多媒体-----网页上的视频大多数为flash格式的，因为flash的兼容性比较好。 以flash动画为例，播放flash动画的代码如下，这个代码不用记，看懂就行。 &lt;object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0\" width=\"1000\" height=\"202\" &gt; &lt;param name=\"movie\" value=\"images/banner.swf\"&gt; &lt;param name=\"quality\" value=\"heigh\"&gt; &lt;param name=\"wmode\" value=\"trandsparent\"&gt; &lt;embed src=\"images/banner.swf\" width=\"1000\" height=\"202\" quality=\"high\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" wmode=\"transparent\"&gt;&lt;/embed&gt; &lt;/object&gt; 以上标记的说明：&lt;object&gt;标记，是IE中引入多媒体的标记。 &lt;embed&gt;标记：是netscape中引入多媒体的标记 ----------图片热点（图像地图）--------- 图片热点含义：绘一张图片加多个链接，默认情况下，一张图只能加一个链接。 标记结构： &lt;img src=\"xxx.jpg/png\" usemap=\"#Map\" /&gt; &lt;map id=\"Map\"&gt; &lt;area shape=\"热区形状\" coords=\"热区坐标\" href=\"链接地址\" /&gt; &lt;/map&gt; (1)&lt;area&gt;标记常用属性 shape:热区的形状，取值：rect（矩形），circle（圆形），polygon（多边形） coords:热区的坐标（位置） 如果shape=\"rect\"时，那么，coords=\"x1,y1,x2,y2\" 例如：corrds=“50，50，200，150” *(x1,y1)为矩形左上角的坐标值,(x2,y2)为矩形右上角坐标值。so (x2-x1)和(y2-y1)可知矩形的长和宽。 如果shape=\"circle\"时，那么，coords=\"x,y,r\",其中(x,y)为圆心坐标，而r是圆的半径。 -----------普通框架----------- 1.框架的概念：框架技术：将一个浏览器窗口划分成若干个小窗口，每个小窗口显示一个独立的网页。 2.框架集和框架页 框架集&lt;frameset&gt;:主要用来划分窗口的 框架页&lt;frame&gt;:主要用来制定窗口默认显示的网页地址 框架与窗户很像 打比方： 一个窗户由窗格（框架集）和玻璃（框架页）构成。 先规划窗格，然后再确定每个窗格中放的玻璃。（先有结构，后有内容。） 框架网页的DID必须是：&lt;!DOCTYPE html PUBLIC\"-//W3C//DTD XHTML 1.0 Frameset//EN\"\"http://www.w3.org/TR/xhtml1/DTD/xhtml-frameset.dtd&gt; 代码如下：&lt;frameset cols=\"200,*\" frameborder=\"yes\" border=\"\"&gt; &lt;frame src=\"xx.html\"/&gt; &lt;frame src=\"xx.html\"/&gt; &lt;/frameset&gt; （1）&lt;frameset&gt;常用属性属性 cols：划分左右型框架 1.cols=\"200,*\" //左框架的宽度为200px，剩下的都是右框架。 2.cols=\"180,*,180\" //左框架和右框架的宽分别为180px，剩下的都是中间框架。 3.cols=\"20%,*\" //另类写法，划分框架时，可以用百分比来表示 rows：划分上下型框架 1.rows=\"200,*\" //上框架的高度为200px，剩下的都是下框架。 2.row=\"180,*,180\" //上框架和下框架的高度分别为180px，剩下的的都是中间框架。 注意：cols和rows不能两个同时用。 （2）frameborder:是否显示框架的边框线，取值1或0，亦yes/no border:边框线的粗细 bordercolor:边框的颜色 3.&lt;frame&gt;框架页的属性 (1)src：该小窗口中，默认显示的网页地址。 noresize:不能调整小窗口的大小，如noresize=\"noresize\" scrolling:是否显示滚动条，取值：auto,no,yes name:给当前小窗口起个名字，这个name就是给&lt;a&gt;标记target属性来用的。 提示做网站后台时，返回首页的相关代码：&lt;a href=\"\" target=\"_top\"&gt; XMLXML文件头含义12345web-app 是web.xml的根节点标签名称version 是版本的意思xmlns是web.xml文件用到的命名空间xmlns:xsi是指web.xml遵循xml规范xsi:schemaLocation是指具体用到的schema资源（对文档的限制） XML的元素XML中元素的标记是自定义的，并具有明确的含义，其组织结构是树形的层次结构，每个元素及其子元素 并不是XML规范好的，而是用户根据自己需要来自定义的，就像是我写坦克大战时用的文件保存法，就需要有一定的格式来读取（辨认）所读取的数据是什么类型 XML文档结构清晰，易读，而且是根据开放的标准建立的","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.kuangcp.top/categories/前端/"}],"tags":[{"name":"H5","slug":"H5","permalink":"http://blog.kuangcp.top/tags/H5/"}]},{"title":"Java字节码","slug":"Memo-Java-AdvancedLearning-ClassFile","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-ClassFile/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-ClassFile/","excerpt":"","text":"目录 start Java基础 类和字节码 类加载和类对象 类加载器 加载和连接 Class对象 类加载器 方法句柄 查看class文件 常量池 字节码 运行时环境 操作码介绍 加载和存储操作码 数学运算操作码 执行控制操作码 调用操作码 平台操作码 操作码的快捷形式 invokedynamic 序列化 serialVersionUID 其他业内主流编解码框架 MessagePack Protobuf proto文件定义 Linux上安装 通过Docker使用 对于Java的使用 Thrift Marshalling 热更新 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Java基础类和字节码 个人相关代码 相关项目 Apache bcel 类加载和类对象 一个.class文件定义了JVM中的类型，包括了域,方法，继承信息，注解和其他元数据 类加载器 TODO 学习类加载器 类装载器、双亲委托模型、命名空间、安全性java ClassLoader类解析-双亲委托机制 加载和连接 图 参考博客: 第七章.虚拟机类加载机制加载 这个过程就是读取字节码文件，创建一个字节数组装在这些内容，加载结束后这个对象还不能直接调用 连接 加载完成后，类必须连接起来，分为三步：验证，准备，解析。 验证： 验证文件的合理性，完整性检查，检查常量池，方法的字节码检查。主要的： 是否所有方法都遵守访问控制关键字的限定 方法调用的参数个数和静态类型是否正确 确保字节码不会试图滥用堆栈 确保变量使用之前被正确初始化了 检查变量是否仅被赋予恰当类型的值 准备： 分配内存，准备初始化类中的静态变量，但不会现在就初始化，也不会执行任何VM字节码 解析： 促使VM检查类文件中所引用的类型是不是都是已知的类型。如果有运行时有未知的类型，那又要引发一次类加载过程 当需要加载的类全部加载解析完毕后，VM就可以初始化最初那个加载的类了。 这时所有的静态变量都可以进行初始化，所有静态代码块都会运行，这一步完成后，类就能使用了 Class对象 加载和连接过程的最终结果是一个Class对象，Class对象可以和反射API一起实现对方法，域构造方法等类成员的间接访问 所以一个类的定义就会有一个Class对象, 但是这个对象的类型呢?怎么判断, Class对象的类型就是他的值么? 类加载器 图 Java平台经典类加载器： 根（引导）加载器： 通常在VM启动后不久就实例化，作用是加载系统的基础JAR(主要是rt.jar)，并且不做验证工作 扩展类加载器： 加载安装时自带的标准扩展，一般包括安全性扩展 应用或系统类加载器： 应用最广泛的类加载器，负责加载应用类，在大多SE环境中主要工作是由他完成 定制类载器： 为了企业框架定制的加载器 方法句柄 主要用于反射 用到再学 图 查看class文件 javap: JDK内置命令, 用来探视类文件内部和反编译class文件 常量池 常量池是为类文件中的其他常量元素提供快捷访问方式的区域。对于JVM来说常量池相当于符号表参考博客 javap -v class文件 输出很多额外信息，# 开头的就是常量池信息 图 字节码 参考博客: 学会阅读Java字节码 字节码是程序的中间表达形式，源码和机器码之间的产物 字节码是由源文件执行javac产生的 某些高级语言特性（语法糖）在字节码中给去掉了，例如循环结构，会转换成为分支指令 每个操作都由一个字节表示，因此叫做字节码 字节码是一种抽象表示方法 字节码进一步编译得到机器码 javap -c -p class文件 反编译字节码文件，-p 能看到私有属性 输出所有的属性以及类的定义信息 静态块 构造方法 方法信息 静态属性信息 静态方法信息 运行时环境 因为JVM没有CPU那样的寄存器，所以是采用的堆栈来计算的，称为操作数栈或者计算堆栈 当一个类被链接进运行时环境时，字节码会受到检查，其中很多验证都可以归结为对栈中类型模式的分析 方法需要一块内存区域作为计算堆栈来计算新值，另外每个运行的线程都需要一个调用堆栈来记录当前正在执行的方法，这两个栈会有交互 操作码介绍 字节码由操作码 opcode 序列构成，每个指令后可能会带参数，操作码希望看到栈处于指定状态中，然后他对栈进行操作处理，把参数移走，放入结果 操作码表有四列： 名称：操作码类型的通用名称 参数：操作码的参数，以i开头的是用来作为常量池或局部变量中的查询索引的几个字节，如果有更多的参数，将会合并 如果参数出现在括号里，就表明不是所有形式的操作码都会使用他 堆栈布局：他展示了栈在操作码执行前后的状态。括号中的元素表示是可选的 描述：描述操作码的用处 [ ] 下面的内容需要继续阅读Java7程序员修炼之道 加载和存储操作码数学运算操作码执行控制操作码调用操作码平台操作码操作码的快捷形式invokedynamic 这个特性是针对 框架开发和非Java语言准备的 序列化 码农翻身:序列化： 一个老家伙的咸鱼翻身 对象转化为二进制流 serialVersionUID 简单的说就是类的版本控制, 标明类序列化时的版本, 版本一致表明这两个类定义一致在进行反序列化时, JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)参考博客 serialVersionUID有两种显示的生成方式： 一个是默认的1L 一个是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段 当你一个类实现了Serializable接口，如果没有定义serialVersionUID，Eclipse会提供这个提示功能告诉你去定义 。在Eclipse中点击类中warning的图标一下，Eclipse就会自动给定两种生成的方式。如果不想定义它，在Eclipse的设置中也可以把它关掉的，设置如下：Window ==&gt; Preferences ==&gt; Java ==&gt; Compiler ==&gt; Error/Warnings ==&gt;Potential programming problems将Serializable class without serialVersionUID的warning改成ignore即可。 其他业内主流编解码框架 因为Java序列化的性能和存储开销都表现不好,而且不能跨语言, 所以一般不使用Java的序列化而是使用以下流行的库 MessagePack Github:msgpack | 参考博客: MessagePack：一种高效二进制序列化格式 Protobuf Google开源的库 全称 Google Protocol Buffers | Github : Protobuf 参考博客: Protobuf语言指南 较为详细, 只是版本有点旧参考博客: 详解如何在NodeJS中使用Google的Protobuf | protocobufGoogle 开源技术protobuf Google Protocol Buffer 的使用和原理 参考博客: 数据交换利器 Protobuf 技术浅析参考博客: Protobuf3语言指南 他将数据结构以 proto后缀的文件进行描述, 通过代码生成工具, 可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性 特点: 结构化数据存储格式: XML JSON等 高效的编解码性能 语言无关, 平台无关, 扩展性好 官方支持 Java C++ Python三种语言, 并且Js的支持也比较好 数据描述文件和代码生成机制优点: 文本化的数据结构描述语言, 可以实现语言和平台无关, 特别适合异构系统间的集成 通过标识字段的顺序, 可以实现协议的前向兼容 在不同版本的数据结构进程间进行数据传递 自动代码生成, 不需要手工编写同样数据结构的C++和Java版本; 方便后续的管理和维护,相比于代码, 结构化的文档更容易管理和维护 习惯性规则: 命名: packageName.MessageName.proto 只是编解码的工具, 不支持读半包, 粘包拆包 proto文件定义123456// 用户数据信息message Article &#123; required int32 articleId = 1; // 文章id optinal string articleExcerpt = 4; // 文章摘要 repeated string articlePicture = 5; // 文章附图&#125; 上面定义了一个消息, 消息具有三个属性, 且行末的注释都会变成Javadoc注释 message 是消息定义的关键字 required 表示这个字段是必需的, 必须在序列化的时候被赋值。 optional 代表这个字段是可选的，可以为0个或1个但不能大于1个。 repeated 则代表此字段可以被重复任意多次包括0次。 int32和string是字段的类型。后面是我们定义的字段名。 最后的1，2，3则是代表每个字段的一个唯一的编号标签，在同一个消息里不可以重复。这些编号标签用与在消息二进制格式中标识你的字段，并且消息一旦定义就不能更改。 需要说明的是标签在1到15范围的采用一个字节进行编码。所以通常将标签1到15用于频繁发生的消息字段。编号标签大小的范围是1 到 2的29次幂–1。 此外不能使用protobuf系统预留的编号标签（19000 －19999）。 数据类型对应表 复杂类型 定义了enum枚举类型，嵌套的消息。甚至对原有的消息进行了扩展，也可以对字段设置默认值。添加注释等123456789101112131415161718192021222324252627282930313233package &quot;com.github.kuangcp&quot;;message Article &#123; required int32 article_id = 1; optional string article_excerpt = 2; repeated string article_picture = 3; optional int32 article_pagecount = 4 [default = 0]; enum ArticleType &#123; NOVEL = 0; PROSE = 1; PAPER = 2; POETRY = 3; &#125; optional ArticleType article_type = 5 [default = NOVEL]; message Author &#123; required string name = 1; //作者的名字 optional string phone = 2; &#125; optional Author author = 6; repeated int32 article_numberofwords = 7 [packed=true]; reserved 9, 10, 12 to 15; extensions 100 to 1000;&#125;extend Article &#123; optional int32 followers_count = 101; optional int32 likes_count= 102;&#125;message Other &#123; optional string other_info = 1; oneof test_oneof &#123; string code1 = 2; string code2 = 3; &#125;&#125; 此外reserved关键字主要用于保留相关编号标签，主要是防止在更新proto文件删除了某些字段，而未来的使用者定义新的字段时重新使用了该编号标签。这会引起一些问题在获取老版本的消息时，譬如数据冲突，隐藏的一些bug等。所以一定要用reserved标记这些编号标签以保证不会被使用 当我们需要对消息进行扩展的时候，我们可以用extensions关键字来定义一些编号标签供第三方扩展。这样的好处是不需要修改原来的消息格式。就像上面proto文件，我们用extend关键字来扩展。只要扩展的字段编号标签在extensions定义的范围里。 对于基本数值类型，由于历史原因，不能被protobuf更有效的encode。所以在新的代码中使用packed=true可以更加有效率的encode。注意packed只能用于repeated 数值类型的字段。不能用于string类型的字段。 在消息Other中我们看到定义了一个oneof关键字。这个关键字作用比较有意思。当你设置了oneof里某个成员值时，它会自动清除掉oneof里的其他成员，也就是说同一时刻oneof里只有一个成员有效。这常用于你有许多optional字段时但同一时刻只能使用其中一个，就可以用oneof来加强这种效果。但需要注意的是oneof里的字段不能用required，optional，repeted关键字 导入另一个proto定义import &quot;article.proto&quot;; 更新Protobuf文件的要求: 不能改变已有的任何编号标签。 只能添加optional和repeated的字段。这样旧代码能够解析新的消息，只是那些新添加的字段会被忽略。但是序列化的时候还是会包含哪些新字段。而新代码无论是旧消息还是新消息都可以解析。 非required的字段可以被删除，但是编号标签不可以再次被使用，应该把它标记到reserved中去 非required可以被转换为扩展字段，只要字段类型和编号标签保持一致 相互兼容的类型，可以从一个类型修改为另一个类型，譬如int32的字段可以修改为int64 使用上, 因为有多个消息类型, 那么会采用一个数值id作为code, 进行对应 方便沟通 Linux上安装 只是安装2.5版本 参考博客: linux下Google的Protobuf安装及使用笔记 | 参考:proto buffer 安装 及 调用 下载2.5 并解压 进入目录 ./configure make 然后 make check 然后 sudo make install protoc --version 有版本则安装成功 注意: ./configure 时, 默认会安装在/usr/local目录下，可以加--prefix=/usr来指定安装到/usr/lib下 如果不加, 上述参数就要执行 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib当然,可以将这个环境变量的设置加在 .zshrc 或者 .bashrc 里不然就会报错: protoc: error while loading shared libraries: libprotobuf.so.8: cannot open shared object file: No such file or directory 通过Docker使用对于Java的使用 Google Protocol Buffer 的使用和原理 C++ 但是原理差不多 生成Java文件touch hi.proto123456package lm;message helloworld&#123; required int32 id = 1;//ID required string str = 2;//str optional int32 opt = 3;//optional field&#125; 据此生成Java文件 mkdir src &amp;&amp; protoc --java_out=./src hi.proto也可以使用该脚本更新协议123456# proto文件中明确定义了一样的包结构就可以直接跑脚本basePath='minigame/proto/proto'targetPath='ssss'rm -rf $targetPath \\&amp;&amp; mkdir $targetPath \\&amp;&amp; protoc $basePath/*.proto --java_out=$targetPath \\ 使用1234// 实例化一个构建器helloworld.Builder msg = helloworld.newBuilder();// 填充信息msg.setId(12); Thrift 官网源于Facebook, 支持多种语言: C++ C# Cocoa Erlang Haskell Java Ocami Perl PHP Python Ruby Smalltalk 它支持数据(对象)序列化和多种类型的RPC服务, Thrift适用于静态的数据交换, 需要预先确定好他的数据结构, 当数据结构发生变化时,需要重新编辑IDL文件 Marshalling JBOSS 内部使用的编解码框架 热更新 通过替换 class 实现不停机热更新 Spring hot swapping Instrumentation 自定义类加载器 OSGI 热插拔接口 Instrumentation 新功能基于Java Instrument的Agent实现Java 5 特性 Instrumentation 实践java组件中的热插拔（osgi)agentmain 方式 相关项目: game-hot-update https://www.cnblogs.com/wgslucky/p/9127681.htmlgroovy hotswap demo","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"字节码","slug":"字节码","permalink":"http://blog.kuangcp.top/tags/字节码/"}]},{"title":"Log.md","slug":"Memo-Java-Log","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Log/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Log/","excerpt":"","text":"目录 start 日志系统 slf4j 体系 Log4j 问题 Log4j2 LogBack Gradle中使用 配置理解 根节点 属性 子节点 设置上下文名称： 设置变量： 获取时间戳字符串： 设置loger： 详解 实践经验 MDC apache 体系 分析日志 Linux上查看日志 lnav 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 日志系统 码农翻身: 一个著名的日志系统是怎么设计出来的？ 深刻的理解了日志系统的来源以及相关关系 slf4j 体系 SLF4J是一套简单的日志外观模式的Java API，帮助在项目部署时对接各种日志实现。 只是接口设计, 以下是具体实现库 lombok+slf4j+logback SLF4J和Logback日志框架详解 目前来说, LogBack要好于Log4j 参考博客: 从Log4j迁移到LogBack的理由 个人体验: logback 1.1.3 log4j 1.7.25 在Java中 - 在Groovy中 Log4j不能在Groovy中获取到正确的 类,方法,方法所在行 直接输出? LogBack可以拿到正确的值, 但是在闭包中, 方法是混乱的 Log4j Log4J使用笔记log4j.properties配置详解 问题 log4j:WARN No appenders could be found for logger 这是路径下没有对应的配置文件, 那么这时就有了神奇的事情, maven项目按道理是resources下就行了,但如果你项目配置文件自己新建目录然后再复制过去什么的, 这么瞎搞的话,虽然在ide是能运行的, 但是一大包就没用了, 那么直接把log的配置单独放在 src/main/java 下就行了 Log4j2 官方文档, 配置详解听说是为了解决Log4j无法在多环境使用的问题 , 也就是类似于 SpringBoot 多profile的功能 LogBack logback简单示例 xml to groovy config Gradle中使用 添加依赖 testCompile &#39;ch.qos.logback:logback-classic:1.2.3&#39; compile &#39;org.projectlombok:lombok:1.16.16&#39; 类上加注解 @Slf4j 然后 就能用了 配置理解 参考博客 根节点 属性 scan : 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 scanPeriod : 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 debug : 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 123&lt;configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\"&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 子节点设置上下文名称：每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用&lt;contextName&gt;设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改。1234&lt;configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\"&gt; &lt;contextName&gt;myAppName&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt;&lt;/configuration&gt; 设置变量： 用来定义变量值的标签，&lt;property&gt; 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过&lt;property&gt;定义的值会被插入到logger上下文中。定义变量后，可以通过${}来使用变量。例如使用&lt;property&gt;定义上下文名称，然后在&lt;contentName&gt;设置logger上下文时使用。12345&lt;configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\"&gt; &lt;property name=\"APP_Name\" value=\"myAppName\" /&gt; &lt;contextName&gt;$&#123;APP_Name&#125;&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt;&lt;/configuration&gt; 获取时间戳字符串：两个属性 key:标识此&lt;timestamp&gt; 的名字；datePattern：设置将当前时间（解析配置文件的时间）转换为字符串的模式，遵循java.txt.SimpleDateFormat的格式。例如将解析配置文件的时间作为上下文名称：12345&lt;configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\"&gt; &lt;timestamp key=\"bySecond\" datePattern=\"yyyyMMdd'T'HHmmss\"/&gt; &lt;contextName&gt;$&#123;bySecond&#125;&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 设置loger： &lt;loger&gt; 用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。&lt;loger&gt;仅有一个name属性，一个可选的level和一个可选的addtivity属性。 name: 用来指定受此loger约束的某一个包或者具体的某一个类。 level: 用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。 如果未设置此属性，那么当前loger将会继承上级的级别。 addtivity: 是否向上级loger传递打印信息。默认是true。 &lt;loger&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个appender将会添加到这个loger。 &lt;root&gt; 也是&lt;loger&gt;元素，但是它是根loger。只有一个level属性，应为已经被命名为”root”. level: 用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL。 默认是DEBUG。 &lt;root&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个appender将会添加到这个loger。 测试类：12345678910public class LogbackDemo &#123; private static Logger log = LoggerFactory.getLogger(LogbackDemo.class); public static void main(String[] args) &#123; log.trace(\"======trace\"); log.debug(\"======debug\"); log.info(\"======info\"); log.warn(\"======warn\"); log.error(\"======error\"); &#125; &#125; 第1种：只配置root1234567891011&lt;configuration&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt; &lt;/configuration&gt; 其中appender的配置表示打印到控制台(稍后详细讲解appender )；&lt;root level=&quot;INFO&quot;&gt;将root的打印级别设置为“INFO”，指定了名字为“STDOUT”的appender。当执行logback.LogbackDemo类的main方法时，root将级别为“INFO”及大于“INFO”的日志信息交给已经配置好的名为“STDOUT”的appender处理，“STDOUT”appender将信息打印到控制台； 第2种：带有loger的配置，不指定级别，不指定appender12345678910111213&lt;configuration&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name=\"logback\"/&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt; &lt;/configuration&gt; 其中appender的配置表示打印到控制台(稍后详细讲解appender )；&lt;logger name=&quot;logback&quot; /&gt;将控制logback包下的所有类的日志的打印，但是并没用设置打印级别，所以继承他的上级&lt;root&gt;的日志级别“DEBUG”；没有设置addtivity，默认为true，将此loger的打印信息向上级传递；没有设置appender，此loger本身不打印任何信息。&lt;root level=&quot;DEBUG&quot;&gt;将root的打印级别设置为“DEBUG”，指定了名字为“STDOUT”的appender。 当执行logback.LogbackDemo类的main方法时，因为LogbackDemo 在包logback中，所以首先执行&lt;logger name=&quot;logback&quot; /&gt;，将级别为“DEBUG”及大于“DEBUG”的日志信息传递给root，本身并不打印；root接到下级传递的信息，交给已经配置好的名为“STDOUT”的appender处理，“STDOUT”appender将信息打印到控制台； 第3种：带有多个loger的配置，指定级别，指定appender1234567891011121314151617&lt;configuration&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name=\"logback\"/&gt; &lt;!--logback.LogbackDemo：类的全路径 --&gt; &lt;logger name=\"logback.LogbackDemo\" level=\"INFO\" additivity=\"false\"&gt; &lt;appender-ref ref=\"STDOUT\"/&gt; &lt;/logger&gt; &lt;root level=\"ERROR\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 其中appender的配置表示打印到控制台(稍后详细讲解appender )； &lt;logger name=&quot;logback&quot; /&gt;将控制logback包下的所有类的日志的打印，但是并没用设置打印级别，所以继承他的上级&lt;root&gt;的日志级别“DEBUG”；没有设置addtivity，默认为true，将此loger的打印信息向上级传递；没有设置appender，此loger本身不打印任何信息。&lt;logger name=&quot;logback.LogbackDemo&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;控制logback.LogbackDemo类的日志打印，打印级别为“INFO”；additivity属性为false，表示此loger的打印信息不再向上级传递，指定了名字为“STDOUT”的appender。&lt;root level=&quot;DEBUG&quot;&gt;将root的打印级别设置为“ERROR”，指定了名字为“STDOUT”的appender。 当执行logback.LogbackDemo类的main方法时，先执行&lt;logger name=&quot;logback.LogbackDemo&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;，将级别为“INFO”及大于“INFO”的日志信息交给此loger指定的名为“STDOUT”的appender处理，在控制台中打出日志，不再向次loger的上级 &lt;logger name=&quot;logback&quot;/&gt; 传递打印信息；&lt;logger name=&quot;logback&quot;/&gt;未接到任何打印信息，当然也不会给它的上级root传递任何打印信息； 如果将&lt;logger name=&quot;logback.LogbackDemo&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt; 修改为 &lt;logger name=&quot;logback.LogbackDemo&quot; level=&quot;INFO&quot; additivity=&quot;true&quot;&gt;那打印结果将是什么呢？没错，日志打印了两次，想必大家都知道原因了，因为打印信息向上级传递，logger本身打印一次，root接到后又打印一次 详解 是的子节点，是负责写日志的组件。 有两个必要属性name和class。name指定appender名称，class指定appender的全限定名。 1.ConsoleAppender:把日志添加到控制台，有以下子节点：&lt;encoder&gt;：对日志进行格式化。（具体参数稍后讲解 ）&lt;target&gt;：字符串 System.out 或者 System.err ，默认 System.out ；12345678910&lt;configuration&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 2.FileAppender: 把日志添加到文件，有以下子节点： &lt;file&gt;：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 &lt;append&gt;：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。 &lt;encoder&gt;：对记录事件进行格式化。（具体参数稍后讲解 ） &lt;prudent&gt;：如果是 true，日志会被安全的写入文件，即使其他的FileAppender也在向此文件做写入操作，效率低，默认是 false。123456789101112&lt;configuration&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.FileAppender\"&gt; &lt;file&gt;testFile.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt; &lt;/configuration&gt; 3.RollingFileAppender: 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。有以下子节点： &lt;file&gt;：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 &lt;append&gt;：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。 &lt;encoder&gt;：对记录事件进行格式化。（具体参数稍后讲解 ） &lt;rollingPolicy&gt;:当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。 &lt;triggeringPolicy &gt;: 告知 RollingFileAppender 合适激活滚动。 &lt;prudent&gt;：当为true时，不支持FixedWindowRollingPolicy。支持TimeBasedRollingPolicy，但是有两个限制，1不支持也不允许文件压缩，2不能设置file属性，必须留空。 rollingPolicy TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。有以下子节点：&lt;fileNamePattern&gt;:必要节点，包含文件名及“%d”转换符， “%d”可以包含一个java.text.SimpleDateFormat指定的时间格式，如：%d{yyyy-MM}。如果直接使用 %d，默认格式是 yyyy-MM-dd。RollingFileAppender 的file字节点可有可无，通过设置file，可以为活动文件和归档文件指定不同位置，当前日志总是记录到file指定的文件（活动文件），活动文件的名字不会改变；如果没设置file，活动文件的名字会根据fileNamePattern 的值，每隔一段时间改变一次。“/”或者“\\”会被当做目录分隔符。 &lt;maxHistory&gt;:可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，且&lt;maxHistory&gt;是6，则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除。 FixedWindowRollingPolicy： 根据固定窗口算法重命名文件的滚动策略。有以下子节点：&lt;minIndex&gt;:窗口索引最小值&lt;maxIndex&gt;:窗口索引最大值，当用户指定的窗口过大时，会自动将窗口设置为12。&lt;fileNamePattern &gt;:必须包含“%i”例如，假设最小值和最大值分别为1和2，命名模式为 mylog%i.log,会产生归档文件mylog1.log和mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz 或者 没有log%i.log.zip triggeringPolicy: SizeBasedTriggeringPolicy： 查看当前活动文件的大小，如果超过指定大小会告知RollingFileAppender 触发当前活动文件滚动。只有一个节点:&lt;maxFileSize&gt;:这是活动文件的大小，默认值是10MB。 例如：每天生成一个日志文件，保存30天的日志文件。1234567891011121314&lt;configuration&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;logFile.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt; &lt;/configuration&gt; 例如：按照固定窗口模式生成日志文件，当文件大于20MB时，生成新的日志文件。窗口大小是1到3，当保存了3个归档文件后，将覆盖最早的日志。12345678910111213141516171819202122&lt;configuration&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;test.log&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt; &lt;fileNamePattern&gt;tests.%i.log.zip&lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;3&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 4.另外还有SocketAppender、SMTPAppender、DBAppender、SyslogAppender、SiftingAppender，并不常用，这些就不在这里讲解了，大家可以参考官方文档。当然大家可以编写自己的Appender。 &lt;encoder&gt;：负责两件事，一是把日志信息转换成字节数组，二是把字节数组写入到输出流。目前PatternLayoutEncoder 是唯一有用的且默认的encoder ，有一个&lt;pattern&gt;节点，用来设置日志的输入格式。使用“%”加“转换符”方式，如果要输出“%”，则必须用“\\”对“\\%”进行转义。123&lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; 模式图 实践经验 Java 调整格式日志输出 日志记录方式, 注意格式的正确, 否则, 错误会被隐藏 Github: CorrectLog.java 在Springboot中还能指定包的日志等级 logging.level.com.github.kuangcp.service = DEBUG MDC 使用 ThreadLocal 存储一些信息, 然后能在xml的pattern中直接引用, 省去了重复手动写 log TODO apache 体系 apache的简单示例 分析日志Linux上查看日志 Linux常用的日志分析命令与工具 其中就是使用简单的cat less awk sed lnav 一个专门用于浏览日志文件的软件 | 官网 | 文档博客: LNAV：基于 Ncurses 的日志文件阅读器","categories":[],"tags":[]},{"title":"Querydsl.md","slug":"Memo-Java-Ecosystem-Querydsl","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Ecosystem-Querydsl/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Ecosystem-Querydsl/","excerpt":"","text":"目录 start Querydsl 个人感想 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Querydsl Github 地址 | 最新文档地址 Querydsl 是一个通用的查询框架, 专注于通过Java API构建类型安全的SQL查询。Querydsl可以通过一组通用的查询API为用户构建出适合不同类型ORM框架或者是SQL的查询语句，也就是说QueryDSL是基于各种ORM框架以及SQL之上的一个通用的查询框架。借助QueryDSL可以在任何支持的ORM框架或者SQL平台上以一种通用的API方式来构建查询。目前QueryDSL支持的平台包括JPA,JDO,SQL,Java Collections,RDF,Lucene,Hibernate Search。 个人感想 初接触, 看起来很是漂亮, 一如Java8的优美, 不用折腾SQL, 2018-06-13 20:48:18","categories":[],"tags":[]},{"title":"Tomcat.md","slug":"Memo-Java-Tool-Tomcat","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-Tool-Tomcat/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-Tomcat/","excerpt":"","text":"目录 start Tomcat Tips 原理 配置运行 配置解压版 Tomcat IDE中配置运行 编码 虚拟目录 默认主页 虚拟主机 配置 GZip压缩 配置IO方式 Tomcat Native Web容器和Web服务器的区别 【web容器】 【Web服务器】 【应用程序服务器（The Application Server）】 【serverlet】 【Tomcat】 【Tomcat与Web服务器、应用服务器的关系】 一、Tomcat 与应用服务器 二、Tomcat 与 Web 服务器 优化 Tomcat僵死问题 Tomcat和Jetty 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Tomcat 官方网站 官网上大致有： Tomcat 7 8 8.5 9 大版本 Tomcat Native 优化Tomcat性能，提升速倍 Apache Standard Taglib JSTL的实现 Tomcat Connectors 用于连接IIS Apache 官方文档 一款功能强大的Tomcat管理监控工具psi-probeTomcat监控管理工具 Tips servletContextLisner 和Spring环境的加载顺序要注意 Tomcat启动卡住,因为random 原理 更多查看 Tomcat那些事儿 公众号Tomcat目录部署与Context描述文件context.xml | Tomcat配置文件解析与Digester| Servlet到底是单例还是多例你了解吗？| Tomcat类加载器以及应用间class隔离与共享 | 啥，Tomcat里竟然还有特权应用? | 你了解JMX在Tomcat的应用吗? 配置运行 精简版, 适合放在服务器 tomcat-clean-8.5.31 | tomcat-clean-9.0.8 个人配置版,适合个人图形化使用 tomcat-admin-9.0.8 | tomcat-admin-8.5.31 配置解压版 TomcatWindows 平台 在setclasspath中把前几行关于JAVA_HOME，JRE_HOME的路径改成自己的 系统中添加catalina_home环境变量 运行tomcatw.exe配置里面所有的路径( JDK JRE ) 双击tomcat.exe启动Tomcat Linux 平台 下载解压，然后 bin 目录下执行 chmod +x *.sh 参考博客 配置管理账号 tomcat-users.xml123456&lt;role rolename=\"manager\"/&gt; &lt;role rolename=\"manager-gui\"/&gt; &lt;role rolename=\"admin\"/&gt; &lt;role rolename=\"admin-gui\"/&gt; &lt;role rolename=\"manager-script\"/&gt; &lt;user username=\"tomcat\" password=\"tomcat\" roles=\"admin-gui,admin,manager-gui,manager,manager-script\"/&gt; 其中admin-gui是为了能访问manger的界面，manager-secret是为了可以上传war文件 配置本机外可访问管理页面 /conf/Catalina/localhost/下 添加manager.xml 1234&lt;Context privileged=\"true\" antiResourceLocking=\"false\" docBase=\"$&#123;catalina.home&#125;/webapps/manager\"&gt; &lt;Valve className=\"org.apache.catalina.valves.RemoteAddrValve\" allow=\"^.*$\" /&gt; &lt;/Context&gt; IDE中配置运行 你一定不知道IDE里的Tomcat是怎么工作的！ 虽然IDE也是引用到解压的Tomcat路径, 但是只是使用了可执行文件, 配置文件和一系列中间文件都是和原Tomcat隔离的, 这样也保证了原Tomcat能单独运行不受影响 编码 编辑conf/下的server.xml，配置Connector项 URIEncoding=&quot;UTF-8&quot; 浏览器表单utf-8 xml utf-8 乱码 服务器 浏览器 乱码 使用response.setContentType(“text/html; charset=utf-8”);。 无效方法response.setChaoactorEncoding; xml文件里面有乱码，saxreader会生成document错误。 浏览器表单get方式：需要重新编码获得字符串 浏览器表单post方式 request.setCharactorEncoding(utf-8); 自己建立的工程里面的web.xml继承了conf/web.xml.只需要重写自己的web.xml相关的配置的参数就可以覆盖其功能 虚拟目录指定webapp目录外的可访问的文件 方法1：conf/server.xml 当中找到host标签里 添加一行 &lt;Context path=&quot;/hello&quot; docBase=&quot;c:/mydsadf&quot;/&gt; 方法2：conf/catalina/localhost/myxml.xml context放置进来&lt; Context docBase=&quot;c:/mydsadf&quot;/&gt; 访问方式http://localhsot:8080/myxml/ 默认主页web.xml123&lt; welcome-file-list&gt;&lt; welcome-file&gt;index.html&lt; /welcome-file&gt;&lt; /welcome-file-list&gt; 虚拟主机server.xml1234567&lt;host name=\"www.baidu.com\" appBase=\"c:/webA\" unpackWARs=\"true\" autoDeploy=\"true\"&gt;&lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log.\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt;&lt; Context path=\"/\" docBase=\"d:/webA\" /&gt;&gt; File f=new File(&quot;/information.xml&quot;);这个写法是错的，空指针异常 request.getParameter返回字符串，如果表单里面是空的，就返回长度为零的字符串。 配置 GZip压缩 tomcat nginx开启Gzip原博客 修改配置文件：/conf/server.xml原文件1&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改成1&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" compression=\"on\" compressionMinSize=\"2048\" noCompressionUserAgents=\"gozilla,traviata\" compressableMimeType=\"text/html,text/xml,text/javascript,application/x-javascript,application/javascript,text/css,text/plain\"/&gt; 配置IO方式 默认http1.1是nio, 还有aio ajp bio Tomcat Native 官方文档 | 参考博客: tomcat安装与配置native,apr Web容器和Web服务器的区别【web容器】何为容器： 容器是一种服务调用规范框架，J2EE 大量运用了容器和组件技术来构建分层的企业级应用。在 J2EE 规范中，相应的有 WEB Container 和 EJB Container 等。 WEB 容器给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使 JSP，SERVLET 直接跟容器中的环境变量交互，不必关注其它系统问题 （从这个角度来说，web 容器应该属于架构上的概念）。web 容器主要由 WEB 服务器来实现。例如：TOMCAT，WEBLOGIC，WEBSPHERE 等。 若容器提供的接口严格遵守 J2EE 规范中的 WEB APPLICATION 标准。我们把该容器叫做 J2EE 中的 WEB 容器。 WEB 容器更多的是跟基于 HTTP 的请求打交道。而 EJB 容器不是。它是更多的跟数据库、其它服务打交道。 容器的行为是 将其内部的应用程序组件与外界的通信协议交互进行了隔离，从而减轻内部应用程序组件的负担（实现方面的负担？）。 例如：SERVLET 不用关心 HTTP 的细节，而是直接引用环境变量 session、request、response 就行、EJB 不用关心数据库连接速度、各种事务控制，直接由容器来完成。 【Web服务器】 Web 服务器（Web Server）可以处理 HTTP 协议。当 Web 服务器接收到一个 HTTP 请求，会返回一个 HTTP 响应，例如送回一个 HTML 页面。 Web 服务器可以响应针对静态页面或图片的请求， 进行页面跳转（redirect），或者把动态响应（dynamic response）的产生委托（delegate）给一些其它的程序 例如 CGI 脚本，JSP（JavaServer Pages）脚本，servlets，ASP（Active Server Pages）脚本，服务器端 JavaScript，或者一些其它的服务器端技术。 Web 服务器仅仅提供一个可以执行服务器端程序和返回(程序所产生的)响应的环境，而不会超出职能范围。 Web 服务器主要是处理需要向浏览器发送 HTML 的请求以供浏览。 【应用程序服务器（The Application Server）】 根据定义，作为应用程序服务器，要求可以通过各种协议（包括 HTTP 协议）把商业逻辑暴露给（expose）客户端应用程序。 应用程序使用此商业逻辑就像你调用对象的一个方法或过程（语言中的一个函数）一样。 【serverlet】 Servlet（Server Applet），全称 Java Servlet，未有中文译文。是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。 狭义的 Servlet 是指 Java 语言实现的一个接口 广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。 Servlet 运行于支持 Java 的应用服务器中。从实现上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。 【Tomcat】 Tomcat 服务器是一个免费的开放源代码的 Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试 JSP 程序的首选。 对于一个初学者来说，可以这样认为，当在一台机器上配置好 Apache 服务器，可利用它响应对 HTML 页面的访问请求。 实际上 Tomcat 部分是Apache 服务器的扩展，但它是独立运行的，所以当你运行 tomcat 时，它实际上作为一个与 Apache 独立的进程单独运行的。 Apache Tomcat is an open source software implementation of the Java Servlet and JavaServer Pages technologies. 【Tomcat与Web服务器、应用服务器的关系】 Tomcat 服务器是一个免费的开放源代码的 Web 应用服务器。因为 Tomcat 技术先进、性能稳定且免费，所以深受 Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的 Web 应用服务器。 一、Tomcat 与应用服务器 到目前为止，Tomcat 一直被认为是 Servlet/JSP API 的执行器，也就所谓的 Servlet 容器。然而，Tomcat并不仅仅如此，它还提供了 JNDI 和 JMX API 的实现机制。尽管如此，Tomcat 仍然还不能算是应用服务器，因为它不提供大多数 J2EE API 的支持。 很有意思的是，目前许多的应用服务器通常把 Tomcat 作为它们 Servlet 和 JSP API 的容器。由于 Tomcat允许开发者只需通过加入一行致谢，就可以把 Tomcat 嵌入到它们的应用中。遗憾的是，许多商业应用服务器并没有遵守此规则。 对于开发者来说，如果是为了寻找利用 Servlet、JSP、JNDI 和 JMX 技术来生成 Java Web 应用的话，选择Tomcat 是一个优秀的解决方案；但是为了寻找支持其他的 J2EE API，那么寻找一个应用服务器或者把 Tomcat作为应用服务器的辅助，将是一个不错的解决方案；第三种方式是找到独立的 J2EE API 实现，然后把它们跟Tomcat 结合起来使用。虽然整合会带来相关的问题，但是这种方式是最为有效的。 二、Tomcat 与 Web 服务器Tomcat 是提供一个支持 Servlet 和 JSP 运行的容器。Servlet 和 JSP 能根据实时需要，产生动态网页内容。而对于 Web 服务器来说， Apache 仅仅支持静态网页，对于支持动态网页就会显得无能为力；Tomcat 则既能为动态网页服务，同时也能为静态网页提供支持。尽管它没有通常的 Web 服务器快、功能也不如 Web 服务器丰富，但是 Tomcat 逐渐为支持静态内容不断扩充。大多数的 Web 服务器都是用底层语言编写如 C，利用了相应平台的特征，因此用纯 Java 编写的 Tomcat 执行速度不可能与它们相提并论。 一般来说，大的站点都是将 Tomcat 与 Apache 的结合，Apache 负责接受所有来自客户端的 HTTP 请求，然后将 Servlets 和 JSP 的请求转发给 Tomcat 来处理。Tomcat 完成处理后，将响应传回给 Apache，最后 Apache 将响应返回给客户端。 优化Tomcat僵死问题 分析各种可能的原因 Tomcat和Jetty 参考博客: Jetty和Tomcat的选择：按场景而定 Jetty官网 1234567一个简单项目, 就是index.jsp 里面放了个 Hello 字符串经过对比 8.5.29 jetty 9.2 启动时间 jetty花费时间是Tomcat2倍启动后内存 Jetty480M Tomcat300M1000并发 20000总量 Tomcat涨到 460M 第二次480M 连续5次后上660M了 10次900M 最长时间时而220ms 时而 70msJetty涨到770M 第二次压测直接上900M了 十次后也是900M 最长响应时间稳定在 220ms","categories":[],"tags":[]},{"title":"Jvm 性能调优","slug":"Memo-Java-AdvancedLearning-JvmPerformance","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-JvmPerformance/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-JvmPerformance/","excerpt":"","text":"目录 start Java的性能调优 JVM参数配置 内存优化 堆外内存 主要指标分析 JDK自带工具 jps jstat jinfo jmap jstack 开源项目 图形化 jvisualvm MAT IBM Heap Analyzer 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs Java的性能调优 调优, 分析 JVM参数配置 内存优化 Blog:java优化占用内存的方法(一) GC 性能优化 专栏 Java调优经验谈 你能不能谈谈，java GC是在什么时候，对什么东西，做了什么事情？” 堆外内存堆外内存堆外内存主要是JNI、Deflater/Inflater、DirectByteBuffer（nio中会用到）使用的。 how to see memory useage of nio buffers 主要指标分析JDK自带工具 都是jdk的bin目录下的工具 jps 主要用来输出JVM中运行的进程状态信息 option: -q 忽略输出的类名、Jar名以及传递给main方法的参数，只输出pid。 -m 输出传递给main方法的参数，如果是内嵌的JVM则输出为null。 -l 输出应用程序主类的完整包名，或者是应用程序JAR文件的完整路径。 -v 输出传给JVM的参数。 -V 输出通过标记的文件传递给JVM的参数（.hotspotrc文件，或者是通过参数-XX:Flags=指定的文件） jstat option: -gcutil 统计heap的gc情况 -t 在第一列输出时间戳。该时间戳从jvm启动开始 -h3 每隔N行输出一次列表头 $PID 进程号 interval 输出间隔时间，单位毫秒 count 输出次数 Demo: jstat -gcutil -t -h5 7919 1000 50 jinfo 观察运行中的java程序的运行环境参数：参数包括Java System属性和JVM命令行参数 Demo: jinfo 14352 jinfo -sysprops 14352 jinfo -flags 14352 jinfo -flag MaxPermSize 14352 jmap 用来查看堆内存使用状况 Demo: jmap -histo $PID 展示class的内存情况 jmap -heap $PID 展示Java堆详细信息 jmap -dump:live,format=b,file=heapLive.hprof 2576 jstack jstack [option] pid 主要用来查看某个Java进程内的线程堆栈信息 Option: -F: 强制产生一个线程dump -m: 打印java和native frames -l: 打印关于锁的附加信息 Demo: jstack -F $PID 开源项目 arthasvjtools 图形化jvisualvm 参考博客: java内存泄漏的定位与分析 Local 使用 VisualVM 进行性能分析及调优参考博客: JVisualVM简介与内存泄漏实战分析 Remote 通常使用两种方式连接远程JVM: JMX jstatd 参考博客: JVisualVM远程监控 jmx jstatd vim jstatd.all.policy 1234grant codebase &quot;file:$&#123;java.home&#125;/../lib/tools.jar&quot; &#123; permission java.security.AllPermission;&#125;; jstatd -J-Djava.security.policy=jstatd.all.policy -p 12028 -J-Djava.rmi.server.logCalls=true open jvisualvm create a remote with jstatd by above port 12028 MAT Memory Analyzer tool(MAT) Official Site 参考博客: JAVA Shallow heap &amp; Retained heap IBM Heap Analyzer Official Site","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"JDK","slug":"JDK","permalink":"http://blog.kuangcp.top/tags/JDK/"},{"name":"JVM","slug":"JVM","permalink":"http://blog.kuangcp.top/tags/JVM/"}]},{"title":"Java的测试","slug":"Memo-Java-AdvancedLearning-JavaTest","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-JavaTest/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-JavaTest/","excerpt":"","text":"目录 start Java的测试 断言 正式代码 测试代码 单元测试 实现方案 使用Junit Idea上Junit的使用 TestNG Mock框架 Mockito DBUnit 感悟 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Java的测试 测试的基础理论 断言正式代码参考博客: Java陷阱之assert关键字详解_javajava 中assert的使用 首先可以用在单元测试代码中。junit侵入性是很强的，如果整个工程大量的代码都使用了junit，就难以去掉或者是选择另外一个框架。如果单元测试代码 很多，并且想复用这些单元测试案例，应该选择assert而不是junit，便于使用别的单元测试框架，比如TestNG。同理正式的功能代码根本就不应 该出现Junit，应该使用assert. assert主要适合在基类，框架类，接口类，核心代码类，工具类中。换言之，当你的代码的调用者是另外一个程序员写得业务代码，或者是另外一个子系统时，就很有必要使用它。比如你做了一个快速排序的算法 这种情况下，如果不检查传入参数的正确性，会抛出一个莫名其妙的空指针错误。你的调用者可能并不清楚你代码的细节，在一个系统的深处调试一个空指针错误是很浪费时间的。就应该直接明确的告诉你的调用者是传入的参数有问题。否则他会怀疑你的代码有BUG。使用assert可以避免两个程序员之间互相指责对方写的代码有问题。assert适用那些你知道具体是什么错误，你和你的调用者已经约定应该由你的调用者去排除或检查的错误。你通过一个断言告诉你的调用者。assert不适用那些外部系统造成的错误，比如用户输入数据的错误，某个外部文件格式错误。这些错误不是你的调用者而是用户造成的，甚至于不属于异常，因为出现输入错误和文件格式错误是经常的，这些错误应该由业务代码去检查。 assert比较适合于被频繁调用的 基类，框架代码，工具类，核心代码，接口代码中，这正是它在运行时被去掉的原因。测试代码应该在测试阶段开启-ea参数，便于对系统深处的核心代码做仔细的测试。 Java较少使用assert的原因是Java有很完整的OO体系，强制类型转换出现得较少，所以不需要类似c那样需要频繁的检查指针的类型是否正确，指针是否为空。同时Java也很少直接管理内存或缓冲区，所以不需要频繁的检查传入的缓冲区是否为空或者是已经越界。 但使用好assert有助于提高框架代码的正确性和减少框架代码的使用者的调试时间。 assert要达到的目的是让程序员方便的发现自己的逻辑错误，并且不影响程序的效率。assert所发现的错误，是完全不应该出现的，是不能用异常代替的。异常，那是系统所允许的，或者是系统不可控的“错误”，它不是程序员的逻辑问题。 assert应该是开发阶段打开，而在发布后关闭。 测试代码 测试中必须要通过断言来得知测试是否通过, 单元测试 单元测试(unit testing)，是指对软件中的最小可测试单元进行检查和验证。 Assert.assertEquals(a,b) 断言两个对象是相等的 assert(expression) 断言表达式为真 实现方案使用Junit Junit4官网|Junit5官网| 如何上手Junit | 如何上手Junit5 Before Test 执行顺序： Before在Test之前执行是毋庸置疑的，但是如果有多个Before的话，按定义的先后逆序执行，也就是说AB顺序定义，BA顺序执行 注意 Before的执行顺序不是平常想的那样，如果你有一个共享的对象，需要在两个Before中完成初始化，是办不到的，必然空指针 遇到的问题: 如果在加了Test注解的方法中像Main方法一样的去开多个子线程对象并运行起来,并不会得到想要的结果 这几个线程都是开了就立马关闭了,而且也是正常的退出码 0 原因: Idea上Junit的使用可以使用TestMe插件 Ctrl Shift T 生成测试类 结合Mockit可以更好的模拟测试环境 TestNG Spring、Spring Boot和TestNG测试指南 Mock框架 mock 模拟 , 也就是说对需要测试的模块, 将该模块依赖的相关对象给修改成自己期望的行为方式(伪造一个假对象), 以移除依赖性, 从而针对性的测试该模块但主要还是适用于单元测试，在集成测试，性能测试，自动化测试等其他测试领域使用并不多 JMockit官方文档 入门博客http://www.baeldung.com/mockito-void-methodshttps://www.tutorialspoint.com/mockito/mockito_quick_guide.htmhttp://static.javadoc.io/org.mockito/mockito-core/2.19.0/org/mockito/Mockito.html#1 Mockito Officail Site | Github:mockitoMockito TutorialUnit tests with Mockito - Tutorial 参考博客: TDD：什么是桩（stub）和模拟（mock）？参考博客: mockitomockito 官网提示: Do not mock types you don’t own Don’t mock value objects Don’t mock everything Show love with your tests! 常规使用 when(mock.get(anyInt())).thenReturn(null); 对void方法的mock doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject()); 使用规则去校验 verify(mock).someMethod(contains(“foo”)); 切忌 不可对非Mock对象使用 mock 的系列方法, 不然会报出南辕北辙的错误,这是首先要排查的一点 一般不用对 void 方法打桩, 事后 verify 就行测试代码针对 mock 对象的 void 方法调用本来就没有什么效果，所以一般也无须用 doNothing(), 况且 void 提供不了返回值作进一步 mock，只需要在事后用 verify() 进行验证一下。 DBUnit 基于Junit的一个数据库测试框架, 方便测试dao层 感悟 好的测试能大大节省时间, 坏的测试大量延误时间 应该在项目主体架构明确后, 才大量书写测试, 验证程序, 避免编写大量无用测试代码 单元测试有多难写, 你的代码就有多高的耦合度","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://blog.kuangcp.top/tags/测试/"}]},{"title":"LayUI.md","slug":"Memo-FrontEnd-Frame-LayUI","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-FrontEnd-Frame-LayUI/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-FrontEnd-Frame-LayUI/","excerpt":"","text":"目录 start LayUI 使用 模块化 非模块化 组件 Layer 树形 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs LayUI使用模块化 写法稍微复杂了些,但是提高了页面加载速度 引入核心文件:12&lt;link rel=\"stylesheet\" href=\"../layui/css/layui.css\"/&gt;&lt;script src=\"../layui/layui.js\"&gt;&lt;/script&gt; 使用layer模块:1234layui.use(['layer'], function()&#123; var layer = layui.layer; layer.msg('Hello World');&#125;); 非模块化组件Layer layer组件 十分强大layer 移动版 弹出页面层 如何将script 标签内容直接引入 123456layer.open(&#123; type: 1, area: ['600px', '360px'], shadeClose: true, //点击遮罩关闭 content: 'test'&#125;); 123&lt;script type=\"text/html\" id=\"test\"&gt;&lt;input type=\"text\" /&gt;&lt;/script&gt; 弹出页面中异步提交表单12345678&lt;script type=\"text/html\" id=\"set_key\"&gt; &lt;form id=\"set-form\" class=\"set-form\"&gt; &lt;input type=\"text\" id=\"key\" required/&gt; &lt;-&gt; &lt;input type=\"text\" id=\"value\" required/&gt;&lt;br&gt;&lt;br&gt; &lt;button&gt;新增 string&lt;/button&gt; &lt;/form&gt;&lt;/script&gt;&lt;button onclick=\"string()\"&gt;String&lt;/button&gt; 12345678910111213141516171819202122232425262728 function string()&#123; var set_content = $(\"#set_key\").html() layer.tab(&#123; area: ['500px', '520px'], tab: [&#123; title: 'set', content: set_content &#125;] &#125;); $(\"#set-form\").submit(function(e)&#123; e.preventDefault(); set(); &#125;); &#125; function set()&#123; var key = $(\"#key\").val() var value = $(\"#value\").val() handlePost('/key', &#123; key: key, value: value &#125;, function(data)&#123; console.log(data) &#125;, function(data)&#123; console.log(data) &#125;) &#125;&#125; 树形 基于layui树形菜单写的树形列表（treetable）","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://blog.kuangcp.top/categories/前端框架/"}],"tags":[{"name":"LayUI","slug":"LayUI","permalink":"http://blog.kuangcp.top/tags/LayUI/"}]},{"title":"Vue.md","slug":"Memo-FrontEnd-Frame-Vue","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-FrontEnd-Frame-Vue/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-FrontEnd-Frame-Vue/","excerpt":"","text":"目录 start Vue1. [构建前后端分离的应用](#构建前后端分离的应用) 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Vue vue.js guide | iview 手摸手，带你用vue撸后台 系列一(基础篇) 构建前后端分离的应用springboot+gradle+vue+webpack 组合使用使用Gradle整合SpringBoot+Vue.js-开发调试与打包","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://blog.kuangcp.top/categories/前端框架/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.kuangcp.top/tags/Vue/"}]},{"title":"NodeJS.md","slug":"Memo-FrontEnd-Node-NodeJS","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-FrontEnd-Node-NodeJS/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-FrontEnd-Node-NodeJS/","excerpt":"","text":"目录 start NodeJs 安装 配置 使用淘宝的镜像 使用 安装Vue 目录 end|2018-12-13 20:53| 码云 | CSDN | OSChina | cnblogs NodeJs安装 官网下载 进入解压的 bin/node 和 npm 建立软链接到 /usr/local/bin/ 目录下 执行 node –version 和 npm -v 查看是否配置成功 添加node的真正解压目录到环境变量中， 之后安装的模块才能被找到12NODE_HOME=/home/kcp/Application/sdk/node-v8.11.1-linux-x64export PATH=$PATH:$NODE_HOME/bin 配置使用淘宝的镜像 镜像地址 还包括各种常用软件 临时使用 npm --registry https://registry.npm.taobao.org install express 永久使用 npm config set registry https://registry.npm.taobao.org 通过cnpm使用 npm install -g cnpm --registry=https://registry.npm.taobao.org emmm, 为什么我就配置不成功 查看配置是否成功: npm config get registry 使用 Hexo 安装Vue npm install -g vue-cli --registry=https://registry.npm.taobao.org","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.kuangcp.top/categories/JavaScript/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://blog.kuangcp.top/tags/NodeJS/"}]},{"title":"Java注解","slug":"Memo-Java-AdvancedLearning-Annotation","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-Annotation/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Annotation/","excerpt":"","text":"目录 start 注解 读取 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 注解 参考博客 全面解析Java注解 | Java注解（2）-运行时框架 参考项目 AnnotationDemo 注解定义包含四个元注解，分别为@Target,@Retention,@Documented, @Inherited。各元注解的作用如下： @Target 表示该注解用于什么地方，可能的 ElemenetType 参数包括： ElemenetType.CONSTRUCTOR 构造器声明。 ElemenetType.FIELD 域声明（包括 enum 实例）。 ElemenetType.LOCAL_VARIABLE 局部变量声明。 ElemenetType.METHOD 方法声明。 ElemenetType.PACKAGE 包声明。 ElemenetType.PARAMETER 参数声明。 ElemenetType.TYPE 类，接口（包括注解类型）或enum声明。 @Retention 表示在什么级别保存该注解信息。可选的 RetentionPolicy 参数包括： RetentionPolicy.SOURCE 注解将被编译器丢弃。 RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃。 RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。 举一个例子，如@Override里面的Retention设为SOURCE，编译成功了就不要这一些检查的信息，相反，@Deprecated里面的Retention设为RUNTIME，表示除了在编译时会警告我们使用了哪个被Deprecated的方法，在执行的时候也可以查出该方法是否被Deprecated。 @Documented 将此注解包含在 javadoc 中 @Inherited 允许子类继承父类中的注解 读取 判断是否有指定注解类型的注解 在类上的注解就是得到类对象, 然后判断 isAnnotationPresent(ExcelConfig.class) 在方法上的注解就是得到所有方法, 属性同理 相关代码片段","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://blog.kuangcp.top/tags/注解/"}]},{"title":"Java的集合","slug":"Memo-Java-AdvancedLearning-Collection","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-Collection/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Collection/","excerpt":"","text":"目录 start 集合 集合继承和实现关系 Iterator Map HashMap 实现原理 List Set 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 集合 重要的知识点，面试必问，使用频率也很高 集合继承和实现关系 Collection 接口 List 接口 ArrayList LinkedList 也实现了Queue接口 双向链表实现 Vector Set 接口 内容不允许重复 Queue 接口 队列接口 SortedSet 接口 单值排序接口 Map接口 HashMap接口 无序, key不重复 HashTable接口 无序, key不重复 TreeMap接口 按key排序, key不重复 IdentityMap接口 key可重复 WeakHashMap接口 弱引用Map集合 Iterator 迭代器 Map HashMap HashTable 键为null的问题 HashMap 实现原理 HashMap 实现原理 HashMap 怎么 hash？又如何 map？ 整理实现 主要看 addVal 方法 以及 resize方法的实现HashMap的数据结构是 数组加单链表 (数组是只放一个Node对象, 单链表是为了放通过hash计算得到的index一致的元素包装成的Node对象) n 是数组大小先 hash (高16和低16做异或)然后 hash&amp;(n-1) 就是结果 (也就是数组的下标) putVal() Node数组 大小 是 使用容量达到0.75 就扩容(翻倍), 初始化大小也要是2的幂 - 扩容就要重新分布单链表 resize() - 如果是链表的最后一个节点 Hash &amp; (32-1) 计算位数 - 如果hash 二进制倒数第五位是0, 那么扩容后, 位置就不变 (16 -&gt; 32) - 如果是1 1+oldCap(16) 链表就是内部类 Node list方式, 然后 如果节点大于8就转红黑树, 当减少到6后退回到list方式 List interface 包括的方法有: List method List接口有众多实现, 最常用的ArrayList LinkedList stackoverflow: list add then unsupportedoperationexception 有时候会使用 Arrays.asList() 或者 Collections.singletonList() 来快速生成 List但是 这两个生成的实例都是返回 AbstractList 的实现类, 其 add remove 方法是没有实现的, 如果调用了就会抛出异常 123public void add(int index, E element) &#123; throw new UnsupportedOperationException();&#125; 这是因为, 这个类设计就是采用的定长数组来实现List, 所以不能对其中元素进行更改 Set Set是无序的，但是StringRedisTemplate的对象操作返回的set竟然是有序的 因为有一个类是SortSet，顾名思义，所以是有序的，要继续多学习和使用Java原生的集合对象了 3分钟搞掂Set集合","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.kuangcp.top/tags/数据结构/"}]},{"title":"Java应用的部署","slug":"Memo-Java-AdvancedLearning-Deploy","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-Deploy/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Deploy/","excerpt":"","text":"目录 start 部署运行 打包可执行jar 用命令手动打包 Maven Gradle 打包war Docker镜像 手动 Maven Gradle 配置文件 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs 部署运行 传统的可执行jar, war 以及Docker镜像 参考博客: JAR 文件揭密参考博客: maven-assembly-plugin 入门指南 打包可执行jar用命令手动打包 关于MANIFEST.MF文件这个文件很重要, 如果自己手动配置就需要编写该文件MANIFEST.MF示例123456Manifest-Version: 1.0Archiver-Version: Plexus ArchiverBuilt-By: kcpCreated-By: Apache Maven 3.5.3Build-Jdk: 1.8.0_152Main-Class: com.youaishujuhui.minigame.Main 编译文件 javac -d *.java 打包字节码成jar jar -cvf hello.jar com/test/*.* 打包成可执行jar jar -cvfm hello.jar mainfest *.* 其中：mainfest 文本文件： Main-Class: com.test.Main 冒号后一定要有空格，文件最后一行一定留空行 运行jar包中指定的类java -cp clojure.jar clojure.main 多个jar运行 java -cp jline-0.9.94.jar;clojure.jar jline.ConsoleRunner clojure.main 参考博客: 用java –jar 命令运行Jar包 Maven不依赖Jar的项目 Demo项目 | 详情 依赖Jar的项目 完善 Maven 含 Jar 打包可执行jar Maven实战（九）——打包的技巧Maven打包成可执行jar参考博客: 使用MAVEN打包可执行的jar包 Demo项目的完整代码片段 多个main的情况下运行指定的main java -cp example03-1.0-SNAPSHOT.jar cn.zhouyafeng.itchat4j.main.TulingRobot war和jar一样使用 Springboot项目能够做到, 其实就是Main方法, 然后配置了一个Servlet的加载类就可以当war用了 通过Maven构建打包Spring boot，并将config配置文件提取到jar文件外 Gradle 参考博客: Building Java Applications 不依赖Jar的项目 依据模板新建项目 gradle init --type java-application 123456789// 主要是如下配置plugins &#123; // Apply the java plugin to add support for Java id 'java' // Apply the application plugin to add support for building an application id 'application'&#125;// Define the main class for the applicationmainClassName = 'App' add this config to build.gradle 12345jar &#123; manifest &#123; attributes 'Main-Class': 'base.Main' &#125;&#125; run : gradle clean jar &amp;&amp; java -jar file 依赖Jar的项目 有好几种插件可以实现 1.shadow插件官网文档 完善 Gradle 含 Jar 打包可执行jar 打包war 最终将生成的war放到tomcat的webapps目录下即可 Docker镜像 以一个基础镜像,然后将war放进去构建成一个镜像, 然后推送到服务器上构建容器进行运行 jib 结合 Maven Gradle 方便的构建 Docker镜像 手动MavenGradle 配置文件 多目标应用环境的发布, 可以使用Maven 多 Profile; Spring 的多profiles; 环境变量; … 在环境中存储配置 通常，应用的 配置 在不同 部署 (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括： 数据库，Memcached，以及其他 后端服务 的配置 第三方服务的证书，如 Amazon S3、Twitter 等 每份部署特有的配置，如域名等 有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的代码和配置严格分离显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。 判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。 需要指出的是，这里定义的“配置”并不包括应用的内部配置，比如 Rails 的 config/routes.rb，或是使用 Spring 时 代码模块间的依赖注入关系 。这类配置在不同部署间不存在差异，所以应该写入代码。 另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 config/database.yml 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。 12-Factor推荐将应用的配置存储于 环境变量 中（ env vars, env ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。 配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 development,test, 和 production 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 staging 或 qa 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 joes-staging ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。 12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。 参考博客: 在环境中存储配置","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://blog.kuangcp.top/tags/部署/"}]},{"title":"Java主要发行版","slug":"Memo-Java-AdvancedLearning-JavaReleaseVersion","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-JavaReleaseVersion/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-JavaReleaseVersion/","excerpt":"","text":"目录 start Java主要发行版本 Java7 Java8 Java9 Java10 Java11 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Java主要发行版本 官网 Release Note Java7 详情 语法糖:数字中的下划线 新的语言小特性:TWR(try with resources) 类文件格式的变化:注解 JVM的新特性: 动态调用 Java8 详情 接口中新增 静态方法,默认方法 Optional Lambda Stream java.time 包 增强了日期时间的处理 181 版本移除了 Derby Java9 参考博客: Java9 新特性汇总参考博客: Java9 新特性 详解 模块化 Java10 类型推断 Java11","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[]},{"title":"Java中的继承与接口","slug":"Memo-Java-AdvancedLearning-ExtendsAndInterface","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-ExtendsAndInterface/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-ExtendsAndInterface/","excerpt":"","text":"目录 start 继承和接口 继承 接口 常用接口 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 继承和接口 要倾向于组合的使用多于继承 参考博客: java的重载、覆盖和隐藏的区别 继承接口个人理解为一个接口就表明一种协议, 实现一个接口就是实现一种协议, 表明实现方能完成协议所规定的相关行为.. 常用接口 Comparable 可比较的, 此接口强行对实现它的每个类的对象进行整体排序。 此排序被称为该类的自然排序，类的compareTo方法被称为它的自然比较方法。实现此接口的对象列表或数组可以通过Collections.sort 和Arrays.sort进行自动排序。 实现此接口的对象可以用作有序映射表中的键或有序集合中的元素，无需指定比较器。强烈推荐（虽然不是必需的） 使自然排序与 equals 一致。 所谓与equals一致是指对于类C 的每一个 e1 和 e2 来说，当且仅当 (e1.compareTo((Object)e2)==0)与 e1.equals((Object)e2) 具有相同的布尔值时，类 C 的自然排序才叫做与 equals 一致 。 接口指定实现的方法 ：int compareTo(T o) 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 强烈推荐 (x.compareTo(y)==0) == (x.equals(y)) 这种做法，但不是 严格要求这样做。一般来说，任何实现 Comparable 接口和违背此条件的类都应该清楚地指出这一事实。 推荐如此阐述：“注意：此类具有与 equals 不一致的自然排序。” Comparator 比较器, 实现了此接口的类具有对某类型排序的能力 使用Lambda表达式的匿名实现 其实也是一样的实现了 compare(o1, o2) 方法 和 Comparable 中的 compareTo 的返回值的意义是一致的, 如果o1 小于、等于或大于 o2，则分别返回负整数、零或正整数。 默认是 Ascend 一个从小到大的有序, 为了不迷惑, 时间也应该使用相同的顺序, 从过去到未来","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"接口","slug":"接口","permalink":"http://blog.kuangcp.top/tags/接口/"}]},{"title":"Java GC","slug":"Memo-Java-AdvancedLearning-GC","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-GC/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-GC/","excerpt":"","text":"目录 start GC 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs GC Garbage Collection 垃圾回收 参考博客: 译垃圾收集器Serial 、Parallel、CMS、G1","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"GC","slug":"GC","permalink":"http://blog.kuangcp.top/tags/GC/"}]},{"title":"Java的IO","slug":"Memo-Java-AdvancedLearning-IO","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-IO/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-IO/","excerpt":"","text":"目录 start IO操作的学习 Java IO简史 Java1.0到1.3 BIO Java1.4 NIO Java1.7 AIO 关于普通IO的文件操作 读取配置文件 可执行jar读取外部配置文件 Maven项目 NIO Buffer 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs IO操作的学习 个人代码:IO流的相关学习 Java IO简史 BIO NIO AIO演变 Java1.0到1.3 BIO同步阻塞式IO但是能自己实现 伪异步IO Java1.4 NIO 非阻塞式IO, 虽然官方名称为New IO, 民间称为No-blocking IO 参考博客: NIO基础详解 对于调用者来说是异步的, 但是实际上是使用的多路复用和一个线程进行轮询, 真的吗? 到底是不是异步的呢? Java1.7 AIO 真正的异步非阻塞IO, NIO2.0 引入了新的异步通道的概念, 以及异步文件通道和异步套接字通道的实现 关于普通IO的文件操作读取配置文件 maven格式路径，会从resources下获取文件例如 /a.xml InputStream is = this.getClass().getResourceAsStream(path); 读取properties文件 ：new Properties().load(is); 按行读取文件 BufferedReader bf = new BufferedReader(new InputStreamReader(is)); 可执行jar读取外部配置文件1234567891011121314151617 Properties properties = new Properties(); File file = new File(\"something.properties\"); FileInputStream fis = new FileInputStream(file); properties.load(fis); System.out.println(properties.getProperty(\"v\")); fis.close();``` - 只要配置文件和打包的jar同级即可#### Maven项目_读取resource目录下配置文件_```java ClassLoader classLoader = MainConfig.class.getClassLoader(); URL resource = classLoader.getResource(\"excel.main.yml\"); if(resource!=null)&#123; String path = resource.getPath(); &#125; 这样也可以, 但是会有诡异的问题, 打包后运行是正常的, idea中运行就不正常, new File(&quot;src/main/resources/excel.main.yml&quot;) NIO NIO学习真是痛苦, 过程繁杂,又有各种并发 难以调试 Buffer Java NIO系列教程（三） Buffer Buffer的基本用法: 使用Buffer读写数据一般遵循以下四个步骤： 写入数据到Buffer 调用flip()方法 从Buffer中读取数据 调用clear()方法或者compact()方法 当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。 一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区： 调用clear()或compact()方法。 clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"http://blog.kuangcp.top/tags/IO/"}]},{"title":"Java7","slug":"Memo-Java-AdvancedLearning-Java7","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-Java7/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Java7/","excerpt":"","text":"目录 start Java5 Java6 Java7 异常处理 TWR 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 参考博客: JDK各个版本比较 JDK5~JDK10 Java5 complete Java6 complete Java7 Official:api 小特性 | Switch 支持 String | 二进制的实例化 原本是 int x = Integer.parseInt(&quot;1010100&quot;, 2);Java7之后int x = 0b110110; | 数字下划线 10_0100__1000__0011 | 钻石语法: 泛型右部直接&lt;&gt;不用写类型变量 异常处理 | 异常处理 允许异常的或操作 catch(IOException | NullPointException e) final关键字: catch (final Exception e){throw e;} 抛出后的是原异常类型的异常而不是Exception TWR | TWR(try with resources) 1234567891011// 从URL下载文件, 其中的资源都会自动关闭// 但是要注意发生异常后,资源也不会自动关闭, 所以确保TWR生效,正确的用法是为各个资源声明独立变量.try(OutputStream out = new FileOutputStream(file); InputStream is = url.openStream())&#123; byte[] buf = new byte[1024]; int len; while ((len = is.read(buf)) &gt; 0)&#123; out.write(buf, 0, len); &#125;&#125; 另一个好处就是改善了错误跟踪的能力, 能够更准确地跟踪堆栈中的异常, 在Java7之前,处理资源时抛出的异常经常会被覆盖,TWR也可能会出现这种情况. 123try((InputStream in = getNullStream()))&#123; in.available();&#125; 在这种改进后的跟踪堆栈中能看到提示, 其中的NullPointException是能够抛出来看到的.没有被隐藏 目前TWR特性依靠一个接口来实现 AutoCloseable. TWR的try从句中出现的资源类都必须实现这个接口. Java7中大部分资源类都修改过但不是所有的资源类都采用了这项技术, JDBC是已经具备了这个特性. 官方提倡尽量采用TWR替代原有的方式 | 简化变参方法调用: HashMap&lt;String, String&gt;[] array = new HashMap&lt;&gt;[2]; 不允许创建已知类型的泛型数组 只能这样写 HashMap&lt;String, String&gt; array = new HashMap[2]; 这样的编写也只是一个敷衍, 编译器会警告: 可以将array定义为HashMap&lt;String, String&gt;数组,但是又不能创建这个类型的实例. 所以这里只是将原始类型实例化了放进去. 现在能够这样编写: public static &lt;T&gt; Collection&lt;T&gt; doSomething(T... entries){} 反射的简化和加强","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"Java7","slug":"Java7","permalink":"http://blog.kuangcp.top/tags/Java7/"}]},{"title":"Java的JDK以及JRE","slug":"Memo-Java-AdvancedLearning-JDKAndJRE","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-JDKAndJRE/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-JDKAndJRE/","excerpt":"","text":"目录 start JDK And JRE Oracle Oracle JDK Oracle JRE OpenJDK 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs JDK And JRE LTS: 8 11 但是11发布后, Oracle修改了使用协议, JDK商用需付费, 仅个人开发演示免费 License OracleOracle JDK 以下是Java8的结构12345678910111213├── bin/├── COPYRIGHT├── include/├── javafx-src.zip├── jre/├── lib/├── LICENSE├── man/├── README.html├── release├── src.zip├── THIRDPARTYLICENSEREADME-JAVAFX.txt└── THIRDPARTYLICENSEREADME.txt bin目录下常用工具: java javac javap jar jconsole jmap jmc jps jstack jstat jstatd jvisualvm Useage: Java 性能分析 以下是Java11的目录结构12345678├── bin├── conf├── include├── jmods├── legal├── lib├── README.html└── release Oracle JRE Java11 开始, 已去掉了JRE 以下是Java8的结构123456789├── bin/├── COPYRIGHT├── lib/├── LICENSE├── plugin/├── README├── THIRDPARTYLICENSEREADME-JAVAFX.txt├── THIRDPARTYLICENSEREADME.txt└── Welcome.html OpenJDK Official Site | Open JDK下载地址 Open JDK 11: Download","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"JDK","slug":"JDK","permalink":"http://blog.kuangcp.top/tags/JDK/"}]},{"title":"JMS","slug":"Memo-Java-AdvancedLearning-JMS","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-JMS/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-JMS/","excerpt":"","text":"目录 start JMS RocketMQ 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs JMS Java Message Service 规范而已,和JDBC一样, 具体实现由厂商来实现 码农翻身:Java帝国之JMS的诞生 RocketMQ 有关demo","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"JMS","slug":"JMS","permalink":"http://blog.kuangcp.top/tags/JMS/"}]},{"title":"JMX","slug":"Memo-Java-AdvancedLearning-JMX","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-JMX/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-JMX/","excerpt":"","text":"目录 start JMX 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs JMX Official Doc | wiki | wici zh 参考博客: JMX学习笔记参考博客: java常见命令及Java Dump介绍","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[]},{"title":"Java并发","slug":"Memo-Java-AdvancedLearning-Concurrents","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-Concurrents/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Concurrents/","excerpt":"","text":"目录 start Java并发 Java内存模型 【理论知识】 可能的问题 好的习惯 【块结构并发】 Java5之前 synchronized 正确使用锁 volatile 正确使用 【现代并发】JUC 概念 CAS指令 原子类 读写锁 具体实现 线程锁 CountDownLatch 锁存器 ConcurrentHashMap CopyOnWriteArrayList Queue BlockingQueue TransferQueue 【控制执行】 任务建模 ScheduleThreadPoolExecutor 【分支合并框架】 【Java内存模型】 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Java并发 个人相关代码主要知识来源 Java程序员修炼之道 | 并发编程网该模块最早在1.5引入,由Doug Lea开发 | doug lea博客中文版 参考博客: 并发编程 参考博客: 不可变真的意味线程安全？ Java内存模型【理论知识】线程模型 共享的，默认可见的可变状态 抢占式线程调度 concurrent包的设计理念 安全性 （并发类型安全性） 并发类型安全：不管发生多少操作都能保证对象保持自相一致。一般采用的是将所有属性私有化 活跃度 在一个活跃的系统中，所有做出尝试的活动最终或者取得进展，或者失败 可能出现瞬时故障的情况： 处于锁定状态，或者在等待得到线程锁 等待输入 资源的暂时故障 CPU没有足够的空闲时间运行该线程 永久故障的常见原因： 死锁 不可恢复的资源问题（例如 NFS不可访问） 信号丢失 性能 测量系统用给定的资源能做多少工作 可重用性 可能的问题 安全性与活跃度相对立，安全性求稳定安全，活跃度是求进展 可重用的系统倾向于对外开放内核，这会引发安全问题 一个安全但是编写幼稚的系统性能通常不会好，因为里面会用大量的锁来保证安全 好的习惯 尽可能限制子系统之间的通信，隐藏数据对安全性非常有帮助 尽可能保证子系统内部结构的确定性， 比如：即便子系统会以并发的，非确定性的方式进行交互，子系统内部的设计也应该按照线程和对象的静态知识 采用客户端应用必须遵守的规则。 这个技巧虽然强大，但是依赖于用户应用程序的合作程度，如果某个糟糕的应用不遵守规则，排查问题很困难 在文档中记录所要求的行为，这是最逊的方法，但如果代码要部署在非常通用的环境下，就必须采用这个方法 系统开销之源 锁与监测 环境切换的次数 线程的个数 调度 内存的局部性 算法设计 【块结构并发】 Java5之前 同步和锁 synchronized： 只能锁定对象，不能锁定原始类型 锁的范围要尽可能的小 被锁定的兑现给数组中的单个对象不会被锁定 同步方法可以视为包含整个方法的同步 (this){...}代码块 但是两者的二进制码的表示是不同的 静态方法会锁定其Class对象，因为没有实例对象可以锁定 如果要锁定一个对象，请慎重考虑使用显式锁定，还是getClass()， 两种方式对子类影响不同 内部类的同步是独立于外部类的 synchronized 并不是方法签名的组成部分，所以不能出现在接口的方法声明中 非同步的方法不查看或关心任何锁的状态，而且在同步方法运行时，他们仍能继续运行 Java的线程锁是可重入的。也就是说持有线程锁的线程在遇到同一个锁的同步点 时是可以继续的 比如 一个同步方法调用另一个类的另一个同步方法 线程的状态模型： 线程创建时处于准备（Ready）状态，然后调度器会准备执行 完全同步对象 策略 一个满足下面所有条件的类就是完全同步类： 所有域在任何公共构造方法中的初始化都能达到一致的状态 没有公共域 从任何非私有方法返回后，都可以保证对象实例处于一致的状态 假定调用方法时状态是一致的 所有方法经证明都可在有限时间内终止 所有方法都是同步的 当处于非一致的状态时，不会调用其他实例的方法，以及调用非私有方法 synchronized 在synchronized代码块执行完成后，对锁定对象所做的所有修改全部会在线程释放锁之前同步到内存中 保证了在同一时刻,只有一个线程可以执行某一个方法或者代码块. 所以这个关键字的作用就是同步 在不同线程中锁定（操作）的对象的内存块 同步的作用不仅仅是互斥,另一个作用就是共享可变性, 当某个线程修改了可变数据并释放锁,其他线程可以获取变量的最新值 如果没有正确的同步,这种修改对其他线程是不可见的 如果锁定的是类的成员属性,或者this, 就是对该对象进行了加锁变成了’单线程’, 就影响了整体性能 使用局部变量就会多线程且保证了数据的一致性 切记不能锁常量（或者显式声明的String）从而引起死锁 正确使用锁 查看JDK源码 ForkJoinTask 的 externalAwaitDone 方法 1.wait方法用来使线程等待某个条件, 他必须在同步块内部被调用,这个同步块通常会锁定当前对象实例. 123456// 这个模块的标准使用方式synchronized(this)&#123; while(condition)&#123; Object.wait(); &#125;&#125; 2.始终使用wait循环来调用wait方法, 永远不要在循环之外调用wait方法 因为有时候, 即使并不满足被唤醒条件,但是由于其他线程调用notifyAll()方法会导致被阻塞的线程意外唤醒,从而导致不可预料的结果 3.唤醒线程,保守的做法是使用notifyAll唤醒所有等待的线程,从优化的角度看,如果处于等待的所有线程都在等待同一个条件,而每次只有一个线程可以从这个条件中被唤醒, 那么就应该选择调用notify 当多个线程共享一个变量的时候,每个读写都必须加锁进行同步, 如果没有正确的同步,就容易造成程序的活性失败和安全性失败,这样的失败是很难复现的.所以务必要保证锁的正确使用 12345678// 这个就是个错误使用的案例int size = 0;public synchronized void increase()&#123; size++;&#125;public int current()&#123; return size;&#125; 这个案例保证了多线程下并发时,对size变量的正确修改,但是不能保证实时读取到的变量值是正确的正确的做法是 current 方法也要加上synchronized关键字 volatile Java多线程i++线程安全问题，volatile和AtomicInteger解释？ 线程所读的值在使用之前总会从内存中读出来 线程所写的值总会在指令完成之前同步回内存中 可以把围绕该域的操作看成成是一个小的同步块 volatile 变量不会引入线程锁，所以不可能发生死锁 TODO 矛盾 volatile 变量是真正线程安全的，但只有写入时不依赖当前状态（读取的状态）的变量才应该声明为volatile变量 正确使用 打开Netty中NioEventLoop的源码 有一个属性 private volatile int ioRatio = 50; 该变量是用于控制IO操作和其他任务运行比例的 volatile是Java提供的最轻量级的同步机制,Java内存模型为volatile专门定义了一些特殊的访问规则: 当一个变量被volatile修饰后: 线程可见性: 当一个线程修改了被volatile修饰的变量后,无论是否加锁,其他线程都能立即看到最新的修改 禁止指令重排序优化, 普通的变量仅仅保证在该方法的执行过程中, 所有依赖赋值结果的地方都能获取正确的结果 而不能保证变量赋值操作的顺序和程序代码的执行顺序一致1234567891011121314151617181920public class ResortJavaDemo &#123; private static boolean stop; public static void main(String[]s) throws InterruptedException &#123; Thread workThread = new Thread(() -&gt; &#123; int i = 0; while(!stop)&#123; i++; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"i\"+i); &#125; &#125;); workThread.start(); TimeUnit.SECONDS.sleep(3); stop = true; &#125;&#125; 我们预期程序会在3s后停止, 但是实际上它会一直执行下去, 原因就是虚拟机对代码进行了指令重排序和优化, 优化后的指令如下:12if (!stop) while(true) 所以需要在stop前加上volatile修饰符, 解决了如下两个问题 main线程对stop的修改在workThread中可见 禁止指令重排序, 防止因为重排序导致的并发访问逻辑混乱 以上示例代码在Java8中是正常运行的, 并不会一直执行下去, 所以还需要找个别的Demo过来 一些人认为volatile可以替代传统锁,提升并发性能, 这个认识是错误的. volatile仅仅解决了可见性的问题, 并不能保证互斥性 volatile最适合使用的是一个线程写, 其他线程读的场景.如果有多个线程并发写操作,仍然需要使用锁或者线程安全的容器或者原子变量来代替 不可变性： 这些对象或者没有状态（属性）或者只有final域。因为他们的状态不可变，所以是安全而又活泼，不会出现不一致的情况 初始化就会遇上问题，如果是需要初始化很多属性，可以采用工厂模式，但是构建器模式更好。 一个是实现了构建器泛型接口的内部静态类，另一个是构建不可变类实例的私有构造方法 思想实现代码 不可变对象中的final域特别要注意： final声明的对象的引用是不可变的， 但是如果引用的是对象，该对象自身的属性的引用是可变的 不可变对象的使用十分广泛，但是开发效率不行，每修改对象的状态都要构建一个新对象 【现代并发】JUC 简称为J.U.C (java.util.concurrent) | The j.u.c Synchronizer Framework中文翻译版 建议通过使用线程池,Task(Runnable/Callable),读写锁,原子类和线程安全容器来代替传统的同步锁,wait和notify 提升并发访问的性能, 降低多线程编程的难度, Netty就是这么做的 线程安全容器底层使用了CAS,volatile,和ReadWriteLock实现 ReentrantLock 和 sync 加解锁机制的区别? 一个作用于线程一个作用于临界变量 不要依赖线程优先级概念CAS指令 互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能额外损耗, 因此这种同步也被称为阻塞同步,悲观锁 与之对应的乐观锁是, 先进行操作, 操作完成之后再判断操作是否成功, 是否有并发问题, 如果有则进行失败补偿, 如果没有就算操作成功. Java中的非阻塞同步就是CAS 1.5就有了 原子类 java.util.concurrent.atomic 提供适当的原子方法 避免在共享数据上出现竞争危害的方法使用Java自带的原子类, 可以避免同步锁带来的并发访问性能降低的问题, 减少犯错的机会. 对于 int, long, boolean 等成员变量大量使用原子类 但是使用者必须通过类似 compareAndSet或者set或者与这些操作等价的原子操作来保证更新的原子性. 常见的操作系统的支持， 他们是非阻塞的（无需线程锁）， 常见的方法是实现序列号机制（和数据库里的序列号机制类似），在AtomicInteger或AtomicLong上用原子 操作getAndIncrement()方法， 并且提供了nextId 方法得到唯一的完全增长的数值 注意： 原子类不是相似的类继承而来，所以 AtomicBoolean不能当Boolean用 读写锁 在读多写少的场景下, 使用同步锁比同步块性能要好 读锁 ReentranReadWriteLock 是共享锁 具体实现线程锁 java.util.concurrent.locks 块结构同步方式基于锁这样的的概念，具有缺点 锁只有一种类型 对被锁住的对象的所有同步操作都是一样的作用 在同步代码块或方法开始时取得线程锁 在同步代码块或方法结束时释放线程锁 线程或者得到锁，或者阻塞，没有其他可能 如果要重构对线程锁的支持， 事实上该包下Lock接口也都实现了： 添加不同类型的锁，例如 读取锁和写入锁 对锁的阻塞没有限制，允许在一个方法中加锁，另一个方法中解锁 如果线程得不到锁（例如已经被线程加锁），就允许该线程后退或者继续执行，或者做别的事情 tryLock() 允许线程尝试锁，并可以在超过时间后放弃 Lock接口的实现类：ReentrantLock 本质上和用在同步块上的锁是一样的，但是稍微灵活些 lock(): 官方API1.8 lock 如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。 如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。 如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1。 trylock(): 官方API1.8 trylock Lock接口的实现类：ReentrantWriteLock 在需要读取很多线程而写入很少线程时，用这个性能更好 CountDownLatch 锁存器 是一种简单的同步模式，这种模式允许线程在通过同步屏障之前做少量的准备工作 构建实例时，需要提供一个数值（计数器），通过两个方法来实现这个机制 countDown() 作用：计数器减一 如果当前计数大于零，则将计数减少。然后什么都不做 如果减后的计数为零，出于线程调度目的，将重新启用所有的等待线程 如果当前计数等于零，则不发生任何操作。 await() 作用：让线程在计数器到0之前一直等待， 如果大于 0 ， 休眠这语句所处的当前线程 例如 a.await() 如果锁存器a的Count不为0 ，就把当前线程休眠掉 如果已经是小于等于0 就什么都不做 能做到： 当一堆线程之间的同步，为了确保有指定数量正常初始化的线程 创建成功，才能开始同步 ConcurrentHashMap ConcurrentHashMap 是 HashMap的并发版本 修改HashMap，并不需要将整个结构都锁住，只要锁住即将修改的桶（就是单个元素） 好的HashMap 实现，在读取时不需要锁，写入时只要锁住要修改的单个桶 Java能达到这个标准，但是需要程序员去操作底层的细节才能实现 ConcurrentHashMap类 还实现了ConcurrentMap接口，有些提供了还提供了原子操作的新方法 putIfAbsent() 如果还没有对应键，就把键/值添加进去 remove() 如果键存在而且值与当前状态相等，则用原子方式移除键值对 replace() API 为HashMap中原子替换的操作方法提供了两种不同的形式 例如之前的完全同步类里的公共 Map实现就是HashMap，如果换成ConcurrentHashMap 那些synchronized关键字修饰的方法就可以换成普通方法了 该类不仅提供了多线程的安全性，性能也很好 CopyOnWriteArrayList 标准的ArrayList的替代，通过写时复制语义来实现线程安全性，也就是说修改列表的任何操作都会创建一个列表底层数组的新副本 这就意味着所有成形的迭代器都不会遇到意料之外的修改 （脏读） 这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效。在不能或不想进行同步遍历 当读操作大于写操作会比较好用， 但又需要从并发线程中排除冲突时，它也很有用。“快照”风格的迭代器方法在创建迭代器时使用了对数组状态的引用。此数组在迭代器的生存期内不会更改， 因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。 在迭代器上进行的元素更改操作（remove、set 和 add）不受支持。这些方法将抛出 UnsupportedOperationException。 Queue Queue接口全是泛型的，这样就更为方便， 自己再封装一个层 BlockingQueue&lt;Pro&lt;Author&gt;&gt;123456789public class Pro&lt;T&gt;&#123; private T pro; public T getPro()&#123; return pro; &#125; public Pro(T pro)&#123; this.pro = pro; &#125;&#125; 有了这层间接引用， 不用牺牲所包含类型（Author）在概念上的完整性，就能够添加额外的元数据了。方便统一性的修改 用上额外元数据的用例： 测试： 比如 展示一个对象的修改历史 性能指标： 比如 到达时间，服务质量 运行时系统信息： 比如 Author实例是如何排到队列的 BlockingQueue 并发扩展类， 基本方法 put() 如果队列已满，会让放入的线程等待 队列腾出空间 take() 如果队列为空，会导致取出的线程阻塞 offer() 将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。 当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。 另一个重载方法：将指定元素插入此队列中，在到达指定的等待时间前等待可用的空间（如果有必要）。 poll() 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。 基本实现 LinkedBlockingQueue 看名字就知道实现方式以及优缺点了 ArrayBlockingQueue BlockingQueue 不接受 null 元素。试图 add、put 或 offer 一个 null 元素时，某些实现会抛出 NullPointerException。 BlockingQueue 的实现主要用于生产者-使用者队列 TransferQueue 本质上是多了一项 transfer()操作的BlockingQueue， 如果接收线程处于等待状态， 该操作会马上把工作项传给他。 否则就会阻塞直到取走工作项的线程出现 即 正在处理工作项的线程在交付当前工作项之前不会开始其他工作项的处理工作， 这样系统就可以调控上游线程获取新工作项的速度 用限定大小的阻塞队列也能达到同样的效果，TransferQueue 执行效率更高 但是这个只有链表的实现版本 相比于BlockingQueue 用法一致， offer() 等价于 tryTransfer() 参数也是一致的，代码基本不需要改动 【控制执行】任务建模 要把目标代码做成可调用（执行者调用）的结构，而不是单独开线程运行展示代码 Callable接口 通常是匿名内部实现类 Future接口 用来表示异步任务，是还没有完成的任务的未来结果，主要方法： get() 用来获取结果，如果结果还没准备好就会阻塞直到它能去到结果，有一个可以设置超时的版本，这个版本永远不会阻塞 cancel() 运算结束前取消 isDone() 调用者用它来判断运算是否结束 FutureTask类 FutureTask是Future接口的常用实现类， 并且是实现了Runnable接口。所以提供的方法是俩接口的方法 提供了两个构造器，一个是Callable为参数，另一个以Runnable为参数 可以基于FutureTask的Runnable特性，把任务写成Callable然后封装进一个有执行者地调度并在必要时可以取消的FutureTask ScheduleThreadPoolExecutor ScheduleThreadPoolExecutor 简称 STPE 线程池类中很重要的类 线程池的大小可以预定义， 也可自适应 所安排的任务可以定期执行，也可只运行一次 STPE扩展了ThreadPoolExecutor类，很相似但不具备定期调度能力 STPE和并发包里的类结合使用是常见的模式之一 【分支合并框架】 引入一种新的执行者服务，称为 ForkJoinPool ForkJoinPool 服务处理一种比线程更小的并发单元 ForkJoinTask ForkJoinTask是一种由ForkJoinPool以更轻量的方式所调度的抽象 通常使用两种任务 小型 无需处理器耗时太久的任务 大型 需要在直接执行前进行分解（可能多次）的任务 提供了支持大型任务分解的基本方法，还有自动调度和重新调度的能力 这个框架的关键特性之一就是：这些轻量的任务都能够生成新的ForkJoinTask实例，而这些实例仍然由执行他们父任务的线程池来安排调度，这就是分而治之 工作窃取： 一个简单的例子 由 RecursiveAction 或者 RecursiveTask 派生出来的才能作为任务单元 这俩也是派生ForkJoinTask而来 RecursiveAction 要重写的方法：protected void compute() RecursiveTask 要重写的的方法：protected Object compute() ForkJoinTask里的 invoke 和 invokeAll public final V invoke() invoke 执行此任务的开始，如果有必要，等待它的完成，并返回其结果，或者在底层计算完成时抛出一个(未检查的)RuntimeException或错误。 public static &lt;T extends ForkJoinTask&lt;?&gt;&gt; Collection&lt;T&gt; invokeAll(Collection&lt;T&gt; tasks) invokeAll 方法的特点是多个执行，但是只有其中有一个是出现了异常，就会取消所有的task ForkJoinTask和工作窃取 ForkJoinTask作为RecursiveAction的超类，他是从动作中返回结果的泛型类型，所以这个类扩展了ForkJoinTask 这使得ForkJoinTask非常适合用MapReduce方式（Google踢出的软件架构，用于大规模数据集的并行计算）返回数据集中归结出的结果 ForkJoinTask由ForkJoinPool调度安排，这个池是一个特殊的执行者服务。这个服务维护每个线程的任务列表，并且当某个任务完成的时候， 他能把挂在满负荷线程上的任务重新安排到空闲线程上去 这就是 工作窃取 并行问题 可以使用分支合并方法解决的问题： 模拟大量简单对象的运动，例如粒子效果 日志文件分析 从输入中计数的数据操作，比如mapreduce操作 以下的列表检查当前问题及其子任务是一个切实有效的方法，确认是否能用分支合并来解决问题 问题的子任务是否无需与其他子任务有显式的协作或同步也可以工作？ 子任务是不是不会对数据进行修改，只是经过计算得出些结果？ 对于子任务来说，分而治之是不是很自然的事？子任务是不是会创建更多的子任务，而且他们要比派生出他们的任务粒度更细？ 如果思考的结果是肯定的，就可以适用，如果思考结果是不确定的，用其他的同步方式更合适 【Java内存模型】 Java Memory Model – JMM 同步动作和被称为偏序的数据结构描述JMM， JMM 的主要规则： 在监测对象上的解锁操作与后续的所操作之间存在同步约束关系 对易失性变量的写入与后续对该变量的读取之间存在同步约束关系 如果动作A受到动作B的同步约束，则A在B之前发生 如果在程序中的线程内A出现B之前，则A在B之前发生 前两个简称为先存后取 敏感行为： 构造方法要在那个对象的终结期之前完成（一个对象被终结之前必须已经构造完整） 开始一个线程的动作受到这个新线程的第一个动作的同步制约 Thread.join() 受到被合并的线程的最后一个动作的同步制约 如果X在Y之前发生，并且Y在Z之前发生， 则X在Z之前发生（传递性） 重要概念： 如果对象不可改变，确保改变对所有线程可见的相关问题就不会出现 代码块之间的 之前发生（Happens-Before） 和 同步约束（Synchronizes-With）关系 之前发生 这种关系表明一段代码在其他代码开始之前就已经全部完成了 同步约束 这意味着动作继续执行之前必须把他的对象视图与主内存同步","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"Concurrent","slug":"Concurrent","permalink":"http://blog.kuangcp.top/tags/Concurrent/"}]},{"title":"Java11","slug":"Memo-Java-AdvancedLearning-Java11","date":"2018-12-17T13:25:18.707Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/17/Memo-Java-AdvancedLearning-Java11/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Java11/","excerpt":"","text":"目录 start Java11 安装配置 Linux 新特性 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Java11 Official:doc | Official:apiTool reference 应该就是真正意义上的 Java9 了, 原先发布的 9 和 10 都不是 LTS, 并且很多原先属于9的特性也是推迟到了这个版本 安装配置 Official site Linux123JAVA_HOME=/path/to/java11export CLASSPATH=.:$&#123;JAVA_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 新特性 Official: migrate guide 参考博客: Java 11 Tutorial 参考博客: Java 11 正式发布，带来ZGC、Http Client等重要特性！","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"Java11","slug":"Java11","permalink":"http://blog.kuangcp.top/tags/Java11/"}]},{"title":"Computer.md","slug":"Memo-Skills-CS-Computer","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-CS-Computer/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-CS-Computer/","excerpt":"","text":"目录 start 计算机历史 起源 硬件系统 硬盘 CPU 操作系统 编程语言 语言的的演化 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 计算机历史起源硬件系统 博客:【不周山之读薄 CSAPP】零 系列概览 CSAPP:深入理解计算机系统 硬盘 存储单位 kb kilobyte; kib kibibyte 的区别: wikipedia CPU 码农翻身:CPU阿甘 梳理了CPU 内存 操作系统 BIOS 硬盘之间的关系和特性 操作系统 码农翻身:操作系统是个大骗子？ 描述了程序从硬盘中读取到内存执行的整个过程 编程语言语言的的演化 码农翻身:一个翻译家族的发家史 低级语言到高级语言的演化","categories":[],"tags":[]},{"title":"Platform.md","slug":"Memo-Platform","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Platform/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Platform/","excerpt":"","text":"目录 start 代码托管平台 Gitlab Gitee URL规则 Github URL规则 MarkDown规则 wiki Bandage图标 Gitea 自建 二进制包仓库 代码质量检测平台 codeclimate codebeat codacy 综合开发平台 华为云 阿里云 ECS ACM OSS 百度开发平台 CCE BOS BAE 其他应用 翻译 腾讯 域名 CVM COS 微信公众号 网易 有道智云 微软 翻译 云存储 NextCloud 坚果云 七牛云 智能机器人平台 图灵机器人 评论系统 消息推送 极光推送 GoEasy 文档 文档托管 文档转换 接口平台 今日头条 测试平台 培训 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 代码托管平台Gitlab Site 功能丰富, 集成了 CI/CD, 也能自己搭建 社区版, 免费的私有库, 用于团队协作的功能比较多 Gitee 码云,国内的github 帮助文档 也是有私有库, 但是私有库有数量限制, 不过那个数挺大的, 1000 还是多少, 但是分支图的显示不喜欢, 分支都没有闭合, 真难受 URL规则 HTTPS &amp; SSH HTTPS: https://gitee.com/kcp1104/MythRedisClient.git SSH: git@gitee.com:kcp1104/MythRedisClient.git Github 全球范围性的网站 开发者文档 在github上修改了项目后，或者以后是和别人一起开发，就要先git pull origin （master）将别人的分支和自己的分支都拉下来确保是最新， 再进行git push -u origin master 才能正确提交代码，如果不pull，提交是注定失败的，还会扰乱分支图 少有人知的 GitHub 使用技巧URL规则 github仓库的URL规则 git.io 是短网址服务 HTTP &amp; SSH SSH: git@github.com:Kuangcp/Script.git HTTPS: https://github.com/Kuangcp/Script.git 目录： https://github.com/用户/项目/tree/分支/相对根目录的目录 文本文件： https://github.com/用户/项目/blob/分支/文件目录 二进制文件，例如图片： https://raw.githubusercontent.com/用户/项目/分支/文件目录 例如同仓库下的这个文件/Linux/Docker.md 可以直接这样写，方便调用，最好最前面不要加.这个表示当前目录的 MarkDown规则 更多详情&gt;&gt; wiki 其实也是一个git仓库, 以特定格式进行显示而已 侧栏的目录依赖于 _Sidebar.md 文件其显示规则类似于Markdown语法: 123* [[Introduction|Home]]* Basic Utilities * [[Using/avoiding null|UsingAndAvoidingNullExplained]] 其中 [[名称|URL]] 类似于 URL的md后缀也要去掉,不然就跳转到md文件的源路径了允许md以文件夹多结构的形式存在, 但是最终的目录规则是扁平的, 直接就是文件名,没有目录名 Bandage图标 shields 规则 https://img.shields.io/badge/note-JavaSE-blue.svg 如果是中文则要转码 颜色: brightgreen green yellowgreen yellow orange red lightgrey blue ff69b4 (也就是说可以设置任意颜色) Gitea 官网 自建 使用docker安装比较简单 配置数据库，一定要是外网的。或者容器互联/data/gitea/conf/app.ini Docker中要修改的配置，都是改成对外的配置1234ROOT_URL = http://git.kuangcp.top/DOMAIN = git.kuangcp.topSSH_PORT = 22SSH_DOMAIN = kuangcp.top 然后还需修改本地的SSH配置才能正常使用 二进制包仓库 JFrog Bintray Maven Central Repository 代码质量检测平台codeclimate 官网 要求比较严格, 有详细的说明 codebeat 官网 要求比较严格 codacy 官网 要求比较宽松 综合开发平台华为云 CSE微服务相关文档 阿里云ECS 阿里云主机, 学生有优惠 9.9每月 1核2g 域名因为是兼并了万网，所以功能更强大， 现在还支持搭建免费的DNS服务器了 ACM 应用配置管理 入门文档如何用ACM简化你的Spring Cloud微服务环境配置管理 OSS 对象存储 12345678910111213资费项 计费项 标准型单价 低频访问型单价 归档型单价存储费用 (注①) 数据存储 0.148元/GB/月 0.08元/GB/月 0.033/GB/月流量费用 (注①) 内/外网流入流量（数据上传到OSS） 免费 免费 免费 内网流出流量（通过ECS云服务器下载OSS的数据） 免费 免费 免费 外网流出流量 00:00-08:00（闲时）：0.25元/GB 8:00-24:00（忙时）：0.50元/GB CDN回源流出流量 0.15元/GB 0.15元/GB 0.15元/GB 跨区域复制流量 0.50元/GB 0.50元/GB 0.50元/GB请求费用 所有请求类型 0.01元/万次 0.1元/万次 0.1元/万次数据处理费用 (注②) 图片处理 每月0-10TB：免费&gt;10TB：0.025元/GB 每月0-10TB：免费&gt;10TB：0.025元/GB 无 视频截帧 0.1元/千张 0.1元/千张 无 数据取回 免费 0.0325元/GB 0.06元/GB 百度开发平台 CCE 容器引擎 -&gt; 入门必看其实就是镜像仓库,比阿里云的好用 域名很短 BOS 对象存储 计价方式关于流量定价中的CDN回源流量, 大致是当你开了CDN加速, 然后CDN为了刷新缓存要去你对象存储源获取最新的文件, 这个消耗的流量同样支持文件夹 存储空间价格12计费项 标准存储单价（元/GB/月） 低频存储单价（元/GB/月） 冷存储单价（元/GB/月） 存储空间 0.128 0.08 0.048 请求次数价格123计费项 规格 标准存储单价（元/万次） 低频存储单价（元/万次） 冷存储单价（元/万次） 写请求次数 PUT,COPY,DELETE 0.01 0.25 0.5 读请求次数 GET Bucket,GET OBJECT及其他所有请求 0.01 0.05 0.1 数据取回价格12计费项 规格 标准存储单价（元/GB） 低频存储单价（元/GB） 冷存储单价（元/GB）数据取回 - NA 0.03 0.15 流量价格1234计费项 标准存储 &amp; 低频存储 &amp; 冷存储单价（元/GB）外网数据流出 0.6CDN回源流出 0.14跨区域数据流出 0.6 BAE 应用引擎，简单的说就是一个提供了环境，你只需上传打包好的可执行文件就可以运行起来了本来的话是比较简单容易上手的, 但是现在要备案了, 就玩不了了 短期使用收费没有很高，十分灵活，就是前期学习入门 配置略麻烦。适合演示使用，例如毕设。 并且还提供一定免费额度的 MySQL Redis MongoDb （只能BAE的内网访问） 还有自动测试 其他应用 百度脑图在线思维导图创作 站内搜索不用自己写搜索了 翻译 官网 免费注册, 每月有 2000,000 字符 免费额度 腾讯域名 域名检测工具 CVM 云服务器学生优惠是 10元每月1核1g 60则是2核2g COS 对象存储 官方文档同样的支持文件夹,还可以拖动文件夹上传,算是最好用的一个了 免费额度123456资源类型 资源子类型 每月免费额度存储空间 存储空间 50 GB流量 外网下行流量 10 GB流量 腾讯云 CDN 回源流量 10 GB请求 读请求 100 万次请求 写请求 100 万次 微信公众号2017-12-21 21:41:43 不说了反正都是Shit一样的接口设计和返回值 希望会变好，碰过就不想再弄了！！！ 网易有道智云 官网 微软翻译每月 2000,000 字符免费 文档api定价 云存储NextCloud 当自己具有服务器的时候, 搭建自己的私有云盘 坚果云七牛云 免费存储额度10g流量额度10g, 但是不能创建文件夹 智能机器人平台图灵机器人 评论系统 畅言 消息推送极光推送 官网 做Android IOS的消息推送和短信等推送 GoEasy 示例 文档文档托管 看云 showdoc showdoc开源,也具有Docker方式 | 示例 Docker安装: 官方文档 跑起来也就几十M内存占用 git clone https://github.com/star7th/showdoc 进入项目目录 然后 docker build -t showdoc ./ docker run -d --name showdoc -p 4999:80 showdoc http://localhost:4999/install/ 然后为了保险起见进容器删除项目根目录的install目录即可 数据与备份 Sqlite/showdoc.db.php 是数据库; 如果有图片就还要备份图片,所以解耦就还是不上传图片了 文档转换 pandoc 接口平台今日头条 今日头条灵犬系统 API https://m.toutiao.com/detector/api/detect/?text=URL 测试平台 自动API测试 吆喝科技A/B测试 灰度上线 培训 咕泡看起来很有深度, 就是有点贵 集智","categories":[],"tags":[]},{"title":"SoftwareDesignEngineer.md","slug":"Memo-Skills-SoftwareDesignEngineer","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-SoftwareDesignEngineer/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-SoftwareDesignEngineer/","excerpt":"","text":"目录 start 软考知识点 【1.计算机组成与结构】 【计算机中数据的表示】： 【CPU】： 【存储系统】： 【例题】 【输入输出系统】： 【总线系统】： 【加密算法】： 【补码】： 【访问方式】： 【2.程序设计语言】 【基本概念】： 编译和解释： KMP模式匹配算法： 高级程序设计语言翻译流程： 文法分析： 【考点】：正规式和DFA或NFA的转换 【3.操作系统】 定义 进程管理 存储管理 处理机 设备管理 文件管理 作业管理 【4.软件工程基础知识】 成本估算 敏捷开发方法 【5.系统开发与运行】 【模块】 【测试方法】 【6.网络与多媒体基础知识】近几年没有考题 【硬件设备】 【网络安全】 动画与视频 媒体类型： 【7.数据库技术，基础】 关系模式（不是指表，但是是包含了表，在表的层次以上） 【数据依赖】 【码】 【范式】 闭包 模式分解 【8.算法与数据结构】 【9.面向对象技术】 三大特性 关联关系： 面向对象分析（OOA）： 设计模式【主要分三类】 1.创建型设计模式 2.结构型设计模式 3.行为设计模式 【常见设计模式】： 【10.标准化与知识产权】 标准化 【11.专业英语】 【12.数据流图】 【13.UML设计与分析】 图形元素讲解 UML概念图 【14.数据库设计】 【15.数据结构与算法】 【16.Java程序设计】 大学生们，你们知道软考的意义吗？（转） 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 软考知识点【1.计算机组成与结构】【计算机中数据的表示】： 定点数：所有数据的小数点位置是固定的，小数点位置在数据最高位是定点小数，在最低位是定点整数，会有溢出的情况发生 浮点数：阶符，阶码，数符，尾数 组成， 尾数决定精度，阶码决定数据范围，最适合浮点数阶码的数字编码是移码 数的机器码表示： 原码：符号位表示该数的符号，0正1负 。原码中分+0和-0 反码：符号位表示法和原码一样，正数不变，负数要取反（除掉符号位） 补码：正数和原码相同，负数=反码加一，最适合加减运算的数字编码 移码：在数X上增加一个偏移量来定义的，常用于表示浮点数的阶码部分，如果机器字长n，规定偏移量是2的n-1次方，移码定义：[X移]=2(n-1次方)+X(-2(n-1)&lt;=X&lt;2(n-1)) 校验码： 奇偶检验码：通过在编码中增加一位校验位来使编码中1的个数为奇数（奇校验）偶数（偶校验） 海明码：在数据位中插入k个校验码，通过扩大码距来实现检错和纠错。数据位n 校验位k 2(k次方)-1&gt;=n+k 循环冗余校验码（CRC）:利用生成多项式的k个数据位和产生的r个校验码来进行编码，编码长度是k+r 数制之间转换：2，8,10,16 【CPU】： 运算器：执行所有算术运算，执行所有逻辑运算并进行逻辑测试（与或非，值比较，零值测试） 指令寄存器（IR）：CPU执行指令的时候，先把它从内存中加载到缓冲寄存器中，再送入IR暂存，指令译码器根据IR的内容来产生各种微操作指令 程序计数器（PC）：PC具有寄存信息和计数两种功能，又称为指令计数器。程序执行分为：顺序执行，转移执行。 程序开始执行之前，将程序的起始地址送入PC，该地址在程序加载到内存时确定，因此PC的内容即是程序第一条指令的地址，执行指令时CPU会自动修改PC内容,确保永远是将要执行的下一条指令地址，顺序执行的话，只是简单的加一，转移指令时，指令地址根据当前地址加上一个向前或向后的偏移量得到，或者根据转移指令给出的直接转移地址得到 地址寄存器（AR）：AR保存当前CPU所访问的内存单元的地址。是为了解决内存和CPU速度不匹配的问题 指令译码器（ID）：指令分为操作码和地址码两部分，由该部分进行解析，协调硬件的运行 时序控制逻辑：控制指令的执行时间顺序 总线逻辑：为多个功能部件服务的信息通路的控制电路 中断逻辑：控制各种中断请求，根据优先级来对中断请求排队。逐个交给CPU执行 寄存器组： 专用寄存器，通用寄存器。上面的都是专用的，通用的可以给程序猿控制（提高速度，貌似没卵用） 【存储系统】： 分类： 读写存储器（RAM）： 只读存储器（ROM）： 固定只读储存器（ROM） 可编程的只读存储器（PROM） 可擦除的可编程只读存储器（EPROM） 闪速存储器（Flash Memory） 相联存储器 CAM 按内容寻址的存储器 Cache：高速缓冲存储器：为了解决内存和CPU速度不匹配的问题而存在 地址映像： 直接映像：主存按Cache的大小分成区，每个区的块数和Cache总块数相同，块号相同的映像到Cache中同一个块号那里(多个区中的同号块映像到Cache同号块上) 全相联映像：主存的块调入Cache不受限制（任意位置） 组相联映像：介于全相联和组相联之间 替换算法 随机替换算法 RAND：随机的 先进先出 FIFO : 总是把最先调用的Cache替换出去 最近最少使用 LRU：把当前近期Cache使用次数最少的那块替换出去（先看访问，再看修改状态） 优化替换算法：先执行一次程序统计Cache使用情况，第二次执行程序再选择最优的算法来替换 磁盘： 磁盘存储器：由盘片，驱动器，控制器和接口组成。其存储容量有两种指标：格式化容量和非格式化容量。 非格式化容量 = 面数（磁道数/面）内圆周长*最大位密度 格式化容量 = 面数 （磁道数/面）（扇区数/道）*（字节数/扇区） 光盘存储器：。。。 【例题】内存按字节编址从 A5000H 到 DCFFFH的区域，其存储容量为224KB 若用16K * 4bit 的存储器芯片构成该内存，需要（ 28） 片 （因为位数来计算的4bit的话，前面的单位是减半的,所以最好是使用bit来计算） 解析：DCFFFH - A5000H = 38000H (16进制) 转换成二进制 0011 1000 0000 0000 0000b 去掉十个0 单位就成了kb,然后就是2的5,6,7次方求和 得到224KB 【输入输出系统】：DMA方式： 无需CPU介入，流程：向CPU申请DMA传送，获取CPU允许后，DMA控制器接管系统总线的控制权；过程中不需要CPU结束回到CPU控制 【总线系统】： 内部总线： 用于芯片一级的互联，分为芯片内总线和元件级总线。芯片内总线用在集成多芯片，元件级总线用于一块电路板内元器件的连接 系统总线：插件板一级的互联，用于构成计算机各组成部分（CPU，内存，接口） 外部总线：又称通信总线，用于设备一级的互联，通过该总线与其他设备进行信息与 【加密算法】： 非对称加密的算法中使用了 私钥和公钥，私钥用于解密和数字签名，公钥用于加密和认证证书的真实性 数字证书：CA组织会给用户颁发数字证书， 由CA的私钥进行创建数字证书，数字签名，然后接收方使用CA的公钥来检查其真实性和数字签名（检查文件内容是否被篡改） 【补码】：一般用于浮点数的阶码，简化计算机运算部分设计，因为 符号位可以运算，减作加处理 【访问方式】：寻址方式访问： 直接 ， 顺序 ， 随机 内容方式访问：相联存储器 【2.程序设计语言】【基本概念】：编译和解释： 编译：词法分析，语法分析，语义分析，中间代码生成，代码优化，生成目标代码（汇编语言/机器语言） 解释：分析部分：词法分析，语法分析，语义分析，然后把源程序翻译成中间代码（常用逆波兰表现形式，树，后缀式，四元，三元式） 解释部分：对中间代码进行解释运行 KMP模式匹配算法：求解模式串 p 中的next 函数值next={ 0 ， j=1; max{k|1&lt;k&lt;j,’p 1 p 2……p k-1 ‘=’p j-k+1 …… p j-1’}； 1 ，其他情况（没有符合要求的k）；}假设 p 为 abaabaca 那么函数值为01122341【答案的解释】： j: 1 2 3 4 5 6 7 8 p: a b a a b a c a next(j): 0 1 1 2 2 3 4 1【自己的理解】： 当 j=1 函数值必然是0 当j=2 函数值必然是1 当j=3 比较p1 和 p2 相同就是2 不同就是1 当j=4 比较p1-&gt; 和 和 &lt;-p n-1 假设有m个相同 那么k=m+1,没有则k=1 参数传递（值传递和引用传递）： 高级程序设计语言翻译流程：词法分析，语法分析，词义分析，中间代码重构，目标代码生成（汇编语言，机器语言） 高级程序设计语言使用的语法一般是 上下文无关法 文法分析：是编译的一个理论支持 推导和直接推导————规约和直接规约 相对应的 文法G的开始符号推导出一串字符串，直到终结符，称为句型。只含终结符的句型是一个句子 由开始符号，推导出的所有句子的全体是语言 【考点】：正规式和DFA或NFA的转换DFA：有限自动机 NFA：无限自动机 自动机是用来读取输入的字符串并做对应的操作 自动机 有初态和终态，初态到终态的任意一条路径就是一个完整的字符串 【3.操作系统】定义 分类 批处理 实时 嵌入式 个人 网络 分布式 特性 并发 共享 虚拟性 确定性 资源管理 文件管理 存储管理 处理机管理 设备管理 作业管理 进程管理 同步是进程间的直接制约—：进程合作的等待问题 互斥是进程间的间接制约—：进程竞争一个资源（进程独占） PV操作： 实现进程同步，互斥的常用方法 P操作，S:=S-1 如果S&gt;=0，执行P操作的线程继续执行，否则阻塞 V操作，S:=S+1 如果S&gt;0，执行S操作的线程就会继续，否则从阻塞队列中唤醒一个线程 进程资源图（分辨死锁，线程竞争）灵活辨别是否是安全序列 临界资源值 = 线程数 × ( 最大需求-1) + 1 不发生死锁的临界：即有一个不是阻塞，其他的线程都是只差一个资源（阻塞等待中） 存储管理 分页 分段 页段混合 处理机 图灵机里：有限和无限的区别就是后继码是否唯一，唯一就是有限 要特别注意表达式的写法，一般这种题目看读取字符结尾就可以快速选择答案 设备管理 磁盘读取 SCAN 扫描算法 磁头按当前运动方向，至最大/最小再逆序折回读取（一来一返） CSCAN 单向扫描算法 磁头按当前运动方向，至最大/小，立马到最小/大又按初始的运动方向进行读取（两个单向） 注意：当柱面是一样的时候，比较扇区的顺序 文件管理 位视图存储 概括：用某号物理块除以字长得到第几个字，容量就要再除以物理块的大小再除字长 系统字长x，物理块大小y，那么第z号物理块需要第z/x个字来描述（注意是字长的区间）。容量为w(G) 需要 w×1024/y/x个字来表示 文件索引 分直接索引项，一级间接索引项，二级间接索引项 公式 a位直接，b位一级，c位二级，数据块和索引块大小是dk，每个地址项是e字节，求逻辑块号X区间： 直接 地址索引：0 &lt;= X &lt; a（0开始计数） 一级 地址索引：a &lt;= X &lt; d×1024/e×b+a 二级 地址索引：d×1024/e×b+a &lt;= X &lt; (d×1024/e)^2×c+d×1024/e×b+a 求指向的内存大小： 直接：直接数×数据块大小 a×d 一级：一级数×索引块大小/地址项大小×数据块大小 b×d/e×d 二级：二级数×(索引块大小/地址项大小)^2 ×数据块大小 c×(d/e)^2×d 路径问题 全文件名，从根目录开始加上文件名 eg: \\d\\d\\f.txt 相对路径从当前路径(当前工作目录)开始的路径 eg:d\\ 绝对路径从根目录开始的路径不含文件名 eg: \\d\\d\\ 作业管理 调度级别：高级调度（作业调度），中级调度（交换调度），低级调度（进程调度） 优先级调度算法：将给出的图看成树，左上为根。同层就是并发，父子关系就体现了优先级 【4.软件工程基础知识】 软件生存周期 可行性分析 需求分析：功能，性能，数据，界面 概要设计：分模块，定功能和关系，详细的数据库设计，数据结构设计 详细设计：模块的详细算法设计，数据库的物理设计 程序编码： 软件测试 维护：纠错维护，改错维护 软件生存周期模型 瀑布模型：线性顺序模型，适用于对需求有完善了解，开发周期快 原型/演化模型：通过原型来不断演化 螺旋模型：综合了瀑布和原型的优点，增加了风险分析 增量模型：先发布核心产品，然后根据需求不断增量，调试，直到完善 喷泉模型：面向对象开发过程，以用户需求为动力，以对象为驱动的模型，使开发具有迭代性和无间隙性 V模型：瀑布模型演化而来，强调了软件开发过程中若干个测试级别。 项目管理 启动 度量 估算 风险分析 进度安排 追踪控制 成本估算 估算策略 自顶向下 先确定整体时间，再按模块，分配时间 自底向上 按模块分析需求时间，再向上累积得出全部时间 差别估算 和类似项目比较 估算方法 专家估算 ：专家一人确定 类推估算 ：自顶向下是类似项目总体参数对比，自底向上是两个相似的功能单元对比 算式估算 ：上面两种带有主观性，这个是为了消除主观性 成本估算模型 IBM 基于60项目的静态模型 Putnam（普特南）模型：动态多变量模型 COCOMO模型： 基本COCOMO模型 静态单变量模型 中级COCOMO模型 静态多变量模型 详细COCOMO模型 将系统分为系统，子系统，模块三层次，包含了中级并考虑了软件开发流程中每一步的成本驱动影响 风险分析 风险识别 ： 风险评估 ：成本，进度，性能是三种典型的风险参考水准 风险控制 ： 风险策略管理 避免风险 控制风险 分散和中和风险 转移风险 进度管理 Gantt 甘特图：描述了任务的开始和结束，并行关系，但是不能体现依赖关系 PERT技术： 关键路径是耗时最长的路径 任务松弛时间 = 最迟开始时间 - 任务最早开始时间 最迟开始时间 = 从终点往回推，用最长时间（关键路径耗时）减去终点到该任务的时间 任务的延时，推迟问题。应当计算由于各种原因引起的推迟路径，计算出总时间，减去原时间，不能只看一段。 文档管理 高质量文档 针对性 分清阅读对象，来适应他们需求 精确性 确切的语句，不能有二义性 清晰性 简明，加以图表 灵活性 各个软件项目，规模复杂性有很多差别，但是能一律看待 人员管理 主程序员组 ：住程序员，后备，资料员，若干程序员 无主程序员组 ：相互平等，调动积极性，但是权责问题不明确 层次式程序员组 ：组长，高级程序员，普通程序员。适合大型项目 软件过程管理 UP的结构 初始阶段： 建立商业案例，确定项目边界 精化阶段： 分析问题领域，建立体系结构基础 构建阶段： 剩余的构建和功能开发，集成为产品，此时是beta版 移交阶段： 测试，基于反馈调整，交付系统 敏捷开发方法 极限编程 将项目细分小模块，迭代编写， 先测试再编程 结对编程 水晶法 ： 每一个项目都要有一套不同的策略和方法 并列争求法 ：该方法使用迭代的方法，将30天一次的迭代，称为冲刺 自适应软件开发方法： 1.一个使命作为指导 2.特征视为客户的关键点 3.过程中的等待很重要 4.变化视为实际的调整，不看做改正 5.确定的交付时间，迫使开发人员考虑每一个版本的关键需求 6.风险也在考虑范围内 CMM 能力成熟度模型 五个级别： 初始级 可重复级 已定义级 定量管理级 优化级 CMMI 的任务是将已有的CMM模型结合在一起，构造为集成模型 程序流程图 简单路径：个人看法，看到选择结构就加一，初始是一个路径（输入到输出） McCabe度量法：V(G)=m-n+2p V(G)：路径复杂度 m:所有流程线 n:所有节点数 p:该有向图的强联通分量（图是有几块组成） ISO/IEC软件质量模型中， 可靠性： 成熟性，容错性，易恢复性，兼容性 可维护性： 易分析性：为 判定软件修改所需的努力 易改变性：进行修改，适应环境变化所需的努力 稳定性：与修改造成的风险后果相关 易测试性：与确认修改所需的努力。 【5.系统开发与运行】 软件体系结构风格分类 （1）数据流风格：批处理序列；管道/过滤器 （2）调用/返回风格：主程序/子程序；面向对象风格；层次结构 （3）独立构件风格：进程通讯；事件系统 （4）虚拟机风格：解释器；基于规则的系统 （5）仓库风格：数据库系统；超文本系统；黑板系统 结构化分析和设计 结构化分析方法： 是基于数据流的方法 数据流图 DFD 数据流：箭头表示，数据的流向 加工：圆或圆框，对数据进行处理的单元接受输入数据，产生输出 数据存储：信息的静态存储 实体：矩形，分数据源（源头），数据潭（终点） 数据字典 是以准确的方式定义所有数据流和数据存储，含三类：数据流条目，数据存储条目，数据项条目 加工逻辑描述 也称 小说明，用来描述加工的，加工逻辑即 做什么 数据流图的设计原则 数据守恒原则：任何一个加工，其所有输出的数据都是从输入数据流中获得 守恒加工原则：对同一个加工来说，输入输出的名字必须不同，即使组成成分是一样的 每一个加工必须有输入流和输出流 外部实体和数据存储之间，自身也是，！不能有数据流！ 父图与子图平衡原则：父图子图的输入输出流，必须一致，该原则不存在于一张图 数据流必须和加工有关，必须经过加工 数据流图的顶层数据流图，描述了系统的输入和输出，只有一个加工表示系统 【模块】 模块独立： 耦合：模块之间的紧密程度 聚合：模块内部各元素之间联系的紧密程度 内聚类型（由高到低） 功能内聚：完成一个单一的功能，各个部分缺一不可 顺序内聚：处理元素相同，而且必须顺序执行 通信内聚：所有处理元素集中在一个数据结构的区域上 过程内聚：与处理元素相关，而且必须按待定的次序执行 瞬时内聚：所包含的任务必须在同一时间间隔内执行（初始化模块） 逻辑内聚：完成逻辑上相关的一组任务 偶然内聚：完成一组没有关系或松散的任务 耦合类型（由低到高） 无直接耦合：两个模块没有任何关系 数据耦合：两个模块间只是参数传递简单数据 标记耦合：两个模块都只和一个数据结构有关 控制耦合：两个模块间传递的信息中有控制信息 公共耦合：两个或多个模块，通过引用一个公共区的数据（数据结构和变量）而发生作用 内容耦合：最高的耦合度 当一个模块使用另一个模块内部的控制和控制信息等数据； 一个模块直接转移到另一个模块； 【测试方法】 白盒测试：由低到高 语句覆盖 冒泡排序只要一个用例就可以达到语句覆盖 判定覆盖 条件覆盖 判定/条件覆盖 条件组合覆盖 路径覆盖： 使用 McCabe度量法 计算路径复杂度，一个路径一个测试用例。 但是折半查找最少两个，和流程图无关，因为结果是互斥的 黑盒测试： 等价类划分：将所有可能输入的数据划分为若干子集，然后从每一个子集中选取少数具有代表性的数据作为测试用例 边界值分析 错误猜测 因果图 回归测试：修改了旧代码后，重新测试，确认修改没有引入其他错误或导致原有代码错误 软件测试步骤：。。。。。。 单元测试，集成测试，确认测试，系统测试 软件维护： 改正性维护：修复错误 约占20% 适应性维护：适应环境 约占25% 完善性维护：增加功能，提高性能 约占50% 预防性维护：为以后增加功能准备 【6.网络与多媒体基础知识】近几年没有考题 SO/OSI七层网络体系结构 1979年建立 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 TCP/IP协议： 应用层 传输层 IP层 网络接口层：包含了OSI模型中的数据链路层，物理层 【网络协议】： LAN模型：IEEE802局域网标准，定义了物理层和数据链路层，数据链路层又分两个子层 1. 物理层 LLC ： 提供两种控制类型，面向连接，非连接 MAC ： 控制对传输介 * TCP/IP协议簇质的访问 2. 网络接口层协议：负责管理为物理网络准备数据 IP（网络层）：网络之间互联的协议 ARP/RARP（网络层）：硬件MAC到IP/IP到硬件MAC的转换协议 ICMP（网络层）：网际控制报文协议 TCP（传输层）：传输控制协议 ，可靠的面向连接的服务 UDP（传输层）：用户数据包协议 ，不可靠的面向无连接的 应用层协议：NFS,Telnet,SMTP,DNS,SNMP,FTP 【硬件设备】 物理层互联设备 中继器 Repeater ： 常用于两个网络节点之间物理信号的双向转发工作 集线器 Hub ：对接收到的信号进行再生整形放大，以扩大网络传输距离（是相当于将各个主机直接联通，在逻辑上构成了一个共享的总线，所以就构成了一个广播域，一个冲突域） 数据链路层互联设备 网桥 Bridge ：扩展网络的距离和范围，提高网络性能，可靠性，安全性 交换机 Switch ：基于mac地址的识别，有记录mac地址的地址表（为通信的两台主机建立专用的通道，所以是交换机的没一个接口都是自己的一个冲突域，所有接口和主机构成了一个广播域） 网络层互联设备 路由器 Router ：连接多个逻辑上分开的网络（） 应用层互联设备 网关 GateWay ：当连接不同类型，并且协议差别大的网络时，要选用网关设备 功能：协议转换，数据分组。 DHCP 客户端可以从DHCP服务器，获得DHCP服务器的IP地址，DNS服务器的IP地址，默认网关的IP地址，但是不能获得WEB服务器的IP地址。 NAT桥接：内网主机发送数据时，NAT将源IP从内网转换成外网址。接受数据时将目的IP（外网）转换成内网网址 安全认证： PPP的NCP可以承载多种协议的三层数据包 PPP使用LCP控制多种链路的参数（建立，认证，压缩） PPP中的安全认证类型： pap认证 是通过二次握手建立认证（明文不加密） chap认证 是挑战握手认证，三次握手建立认证（密文采用MDS加密） PPP的双向认证 采用的是chap的主验证风格 PPP的加固认证 采用的是两种 （pap chap）同时使用 无线接口标准 :国际电信联盟，在2000年5月 确定W-CDMA，CDMA2000，TDS-CDMA三大主流无线接口标准 中国独自制定的3G标准是 TD-SCDMA IP地址 IP地址全0是指任意网络，全1是指当前子网的广播地址 【网络安全】 防火墙技术分类 包过滤型防火墙 代理服务器型防火墙 监测型防火墙 防火墙体系结构 包过滤路由器结构 双穴主机结构 屏蔽主机网关结构 被屏蔽子网结构 防火墙的工作模式 透明模式 NAT模式 路由模式 防火墙的安全策略 禁止外部网络ping内部网络 禁止外部网络非法用户访问内部网络和DMZ区应用服务器 禁止外部网络用户对内部网络HTTP、FTP、TELNET、TRACEROUTE、RLOGIN等端口访问 禁止DMZ区的应用服务器访问内部网络 允许外部网络用户使用DMZ区的应用服务：HTTP,HTTPS,POP3 允许DMZ区内的工作站与应用服务器访问Internet 允许内部企业用户访问DMZ区的应用服务：DNS,POP3,SMTP,HTTP,HTTPS,FTP等 允许内部企业网络访问或通过代理访问外部网络 模拟和数字信号的转换：A/D是模拟到数字和D/A 数字到模拟 声音数字化： 采样：把时间连续的模拟信号 转换成时间离散幅度连续的信号 量化：把幅度上连续取值的每一个样本，转换成离散值表示，量化也称A/D转换 编码：数据压缩和编码 图形和图像 色彩三要素：亮度，色调，饱和度 三基色原理：红 绿 蓝 彩色空间： RGB彩色空间： CMY彩色空间： YUV彩色空间： 图形数据的表示： 矢量：用指令描述构成一幅图像 位图：使用像素点来描述 图像的属性： 分辨率：像素数目 图像深度（值域）：确定了图像的每个像素可能有的颜色数，或者确定灰度图像的每个像素可能有的灰度级数。 它决定了彩色图像中的可能出现的最多颜色数，或者灰度图像中的最大灰度等级 真彩色和伪彩色：真彩色是像素值中存有RGB三个分量值，伪彩色是将像素值作为地址索引，在彩色查找表中查找这个像素实际的RGB值 图像的压缩编码：有损（JPEG）和无损压缩 图像文件格式： BMP：windows采用的图像文件格式，采用位映射存储格式，不压缩 GIF：无损压缩算法，可以显示简单动画 TIFF： PCX： PNG：作为GIF的替代品而开发的，压缩采用的是LZ77无损压缩算法 JEPG：有损压缩算法，压缩比例大 Targe： WMF：只在windows中使用，保存的是函数调用信息 EPS： DIF：AutoCAD中常采用 图像的存储 例题：使用150 DPI扫描一幅3×4英寸的图，原始24位的图像占用多少字节 150DPI 表示每英寸150像素点 所以 150×150×3×4×24/8 得到占用字节数 动画与视频 彩色电视的制式：NTCS和PAL，前者用于日美加拿大，墨西哥等，后者用于中国，欧洲，中东 视频文件格式：GIF,FLC/FLI,AVI,.MOV/QT 视频压缩标准：H.261,JEPG,MPEG,DVI 媒体类型： 感觉媒体：使人感觉得到的媒体，音乐，图像等 表示媒体：为加工处理传输感觉媒体而来的一种媒体，例如文本编码，图像编码，声音编码 表现媒体：进行信息的输入输出的媒体：键盘，鼠标，扫描仪，话筒 存储媒体：存储表示媒体的物理介质，硬盘，光盘 传输媒体：电缆，光缆等 通常没有特殊说明的情况下，信息媒体就是指感觉媒体 【7.数据库技术，基础】关系模式（不是指表，但是是包含了表，在表的层次以上） 一个关系模式应该是五元组 R（U,D,DOM,F） R 符号化的元组语义 U 一组属性 D 是属性组U中的属性所来自的域 DOM 为属性到域的映射 F 为属性组U上的一组数据依赖 一般使用三元组 R &lt;U,F&gt; 当且仅当 U 上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系。 【数据依赖】 数据依赖是一个关系内部属性与属性之间的一种约束关系 1.函数依赖 FD 若U的子集X,Y，X和Y形成唯一标识，X函数确定Y，Y函数依赖于X。记X -&gt; Y 非平凡的函数依赖：X-&gt;Y 但是Y不属于X 平凡的函数依赖：X-&gt;Y Y属于X X 称为该函数依赖的决定属性，决定因素 X-&gt;Y 并 Y-&gt;X 则 XY 2.多值依赖 MVD 1.1 完全函数依赖：X-&gt;Y 并且X的真子集D 都存在子集 D不能-&gt;Y。 1.2 部分函数依赖：X-&gt;Y 但是Y不完全函数依赖于X 。 1.3 传递函数依赖：X-&gt;Y（Y不属于X），Y不能-&gt;X， Y-&gt;Z（Z不属于Y）则称Z对X传递函数依赖 【码】 设 K是R&lt;U,F&gt;中的属性或属性组，K能完全函数依赖推出U，则K是R的候选码。 如果上面的K是部分函数依赖，则称K是超码，候选码是最小的超码 主属性：被包含在任一候选码中的属性 非主属性：主属性的补集 全码：所有属性一起构成了码 外码：关系模式R中属性或属性组 X 不是R的码，但是X是另一个关系模式的码，则X是外码 【范式】 应用于关系模式R&lt;U,F&gt; 1NF：每一个分量都是不可分的数据项 2NF：R满足1NF，且每一个非主属性完全函数依赖任何一个候选码 3NF：R满足1NF，R中不存在码X，属性组Y以及非主属性Z（Z不属于Y） 使得X-&gt;Y Y-&gt;Z Y不-&gt;X 则称R是满足3NF（取消了传递函数依赖） BCNF：满足1NF，若X-&gt;Y且Y不属于X时，X必含有码，则R是满足BCNF 所有非主属性对每一个码都是完全函数依赖 所有主属性对每一个不包含它的码也是完全函数依赖 没有任何属性完全依赖于非码的任何一组属性 闭包 在关系模式R&lt;U,F&gt;中为F所逻辑蕴含的函数依赖的全体叫做F的闭包 设F是属性集U上的一组函数依赖，X,Y属于U， ](http://i.imgur.com/pChaMD3.png)={A|X->A} 称为![ 属性集X关于函数依赖集F的闭包 模式分解 具有无损连接性（粗略概述：不减少字段和改变元组） 要保持函数依赖（子模式里满足依赖关系） 既要保持函数依赖性，又要具有无损连接性 通过使用模式分解能提高关系模式能满足的范式等级 【8.算法与数据结构】 考点： 排序算法，查找算法，常用算法，二叉树，图，模式匹配，线性结构，栈，队列，时间复杂度 串的模式匹配： Brute-Force算法 KMP算法 堆串的问题 字符串分串名，串值 串名使用符号表存储 串值使用堆串存储方法 循环队列求下标记得减去总长再对总长取余 二叉树的转换： 【9.面向对象技术】 面向对象 = 对象+分类+继承+用消息通信 对象：对象名，属性，操作 特性：清晰的边界，良好定义的行为，可扩展性 类：对象的抽象 消息：对象之间通信的一种构造（对象调用方法） 三大特性 继承：可分单重继承，多重继承 多态： 参数多态：指同一个对象，函数，过程能以一致的形式用于不同类型 包含多态：子类型化，即一个类型是另一个类型的子类型 过载多态：同一变量被用来表示不同的功能 强制多态：通过语义操作，把一个变元的类型加以变换，以符合函数要求，不强转就会使得函数错误 封装：目的是将定义和数据分离，保护数据不被对象使用者直接存取 重置（覆盖）：指在子类中改变父类中既有函数行为的操作，通过一种动态绑定是的子类继承父类的前提下，用适合自己要求的实现去覆盖父类的实现 重载：子类保留父类的函数名，但使用不同类型的参数 动态绑定：以函数调用和函数本体的关联为基础，绑定动作在运行期才根据对象类型运行。也称后期绑定（应该就是根据参数来判断实例化什么对象或执行对应的方法） 静态绑定：编译过程中，将函数调用与响应调用所需的代码结合的过程 关联关系： 泛化 ： 类和类之间的继承关系，接口之间的继承关系，类和接口的实现关系，泛化关系是从子类指向父类 关联 ： 当一个对象的实例和另一个对象的实例存在固定的对应关系时，关联体现的是两个类或者类和接口之间语义级别的一种强依赖关系，可以单或双向。 聚合 ： 体现的是整体与部分的关系，整体与部分之间是可分离的，他们各自有各自的声明周期，部分可以属于多个整体对象，也可以为多个整体对象共享 组合 ： 也称强聚合，整体和部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束 面向对象分析（OOA）： 1.分析问题域，建立用例模型。 2.发现和定义对象和类 3.识别对象的内部特征 4.识别对象的外部联系 5.识别对象之间的交互 OOA模型（面向对象分析）： 5个层次： 主体层 对象类层 结构层 属性层 服务层 5个活动： 标识对象类 标识结构 定义主题 定义属性 定义服务 OOD模型（对象建模技术）： OOA的五个层次和五个活动贯穿在OOD中 四个活动构成： 设计问题域部件：OOA的结果就是OOD的问题域部件 设计人机交互部件 设计任务管理部件：识别事件驱动任务 设计数据管理部件：目的是隔离数据管理方案对其他部件的影响 【OMT】 OMT模型 对象模型 动态模型 功能模型 模型关系 OMT步骤 分析： 系统设计： 将系统分解成子系统 标识问题中固有的并发性 将子系统分配到处理器和任务 选择数据存储管理的手段 处理对全局资源的访问 选择软件中控制的实现 处理边界条件 设置折中的优先级 对象设计：设计者必须履行一下步骤： 综合考虑三个模型以获得类上的操作 设计实现操作的算法 优化数据访问路径 实现与外部交互的控制 调整类结构以增加继承 设计关联 确定对象表示 将类和关联包装到模块中 实现： 【UML】 事物 结构事物：模型的静态部分，描述概念或物理元素，例如：类，接口，协作，用例，主动类，构件，节点 行为事物：UML模型的动态部分。例如：交互（消息，有向线段），状态机（对象或交互的状态，圆角矩形） 分组事物：模型分解组成的“盒子”，例如：包（概念性，仅存在开发阶段，文件夹图形） 注释事物：UML的解释部分，例如：注解 视图 分为三个视图域：结构分类，动态行为，模型管理 类图（Class Diagram）:展现了一组对象，接口，协作以及之间的关系，作为静态视图，还可以包含依赖，关联，泛化，实现，注解，约束关系等 用例图（Use Case Diagram）：展现了一组用例，参与者以及两者的关系。对系统的静态用例视图建模时，可以分两种方法：对系统的语境建模，对系统的需求建模 构件图（Component Diagram）：展现了一组构建之间的组织和依赖，通常将构建映射一个或多个类、接口或协作 部署图（Deployment Diagram）：体系结构的静态实施视图，与构件图相关，通常一个节点包含一个或多个构件，类似包图 状态图（statechart Diagram）：展现了一个状态机，它由状态，转换，事件和活动组成，一般是分析一个对象,强调对象行为的事件顺序。 状态图中的状态包括状态名、内部活动、内部转换、入口和出口动作等部分 活动图（activity Diagram）：特殊的状态图，展现了系统从一个活动到另一个活动的流程 交互图 ：顺序图和协作图均被称为交互图 顺序图强调消息时间序列 系统的动态方面建模 对象图 （Object Diagram）：静态的实例，一组对象以及它们之间的关系 一般包括对象和链 设计模式【主要分三类】1.创建型设计模式 抽象了实例化过程，它们帮助一个系统独立于如何创建，组合和表示它的那些对象。 一个类创建型模型使用继承改变被实例化的类，而一个对象创建型模型将实例化委托给另一个对象 将一组固定行为的硬编码转移为定义一个较小的基本行为集，这些行为可以被组合成任意数目的更复杂性的行为。这样创建有特定行为的对象要求的不仅仅是实例化一个类 12- 生成器 Builder，是一种对象构建模式，模式通常包含Builder，ConcreteBuilder。Director 和 Product四部分- 2.结构型设计模式 适配器(Adapter)模式，桥接(Bridge)模式，组合(Compontent)模式，代理(Proxy)模式，享元(Flyweight)模式，Facade模式，装饰(Decorator)模式，命令(Command)模式，状态(State)模式 结构型设计模式涉及如何组合类和对象以获得更大的结构 结构型模式采用继承机制来组合接口或实现。 结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能 Composite模式它将对象组合成树形结构以表示“部分-整体” Flyweight模式该模式为共享对象定义了一个结构，强调对象的空间效率，自由共享 Facade模式（外观模式）描述了如何用单个对象表示整个子系统（外部与其内部通信必须通过一个统一的对象进行交互），模式中的facade用来表示一组对象，外观设计模式提供一个高层次的接口是的子系统易于使用。适用情况: 1.为复杂的子系统提供一个简单的接口 2.客户程序与抽象类的实现部分有很大依赖性 3.构建一个层次结构的子系统时，适用外观模式定义子系统每层的入口 Bridge模式 将对象的抽象和实现分离，从而可以独立的改变他们。 Decorator模式描述如何动态地为对象添加职责，模式采用递归方式组合对象，从而允许添加任意多的对象职责。 3.行为设计模式 行为设计模式涉及算法和对象间职责的分配，行为模式描述对象和类的模式以及其通信模式 行为模式使用继承机制在类间派发行为 【常见设计模式】： 适配器 模式（Adapter）：适配器是的一个接口与其他接口兼容，从而给出了多个不同接口的同一抽象。一般分类结构和对象结构两种： 类适配器：适配器类继承被适配类，实现某个接口，在客户端类中可以根据需求来建立子类 对象适配器：适配器不是继承，是使用直接关联，或称委托方式 中介者 模式：包装了一系列对象相互作用的方式，使得对象间的相互作用是独立变化，但是与中介者紧密联系 观察者 模式 Observer：一个目标物件管理相依于它的管理物件，并且在它本身的状态发生改变时发出通知，这种模式常用来实现事件处理系统。（也称发布-订阅，模型-视图，源-收听者模式） 观察者（接口）：更新信息，展示信息，给 被观察者（形参） 注册上观察者 被观察者（接口）：发出更新通知（遍历观察者集合并注册），当自身发生改动时发出通知消息 单例模式 Singleton 一个类只有一个实例易于外界访问 装饰器模式 创建一个新类为某一个类动态添加新功能或增强原有的功能，避免代码重复或具体子类的数量增加 策略模式 优点：灵活添加同一问题的不同解决方案 状态模式 允许对象在内部状态时变更其行为，并且修改其类： 环境类（Context）：定义客户感兴趣的接口，维护一个子类的实例，这个实例就是当前状态 抽象状态类（State）：定义一个接口以封装与Context的一个特定状态相关的行为 具体状态类（concreteState）：每一子类实现与Context的一个状态相关的行为 例题：纸巾售卖机:有四个状态! 【状态图】 【类图】 例题：TCP连接状态: 命令模式 command： 行为请求者 与 请求实现者 之间 紧耦合 的关系 将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化，支持可撤销的操作 下例：使用了接口来实现多态，子类是多个的，方法同名并功能多样的 代码复用好，代码结构清晰【参数类表最好不要出现标志变量，最好分离出另一个方法】 桥接模式 ： 便于扩展，实现与抽象分离（解耦）对一个模块修改不影响别的模块 抽象工厂模式 ： 提供一个创建一系列相关实例相互依赖的对象。 当一个系统要独立于它的产品的创建，组合和表示时 当一个系统要由多个产品系列中的一个来配置时 当需强调一系列相关的产品对象的设计以便进行联合使用时 想提供一组对象而不显示他们的实现过程，只显示他们的接口 原型模式 ： 对象创建模型： 允许一个对象创建另一个可定制的对象，封装实例化细节。 实现Cloneable接口（Java自带接口），重写clone方法（在这里实例化对象，new或反射，按需求来修改） 该例，组合关系，在对方使用clone来代替构造器来实例化对象，并做好了绑定操作，大量减少代码量 生成器模式： 【10.标准化与知识产权】标准化 标准分类 按适用范围：国际标准，国家标准，行业标准，企业标准，项目标准 按性质分类：技术标准，管理标准，工作标准 对象和作用：基础标准，产品标准，方法标准，安全标准，卫生标准，环境保护标准，服务标准 法律约束力：强制性标准和推荐标准（一般是加上T） 知识产权：分两类 工业产权： 专利，商标，厂商名称，服务标记，实用新型，工业品外观设计，原产地名称，制止不正当竞争等内容 著作权：指作者对其创作的作品享有的人身权和财产权。人身权包括发表权，署名权，修改权和保护作品完整权等；财产权包括作品的使用权和获得报酬权 知识产权的特点： 无形性，双重性，确认性，独占性，地域性，时间性 计算机软件著作权 主体和客体：主体是指享有著作权的人，客体是计算机程序及其相关文档 受保护的条件 独立创作：开发者独立开发完成，复制和抄袭的作品不得获得著作权 可被感知：作品应当是作者的创作思想在固定载体上的一种实际表达 逻辑合理 著作权的权利： 计算机软件著作人身权：发表权和开发者身份权 财产权：使用权，复制权，修改权，发行权，翻译权，注释权，信息网络传播权，出租权，使用许可权和获得报酬权，转让权 软件合法持有人的权利： 根据需要把软件装入计算机等储存设备中；根据需要进行必要的复制；为了防止复制品损坏，制作备份复制品；为了把该软件安装于计算机做的必要的修改 计算机软件著作权的保护期：自开发完成之日计算 50年 【11.专业英语】 【12.数据流图】 主要 看细心，业务逻辑不能分析错误 要看清楚所有出现的业务名词或 对存储的读写 不能有一个遗漏 确定数据流的起点和终点，一般存储都是叫做**表 子图里 存储必须要有读和写 缺一不可 注意实体是不能写错的，一般是人（某职位） 【13.UML设计与分析】 题目套路： 第一题：读懂题目，搞定逻辑和业务流程，填补类图，填多重度等（类模型看参数及关联推断类名和关系（特殊的：聚合，泛化），切记不能随便填类名） 第二题：填流程图，用例图（突破口：特殊关系：泛化，组合），等 第三题：优化，分析，模式优化，添加功能，模式等（概念题） 注意 书写规范，看清题意 候选类的选择 使用了良性原则： 不会在实际中造成危害的依赖关系，都是良性依赖 候选类的删除 使用了接口隔离原则（ISP）： 不应该强迫类实现依赖于他们不同的方法（不需要的方法不实现） 图形元素讲解 用例图： 消息传递：实线箭头 关系（类图） 依赖：虚线箭头 （线上方可能注明：include-包含，extend-扩展，bind-绑定，friend-友元） 关联：实线（双向）实线箭头（单向） 看成数据通道 聚合：空心菱形实线： 对象做另一个对象的成员 菱形是整体方 组合：实心菱形实线： 泛化：实线空心箭头（可理解为继承） 实现：虚线空心箭头 多重度：考虑时要从对方的角度考虑自己的数量应该是什么范围 【0..1】 : 0或1 【 1 】 ：只有一个 【0..*】 ： 0或更多 【 * 】 ： 0或更多 【1..*】 ：1个或更多 UML图 元素说明 关系图 关联图 示例图 顺序图 顺序图和用例图 状态图 活动图 活动图关系 构件图 部署图 部署图关系 外链博客： 一.用例图_1 || 用例图_2 二.类图_1 || 类图_2 三.序列图 四.状态图 理解九种图 状态图： UML概念图 有点像ER图，也是描述了实体之间关系（有一对多等关系），有面向对象特有的关系 【14.数据库设计】 考试套路： 1.补全ER图 2.补全关系模式指明主外键 3.添加一个实体，或修改关系模式。或者优化 考点： ER图的补充，主外键的确定，业务关系的正确具体分析，模式优化（模式分解） 注意：给出的ER图是不全的，可能还会少实体，关系 一定要仔细检查大段的说明文字，不能遗漏关系，字段等 ER图 【15.数据结构与算法】 【16.Java程序设计】 一般考的是设计模式直接应用于代码上，一年一个模式:要注意根据对应的设计模式的精神，来考虑代码的安排 特别注意abstract的使用，在方法，类的修饰上 写属性不要忘记数据类型，权限修饰符最好写上 由子类或实现类来推断出，上层类/接口的方法和具体实现 大学生们，你们知道软考的意义吗？（转） 作者： 顾若赵 职称评定——关卡重重路艰难 很早以前就听说计算机行业中，获得“系统分析员”(以下简称系分)称誉是从业人员的最高境界，但直到2004年年初，我才比较深入地了解了我国的系分和软考(计算机技术与软件专业技术资格(水平)考试)，并于同年以实际行动参加了该项考试，幸运地获得了国家颁发的“系统分析师”资格证书。 我在IT界摸爬滚打近十年，其间开发过电脑主机板，调试过汇编程序，写过Fortran、C、Java代码，设计过方案，管理过项目，安装过网络主机，维护过网站，带领过团队，几乎所有IT岗位我都蹲过，但却没有参加过任何国家认证考试。 2003年，我决定参加高级工程师职称评定，为此我在核心期刊上发表了3篇论文并通过了职称英语考试。9月份开始准备申报材料，却意外地得知我还要通过计算机应用能力考试才有资格参加社会化评审，原因仅仅因为我不是计算机专业科班出身！ 当我参加了计算机应用能力考试之后，我的一位朋友告诉我：“可能今年你也评不了职称，因为计算机专业职称不评了，需要参加计算机考试。”我说：“我考了，WORD模块，刚拿的证。”他说：“两回事，你知道软考吗？” 随后，我仔细研究了后来改变了我命运的那份文件——关于印发《计算机技术与软件专业技术资格(水平)考试暂行规定》和《计算机技术与软件专业技术资格(水平)考试实施办法》的通知(俗称人事部39号文)，其中第十条：通过考试并获得相应级别计算机专业技术资格(水平)证书的人员，表明其已具备从事相应专业岗位工作的水平和能力……取得高级资格，可聘任高级工程师职务。第十一条：计算机专业技术资格(水平)实施全国统一考试后，不再进行计算机技术与软件相应专业和级别的专业技术职务任职资格评审工作。果然，要想获得高级职称资格，就得真刀实枪地参加全国统考，而不用费尽心机地准备什么论文、评审材料，还要找关系与评委混个脸熟，还可能因为名额限制等原因，为此奋斗好几年。 这真是太好了！我兴冲冲地在考试报名截止日期当天报了名。 软考大纲——覆盖面广含金高 等我开始静下心来阅读高级资格(系统分析员)考试大纲时，心差点凉了半截！这个系分的考试内容覆盖了在学校学过、报刊上看过、工作中实践过的几乎所有IT知识，而且还包括高等数学、线性代数、离散数学等早已遗忘的理论知识！不仅如此，考试还是个“体力”活儿，需要在一天内完成三场考试：第一场150分钟，考综合知识；第二场90分钟，考案例分析；第三场120分钟，考专业论文。 看来，要想通过考试拿到职称资格，也并不轻松！ 上网检索有关系分和软考的信息，了解到软考是国家人事部和信息产业部组织的国家级考试，目前每年举行两次。考试的级别包括：程序员、软件设计师、网络管理员、网络工程师、数据库工程师、软件评测师、信息系统监理师、信息系统项目管理师、系统分析员等20个资格。从1990年开始，软考就成为国家级考试。软考现已纳入全国专业技术人员职业资格证书制度的统一规划，从2004年1月1日开始，全国不再进行相应专业技术职务任职资格的评审工作。报考任何级别不需要学历、专业、资历条件，实现了“以考代评”，不拘一格选拔人才！ 业界的一个共识是，经过十多年的发展，软考不仅为国家和社会选拔了大量的符合岗位需求的计算机软件人才，而且规范和引导了IT行业从业人员的知识结构。 而网上热点话题包括软考含金量高、软考通过率低、中日软考互认等，印象最深的是某位网友经过统计得出“2002年前，获得系统分析员证书的不超过千人”的“恐怖”结论，甚至许多人把参加软考当作一种“人生挑战”。 根据考试大纲内容，我找来了官方教程以及大量的相关书籍(离散数学、线性代数、计算机原理、网络原理、软件工程等等)，每天抽出时间阅读几个小时以上，有空就上网快速查找最新的计算机和软件知识。刚开始还感觉枯燥，几天后，却变得有些兴趣盎然，觉得有时间系统地看看书的感觉真好，那段时间就像一首歌唱的那样：痛，并快乐着！ 考证虽是我的初衷，但是在软考大纲的指导下，有条理地理顺知识结构、总结并融会贯通理论知识与实际经验，找回因多年忙碌工作而产生的与新知识之间的落差，即使不能通过考试，也是非常有意义的收获。心态放平和了，轻装上阵。 2004年5月23日，我踏入软考考场。考场秩序井井有条，感觉就像高考。后来，这日子印在了我的高级资格证书上，让我终身难忘。我认为：十年的工作积累非常重要，没有那些实践，这次通过高级资格考试简直是天方夜谭，也许这就是平时所谓的厚积薄发吧。 软考作用——内涵丰富意义深 细细体味，感慨颇多，软考决不只是单纯的职称考试。它的内涵非常丰富。 计算机产业是个变化非常快的产业，新技术、新产品层出不穷，可谓“过尽千帆皆不是”、“大浪淘沙始见金”，但万变不离其宗。软考的诞生、快速发展，正是源于计算机产业的这个特点，同时又满足了资格评定、水平测试的社会与心理需求。 在熟悉软考的日子里，我切实体会到，软考考试内容以计算机、软件专业的基本理论为“纲”，以新技术应用为“目”，命题灵活，不拘泥于具体产品和技术实现，其中又体现出优美的计算机文化和计算机“哲学”。 软考的考试大纲是根据一般IT企业的岗位需求，经过科学分析、综合制定的，因此软考非常注重对实践技能的考核，使得用人单位可以据此合理配置其人力资源。 软考各级证书(包括高级)获得者中，有一些还是正在苦读或刚刚毕业的大学生，这无疑大大增加了他们的就业竞争筹码，或者说，大学生可以将软考考试内容作为梳理其理论知识并弥补其实践经验不足的指南。 软考能够很好地反映出工作多年的专业技术人员的知识、经验和积累，是对技术人员能力的一个很好鉴定，同时也为大家学习、更新知识提供了一个系统的参考。 软考对我国IT业的贡献，是提供了一个公开、量化、中立、一致的全国统一标准的评估手段，比较科学地反映了专业技术人员的理论与应用水平。 它不仅帮我圆了“高工”梦，客观上还规范、系统化了我的知识体系，让我对自己有了新的评价，新的起点！ 许多考生对软考是又爱又恨，“梅花香自苦寒来”，想要通过软考以实现自我价值，确实需要花一定功夫，但功夫不会白费。套用电视剧中的一句话，颇能反映许多考生对软考的感情： “如果你恨他，让他参加软考；如果你爱他，让他参加软考！”","categories":[],"tags":[]},{"title":"Project.md","slug":"Memo-Book-Work-Project","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Book-Work-Project/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Book-Work-Project/","excerpt":"","text":"目录 start 工程相关 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 工程相关The cathedral and the bazaar","categories":[],"tags":[]},{"title":"NetworkBooks.md","slug":"Memo-Book-CS-NetworkBooks","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Book-CS-NetworkBooks/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Book-CS-NetworkBooks/","excerpt":"","text":"目录 start 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Real time Webservice webapi的设计与开发 网络是怎样连接的","categories":[],"tags":[]},{"title":"Algorithm.md","slug":"Memo-Book-CS-Algorithm","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Book-CS-Algorithm/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Book-CS-Algorithm/","excerpt":"","text":"目录 start Algorithm 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Algorithm算法的乐趣 算法导论(英文原版更好) 算法 official site Github:TheAlgorithms 有各种编程语言的算法实现","categories":[],"tags":[]},{"title":"Website.md","slug":"Memo-Website","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Website/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Website/","excerpt":"","text":"目录 start 常用的网站 软件下载站 国内镜像源站点 镜像站点 特别网站 库托管 社区网站 娱乐 资源网 字典网站 图书馆 学习网站 并发 语言 Java Python Erlang Elixir Go Git Github相关 持续集成 前端 素材网 web站点分析 人工智能 在线工具 工具软件 IDE VCS 网络 穿透工具 抓包工具 Web服务器 镜像 安全 授权 构建工具 文档处理 UML Log文件 异步 响应式 Database 前端 富文本编辑器 模拟器 Other 安卓手机 Google 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs 常用的网站软件下载站 https://en.softonic.com/windows软件居多 VirtualBox和VMWare的镜像网 安卓在X86设备上的ISO下载 国内镜像源站点 网易下载系统是 *-cd 的文件 清华大学 中科大中国科学技术大学 各大Linux发行版以及一些开源软件 浙江大学 阿里云 开发资源 OS镜像 Linux运维派 sourceforgeLinux发行版列表 程序员应该访问的最佳网站中文版 mycat镜像站 镜像站点 Google 1 2 3 特别网站 ping domain true ip 测试你当前连接用的是ipv4还是ipv6 badge网站 工信部备案查询 亲戚关系计算器项目 程序员的导航页 代码时间 访谈类语言节目 云收藏SpringBoot搭建的收藏夹服务 ce安全网没事看看这个网站, 提高安危意识 schacon.github.io dictionary 学术搜索 habitica通过游戏的方式激励完成个人日常任务 手机参数对比网站 文档汉化 库托管 libraries.io 社区网站 掘金门户网 吾爱破解 解道 http://www.importnew.com小众? http://www.cnblogs.com http://blog.csdn.netCSDN 人数似乎比较多, 解决问题方案比较多 http://www.infoq.com/cn/infoQ 比较有深度 https://www.oschina.net/开源中国 软件的资讯比较多 码农网看起来是有些深度的, 有时间就看一看 10条有一些深度系列文章 内存溢出网内存溢出网 并发编程网大佬和深度好文 深度开源 安卓居多 dockone主要讨论容器技术 Spring4AllSpring国内社区 IBM 开发社区 daocloud社区 techug.com技术博客 娱乐 数字尾巴 小清新的数字技术 粤语影院 资源网 脚本之家用windows的时候一直以为是下盗版软件的地方, 现在才知道还有各种编程学习资源 河东软件园和上面一样 搜网盘 字典网站 参考博客: 搜索列表 海词词典 汉典 英文字典 https://www.merriam-webster.com https://www.dictionary.com 图书馆 维基教科书 学习网站 杭电ACM题库 hackerrank leetcode 中国 lintcode 并发 并发编程网 http://ifeve.com IBM社区 MDN web docs火狐社区的关于Web的文档 语言Java 传智播客Activiti工作流视频教程 免费全套 5.4 视频 maven在线训练网 teavm将字节码转译成js Python 廖雪峰Python3 Erlang Erlang Elixir 官网 Go go 在线编译执行 学习go 在线编辑运行 Git 廖雪峰学习网站 Github相关 Github-page优秀示例大厂的网页 持续集成 国内一个产品 | 文档 前端 json.cnjson工具 pixlr简直神器啊, 在线使用PS, woc!!! PS在线工具功能有限,也可以玩玩 bootcdn 常用js css的cdn 填充图 jshell可以在线练习HTML CSS Js 素材网 色码表 素材之家 web站点分析 网站性能分析十分详细 人工智能 AlphaGo学习网站 比较神秘的网站该人建站很久, 发表记录自己的看法 关于智能 在线工具 开源中国 脚本之家 tool.lu小而全 工具软件IDE IDEA lanyus Eclipse 中科大eclipse镜像源 VCS SVN subminSVN管理的Web界面 git 最好用的vcs 自建Git服务 gogs 自建git服务器 gitea gogs加强 docker安装 网络穿透工具 lanproxy 将局域网个人电脑、服务器代理到公网的内网穿透工具 ngrok随机域名到穿透到内网 eg: ngrok http 8080 frp自己服务器外网到内网穿透 下载地址使用帮助 抓包工具 whistle nodejs 平台的抓包工具 fiddlerwindows平台抓包工具 charles跨平台收费 咳咳 Web服务器 tomcatApache基金会 jettyEclipse基金会 undertow 轻量高可用 镜像 浙大镜像工具 安全授权 jwtJSON WEB TOKEN 构建工具 Maven service.gradle.orgOfficial download gradle-tomcat-plugingradle中tomcat插件 sbt 文档处理 Gitbook gitbook-useGitbook的使用 pandoc 一个文档格式转换的软件，markdown docx retextmarkdown书写软件 API文档管理 UML 免费UML软件统计 博客 bouml 官方网站下载 argouml argouml官网 Log文件 方便的查看Log文件 otroslogviewer chainsaw vigilog 异步 dwrJs调用Java方法并拿到返回值 响应式 vertx构建响应式应用程序 Database sssdb 键值对数据库 MySQL官方下载地址 Mysql-Font 连接Mysql的客户端 HeidiSQL十分好用 sqlectron 简单直观的数据库图形化软件 前端 Framework7开发类似ios7的web应用（HTML） Bootstrap LayUI Hotkeys前端捕获按键输入,可以用来设置快捷键 socket.io基于nodejs的socket技术 h-ui 富文本编辑器 wangeditor富文本编辑器 ckeditor开源中国在用的富文本编辑器 github地址 模拟器 genymotion 安卓模拟器 Other crashJava中的Shell环境 安卓手机Google google安装器","categories":[],"tags":[]},{"title":"GitBase.md","slug":"Memo-Skills-Vcs-GitBase","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Vcs-GitBase/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Vcs-GitBase/","excerpt":"","text":"目录 start Git基础 Git常用命令 fork相关操作 仓库基本命令 config status rm commit remote submodule show push log 对比两个分支的差异 查看文件的修改记录 diff tag 分支操作 stash clone branch checkout fetch pull merge rebase grep 常用文件 .gitignore gitattributes Tools git-svn Submodules 各个VCS工具的区别以及优缺点 Git SVN repos的使用 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs Git基础 Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. – git-scm.com Github:gitofficial doc: gitGitee: about gitGit官网中文教程 | 对应的仓库 index stage work 三个概念上的区域 index 已经 commit 的内容, 不可更改历史commit stage 执行 add 命令, 将文件缓存到该区 work 默认目录, 修改的就是该分区 Git常用命令 git-tips学习Git的仓库git权威指南的组织完整书籍,以及相关测试题 使用原理视角看 Git如何高效地使用 Git 参考博客: 重看”Linus Torvalds on Git”视频GUI客户端 tig tig命令，git的加强版 fork相关操作 在 Github Gitee Gitlab 等平台, 命令的方式管理fork的仓库 其实可以把别人的fork或者原仓库, 当成一个分支就行了, 将分支关联远程URL即可: –set-upstream 参数 然后就能下拉 合并别人的仓库了 如果没有一个Github 码云这样的平台, 而只是单独的两个点, 两个用户或者IP之间要使用同一个仓库进行开发两个人互为对方的远程库, 互为服务器即可完成, 即使使用的是动态IP, 应该也不会受太大影响??? 仓库基本命令 使用 git help 加上命令, 就能看到命令对应的文档 config git config user.email *** 和 git config user.name *** 这两个是必须的， 如果想统一配置不想每个仓库单独配置就 git config --global user.name email同理 git config http.postBuffer 524288000 设置缓存区大小为 500m git config core.fileMode false 忽略文件的mode变化，一般发生在文件放在挂载盘的时(默认755) [ ] 自己整理下配置项 参考博客: CRLF和LF参考博客: git 换行符LF与CRLF转换问题 status git status –help 查看详细介绍 -s --short 简化输出 ?? 表示新添加未跟踪 A 新添加到暂存区 M 修改过的文件 MM 修改了但是没有暂存 rm 删除文件 git rm 文件 从git仓库中删除文件, 但是文件系统中保留文件 git rm --cached 文件 如果仅仅是想从仓库中剔除, 那么执行完命令还要在 .gitignore 文件中注明, 不然又add回去了 commit 官方文档 git commit -am &quot;init&quot;: a git库已有文件的修改进行添加, m 注释 git add * 如果有新建立文件就要add 再之后commit就不要a参数了 git commit -m &quot;&quot; 如果只是修改文件没有新建 git commit -am &quot;&quot; git commit 会自动进入VI编辑器 第一行：用一行文字简述提交的更改内容 第二行：空行 第三行：记述更改的原因和详细内容 使用下面方法关闭退出 --amend 追加文件到上次commit Official Doc 如果上次提交漏了文件, 只需把漏的文件加入到 index区中, 然后执行 git commit –amend 即可 remote 官方文档 常用参数 add name URL地址 添加远程关联仓库 不唯一，可以关联多个, 一般默认是origin set-url name URL地址 修改关联仓库的URL rm URL 删除和远程文档库的关系 rename origin myth 更改远程文档库的名称 show origin 查看远程分支的状态和信息 删除远程库某分支git push 远程名称 --delete 分支名称 git ls-remote 显示本地仓库跟踪的那个远程仓库 git remote -v 查看关联远程仓库的详情(push和pull的地址) 删除，重命名远程分支 submodule 子模块 学习 show 展示提交信息 显示当前提交的差异 git show HEAD HEAD替换成commit的sha值就是显示指定提交的修改 git show -h 查看更多 push 常用参数 -h 查看所有参数和说明 -q 控制台不输出任何信息 -f 强制 使用这个参数时要再三考虑清楚 --all 推送所有引用 -u upstream 设置 git pull/status 的上游 git push origin master和git push -u origin master 区别在于 前者是使用该远程和分支进行推送 后者也是推送, 并设置origin为默认推送的远程, 以后push就不用注明远程名了(多远程的情况下要注意) -d 删除引用 --tags 推送标签（不能使用 –all or –mirror） 出现 RPC failed; result=22, HTTP code = 411 的错误 就是因为一次提交的文件太大，需要改大缓冲区 例如改成500m git config http.postBuffer 524288000 提交本地所有分支 git push --all pull时同理 删除远程分支 git push 远程名称 --delete 分支名称 第一次与远程建立连接 git push -u origin master | git push --set-uptream master | git push -all 这几个都是可以的,最后那个简单, 还能将别的分支一起推上去 log 更多说明 查看 git help log | Official Doc -p 显示每次提交的内容差异 git log -p -2 仅显示最近两次提交的差异 查看每一次提交的修改内容 --stat ---pretty=[online/short/full/fuller/format] 使用预定义格式显示 format 是可以自定义格式和占位符 图形的样子显示分支图 --graph 显示每个分支最近的提交 --simplify-by-decoration git log --author=&#39;A&#39;输出所有A开头的作者日志 git log 文件名 文件名 输出更改指定文件的所有commit 要文件在当前路径才可 git log --after=&#39;2016-03-23 9:20&#39; --before=&#39;2017-05-10 12:00&#39; 输出指定日期的日志 git shortlog 按字母顺序输出每个人的日志 --numbered 按提交数排序 -s 只显示每个提交者以及提交数量 彩色输出Log12345alias glogc=\"git log --graph --pretty=format:'%Cred%h%Creset %Cgreen%ad%Creset | %C(bold cyan)&lt;%an&gt;%Creset %C(yellow)%d%Creset %s ' --abbrev-commit --date=short\" # 彩色输出alias gloga='git log --oneline --decorate --graph --all' # 简短彩色输出alias glo='git log --oneline --decorate' # 最简单alias glol='git log --graph --pretty='\\''%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'\\'alias glola='git log --graph --pretty='\\''%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'\\'' --all' 对比两个分支的差异 参考博客 查看 dev 有，而 master 中没有的 git log dev ^master 反之 git log master ^dev 查看 dev 中比 master 中多提交了哪些内容：git log master..dev 不知道谁提交的多谁提交的少，单纯想知道有什么不一样：git log dev...master 在上述情况下，再显示出每个提交是在哪个分支上:git log --left-right dev...master 注意 commit 后面的箭头，根据我们在 –left-right dev…master 的顺序，左箭头 &lt; 表示是 dev 的，右箭头 &gt; 表示是 master的。 查看文件的修改记录 git log fileName 或者 git log –pretty=oneline fileName 更容易看到 sha-1 值 git show sha-1的值 就能看到该次提交的所有修改 diff 默认是将 work 区 和 index 区 进行比较 --cached stage 区 和 index 区 进行比较, 等同于--staged 12345git diff [options] [&lt;commit&gt;] [--] [&lt;path&gt;...]git diff [options] --cached [&lt;commit&gt;] [--] [&lt;path&gt;...]git diff [options] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;...]git diff [options] &lt;blob&gt; &lt;blob&gt;git diff [options] [--no-index] [--] &lt;path&gt; &lt;path&gt; Github:diff-so-fancy一个更方便查看diff的工具 最简单的就是 npm install -g diff-so-fancy 安装 tag Official Doc 查看所有标签 git tag -l &#39;v1.0.*&#39; 列出v1.0.* 展示标签注释信息 git show tagname 新建一个标签并打上注释 git tag -a v1.0.0 -m &quot;初始版本&quot; 由指定的commit打标签 git tag -a v1.2.4 commit-id 切换标签 git checkout tagname 和切换分支一样的，但是标签只是一个镜像，不能修改 如果要在某tag上新建一个分支， git checkout -b branchname tagname 提交指定的tag git push origin tagname （默认不会自动提交标签） 提交所有的tag git push --tags 删除本地标签 git tag -d tagname 删除远程的tag git push origin --delete tag &lt;tagname&gt; 分支操作 git checkout -b feature-x develop 从develop的分支生成一个功能分支，并切换过去 完成功能后：git checkout develop 合并： git merge --no-ff feature-x 删除： git branch -d feature-x git checkout -b release-1.2 develop 新建一个预发布分支 git checkout master 确认没有问题后 git merge --no-ff release-1.2 合并到master分支 git tag -a 1.2 打标签，这就是github上软件的版本控制 没有问题后 合并到develop分支git checkout develop git merge --no-ff release-1.2 删除预发布分支 git branch -d release-1.2 git checkout -b fixbug-0.1 master 新建修复bug的分支 git checkout master `git merge –no-ff fixbug-0.1 git tag -a 0.1.1` 修补结束后合并到master分支 git checkout develop git merge --no-ff fixbug-0.1 再合并到develop分支 删除分支 git branch -d fixbug-0.1 删除远程没有本地有的分支git fetch -p stash Official Doc将当前修改缓存起来, 减少不必要的残缺提交 stash命令的缓存都是基于某个提交上的修改, 是一个栈的形式 参考博客: Git Stash的用法底下的评论也很有价值, 值得思考参考博客: git-stash用法小结 git stash –help 查看完整的使用说明 list 输出大致为: stash@{num}: On branchName : comment save save comment pop 将最近的stash pop出来, 应用到工作目录中, 原有的 stash 就丢弃了 apply 将指定的stash 应用到工作目录, 不丢弃原有的stash drop 丢弃指定的stash, 如果想丢弃当前项目所有更改就可以将所有更改 save stash 然后 drop clear 清除所有 stash 如果需要恢复 stash@{0}: On feature-test: test 就在 feature-test 分支上建立新分支, 然后 apply stash@{0} 不推荐用 pop, 当stash多了以后 人不一定都记得每个stash都改了啥, 可能会有冲突以及修改覆盖的问题 最好用新分支装起来, 然后合并分支, 或者是 cherry-pick, 修改也不会丢失 clone git clone branchname URL 克隆远程仓库的指定分支 git clone URL 目录 克隆下来后更名为指定目录 git clone --depth 1 URL 只克隆最近一次提交的历史, 能大大减小拉取的大小 (Shallow Clone) 但是如果要用到之前的提交历史就还是要下拉下来的 类似于懒加载 且在新建一个远程仓库后, 推送时会报错:shallow update not allowed 因为本地库是残缺的 所以需要新建一个目录, 把原仓库全拉下来, 再添加远程进行推送, 然后删除该目录, 残缺版的仓库也能正常向新远程推送提交了 克隆在指定tag状态的仓库 git clone URL --branch=name 然后 Git会提示1234您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以通过另外的检出分支操作丢弃在这个状态下所做的任何提交。如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在检出命令添加参数 -b 来实现（现在或稍后）。例如：git checkout -b &lt;new-branch-name&gt;按提示执行命令即可解决 branch 列出远程分支 -r / –remote 创建分支 git branch name 删除分支 -d checkout Official Doc: git checkout alias gch=’git checkout’ gch . 取出最近的一次提交, 覆盖掉 work 区下当前目录(递归)下所有已更改(包括删除操作), 且未进入 stage 的内容, 已经进入 stage 区的文件内容则不受影响 gch 文件1 文件2... 同上, 但是只操作指定的文件 gch [commit-hash] 文件1 文件2... 根据指定的 commit 对应hash值, 作如上操作, 但是区别在于 从 index 直接覆盖掉 stage 区, 并丢弃 work 区 gch [commit-hash] . 如在项目根目录执行该命令, 会将当前项目的所有未提交修改全部丢失, 不可恢复!!!! [ ] 验证 git checkout [commit-hash] 节点标识符或者标签 文件名 文件名 ... 取出指定节点状态的某文件，而且执行完命令后，取出的那个状态会成为head状态， 需要执行 git reset HEAD 来清除这种状态 fetch 访问远程仓库, 拉取本地没有的数据 git fetch origin dev-test 下拉指定远程的指定分支到本地, 本地没有就会自动新建 git fetch --all 下拉默认远程的所有分支的代码 pull 不仅仅是下拉代码, 还会进行merge合并, 所以安全起见, 是先fetch然后再进行合并操作 git pull origin dev 下拉指定远程的指定分支 git pull --all 下拉默认远程的所有分支代码并自动合并 merge 官方文档 Official Doc: 高级合并参考博客: 解决 Git 冲突的 14 个建议和工具 git merge develop默认会直接将当前分支指向Develop分支。(一条拐弯的分支线) 推荐: git merge --no-ff develop 在当前分支主动合并分支Develop，在当前分支上生成一个新节点(有一个环的线) merge 就是获取对方的修改, 与自己这一份进行合并(对 对方没有任何影响) master merge dev 就是 master 下载 dev 的那一份代码, 与自己的这份代码合并为一份 如果遇到冲突： git mergetool 使用工具进行分析冲突文件方便修改 配置mergetool工具： git config --global merge.tool kdiff3 git config --global mergetool.kdiff3.cmd &quot;&#39;D:/kdiff3.exe&#39; \\&quot;\\$BASE\\&quot; \\&quot;\\$LOCAL\\&quot; \\&quot;\\$REMOTE\\&quot; -o \\&quot;\\$MERGED\\&quot;&quot; git config --global mergetool.prompt false git config --global mergetool.kdiff3.trustExitCode true git config --global mergetool.keepBackup false rebase 衍和操作 参考博客 |Git rebase -i 交互变基 |git rebase的原理之多人合作分支管理他会将分支中的圈, 消除掉, 成为线性结构 效果和merge差不多，但是分支图更清晰?TODO 有待详细学习 与master合并：git merge master 换成 git rebase master 当遇到冲突： git rebase --abort 放弃rebase git rebase --continue 修改好冲突后继续 grep 搜索文字 git grep docker -n搜索并显示行号 --name-only 只显示文件名，不显示内容 -c 查看每个文件里有多少行匹配内容(line matches): 查找git仓库里某个特定版本里的内容, 在命令行末尾加上标签名(tag reference): git grep xmmap v1.5.0 git grep --all-match -e &#39;#define&#39; -e SORT_DIRENT 匹配两个字符串 常用文件.gitignore123456789# 注释*/ 忽略所有文件build/ 所有build目录/build 只忽略当前目录的build, 子目录的不忽略*.iml 所有iml文件?.log 忽略所有 后缀为log, 文件名字只有一个字母!*.java 不忽略所有java文件a.[abc] 忽略 后缀为 a或者b或者c 的文件doc/*.txt 忽略 doc一级子目录的txt文件, 不忽略多级子目录中txt gitattributes gitattributes 配置文件的换行符 eol working-tree-encoding ident filter merge whitespace export-ignore delta encoding Toolsgit-svn git-svn 文档 Submodules 官方文档git submodule的使用参考博客: Git Submodule使用完整教程 能够在一个git仓库中将一个文件夹作为一些独立的子仓库进行管理 各个VCS工具的区别以及优缺点Git 分布式的去中心化的, 大多数操作是本地化操作, 速度快, 更方便 最大的区别是其他的 VCS 都是 一个增量式的文件集合, git 是文件的一系列快照, 类似于 AUFS 文件系统一层一层那样 SVN Svn笔记 中心化的, 代码统一保存, 如果中心发生错误, 代码会全部毁掉, 提交是必须要和服务端通信才能完成 允许部分的进行修改, 下拉, 提交. 而对于Git来说一个仓库就是一个整体(Git submodule 目前也能完成, 但是还是没有SVN灵活) 优点: 能够精确控制每个目录的每个人的访问权限 git和SVN一起用可以通过 git-svn 使用Git的命令与SVN服务器进行交互 Official doc: git-svn 但是个人目前在用的方式是直接 git 和 svn 一起用参考博客: 为啥要同时用 SVN 和 Git 管理项目 IDEA中移除git相关插件, 防止混乱, 而且最好是先把SVN项目拉下来, 达到 先让IDEA使用SVN管理项目 的目的 然后 git init 避免LRLF LF 问题 12git config --global core.autocrlf falsegit config --global core.safecrlf false 互相忽略各自配置目录 .svn .git 至此, 就能和团队保持一致的使用SVN, 然后自己多任务开发时, 又能使用git优秀的分支模型 当然该场景是有限的, 也就是说只有你一个人在用git 而且团队中使用SVN时没有使用SVN的分支模型, 这个是没有问题的 如果SVN也用了分支, 那么就要命了, 这么多分支和状态, 要靠大脑记住实时的状态就…. repos的使用 综合各个VCS的管理方式","categories":[{"name":"Git","slug":"Git","permalink":"http://blog.kuangcp.top/categories/Git/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"Git实践","slug":"Memo-Skills-Vcs-GitAction","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Vcs-GitAction/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Vcs-GitAction/","excerpt":"","text":"目录 start GitInAction Tips 配置记住密码 【安装】 Linux(debian系) windows GUI 【简单使用】 配置GPG 实验楼上使用Github 码云 【git初始化配置】 【VI编辑器的使用】 【配置SSH连接上Github】 Github上fork别人项目的操作 Github上PR .gitingnore文件 终端中显示当前分支 命令的自动补全 搭建Git服务器 使用git daemon搭建简易 Server 【HTTP访问Git服务器】 【配置HTTPS】 【使用SSH登录GitServer】 基础命令概述 reset使用方式 1.回滚add操作 2.回滚最近一次commit 3.回滚最近几次的commit并添加到一个新建的分支上去 4.永久删除最近几次 5.回滚merge和pull操作 6.在被污染的working_tree中回滚merge或者pull 7.被中断的工作流程 8.Reset一个单独的文件 9.保留working_tree并且丢弃一些commit 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs GitInAction try git Github: lazygit命令行的简易图形化 Tips 虽然在物理上本地仓库中所有文件是放在一起的，但是分支之间是互不能访问以及操作的 在本地的每次commit都是有index的，上传到github可以不用那么频繁，反正都是有记录的 出现了冲突，从而无法自动merge： 1234git pull 对方的分支git checkout 自己的分支git merge --no-ff 对方的分支git push （自己的源+分支）origin master 切记：避免隐私的配置文件上传github时，将配置分离出来配置.gitignore中忽略掉配置文件，然后建立模板文件夹放待配置的文件即可 大意的后果：程序员复仇记 | 这些年，GitHub 上泄露了些什么？ 不小心把密码上传到 GitHub 了，怎么办 cat ~/.ssh/id_rsa.pub | xclip -sel clip 复制公钥 Linux下当大量文件出现mode的变化（因为你的目录移动，文件权限变化等影响的）可以设置忽略掉 git config core.fileMode false 当将目录备份出去，然后重装系统粘贴回来，权限就变了，mode也变了，可以设置忽略掉改变 git的输出中文乱码 执行 git config --global core.quotepath false即可 配置记住密码 Windows下记住密码 ： 新建环境变量 HOME 值：%USERPROFILE% 在C盘User下你的当前用户目录下新建_netrc文本文件： machine https://github.com/Kuangcp/ login *** password *** 成功配置，测试便知 Linux下记住密码：(如果使用了多个github账号，设置这个后只能使用一个账号的自动登录，另一个账号将完全连不上github，ssh也只能一个账号配一个，不能多个账号用一个ssh) touch .git-credentials vim .git-credentials 输入： http://{username}:{password}@github.com 或者是https开头 git config --global credential.helper store ~/.gitconfig 文件中多了以下内容即可 [credential] helper = store ssh 方法：（推荐） ssh-keygen 不设置密码 cat ~/.ssh/id_rsa.pub | xclip -sel clip 添加即可 关于许可证 Github许可证网 新建项目的时候可以选择 添加.gitignore和许可证类别 许可证大致分为 MIT Apache2.0 GPL MIT 简单宽松的许可证，任何人可以拿代码做任何事与我无关eg: jQuery、Rails Apache 关注于专利，这类似于MIT许可证，但它同时还包含了贡献者向用户提供专利授权相关的条款。 Apache、SVN和NuGet GPL 关注于共享改进，这是一种copyleft许可证，要求修改项目代码的用户再次分发源码或二进制代码时，必须公布他的相关修改。 Linux、Git 【安装】Linux(debian系) sudo apt-get install git 安装最新版本Git sudo add-apt-repository ppa:git-core/ppa 如果命令找不到就先安装这个 sudo apt-get install software-properties-common sudo apt update sudo apt install git 从源码安装 Github:git make prefix=/usr/local all sudo makeprefix=/usr/local install 安装文档(可选): sudo apt-get installasciidoc make prefix=/usr/local docinfo sudo makeprefix=/usr/local install 卸载 sudo find /usr/local -depth -iname ‘git*’ -exec rm -fr {} \\; windows 直接搜索git-for-windows 建议使用360搜索,会有360的下载链接,无意间发现 毕竟官网的下载速度不敢恭维 GUI 官方列表 【简单使用】Github下拉到eclipse 1.在GitHub上新建一个项目，不勾选初始化，复制下URL 2.在eclipse新建项目然后在eclipse里添加git remote 3.commit -》push 完成 4.打开Git Bash 使用命令行再查看一下 本地已有代码关联远程空仓库 先在远程建立空仓库 一般各大平台也都有命令提示 传送门: Gitee | Github | Bitbucket | GitLab …12git remote add origin https://github.com/Kuangcp/StudentManager.gitgit push -u origin master 说明下上面的命令 第一条是设置了一个远程仓库 仓库名为origin URL是后面那个,一般默认的远程仓库名都叫origin 名字可以随便取 但是提交就要标明仓库名了,而且分支也是一样的默认是master可以自己加别的分支. git push -u 随便 随意 建立本地空仓库并关联到远程仓库 1.先在GitHub上创建一个仓库，不勾选README（不然添加远程仓库还得pull一下README文件才能push） 如果本地没有则 mkdir 库名创建一个文件夹，最好和远程的库同名 2.在某本地项目根目录下运行 Git Bash 2.1 git init 初始化（建立 .git 目录） 2.2 touch README.md 2.3 git remote add origin master URL 连上远程仓库 2.4 git push -u origin master 输入用户名，密码 （若因为没有上游节点就按提示输入命令建立初始节点即可 git push –setupstream origin master） 原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：git branch --set-upstream dev origin/dev master同理 配置GPG 阮一峰:GPG入门教程 能够提高安全性,但是麻烦,不过向来这两者就是不可兼得的. 实验楼上使用Github 方便学习使用 git clone URL 复制下来，默认是master git branch 新分支名 新建一个分支，切换过去，使用的就是这个新分支放代码 git push origin 新分支名 add commit 之后就push git fetch origin 已有分支 下拉别的分支代码 码云 帮助文档 如何进行减少提交历史数量以及修改自己的commit中的邮箱 改写历史，永久删除git库的物理文件 【git初始化配置】123git config --global user.name \" \"git config --global user.email \" \"git config --global color.ui auto 如果是多个账号使用同一台电脑就不要配置这个，单独配置每个仓库下的用户名，邮箱即可git config user.name &quot;&quot; 【VI编辑器的使用】 详情 在pull或者合并分支的时候有时会遇到打开 VI编辑器 的状态 可以不输入(直接下面3,4步)如果要输入解释的话就需要:12341.按键盘字母 i 进入insert模式2.修改最上面那行黄色合并信息,可以不修改3.按键盘左上角&quot;Esc&quot;4.输入`:wq`,按回车键即可 或者 :x 【配置SSH连接上Github】 其他平台类似 【Markdown语法】: @用户名， @组织名 ；#编号 会连接到该仓库对应的Issue编号 。 通过 用户名/仓库名 #编号 来指定仓库的指定Issue 【将Bash和GitHub绑定起来】： 1.在GItHub上设置SSH key， 有一个即可 2.$ssh-keygen -t rsa -C “xxx@outlook.com“ 生成一个具有指定邮箱的rsa密钥对,然后复制到平台上 3.设置密钥对密码. 当然为了偷懒就不设置,不然每次提交都要输入…. 4.测试SSH连接 $ssh -T git@github.com 输入 密钥对 密码 询问将github的ip加入已知列表中 选择yes Github上fork别人项目的操作合并对方最新代码 首先fork一个项目, 然后clone自己所属的该项目下来,假设 原作者为A 自己为B 添加原作者项目的URL 到该项目的远程分支列表中 git add remote A A_URL fetch作者的代码到本地 git fetch A 新建本地分支, 并与A的远程分支绑定 git branch A A/master 合并两个分支代码 git merge --no-ff A/master push即可 Github上PR Using git to prepare your PR to have a clean history .gitingnore文件 Github: gitignore | 一行是一个配置, 是独占一行的 使用 # 注释一行 test.txt 忽略该文件 *.html 忽略所有HTML后缀文件 *[o/a] 忽略所有o和a后缀的文件 !foo.html 不忽略该文件 示例文件123456789101112# maven #target/# IDEA #.idea/*.imlout/# eclipse #bin/.settings/.metadata/.classpath.project 终端中显示当前分支 使用 .git-prompt.sh 在Bash下显示当前分支 Windows环境不用看,安装的Git-for-windows软件已经会显示分支名了 wget https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh -O ~/.git-prompt.sh 下载脚本 chmod +x ~/.git-prompt.sh 赋予可执行权限 在 .bash_alases文件中添加1234567891011lightgreen=&apos;\\[\\033[1;32m\\]&apos;lightcyan=&apos;\\[\\033[1;36m\\]&apos;lightpurple=&apos;\\[\\033[1;35m\\]&apos;yellow=&apos;\\[\\033[1;33m\\]&apos;nocolor=&apos;\\[\\033[0m\\]&apos;source ~/.git-prompt.shset_bash_prompt()&#123; #PS1=&quot;[e[32m]u[e[m]@[e[33m]W[e[36m]$(__git_ps1 &apos; (%s)&apos;)[e[31m]$[e[m]&quot; PS1=&quot;$&#123;lightcyan&#125;\\t$&#123;lightgreen&#125;\\w$&#123;lightpurple&#125;$(__git_ps1 &apos; (%s)&apos;)$&#123;yellow&#125; → \\[\\e[m\\]&quot;&#125;PROMPT_COMMAND=&quot;set_bash_prompt; $PROMPT_COMMAND&quot; 命令的自动补全 git自动补全脚本GitHub地址 下载脚本 wget https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/.git-completion.bash 在 .bashrc 或者 .bash_aliases 中添加 source ~/.git-completion.bash 重启终端或者 source .bashrc即可 双击tab可以得到命令建议 搭建Git服务器使用git daemon搭建简易 Server目录结构1234├── a│ └── .git└── b └── .git 也就是说在仓库目录的父级目录 作为基础目录 (base-path) git daemon --export-all --base-path=&#39;BASE_PATH&#39; --port=8080 在 BASE_PATH 启动一个Git守护进程 --export-all 开放当前目录下所有项目 --enable=receive-pack 为了安全，默认是仓库不能被修改，添加这个参数就可以push了 --base-path=&#39;&#39; 指定开放的基本目录（指定开放别的路径） --port=8080 指定开放的端口 --verbose 启动看到的日志信息更多 克隆: git clone git://localhost:8080/a 【HTTP访问Git服务器】 安装Apache： Web服务器 配置Apache服务器的开放的目录以及Git的路径 123456&lt;Location /git&gt; AuthType Basic AuthName \"GIT Repository\" AuthUserFile \"/home/mythos/GitRemoteRepo/htpassed\" Require valid-user&lt;/Location&gt; 切换到Apache的bin目录下：htpasswd -cmb /home/mythos/GitRemoteRepo/htpsswd 账号名 密码 到仓库目录下 git init --bare 程序项目名称 git clone http://localhost/git/程序项目名称 输入用户名密码即可 【配置HTTPS】 切换到Apache主目录下 bin\\openssl genrsa -des3 -out server.key 2048 -config conf\\openssl.cnf 输入密码 bin\\openssl req -new -key server.key -out server.csr -config conf\\openssl.cnf 输入之前密码 bin\\openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt 输入之前密码 把server.key 更名为server.key.old :bin\\openssl rsa -in server.key.old -out server.key 将server.key server.crt 移动到conf 修改 httpd.conf 去掉如下三行的注释 # 字符 123LoadModule socache_shmcb_module..LoadModule ssl_module..Include conf/extra... 因为是自己建立的SSL证书 所以要去掉SSL验证 git -c http.sslVerify=false clone URL 或者直接改配置文件，省的每次输这么多 git config http.sslVerify false 【使用SSH登录GitServer】 实践一下 基础命令概述 git touch file1 file2 新建三个文件 echo &quot; &quot;&gt;&gt;file1 修改文件file1 git rm 文件名 ： 删除文件至缓存区 git commit -am &quot; &quot;从缓存提交（切记要先 commit 才能 push） git diff ： 查看当前工作树和暂存区的差别 git diff --cached：查看缓存中文件修改的痕迹和对比 输入q 退出 git log --graph：查看（图形化）提交日志 输入q退出 git banrch分支名 ：创建新的分支 git branch -a查看当前分支信息 git checkout -b：创建一个分支，并立即切换 git checkout -b feature-D origin/feature-D 新建一个分支来接收同步后面那个远程仓库的分支 git pull：获取最新的远程仓库分支 git pull origin feature-D：只把本地的feature-D分支更新到最新 git reset --hard 哈希值：数据库的回滚操作似的 git reflog 查看仓库的操作日志 git mv -k oldName newName :更改文件名字 12345usage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] &lt;command&gt; [&lt;args&gt;] reset使用方式1.回滚add操作12345678910edit (1) git add a.txt b.txt 看邮件(2) git reset(3) git pull URL1.1 编辑了两个文件并且添加到了index1.2 接收邮件，发现某人要你pull，有一些改变需要你merge 下来1.3 然而你已经把index给改变了，因为当前的index 和 HEAD commit不匹配了，但是你知道，即将pull的东西不会影响 到a.txt 和 b.txt，因此你可以revert这两个文件的改变，revert后，那些改变依然在working directory中，因此需要执行git reset1.4 然后，执行了pull后 自动merge，两个文件依然在working directory中 2.回滚最近一次commit12345678910git commit ... git reset --soft HEAD^(1) edit (2) git commit -a -c ORIG_HEAD(3)2.1 当提交后，你发现提交的代码不完善，需要重新编辑一下，执行 1 语句让working directory和reset之前一样，不做改变2.2 对working tree下的文件做修改2.3 然后使用reset之前那次commit的注释等相关信息都重新提交，注意老的HEAD会被备份到文件.git/ORIG_HEAD中，命令中就是引用了这个老的相关信息 -a 表示自动将所有的修改的和删除的文件都放进 stage area（理解为代码区，未被git跟踪的文件不受影响） -c 表示 拿已经提交的commit对象中的信息来做这次的提交这条命令就是，将所有更改的文件加入到stage area中，并使用上次的提交信息来提交 3.回滚最近几次的commit并添加到一个新建的分支上去123456 git branch myth/test (1) git reset --hard HEAD^3 (2) git checkout myth/test (3)3.1 你已经提交了好几个commit，但是觉得不够成熟和完善，不足以添加到master分支上，所以在当前HEAD创建一个新分支3.2 然后回滚掉最近三次提交（删除）3.3 切换到新分支上就能对代码进行润色了，等待之后的merge 4.永久删除最近几次 commit git reset --hard HEAD~3 5.回滚merge和pull操作1234567891011 git pull URL (1) git reset --hard (2) git pull .topic/branch (3) git reset --hard ORIG_HEAD (4)5.1 从origin上拉下来一些更新，但是产生了许多冲突，暂时又没时间去解决这些冲突，所以想撤销pull操作，等待以后来pull5.2 由于pull操作产生了冲突，因此所有pull下来的改变尚未提交，仍然在stage area中，这种情况下 git reset --hard 与 git reset --hard HEAD 效果一样 都是清除那些使index和working directory乱套的东西5.3 将topic/branch 合并到当前的branch，这次没有冲突，并且合并后的更改自动提交5.4 但是此时又觉得将topic/branch合并过来又太早了，决定回滚merge操作，执行4语句 之前有说过，git reset操作会备份一个ORIG_HEAD， pull和merge操作同样会，为了回滚操作 6.在被污染的working_tree中回滚merge或者pull","categories":[{"name":"Git","slug":"Git","permalink":"http://blog.kuangcp.top/categories/Git/"}],"tags":[]},{"title":"DockerBook.md","slug":"Memo-Book-DockerBook","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Book-DockerBook/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Book-DockerBook/","excerpt":"","text":"目录 start Docker 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Docker Docker — 从入门到实践","categories":[],"tags":[]},{"title":"GoBooks.md","slug":"Memo-Book-GoBooks","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Book-GoBooks/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Book-GoBooks/","excerpt":"","text":"目录 start 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 《Go入门指南》 Learning-Go 使用Go构建一个WebApplication Go语言圣经（中文版）","categories":[],"tags":[]},{"title":"JavaBooks.md","slug":"Memo-Book-JavaBooks","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Book-JavaBooks/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Book-JavaBooks/","excerpt":"","text":"目录 start Java书籍 视频 未读 已阅读 《Java程序员修炼之道》 《Java8实战》 《Netty权威指南》 《Netty in Action 中译》 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Java书籍 从 Java 代码到 Java 堆 理解和优化您的应用程序的内存使用 视频 用Java学编程 讲师：翁恺 未读 程序员必读书单参考博客: 一个合格的程序员应该读过哪些书(偏java)参考博客: 2018 年 Java 程序员必读的十本书参考博客: 程序员必读的六本书参考博客: Java自学书籍Top 10 head first Java head first 设计模式 设计模式 可复用面向对象软件的基础 四人帮 Java编程思想 需要精读 Java核心技术 卷1 基础知识 卷2 高级特性 实战java高并发程序设计 深入理解Java虚拟机 Effective Java 图解Java多线程设计模式 大教堂和集市 参考博客: 《大教堂和集市》笔记 Mybatis 从入门到精通 深入实践SpringBoot 深入浅出 Mybatis 技术原理与实战 SpringCloud 与 Docker 微服务架构与实战 深入Java虚拟机(原书第2版) 译者: 曹晓钢 / 蒋靖 已阅读《Java程序员修炼之道》 Benjamin J.Evans | Martijn Verburg 2017-08-15 21:14:02 这本书在理论上的讲解的确是挺扎实的，但是案例代码不敢恭维，本来Java就不是脚本语言，多个类的协作很常见，里面的demo都是不事先说明这里的案例 引用的这些类源码是什么，干什么的，虽然是很简单的类，基本可以猜出来，那么既然如此，为什么不使用更为简单的，就单个类来讲解这个知识点 而且代码又不规范，甚至出现了 l 1 要我去区分，这个是看的书里面第一次看到这样的源码，应试考试题目都没有这样的。。。2017-08-27 10:49:46 基本整理完了一遍，有些暂时没有用到的先不去学习，总的来说书挺好，对思想的理解有好处，代码就自己想一个更好，书上源码来自一个项目，不简单明了 《Java8实战》2018-03-11 14:25:10 开始正式的看这本书, 虽然图书馆有这本书, 也稍微看了下目录, 但是一直没有精读, 看前面的一部分就能看出这是一本不错的书, 讲述了Java8的特性, 以及带来的效率的巨大提升 《Netty权威指南》2018-04-03 09:34:32 版本1和2都有大致的看, 学习到了数据交换协议, 以及Netty的简单使用, NIO AIO的学习和使用, Netty封装后, 开发简洁了很多, 使用原生的写法要复杂很多 并发的再一次学习和理解, 但还是没有开始动手实践 Netty自己定义协议栈 还没有学习, 感觉挺有难度 《Netty in Action 中译》 如何评价《Netty实战》这本书？","categories":[],"tags":[]},{"title":"LinuxBooks.md","slug":"Memo-Book-LinuxBooks","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Book-LinuxBooks/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Book-LinuxBooks/","excerpt":"","text":"目录 start Linux 未读 已读 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Linux awk学习笔记 Linux 101 hacks 未读 鸟哥的Linux私房菜 构建高可用 Linux 服务器（第 4 版） 余洪春 快乐的命令行 https://github.com/billie66/TLCL 只是为了好玩 Linux命令行与shell脚本编程大全 Linux Shell脚本攻略 二 三 版 已读","categories":[],"tags":[]},{"title":"PythonBooks.md","slug":"Memo-Book-PythonBooks","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Book-PythonBooks/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Book-PythonBooks/","excerpt":"","text":"目录 start Python 未读 已读 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Python 笨方法学Python 简明 Python 教程 Python3-cookbook 深入Python中文版 深入Python3 Python 手册 tornado教程 未读 Python Web 开发实战 已读","categories":[],"tags":[]},{"title":"CodeExcellentCode.md","slug":"Memo-Skills-SoftwareEngineering-CodeExcellentCode","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-SoftwareEngineering-CodeExcellentCode/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-SoftwareEngineering-CodeExcellentCode/","excerpt":"","text":"目录 start 写出优秀的代码 代码的坏味道 《代码整洁之道》 命名 函数 注释 格式 异常 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 写出优秀的代码 代码整洁之道 代码的坏味道如果在代码中，存在下面的情况之一者，则说明代码需要清除腐败。 代码中存在许多大型的类和复杂的函数 函数的名称很晦涩或者会误导人。如果函数名称没有良好地反应函数的用途，那么会造成惊人的副作用。 没有任何结构：应该在哪里找某个功能非常不清晰。 内容重复：有许多相互独立的代码在做着同一件事情。 高耦合性：复杂的模块相互连接和依赖关系，将意味着某个地方的小小改动就会影响整个代码，甚至会影响看起来不相关的模块。 当数据流过系统时，它将在各个表示方法之间转化。 API变得模糊不清。由于考虑不周，增加了新功能，曾经整洁的接口现在在范围上变得宽泛。 API在不同代码版本中快速地变换。 公共API中泄露了部分私有实现，以便可以进行别的快速的修改。 代码中到处都是权宜之计：治标不治本的修改。它们隐藏了真正的问题。系统的外围尽是这种修改，结果导致缺陷隐藏在系统的核心。 有些函数的参数太多。这些函数有许多并不使用的参数，而只是将他们传递给下一级函数调用。 你发现代码太可怕了，以至于你都不想去修改它。你不知道它是会改善的，还是会轻微地破坏它，或是它更糟糕。 添加新功能时没有提供任何支持文档：现有的文档过时了。 你发现有的注释说：“不要动这段代码……” 《代码整洁之道》命名 有意义，短而精悍 类用名词，方法用动词，还要特别注意语境 普通变量：首单词小写，其后使用驼峰法命名 常量：全部大写 命名有意义，简单直接明了就不需要注释了 函数 短小，只做一件事，if while for try catch中只写一句话（调用一个函数），并且减少嵌套 如果非要用 switch 语句就要尽量简化他 函数参数越少越好，最好没有 函数参数最好不要使用输出类型 分隔指令（动作，会改变数据）与查询（只做一件事） 使用异常代替返回特定的错误码 把try catch 抽离封装到函数内 避免重复 注释 注释越少越好，注释往往得不到维护，代码变动了，注释却没有变，这时候的注释就是错误的引导了（坏注释） 注释都是程序猿的自言自语，不要说废话 避免 坏注释，多余的注释 格式 赋值，一般的类、方法的缩进格式我已经了解 注意：函数的参数，最好是这种格式 fun(int a, int b, ){} 逗号后要加空格 一行字符在20-120之间，不过我一般是达到不使用滑动条看代码即可 函数的排布，最好是越底层越在下面的行数上 异常 避免null：避免函数返回值是null以及函数入参是null 尽量避免可控异常（throws）的出现，因为破坏了封装","categories":[],"tags":[]},{"title":"RegularExpression.md","slug":"Memo-Skills-RegularExpression","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-RegularExpression/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-RegularExpression/","excerpt":"","text":"目录 start 正则表达式学习 基本字符 特殊字符 Python Shell 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 正则表达式学习 shell regex 基本字符 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用：([0-9]{3})? 匹配出现三个数字连着的字符串 {N} 匹配前面出现的子表达式 N 次 {N,M} 匹配前面的子表达式 N-M 次 [...] 匹配字符集的任一单个字符 ： [abcdejk]就是匹配里面任一单个字符 [^...] 不匹配此集合中任一字符，包括某一范围的字符：[^0-9] 字符串中不含数字 [x-y] 匹配x-y范围内单一字符 ： [0-9] [a-z] * 匹配前面的子表达式 0或多次。 + 匹配前面的子表达式 1或多次。 ? 匹配前面的子表达式 0或1次，或指明一个非贪婪限定符。 . 匹配除换行符 \\n之外的任何 单个字符。 \\ 将下一个字符标记为或转义字符、或原义字符、或向后引用、或八进制转义符。’\\n’ 匹配换行符。 | 指明两项之间的一个选择。 以上字符 要想表示原字符都需转义 特殊字符 \\d 匹配任何十进制数字 与[0-9]相同 \\D与之相反 \\w 匹配任何字母数字字符 与 [a-zA-Z0-9_] 相同， \\W与之相反 \\s 匹配任何空格字符 与 [\\n\\t\\r\\v\\f] 相同 \\S与之相反 \\b 匹配任何单词的边界 \\B与之相反 \\N 匹配已保存的子组N次 ： name\\100 \\c 逐字匹配任何特殊字符c ,就是转义字符的使用！ \\A \\Z 匹配字符串的开始或结束 构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与操作符将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。 Python re.jpg Shell Shell正则表达式","categories":[],"tags":[]},{"title":"Problem.md","slug":"Memo-Skills-Problem","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Problem/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Problem/","excerpt":"","text":"目录 start 问题解决方案 Linux JDK IDE IDEA Docker 内存高占用 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 问题解决方案Linux 详细 JDK Picked up _JAVA_OPTIONS: 例如这样的提示, 由于设置了 _JAVA_OPTIONS 或者 JAVA_OPTIONS 就一定会输出这个提示 参考博客: Disabling Java_Options On Java Console Apps in Linux 参考博客: Suppressing the “Picked up _JAVA_OPTIONS” message 参考博客: 理解环境变量 JAVA_TOOL_OPTIONS 但是又不能直接 unset, 这个变量似乎是用来解决字体锯齿问题的, 所以需要如下配置123_SILENT_JAVA_OPTIONS=\"$_JAVA_OPTIONS\"unset _JAVA_OPTIONSalias java='java \"$_SILENT_JAVA_OPTIONS\"' 只需将该配置加到 /etc/profile 文件尾部, 这样的话, 终端不会有如上提示 但是IDEA中输出控制台仍带有该提示, 在 bin/idea.sh 中也添加如上配置即可(在最后一段之前) Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=gasp 原因是linux自带的OpenJDK影响了安装的java, 同样的也是可以采用如上的方法, 或者: sudo mv /etc/profile.d/java-awt-font-gasp.sh /etc/profile.d/java-awt-font-gasp.sh.bak IDEIDEA 调整参数，解决CPU满载 同样的 Docker内存高占用 明明是一样的docker配置，构建出来的镜像按道理也应该是一样的，所以运行出来的容器也应该是一样的才对，但是结果却是两倍的差别 优化jvm？ 修改基础镜像？ [ ] docker ps hanging on docker 1.13.2","categories":[],"tags":[]},{"title":"Miscellaneous.md","slug":"Memo-Skills-Miscellaneous","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Miscellaneous/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Miscellaneous/","excerpt":"","text":"目录 start 学习杂记 首先我想说三句话： 学习方式 一些建议 无论做什么，原则最重要 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 学习杂记 一个牛人给Java初学者的建议(必看篇) 首先我想说三句话： 1、欢迎入坑，现在爬上去还来得及。 2、没有毅力之人一事无成。 3、正确的选择会使你的事业一帆风顺。 学习方式 1、要想成大神，必须自己下功夫，俗话说老师引进门，修行靠个人。编程也不例外。没有哪个培训机构能100%保证能把你培养成啥样。 不要纠结是否要选培训机构、要选哪个培训机构。实际上如果你强迫自己学一门语言一年，如果还是懵懂的很厉害(譬如连hello world都写不出)， 那么基本请考虑换个事情做做吧。一般好的程序员都是靠自学的。就像老板大部分都没上过MBA. 2、选择开发语言 ????选啥语言？ Php?你会发现学了一半，好像java做的事情更多 Java?你会发现学了一半好像ios开发更有前景 Ios?你会发现还不如android好 Andoid?你会发现其实还是php容易找工作 所以初学者其实很难选择语言。既然难，索性不要急于选。 还有一个故事发生在好多人身上：有个人全力自学c++，突然觉得c++不如java学的快，而且相对工作岗位也少，在c++学了很大一块了，想换方向选择java，纠结了很长时间，后来终于想通了，还是坚持学习c++。其实选择语言并不困难，你觉得什么适合你，就学那个。我看到过一个学校的专业班级（和企业合作，有php、java和.net三个方向），学生到了大四可以选择进入这个班级，作为企业定向培训。这个班级分类学生很有意思： 1、 老师在网上下载了php、java和.net三个语言的基础教程，分发给大家2、 每个人分别看入门教程各一天。（只许看第一章，不许动手写程序）3、 然后选择自己“感觉看的最爽”的语言进行班级语言分类选择。 这就是一个很实践的帮助学生选语言的方式。 3、选一本好书 如果语言确定了，那么选一本书就很重要。如果你没有项目经验，那么学一门语言基本上靠看网络文章是学不好的。必须买书，因为网络上很多技术文章都有各种错误，我写的也不例外。一本书好不好，主要看第一章、中间一章和最后两章。基础讲得好，一般不会差。高级章讲的好，一般也不会差。差的书在于基础部分讲的冗余、啰嗦、拖沓，到了高级章节一掠而过（实际上是写书的人自己也不会）。入门书籍不需要太多，1,2本足够，要真正的吃透。 4、以正确的方式看视频 可以在网上找点对应的视频看着学习，能听懂视频里面的东西后，开始回归教材，不建议一直对着视频学习，因为视频都是别人咀嚼过的东西，要建立自己的知识体系还得靠大脑自己去一遍遍的破除疑惑的过程，看书是最枯燥也是最有效的，看书学习，前提就是要对理论有个大概的了解， 5、懂得实践(在实践中创新) 试问一句，当你遇到了一个很大的问题，你自己去解决了他，百度也好，问人也好。可是最终还是你自己解决了问题。你当时心情绝对是极好的。尝试在电脑上去实践，很多人拿着题目不断在刷， 其实没那个必要，在理论掌握的差不多的情况下，把对应的课后题目独立在电脑上能实践好就够了，如此反复的去做，不厌其烦的去做。遇到不明白的理论，重复第三和第四条。书读百遍，其义自现。 6、最终还是要有恒心有毅力 你要真正的拿出一段时间把一本基础的书籍看的差不多，这个打基础的阶段，真的需要十足的耐心，这点都做不到，后面会带来一系列的连锁反应，最后可能导致你最后的放弃。一栋大楼，地基最重要，编程同理，基础知识最重要。 7、主意横向扩展 现在都知道，社会上会的东西越多，你就越能在社会立足。没错，前期是要抱着必死的入坑的心态学好一门语言。到后期，学Android可以尝试学学数据库，xml html 之类的，学web前端编程的可以尝试学学后端，或者java 或者把你的 css/js 学的更精通！学后端的人可以尝试学学其他的后端语言 ?比如 ruby asp.net jsp 或者可以学学 python? 一些建议 1、Linux学习 微软不做老大已经很多年，大家一定很怀念当年vb6雄霸天下的年代。这个年代如果你还只会windows而对linux一点不会，那么已经不能称之为合格的程序员了。据统计，学习linux很有助于你学习真正的开发语言。所以如果你一点基础都没有，不妨抛开一切所谓的语言，先把linux学一学，学到一定程度后你必然会觉得豁然开朗。除非你记性太差，那么linux其实并不难学。 2、不要过早玩开源 这点其实很多忽视了，都以为学编程先弄个开源框架学习。一般来说，好的开源框架集结了多个技术大神多年来的技术经验和思想，你想在毫无基础的情况下学会必然会让你一头雾水。正所谓：零基础学开源框架属于杀敌一千自伤八百，很不上算。当然也不排除有些奇葩能搞定。太早玩开源好比早恋，弊总是大于利，但是运气好你成为大神的时间会缩短很多。 3、反向思维写程序 大部分程序员初学编程有个习惯，写完一段代码后想着如何优化。实际上这个办法适合大部分人，但凡事都有例外，并不一定所有人都能这么干并能干成功，反而越写越觉得没有信心，当你也有这种情况时请看下面方法：这里有个我在一个技术大牛“回忆录”中看到的办法：先按照教程学习，然后合上书、拔了网线，把刚才学到的内容用程序写出来，注意不要写太多。编译通过后，进行反向思维，写一段性能更烂的程序，并时刻关注内存耗费情况。再次编译通过后，重复上述步骤，再写一段性能更烂的程序，并时刻关注cpu耗费情况。………… 重复上述步骤数次后，你会发现你再也写不出比最后一段更烂的程序了，然后你会发现为了写更烂的程序你竟然把各种知识点都掌握了。 无论做什么，原则最重要无论什么时候，你都不能以身体为代价去做一些事。熬夜是不好的习惯(哎，虽然我在熬夜写稿)，你为了追求一个安静的环境、你完全可以背上电脑，去图书馆。最后一点 时间都是挤出来的，没有时间只是找理由逃避。怎么样，你还想入坑吗？","categories":[],"tags":[]},{"title":"CelebrityQuotes.md","slug":"Memo-Skills-CelebrityQuotes","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-CelebrityQuotes/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-CelebrityQuotes/","excerpt":"","text":"目录 start 名言 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 名言 David Wheeler All problems in computer science can be solved by another level of indirection. 计算机科学中的任何问题都可以通过加上一层间接层来解决","categories":[],"tags":[]},{"title":"Repository.md","slug":"Memo-Repository","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Repository/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Repository/","excerpt":"","text":"目录 start 【GitRepos】 【Organization】 User 翻译和搬运 【算法】 【Java】 综合索引 源码学习 Java8 框架以及高级特性 应用广泛 个人团体开发 二次框架 进阶 Demo 微服务 Android Web 前后端综合 BuildTool Tool 【Docker】 web Demo 【Python】 【Linux】 Database 前端 Vue 有趣 Tools 微信相关 网络有关 其他 工作 简历 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 【GitRepos】 收集的一些优秀的git仓库, 一般是参考学习为主, 用为主的工具放在了AppList下 【Organization】 ApacheCN含有一些学习的文档和视频资料 稀土 掘金的组织 docker-librarydocker仓库组织,含有大量软件的Dockerfile aliyun大厂 Spring4All User 一些值得学习的人 他们的仓库都有必要看一下 Kenny BastaniSpring 专家 waylau 擅长 Maven Gradle netty Spring anapsix擅长docker aleen42 写了好几个方便的gitbook插件 Exrick前后端都有一定造诣 oldratlee哲良, 大厂，有极客风范 有关java和shell的仓库 梁少锋公众号:前端控 pkpk1234华为程序员, 有关于Java9和自己写Servlet容器的项目 小土刀看了很多书,写了很多博客 Yong Zhu有两个关于IOC和ORM的开源项目值得学习 魏楚阳和我同龄就进了大厂, 学习的东西确实多, 学习能力很好 xuxiaodong活跃在开源社区, 17年开始就不活跃了,不知道为什么 mank319go for it 作者 cycleuser博士, 翻译了很多东西 翻译和搬运 translations翻译外国的文章 掘金翻译计划 【算法】 魏楚阳的算法学习 interview面试所需算法练习 【Java】综合索引 Java资源大全中文版 源码学习 tiny-spring Spring精简版 Java8 little-java-functionsJava8的函数式编程 作者博客 java8指南 vavr基于Java8的库, 简化代码 框架以及高级特性应用广泛 druid 阿里数据库连接池 dubbo RPC 框架 Eclipse Collections更丰富的集合操作 guavaGoogle工具包 Jfinal 简洁 actMVC全栈框架 okhttpJava上性能较好的HTTP交互工具 feignFeign makes writing java http clients easier elasticsearch 分布式全局搜索 webmagic 爬虫框架 zxing 二维码处理的项目 个人团体开发 easypoi 虽然代码非常不规范，也没人维护的样子，但是这个开源精神要学习 uflo 国内的流程引擎 jeewx微信管家平台 禅道项目管理软件 myth可靠消息解决分布式事务框架 teaVM字节码转译成js nutzam一个简单的MVC web开发框架 java-replJava REPL环境 JsonPath Java DSL for reading JSON 二次框架 jeesiteSpring基础构建的maven jsp项目 bootstrap Guns基于Springboot开发了大量模块 MyRestUtilRest 进阶 全栈? Java设计模式 设计模式详解 编码规范 知乎上的专栏对应源码程序员为什么这么累 Demo springboot-action Springboot常见的模块都有,文档也多 Java-learing Java基础学习仓库, 代码量比较大也比较详细, 但是没有逻辑和注释, 看起来费劲 rabbitmq入门学习代码 docker-demos Maven和Gradle结合docker使用 mybatis-spring-boot chrome-plugin-demoChrome插件案例, 最新火狐(54之后)也适用 netty-in-action-cn Netty实战中文版配套代码 日志系统SpringBoot 开发的 微服务 shopSpringClod的实战案例 daijie基于spring-cloud系列整合的依赖jar包 Android 安卓进阶学习指南 Web Springboot实战 Springboot的案例 weixin-java-tools 微信的java工具项目 包含企业号 微信支付 小程序 zheng SSM框架整合的一个丰富解决方案 Java后台管理集成Spring4.x+SpringMVC+Mybatis java-jwtJSON WEB TOKEN blade轻量级Web框架 前后端综合 vue vuex Springboot 代码模板 BuildTool ant maven gradle sbt Tool IDEA教程 SeleniumHQ自动化测试 Springboot搭建的简易博客 restfeel一个Rest接口的管理测试平台 陈光剑 mushroom 基于Java的动态内容管理系统 notesnotes shell 软件 【Docker】 Docker官方github组织 docker的官方Dockerfile以及doc文档 openoffice in docker shipyard docker图形化，功能稍多，配置略麻烦 ui-for-docker docker 简单易用图形化 openjdk openjdk的dockerfile仓库 docker-alpine-java java 运行环境 alpine为基础镜像 web webdis 基于redis构建的使用http请求存取数据 Demo gin-example 对应博客 【Python】 python python某书的案例源码 跟老齐学Python书籍配套源码 PythonWeb开发 书籍相关源码 scrapy-redis 爬虫框架结合redis使用 Python的一些脚本 Python实用性脚本 习题的一些Python 区块链Python附加Python中Docker的用法 pyspider爬虫框架 httpiehttps://github.com/jakubroztocil/httpie 【Linux】 Java程序员眼中的Linux Database ssdb 一个类似redis的键值对数据库 前端 amazeUI hui LayUI 国产layUI框架 js代码块集合 flowchart绘制svg flow图形 mathjax渲染数学公式 Vue iviewvue 的前端组件 | 文档 vue-rap | 文档 vue-layuivue和layui的结合 ssr-web基于vue的静态博客生成器 有趣 一个在线游戏 插件项目, 搜图 完整项目网址 Tools oneinstack 一个在Linux上管理web，数据库，ftp, 等服务的软件 学生的优惠资源 JVM分析优化的定制JDK acme可以自动更新https证书从lets上 acme-tiny同样支持acme协议然后更新证书 noVNCjs VNC client 微信相关 微信小程序Demo 网络有关 frp内网穿透 其他 HelloGibhub有趣的项目 serverlessserverless学习手册 marpmarkdown书写PPT build your own 使用各种语言和技术栈,实现一个东西 工作简历 简历模板","categories":[],"tags":[]},{"title":"AppManual.md","slug":"Memo-Skills-AppManual","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-AppManual/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-AppManual/","excerpt":"","text":"目录 start 软件使用记事 【包管理】 使用sdkman 【服务管理】 oneinstack 【常用工具】 网络工具 nmap apache benchmark 日常工具 百度网盘 输入法 搜狗输入法 rime 小小输入法 qgit convert todo.txt todo.txt-cli 【IDE】 Idea eclipse 绘图工具 在线版 安装版 安全工具 gpg 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 软件使用记事【包管理】使用sdkman 但是总会莫名其妙的冒出问题，sdk命令掉线始终连不上网，终端打开巨慢 安装 安装sdkman curl -s &quot;https://get.sdkman.io&quot; | bash 遇到提示zip 就是需要安装zip sudo apt install zip 然后重新执行命令 执行脚本：source &quot;/home/kuang/.sdkman/bin/sdkman-init.sh&quot; 或者重启终端就可以使用了，查看sdkman 版本:sdk version使用 官网文档 查看所有 sdk list 查看某sdk的版本 sdk list java 不指定版本则默认安装最新版 sdk install java 安装指定版本 sdk default java 8u131-zulu 开始使用指定版本(for the current shell only) sdk use scala 2.12.1 查看当前版本 sdk current java 验证是否成功：java -version 移除 sdk uninstall scala 2.11.6 【服务管理】oneinstack 一键配置环境 官方文档 配图 apt -y install wget screen curl python 下载源码： wget http://aliyun-oss.linuxeye.com/oneinstack-full.tar.gz #阿里云经典网络下载 wget http://mirrors.linuxeye.com/oneinstack-full.tar.gz #包含源码，国内外均可下载 wget http://mirrors.linuxeye.com/oneinstack.tar.gz #不包含源码，建议仅国外主机下载 tar xzf oneinstack-full.tar.gz cd oneinstack #如果需要修改目录(安装、数据存储、Nginx日志)，请修改options.conf文件 screen -S oneinstack #如果网路出现中断，可以执行命令screen -R oneinstack重新连接安装窗口 sudo ./install.sh #注：请勿sh install.sh或者bash install.sh这样执行 【常用工具】 基本是Linux工具，因为主力是用Linux 网络工具nmap 端口扫描 参考博客 扫描nmap &lt;param&gt; IP -sP -sT -sR -n 最简单直接的参数 apache benchmark 压力测试工具 测试本机超过100连接报错 104: Blog:解决问题 日常工具百度网盘 百度网盘命令客户端 Go语言实现 输入法搜狗输入法 唯一一个大厂支持Linux Ctrl Alt B 显示/关闭 特殊字符面板 rime rime 用过一下子有莫名其妙的bug就卸载了 小小输入法小小输入法在Deepin上的使用 qgit git查看仓库的命令行式图形化界面 convert 注意 该软件是按后缀来识别图像文件格式的… 所以 jpeg 可以直接改成 jpg 用 参考博客 将图片转换成指定大小 这是保持比例的 convert -resize 600X600 src.jpg dst.jpg 中间是字母X 如果不保持比例，就在宽高后加上感叹号 可以只指定高度，那么宽度会等比例缩放 convert -resize 400 src.jpg dst.jpg 还可以按百分比缩放 批量修改 如果没有 -path 语句，新生成的 png 文件将会覆盖原始文件 参考博客 mogrify -path newdir -resize 40X40 *.png 把png图片全部转成40X40大小并放在新文件夹下 mogrify -path newdir -format png *.gif 将所有gif转成png放在新目录下 将原有大小图片转换成其他指定大小的图片(保持比例) 原图片 a b -&gt; x y x/y 得到比例 在 原图中裁剪出同样比例的图片 (Viewnior就很好用) 将裁剪出来的图片转换指定大小 convert -resize xXy src.jpg dst.jpg todo.txt 官网 一个简约的 TODO 软件 todo.txt-cli 终端中的TODO todo.txt-cli 【IDE】Idea 更多 eclipse【eclipse EE Mars】 这里的Tomcat是使用了你所导入的必要执行文件，但是运行的必要配置文件在eclipse Server项目里另有一份 而且运行时也是使用这份配置文件，这样的结果是可以使用一份Tomcat目录，在eclipse配置运行多个Tomcat 但是奇怪的是 访问不了Tomcat主页即：localhost:8080 所以也就不能管理Tomcat 查看运行状态 资源下载 archive.eclipse.org/eclipse/downloads/ 绘图工具在线版 processon 安装版 安全工具gpg 参考博客 常用参数12gpg --list-key --gen-key 生成的过程, 输入相关的提示信息, 最后输完密码后需要输入随机字符, 就也是按照提示, 但是1.4是正常的, 其他的直接假死,不是很理解这种操作","categories":[],"tags":[]},{"title":"InterviewSkill.md","slug":"Memo-Skills-Work-InterviewSkill","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Work-InterviewSkill/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Work-InterviewSkill/","excerpt":"","text":"目录 start 面试技巧 铺垫 简历 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 面试技巧 参考博客: 面试的时候问：你的期望薪资多少？怎么谈？一个两年Java的面试总结 铺垫 很多同学是0基础开始学习java开发： java开发，我到底能不能学好？ 答案是肯定的。概念很朦胧，软件开发到底是什么？软件开发只是一份工作，和送快递的没什么区别。学习软件开发只有一个目的，赚钱！ 如果学不好，转行，干别的去！！学习软件开发，一定要抱一个目的。死地而后生！！就是没有退路。 学习的同学，有很多的只是去听、看，但是不练！软件开发，最重要的就是练！！ 很多人只是在想这些事，很容易。但是真正做到的应该没几个！！如果让你通宵玩游戏，你会觉得累吗？但是，现在要你通宵敲代码。心态问题。 沿袭了上学时的状态，老师讲多少，我学多少。 很多不是自己想来，不是主动的。 每个人都曾经犯过错，也是好事。 学习过程中，都很努力，但是效果不是特别好？ 用功不如用心的。 大家一定要培养自己做事情要有套路！！ 以目的为驱动！！通过目的去分析怎么做！！然后再去做！！ 练习的时候，要去想。为什么这样做？？ 举一反三。 必须要练，练代码！ 只知道学习，但是到底学的内容是什么？能做什么？有什么效果？ java，内容多，杂！所有的内容在将来的工作不一定能用！因为不知道将来那些能用的上。 要了解一下将来的工作内容。 市场调查、需求分析、合同定义、需求分析(需求里的难度、风险)、概要设计、详细设计、数据库设计、开发阶段(我们要从事的)、测试阶段(有可能参与)、修改过程、再测试(这个阶段至少要经历3次)、试运行、正式运行 成本/回报比 软件开发工程师，那将来的发展如何？ 项目经理、数据库设计、系统设计(需要用到哪些技术) 部门经理、系统架构师、1.5线(前期规划方案)、配合销售人员做市场(售前) 项目总监、大部门经理 管理方面：人际沟通、管理能力（1、人的管理；2、事的管理） 项目方面：人际沟通、项目进度把控、人的管理 市场方面：性格要外向、人际沟通、适应销售的环境 一般应届毕业生，能掌握80%，将来的薪资在5K左右 * 软件开发，到底要怎么学？ * 程序员都是实践家，用代码来探路？ * 软件开发，没有捷径。压缩时间！！ * 抗压能力 * 应变能力 * 沟通能力 * 技术能力 简历 之前的看法是只要有一页即可, 现在和亲戚交流下之后, 两页是刚好的, 第一页是教育经历,经验, 第二页是技能 面试：（站在自己的角度看面试，成功都是站在对方角度看问题） 第一阶段：准备 写简历： 篇幅：建议最多不要超过3页(不包含封皮) 模板：不建议使用模板，使用word里的画表格。 格式：1）基本信息（记得写联系方式、联系方式放在一起）； 2）项目经验（工作经历） 3）工作经历（项目经验） 4）个人能力，作用：充数的 5）相关认证，oracle认证、PMP认证(项目管理认证)、weblogic认证、IBM认证 字体：宋体；大小：小四或者四号；行间距：1.5倍 投简历：建议每天早上8:30（改系统时间）；海投（每天200）；搜“java”，“J2EE”；邮件形式：申请职位+姓名+联系方式 笔试题：1）会的；2）会的但是不熟；3）不会的 ———— 背（2000，20%） 项目经验怎么写？ 写模板：（总分总） 基于。。(用到的技术，J2EE + Oracle 9i + Linux)的。。。系统(软件)，实现了。。。的功能，满足了。。。的需求。 在该项目你负责那些模块，完成了哪些功能，实现了哪些效果，使用哪些技术。在该项目中遇到哪些问题，如何解决的。 该项目经历了多长时间(项目周期)，团队人数，你在团队中的角色。 项目经验雷同，如何能写出不一样的项目经验？ 上网搜！ 搜到的项目，项目简介或者系统简介。实际上是满足“系统(软件)，实现了。。。的功能，满足了。。。的需求。” 无论什么项目或者系统，在我的简历里，使用的技术都是一样的。 J2EE+ORACLE+LINUX JSP/SERLVET/STRUTS/SPRING/HIBERATE 项目周期、团队人数你在团队中的角？编出来的！只要编的合理就OK。 写完的简历，给就业老师、任课老师帮你看。 心理问题： 如何能把背下来的题说成让对方感觉像是你会的题一样？ 如何能把别人的项目能说成让对方感觉像是你的项目？ 1）面部表情；2）语速；3）语调！ 每天晚上回家，进卫生间，对着镜子：说！ 说什么？1）准备一段背下来的内容；2）说一段平时说话的内容 用手机录下来，放在电脑上，作对比！ 就开始练 第一阶段：一直练到你自己把自己给骗了！ 找别人练， 第二阶段：你说一段背下来的内容，对方会感觉是你会的！ 有同学是南方，普通话不是很好。 1）一定要站在对方角度看问题；2）一定要尽力为对方着想！ 第二阶段：面试 组团面试 面试：1）技术类(1、笔试题;2、上面两个问题练好)；2）非技术类，面试陷阱 第三阶段：谈价格 自我评估(真实) —— 5000(应届毕业,掌握80%,5K左右) 期望值 —— 7000(期望值和自我评估相差1000至2000左右) 你想要多少啊？ 直接说出你的期望值。10000 实在太高了，根本给不了 你们能给多少啊？ 对方给一个标准，6000 表示出非常为难，第二次要价：（期望值-对方的价格）/2+对方的价格 实在太高了，根本给不了 第三次要价：（第二次要价-对方的价格）/2+对方的价格 开始犹豫，不能给对方犹豫的机会，想尽一切办法告诉对方：你值这个价 你这么大领导，连这点权利都没有？ 这么大一家公司，每个月也不差这1000或2000吧 我相信我为公司能创造出来的价值会远远超过公司给我的这个待遇 有点高，在犹豫 你们能给多少啊？ 根据对方的价格来判断：对方的上线 非这个价不谈 不要那么执着，找一些理由来说明你不值这个价格 那好，既然我那么多不足。那算了 那好吧 刚好在对方的范围内，对方很高兴 考虑能不能接受 在要价格的时候，尽量高标准 在讨价还价的时候，一定要注意的是：每一次对方的表情，通过表情判断对方的想法 行为心理学，HR(行政、财务等) 铁打的心、自我调节能力 我的第一份工作, 钱不是重点, 要的是长远的发展, 希望是7k 因为同学在上海深圳都是78k, 而且我的水平和他们差不多, 所以我值这个价 将来在公司如何发展？ 遍历公司里的所有的技术人员包括技术领导：一定要找到公司的技术大牛(公司所用的) 遍历公司里的所有的业务人员包括技术人员，一定要找到对公司业务非常熟悉那些人 在公司里的将来发展就靠这两种人 想尽一切办法和这些人搞好关系：一定不要在公司里上班的时间。一定要投其所好 直接领导和主要领导 和主要领导搞好关系的同时，要注意不要让直接领导感觉到 直接领导搞好关系到什么程度？就是让直接领导把你当自己人 HR、行政：尽量不要与这些人有交集","categories":[],"tags":[]},{"title":"测试理论","slug":"Memo-Skills-Test-TestTheory","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Test-TestTheory/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Test-TestTheory/","excerpt":"","text":"目录 start 测试 为何要使用测试 基础知识 测试替身 虚设对象 存根对象 伪装替身 模拟对象 测试类别 单元测试 【A/B测试】 A/B测试的应用场景 元素/控件层面 功能层面 产品层面 公司层面 相关问题 【冒烟测试】 TDD 测试驱动开发 什么是TDD TDD实践 Mock BDD 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs 测试 参考博客: 测试的道理 为何要使用测试 帮助理解需求 单元测试应该反映Use Case，把被测单元当成黑盒测试其外部行为。 提高实现质量 单元测试不保证程序做正确的事，但能帮助保证程序正确地做事，从而提高实现质量。 测试成本低 相比集成测试、验收测试，单元测试所依赖的外部环境少，自动化程度高，时间短，节约了测试成本。 反馈速度快 单元测试提供快速反馈，把bug消灭在开发阶段，减少问题流到集成测试、验收测试和用户，降低了软件质量控制的成本。 利于重构 由于有单元测试作为回归测试用例，有助于预防在重构过程中引入bug。 文档作用 单元测试提供了被测单元的使用场景，起到了使用文档的作用。 对设计的反馈 一个模块很难进行单元测试通常是不良设计的信号，单元测试可以反过来指导设计出高内聚、低耦合的模块。 基础知识 码农翻身: 张大胖和单元测试 个人笔记: TDD 测试驱动开发 测试替身 泛指任何出于测试目的的替换真实对象的假冒对象，为了解决测试代码的依赖项问题。四种方式： 虚设，伪装，存根，模拟 p286 虚设对象 他是用来填充参数列表，填补那些总也不会用的必填域。大多数情况下，甚至可以传入null，就是把需要的参数虚拟出来 只是为了避免NPE，让代码能跑起来 存根对象 用来代替真实环境对象，需要有做出相同响应的对象，就是存根对象 将一些外部类或三方资源，写一个类，以及对应的方法，来提供测试运行 伪装替身 伪装替身，可以看作是存根的升级。他做的工作几乎是和生产代码是一样的，单位了满足测试需求也会使用便捷的方式 例如 内存数据库HSQLDB 的使用， 模拟对象 存根对象的调用通常会返回形同的结果。所以不能模拟任何与状态有关的行为，模拟对象就能够更好的胜任 在准备要用的模拟对象时，告诉他会有哪些调用，以及对应的相应，模拟会和DI结合更好。可以用一个虚拟的对象，这个对象完全按照已知方式行动 模拟类库：Mockito官网 调用mock()方法创建模拟对象，并将模拟目标类型的class对象作为参数传进去。 然后要把模拟对象需要的行为记录下来，通过 when方法表明要记录哪些方法的行为，然后用thenReturn方法指定期望结果。 测试类别 单元测试, 集成测试 单元测试 3A 原则: Arrange: 初始化测试对象或者准备测试数据 Act : 调用被测方法 Assert: 断言 【A/B测试】 对照实验，也叫随机实验和 A/B测试 参考来源:知乎问题 | 相关三方平台 A/B测试其实是一种“先验”的实验体系，属于预测型结论，与“后验”的归纳性结论差别巨大。A/B测试的目的在于通过科学的实验设计、采样样本代表性、流量分割与小流量测试等方式来获得具有代表性的实验结论，并确信该结论在推广到全部流量可信。说句题外话，大量的大数据公司都在尝试通过“后验”结论进行未来行为预测，个人觉得然并卵，主要是因为数据不全、脏数据、随机事件、建模人为因素等等影响，方向无比正确，现实无比残酷 A/B测试的应用场景 A/B测试这种方法论的应用非常广泛，这里讨论在Web产品、移动产品、数字广告优化领域的应用。应用场景由小到大可以可以分为： 元素/控件层面 功能层面 产品层面 公司层面 元素/控件层面灰度发布 和 A/B测试：重要页面的修改和流程上的调优，通过灰度发布到1%或者5%的用户，看其实际对用户的数据影响（访问时间增加、留存提高、下单率提高等），决定此修改到底是100%发布还是被砍掉Google：每个月从上百个A/B测试中找到十几个有效方案，月营收提升2%左右，10亿美元的规模广告位左移一个像素带来X%的增收，左移两个像素带来Y%的亏损任何产品改动需要A/B测试才能上线Facebook：6个月内所有版本完全线上灰度发布，通过不断进行用户流量分割的方式进行实验，获得无Bug口碑 灰度发布就是,先把一部分线上的业务分流到新系统上, 然后看情况, 再判断是否全部上线 功能层面无论是推荐算法还是定价策略为了简单理解，说个定价策略，如上图。一个价格包含这个几个因素： 1.价格区间：用我最朴素的理解，人类是喜欢折扣的不理性动物：人们明显更乐意花45折买一个价值900块钱的东西而不是花67折买一个价值600块的东西，尽管东西一样，最终价格一样都是400块。所以你看电商广告都是打折配合几个垫背的低价来卖。。。 2.价格精度：以前去超市经常能发现2.99元或者8.99，现在都变成2.32或者4.23，这是弄啥嘞？这里面太多心理学与营销的东西就不说了，在某些情况下，即使几分钱的价格变化对用户转化的影响是巨大的，比如一个东西原来卖400元，那现在改成399还是401可能对总营收的影响并不巨大，但是配合用户转化率的变化，可能营收的差异就天差地别了。 3.价格周期：伴随着产品迭代、促销等等因素影响，什么时候降价是对自己最有利的策略，完全可以A/B测试来解决 产品层面A/B测试在产品层面的应用主要是通过“灰度发布”来实现的。就目前移动端的产品来说，iOS的应用商店审核期是个大大大坑，任何BUG打补丁还得再来一遍，也就意味着补丁的审核期内用户带着BUG使用，这个太致命了，用户的获取成本高的吓人，因为这个流失太不值得了，基于A/B测试的灰度发布更重要的不是优化，而是保护性发布，先通过小流量的实际用户测试，有BUG或者新版本体验不好，可以立即回滚到老版本，简单有效。 公司层面A/B测试其实也是谷歌管理方法论，具体文章请参考： Google 的产品策略：两边下注 &amp;version=11020113&amp;pass_ticket=N7rowGeMgSIo27M2UKuWi1JsLuQ2wgA2f6hPaARrza5teBqjdjGkx5S6hAcmdLxo) 相关问题 辛普森悖论（Simpson’s Paradox）亦有人译为辛普森诡论，为英国统计学家E.H.辛普森（E.H.Simpson）于1951年提出的悖论，即在某个条件下的两组数据，分别讨论时都会满足某种性质，可是一旦合并考虑，却可能导致相反的结论。相关:辛普森悖论：诡异的男女比例 大多数的产品或功能上线前都会进行测试，实际上很多的测试行为并不科学，特别是很多定向的用户测试经常会有这个弊端，简单来说，如果新上线的一个功能，所有的研发工程师都说好，那是不是意味着所有的用户都觉得好？很多情况下是否定的。当然这个例子比较简单，实际上很多A/B测试方法并没有考虑到这个问题，以至于最后得出的结论跟实际情况差异巨大。要解决这个问题，对采样、聚类、流量分割等要求非常的高，这也是为什么A/B测试工具不能像很多统计工具一样，埋个点看数据，再根据数据反推业务逻辑，而是要充分与业务结合，从一开始就应该考虑业务策略，让用户去选择适合其口味的产品。 现在的创业者面临着前所未有的竞争压力，好的想法与用户接受的想法有着各种不可逾越的鸿沟。特别是伴随着激烈的竞争，谁能领先一步可能就变成了赢者通吃的局面。 相关专栏: [A/B]那些年，我们追过的AB Testing （一） | [A/B]那些年，我们追过的AB Testing （二）从“People you may know”到growth hacking 【冒烟测试】 冒烟测试源自硬件行业，对一个硬件或者硬件组件改动后，直接给设备加电，看看设备会不会冒烟，没冒烟，就表示待测组件是通过了测试。目的是确认软件基本功能正常，可以进行后续的正式测试工作。 TDD 测试驱动开发 Java程序员修炼之道 测试驱动开发章节 p276.jpg TDD带来的好处 更清晰的代码 只写需要的代码 更好的设计 有些开发人员管TDD叫测试驱动的设计 更出色的灵活性 TDD会鼓励按接口编码 更快速的反馈 不会直到系统上线才知道bug的存在 红 - 绿 - 重构循环 先编写不能通过测试的红色代码，就是一个简单的思路编写 然后修改，让测试通过，然后完善设计，进行重构编写，又进入红绿阶段，然后再重构 重构是为了通过测试你写的快速实现，重构减轻自己和别人的技术债务(临时凑合出来的设计或代码将来会付出更多的工作) 有了通过测试， 就可以放心的重构，应该实现的业务逻辑就不可能会被忽视 多个测试用例 为了覆盖更多情况 按照TDD风格，就应该为之前编写的测试用例，进行多路径全覆盖，这个测试依然是红绿重构循环。 深入思考 红 绿 重构循环 失败测试（红） 一些开发人员喜欢编写编译失败的测试，喜欢等到绿色步骤才提供实现代码 也有一些开发人员喜欢先把测试调用的方法签名写出来，这样虽然编译能通过，但还是失败 通过测试 这一步应该尽量少写代码，只要能测试通过即可。 重构 许多地方需要重构，一般是： 去掉硬编码的变量， 或把大方法拆分，对于面向对象来说应该遵循 SOLID 原则 解释SOLID原则 可以把通用的设置和拆卸代码提取出来。可以重命名测试，以便于更准确地反应他的意图，根据静态分析工具例如CheckStyle FindBugs p283.jpg 应该尽可能的遵守单个测试循环的开发模型，不要同时开多个测试循环，一堆红色 什么是TDD 百度百科词条, 简单来讲就是红绿循环, 红 绿 红…TDD是测试驱动开发（Test-Driven Development）的英文简称，是敏捷开发中的一项核心实践和技术，也是一种设计方法论。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。TDD虽是敏捷方法的核心实践，但不只适用于XP（Extreme Programming），同样可以适用于其他开发方法和过程。 个人理解：引用Mockito框架中的 “when thenReturn” and “when thenThrow“ 由预定输入，运行方法或模块后，需要返回预定的数据或者抛出预定的异常，这就是已经写好了测试 然后根据测试原型，去思考真正的功能代码的实现，当代码实现后，能够通过之前写的测试就代表着一个方法或模块的开发成功，然后开发下一个 要想做到这样的地步，首先基础的环境要思考好，耦合的问题要明确，确定公共模块之后，再一个个的TDD进行开发。一个很好的思想，不用担心你之后的改动会让代码变得丑陋不堪 优点：在任意一个开发节点都可以拿出一个可以使用，含少量bug并具一定功能和能够发布的产品。缺点：增加代码量。测试代码是系统代码的两倍或更多，但是同时节省了调试程序及挑错时间。 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。 比如对函数abs()，我们可以编写出以下几个测试用例： 输入正数，比如1、1.2、0.99，期待返回值与输入相同； 输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反； 输入0，期待返回0； 输入非数值类型，比如None、[]、{}，期待抛出TypeError。 把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。 TDD实践java测试驱动开发(TDD)之《井字游戏》 Mock 参考博客: 面向开发的测试技术（一）：Mock 既然使用模拟技术, 就要让模块的设计更易于测试, 也就是耦合更低, 之间的依赖更少, 一个正向循环呢 Mockito Official Site 该框架有多种语言的实现 Java Python … Easy Mock Official Site BDD 行为驱动开发 behavior-driven development 作为TDD的一个变种 cucumber about bdd 它的重点是描述程序的行为, 而不是一组需要通过的单元测试","categories":[{"name":"测试","slug":"测试","permalink":"http://blog.kuangcp.top/categories/测试/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://blog.kuangcp.top/tags/测试/"}]},{"title":"Junit","slug":"Memo-Skills-Test-Junit","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Test-Junit/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Test-Junit/","excerpt":"","text":"目录 start 如何使用Junit 引入依赖 Maven项目 Gradle项目 编码规范 常用注解 Rule注解的使用 断言的使用 assertThat 参数化测试 测试套件 分类测试 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs 如何使用Junit Official doc: 4.12 Junit4已经停止更新了, 取而代之的是 Junit5 Jupiter, 但是Spring等众多框架仍使用Junit4 基本使用JUnit 主要的三个特性： 用于测试预期结果和异常的断言， assertEquals() 设置和 _拆卸_ 通用测试数据的能力， @Before @After 运行测试套件的测试运行器 一个基本的JUnit测试 @Before 标记方法， 测试运行前准备测试数据 @After 标记方法， 测试运行完成后拆卸测试数据 @Test 测试方法 例如：预期的异常@Test(expected=NullPointException.class) 引入依赖Maven项目 参考项目 添加依赖123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 例如该项目结构123456789101112131415├── pom.xml└── src ├── main │ └── java │ └── com │ └── github │ └── kuangcp │ └── Caculate.java └── test └── java └── com └── github └── kuangcp ├── AssertTest.java └── CaculateTest.java 如果是Idea然后使用快捷键Ctrl Shift T即可自动创建测试类 Gradle项目 编码规范 手动创建则一般按照规范是: 包结构要和被测试类保持一致 创建一个Java类, 命名为被测试类名字后加上Test 测试具体的方法: test加上方法名 所有测试方法返回类型必须为void且无参数 测试方法里一般使用断言进行测试, 更为直观 常用注解 参考博客: JUnit4使用教程-快速入门 | 参考博客: JUnit4单元测试入门教程: @Test : 测试方法，测试程序会运行的方法,可设置参数 (expected=XXException.class) 期望该测试方法应该抛出某异常 (timeout=xxx) 限制该测试方法的执行时间, 超时视为失败 注意被注解的方法 必须是 public 无参数 非静态 @Ignore : 被忽略的测试方法 @Before: 每一个测试方法之前运行 @After : 每一个测试方法之后运行 @BeforeClass: 所有测试开始之前运行, 在测试类还没有实例化就已经加载所以需要static修饰 @AfterClass: 所有测试结束之后运行, @FixMethodOrder(MethodSorters.NAME_ASCENDING) 指定Junit方法执行顺序 since 4.11 Rule注解的使用 也可以使用 @Rule 来规定测试类中所有测试方法12@Rule public Timeout timeout = new Timeout(1000); 断言的使用 使用 Hamcrest 工具能让断言更为简洁强大 直接使用关键字 assert, 例如 assert a == null (不推荐, 因为断言不通过时没有详细报错) 静态导入 import static org.junit.Assert.*, 使用其大量工具方法: 方法签名 用法 assertNull(java.lang.Object object) 检查对象是否为空 assertNotNull(java.lang.Object object) 检查对象是否不为空 assertEquals(double expected, double actual, double delta) 检查 指定精度 的double值是否相等 assertNotEquals(double expected, double actual, double delta) 检查 指定精度 的double值是否不相等 assertFalse(boolean condition) 检查条件是否为假 assertTrue(boolean condition) 检查条件是否为真 assertSame(java.lang.Object expected, java.lang.Object actual) 检查两个对象引用是否引用同一对象（即地址是否相等） assertNotSame(java.lang.Object unexpected, java.lang.Object actual) 检查两个对象引用是否不引用统一对象(即地址不等) assertArrayEquals(Object[] a, Object[] b) 检查两个数组是否相等 assertThat(T, Matcher&lt;? super T&gt;) 检查泛型是否匹配, 以及一系列复杂的表达式 fail(String string) 依据入参并宣告测试失败 12345678910111213141516171819202122public class AssertTest &#123; @Test public void testEquals()&#123; String a = \"hi\"; String b = \"hi\"; // 使用assert关键字 assert a.equals(b); // 使用Assert类的静态工具方法 assertEquals(a, b); assert a == b; assertSame(a, b); // 因为trim 调用了SubString方法， 而这个方法是返回一个new的字符串 String c = \"h\"+\"i\".trim(); assertEquals(a, c); assertSame(a, c); &#125; @Test public void testFail()&#123; fail(); fail(\"测试失败\"); &#125;&#125; assertThat 参考博客: assertThat详解 参数化测试 Junit 4 参数化测试 允许通过变化范围的参数值来测试方法 | 个人认为: 将测试方法的入参集合数据和测试行为分离开, 简化书写逻辑 对测试类添加注解 @RunWith(Parameterized.class) 将需要使用变化范围参数值测试的参数定义为私有变量； 使用上一步骤声明的私有变量作为入参，创建构造函数； 创建一个使用`@Parameterized.Parameters`注解的公共静态方法，它将需要测试的各种变量值通过集合的形式返回； 使用定义的私有变量定义测试方法； 123456789101112131415161718192021222324252627282930313233343536// 1@RunWith(Parameterized.class)public class CaculateTest &#123; // 2 private double numA; private double numB; // 3 public CaculateTest(double numA, double numB) &#123; this.numA = numA; this.numB = numB; &#125; // 4 @Parameterized.Parameters public static Collection&lt;Object[]&gt; data()&#123; Object[][] data = new Object[][]&#123; &#123;2, 4&#125;, &#123;3, 5&#125; &#125;; return Arrays.asList(data); &#125; // 5 @Test public void testAdd() throws Exception &#123; Caculate caculate = new Caculate(); double result = caculate.add(numA, numB); System.out.println(\"input \"+numA+\" + \"+numB+\" = \"+result); assert result != 0; &#125; // 别的方法也是可以一样的使用, 而且所有的测试方法都受到了影响 都会迭代多次 @Test public void testDevide()&#123; double result = caculate.devide(numA, 3); System.out.println(\"input \"+numA+\" + \"+3+\" = \"+result); assert result != 0; &#125;&#125; 最后执行testAdd 测试方法的结果是: 将data方法返回的数据迭代执行testAdd, 测试套件 Junit 4允许通过使用测试套件类批量运行测试类 | 批量执行测试类, 组装为一个套件,一起执行 在当前测试类上加上如下注解: @RunWith(Suite.class) @SuiteClasses(TestClass1.class, TestClass2.class) 那么在执行当前测试的时候会依次执行注解中那些测试类.注意最好不要在该测试类中书写测试方法, 因为运行不了, 但是如果写了, 直接运行该测试类却又不会受影响 1234@RunWith(Suite.class)@Suite.SuiteClasses(&#123;AnnotationTest.class, EvenNumberCheckerTest.class&#125;)public class SuiteTest &#123;&#125; 分类测试 参考博客 | JUnit4— @Annotation注解总结","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://blog.kuangcp.top/tags/测试/"},{"name":"Junit4","slug":"Junit4","permalink":"http://blog.kuangcp.top/tags/Junit4/"}]},{"title":"WorkThinking.md","slug":"Memo-Skills-Work-WorkThinking","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Work-WorkThinking/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Work-WorkThinking/","excerpt":"","text":"目录 start 工作思考 如何学习 如何完成任务 交流 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 工作思考 参考博客: 如何提升你的能力？给年轻程序员的几条建议 一套高效的开发环境 一个信息采集器和一本笔记本1.目标要够大，这样你才能看到更多的风景。 目标应该设定在解决哪一类问题，而不是精通哪一类技术。技术只是手段，不是目的。 打造自己的 portfolio 建议每个程序员都应该经营一款自己的产品，它可以是一款app，一个网站或是一个开源软件。 https://insights.thoughtworks.cn/five-steps-of-developer/ 如何学习 没有人教代表你发挥的余地很大, 提升空间空前, 不该抱怨, 应该看到这个机会所在. 占据一个位置, 就能够享有这个位置的资源和眼界, 尽快在这样的环境里学习, 能力提升, 比那些有能力却没有机会的人进步不知道快到哪里. 所以, 要看到机会, 不要抱怨, 哪怕不行, 也要给别人留下自己认真学习可以做好的印象, 占据一个位置才是要紧. 职场工作里, 人们需要一种核心的价值观指导他们面对恐惧. 不管你想解决任何事情, 你都需要先调整成已经成功解决这个问题的人的思维. 然后学习他的做法, 先COPY下来, 然后针对性的调整细节. 赶紧尝试, 赶紧行动, 过程中看看错误的地方是哪里. 总结成功的经验, 把每一次学习和实践中宝贵的思维方式, 行动方法记录下来. 每天定时定量的学习, 这样可以保证每天都有只是摄入. 能COPY就先COPY, 切勿贪多, 不要没有积累的时候就开始发挥. 调整好自己的思维, 不对周围包邮过对的元气, 靠学习和工作的结果积累第七, 不表现出畏缩悲观, 才能有一个平和的心态去积累去发展, 去实现更为远大的目标. 如何完成任务 首先明确需求, 不要过多实现也不要缺斤少两, 让自己的任务完成的质量高而又不浪费时间. 当然扩展性最好是要时刻考虑好的. 交流职责明确 配合问题 参考博客: 如何更好地控制情绪，不「抬杠」？参考博客: 看清程序员怒打产品经理的本质","categories":[],"tags":[]},{"title":"PomodoroTechnique.md","slug":"Memo-Skills-Work-PomodoroTechnique","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Work-PomodoroTechnique/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Work-PomodoroTechnique/","excerpt":"","text":"目录 start 番茄工作法 规则 工作流程 细节 相关软件 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 番茄工作法 参考: 知乎:分秒时知乎专栏:什么是番茄工作法？该如何运用？ 规则 规则一：一个番茄时间共30分钟，包括25分钟的工作时间和5分钟的休息时间。 规则二：一个番茄时间是不可分割的。番茄工作法中，时间的的最小单位是一个番茄时间。一个番茄时间不能被划分： 不存在半个番茄时间或者一刻钟的番茄时间这样的事情。 规则三：每四个番茄时间后，停止你的工作，进行一次较长时间的休息，大约15到30分钟 规则四：完成一个任务，划掉一个 工作流程 计划 在每一天的开始，从Activity inventory 活动清单中选出你今天要完成的任务，优先考虑他们，并把他们记在to do today 工作计划表中； 追踪 按照to do today 完成任务，加上计划外的紧急事件（当日需要做的），记录每项任务所耗用的番茄时间； 记录档案 每天的结束时，把已经完成的任务记录在档案（自己建，可以用书本，也可用电子表格）中。 分析 “你要跟踪和记录什么，取决于你要观察什么”（！每天结束时，记录档案和思考如何提高不应该超过一个番茄时间，否则，再好的工作法也会成为累赘） 细节第一阶段：弄清完成某项任务所需的时间&amp;把“下一步动作（计划任务）”详细些（路径划）。Eg, 不是“看一本书”而是看这本书的哪个部分“看某本书到第几页或者某章” 第二阶段：减少被打断的次数我们如何避免来自内部因素的打断：·每当你意识到潜在的打断将要来临时，比如肚子饿了，想吃东西，请你在工作记录番茄的地方上一个[‘]，&amp;然后，判断是否是今日要做的，是的话，记在计划外事件清单那列，不是的话，记在活动清单。（记录时，写出截至日期或者什么时间去做）·继续当前的番茄时间 。&amp;直到完成这个番茄时间后，再去处理刚才的记录，如果不影响休息，就在休息时间处理，如果超过两分钟的话，就计划一个新的番茄时间。然后按照重要紧急优先原则，处理to do today 清单上的任务外部因素——被他人打断·方法同内部因素&amp;判断事情的紧急性，记录这件事情，继续自己的番茄时间，当这个番茄时间完成后处理。让打断变成任务·成功地拖延打断，越迟越好，尽量减轻这些打断的紧急程度，增加这些打断的可控制性。·逐渐地减少专用番茄数&amp;“计划赶不上变化快”，控制打断次数 第三阶段：估测某项任务所需要的时间规则一：如果一项任务的估测值大于5到7个番茄数，那么就打散它规则二：如果估测值小于一个番茄数，就把几个小任务合成一个大任务·从表中找出相似的任务，把他们加合在一起成一个番茄时间为止·表中没有标识估测值得任务，规则三：估测结果的记录日期、时间、任务类型 、任务描述、估测值、实际、差别 相关软件 各大平台的相关软件 目前使用的是 go for it 感觉比较好用,简洁 极简番茄 番茄TODO 番茄土豆 番茄时间钟","categories":[],"tags":[]},{"title":"Svn.md","slug":"Memo-Skills-Vcs-Svn","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Vcs-Svn/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Vcs-Svn/","excerpt":"","text":"目录 start SVN 服务端安装 svnadmin使用 备份和恢复 远程 客户端安装 使用 添加文件 配置忽略文件 提交 查看仓库 处理冲突 树冲突 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs SVN 传统的中心化版本控制工具,能够精确控制每个目录的权限, Apache顶级项目SVN 官网 | SVN中文网 Subversion 与版本控制 书籍 服务端安装 安装 svnadmin svnadmin使用 参考 建立一个仓库svnadmin create /yc/svn/rep-ops 备份和恢复 SVN版本库的备份、还原、移植（初级篇、中级篇和高级篇）svn备份一般采用三种方式 备份 svndump /svn/repos &gt; a.dump 恢复 svnadmin load /svn/repos &lt; a.dump 远程 详细文档| 问题的解决| 参考 增量备份 svnrdump dump http://192.168.10.200/svn/test/ --username kuangchengping --password 123456 -r 3:4 --incremental &gt; b4.dump 恢复 svnrdump load http://192.168.10.200/svn/test/ --username kuangchengping --password 123456 &lt; b4.dump 客户端安装Ubuntu sudo apt install subversion 安装后可使用的命令就是svn 使用 参考博客: linux-svn命令 | SVN常用命令| Linux下SVN客户端使用教程（全） 下拉代码 svn co URL 添加文件 svn add filename , 或者 *.java是添加当前目录下java文件, 或者 文件夹, 一般使用文件夹好点,也就是src目录 强制添加所有文件svn add * --force 将改动的文件提交到版本库 svn ci -m &quot;update&quot; 因为是中心化的仓库, 所以提交就是推送到总仓库了, 不像Git那样先提到到本地仓库, 然后推送至远程仓库 更新本地代码 svn up svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本 删除文件 svn remove|rm path 参考博客: svn下忽略文件和文件夹参考博客: svn 忽略文件、文件夹 配置忽略文件 svn propedit svn:ignore 项目文件夹 会打开默认配置, 和gitignore一样的配置, 然后保存即可 文件夹就是项目, 所以要在项目根目录的上级目录执行这条命令 如果上面没有调起编辑器, 就要在 .bashrc 中 export SVN_EDITOR=vim 然后提交到仓库( svn co -m “xxx” ), 即可完成 忽略文件的配置, 为了可见性, 一般和.gitignore一样的配置即可 导入忽略文件 svn propset -F .svnignore . 提交 参考博客: SVN提交注意点 部分提交 参考 提交指定文件以及目录 svn ci readme.md src/* -m &quot;1.update readme 2.add src change&quot; svn ci -m &quot;msg&quot; 提交所有已添加到版本库的操作(新建, 修改, 删除) 查看仓库 查看最后修改的文件 | svn历史版本对比以及还原到历史版本 svn log | less 这样能更为方便和干净 svn cat -r 版本号 文件 输出某个版本的某文件(文件必须在本地存在) svn diff -r 版本号:版本号 文件 对比两个版本的某文件 svn st 处理冲突 冲突的产生: 因为多个开发人员进行修改了同一个文件夹(修改,删除文件夹), 同一个文件. 树冲突 多个开发人员修改了同一个文件夹, 并且一方修改, 一方做了删除 参考博客: SVN 树冲突解决详解参考博客: 使用SVN命令行解决树冲突(tree conflict) 标记冲突已解决(使用本地的状态, 本地该文件的状态是Delete, 提交后服务端对应的文件就会被删除) svn resolve --accept=working file/dir","categories":[{"name":"Svn","slug":"Svn","permalink":"http://blog.kuangcp.top/categories/Svn/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"GitTeam.md","slug":"Memo-Skills-Vcs-GitTeam","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Vcs-GitTeam/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Vcs-GitTeam/","excerpt":"","text":"目录 start 基于Git进行团队开发 基础思想 Git Flow 本地和远程 模板化提交信息 图形化工具 SourceTree git-cola 小规模团队使用码云组织的总结 最终方案 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs 基于Git进行团队开发 在阿里，我们如何管理代码分支？版本控制最佳实践 整理和学习这几种管理方式 Github gitee gitlab bitbucket 等各大平台都是这样一种模式:个人和个人开发者之间是并行master，只适合偶尔开发提交一些代码组织就是适合给多个人，等同的稳定开发时，分支就会比较明确，这个笔记就是记录组织中git的使用 基础思想Git Flow Vincent Driessen 提出了 A Successful Git Branching Model 依据以上思想开发的 git flow工具 介绍 Git Flow 参考博客: Git 在团队中的最佳实践–如何正确使用Git Flow 参考博客: Getting Started – Git-Flow 规范的分支图 规范的分支图 Git Flow常用的分支 Production 分支 也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改 Develop 分支 这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支 Feature 分支 这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release Release分支 当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支 Hotfix分支 当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release 本地和远程 指定本地开发分支和远程的绑定关系 git branch --set-upstream dev origin/dev master同理 一个本地库是能够绑定多个远程的 分支图复杂的一个项目 只是演示分支的复杂度 模板化提交信息 git commit message 的模板化 新建 ~/.gitmessage 文件 ~/.gitconfig 中添加12[commit]template = ~/.gitmessage 那么效果就是 git commit 不指定-m 参数就会调用该模板显示 图形化工具 诚然, 命令行是高效的, 从学Git开始就是用命令行, 这只是在单兵作战或者说没有使用多分支的情况下是没有问题的当多人协作时, 需要Review代码时, 知道每个人每次提交更改了些什么, 图形化就很方便了 SourceTree Official site 仅支持 Windows 和 Mac git-cola Github: repo轻量, 简洁, 跨平台, 正是我想要的 小规模团队使用码云组织的总结 master发行分支 dev开发主分支 dev-*开发者分支 fea-*开发者自己的功能性分支 在码云上创建私有仓库，然后管理成员，将开发者一一邀请进来，然后这时候就有了一个问题： 所有的开发者都具有master的所有权限，所以这时候就会很容易出现冲突,所以就需要设置master和开发主分支dev为保护模式，只有管理员负责进行推送 管理员， 新建若干分支：git branch 分支 提交到远程 git push --all 对应的开发者克隆项目，然后 git checkout 对应的自己的分支 就可以开始工作了 （ 如果没有分支就下拉命令git fetch origin 对应的分支） 然后各个开发者写自己的，然后提交git push 就行了 管理员需要 git fetch origin 分支得到所有分支 针对每个分支进行拉取： 切换过去git checkout 开发者分支，然后git pull 开发者分支下拉最新 然后选择合并git merge --no-ff 开发者分支 ，处理冲突然后提交 开发者下拉自己的分支 或者开发主分支 dev 即可 分支的处理的一次实验 2017-10-21 23:57:34 git fetch --all 获取远程所有分支（新分支） git pull --all 获取所有分支最新提交 这个就会自动合并？？？越来越不理解了 dev-test 分支进行修改，然后提交一次，然后push master： git merge --no-ff dev-test 进行合并，就会在分支图上得到一个环 master 分支本地会多出2个提交 dev-test 进行修改，然后1次提交，push master : git pull origin dev-test 执行merge命令就会提示没有可以合并的修改。 这是为什么？？？？ 最终方案双方都有修改 开发人员提交完后，主分支管理人员切换到开发人员的分支然后 git pull 开发人员分支，然后切换回主分支上 git merge --no-ff 开发人员分支（填写注释） 然后push 然后切换到开发人员分支上执行 git merge master 然后 git push 还是git pull origin master 然后通知开发人员下拉其自己的开发分支即可 只有一方修改 主分支进行修改了开发分支没有动，那么开发分支 直接下拉 git pull origin master下拉修改代码即可 如果是开发分支修改，主分支没有动，那么管理员负责切换到开发分支 然后pull 然后merge 然后 push 然后切换开发分支 然后 pull 处理冲突","categories":[{"name":"Git","slug":"Git","permalink":"http://blog.kuangcp.top/categories/Git/"}],"tags":[{"name":"团队","slug":"团队","permalink":"http://blog.kuangcp.top/tags/团队/"}]},{"title":"Git深入学习","slug":"Memo-Skills-Vcs-GitAdvance","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Vcs-GitAdvance/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Vcs-GitAdvance/","excerpt":"","text":"目录 start Git Advance 版本控制系统(VCS) Tips 清理仓库大文件 gc 提交行为准则 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs Git Advance版本控制系统(VCS) 码农翻身:小李的版本管理系统 Tips git ls-files 列出文件列表 git ls-files | xargs wc -l 计算文件中程序代码行数 通过工具：xargs wc (中文命名的文件编码问题无法计算行数) git ls-files | xargs cat | wc -l 计算行数总和 二分查找捉虫记通过分析提交历史查到哪次提交引起的Bug然后检出,修复 API: github开发接口 清理仓库大文件 official:7.6 Git 工具 - 重写历史 Tool: bfg-cleaner 参考博客 从git中永久删除文件以节省空间 |参考博客4 减小磁盘占用删除仓库的某个时间点之前的历史记录，减少.git 目录大小如何清洗 Git Repo 代码仓库 参考博客: 寻找并删除Git记录中的大文件 找出大文件 git rev-list --objects --all | grep &quot;$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -10 | awk &#39;{print$1}&#39;)&quot; 删除文件, 重写提交 git filter-branch --force --index-filter &#39;git rm --cached --ignore-unmatch 文件的路径&#39; --prune-empty --tag-name-filter cat -- --all 强制推送 git push origin --force --all git push origin --force --tags 使用git pull rebase来更新分支，而不是 git merge 不然大文件又从别的分支回来了 要注意, 所有的分支都必须pull rebase , 只要还有一个人留有对大文件的引用, 大文件就一直在仓库 gc 只能压缩一部分空间git gc -h: --aggressive 默认使用较快速的方式检查文档库,并完成清理,当需要比较久的时间,偶尔使用即可 --prune[=&lt;日期&gt;] 清除未引用的对 --auto 启用自动垃圾回收模式 --force 强制执行 gc 即使另外一个 gc 正在执行 提交行为准则 参考博客: SVN提交更新的一个准则 提交之前先更新 SVN更新的原则是要随时更新，随时提交。当完成了一个小功能，能够通过编译并且并且自己测试之后，谨慎地提交。 如果提交过程中产生了冲突，则需要同之前的开发人员联系，两个人一起协商解决冲突，解决冲突之后，需要两人一起测试保证解决冲突之后，程序不会影响其他功能。 如果提交过程中产生了更新，则也是需要重新编译并且完成自己的一些必要测试，再进行提交。 保持原子性的提交 每次提交的间歇尽可能地短，以一个小时，两个小时的开发工作为宜。如在更改UI界面的时候，可以每完成一个UI界面的修改或者设计，就提交一次。在开发功能模块的时候，可以每完成一个小细节功能的测试，就提交一次，在修改bug的时候，每修改掉一个bug并且确认修改了这个bug，也就提交一次。我们提倡多提交，也就能多为代码添加上保险。 提交时注意不要提交本地自动生成的文件 对于Java来说, IDE自身配置文件, 和字节码文件是无需提交的 例如 .idea目录 iml文件 不要提交不能通过编译的代码 代码在提交之前，首先要确认自己能够在本地编译。如果在代码中使用了第三方类库，要考虑到项目组成员中有些成员可能没有安装相应的第三方类库，项目经理在准备项目工作区域的时候，需要考虑到这样的情况，确保开发小组成员在签出代码之后能够在统一的环境中进行编译。 不要提交自己不明白的代码 提交之后, 你的代码将被项目成员所分享。如果提交了你不明白的代码，你看不懂，别人也看不懂，如果在以后出现了问题将会成为项目质量的隐患。因此在引入任何第三方代码之前，确保你对这个代码有一个很清晰的了解。 提前协调好项目组成员的工作计划 在自己准备开始进行某项功能的修改之前，先给工作小组的成员谈谈自己的修改计划，让大家都能了解你的思想，了解你即将对软件作出的修改，这样能尽可能的减少在开发过程中可能出现的冲突，提高开发效率。同时你也能够在和成员的交流中发现自己之前设计的不足，完善你的设计。 对提交的信息采用明晰的标注 +) 表示增加了功能 *) 表示对某些功能进行了更改 -) 表示删除了文件，或者对某些功能进行了裁剪，删除，屏蔽。 b) 表示修正了具体的某个bug cherry pick","categories":[{"name":"Git","slug":"Git","permalink":"http://blog.kuangcp.top/categories/Git/"}],"tags":[{"name":"Advanced","slug":"Advanced","permalink":"http://blog.kuangcp.top/tags/Advanced/"}]},{"title":"TestNG","slug":"Memo-Skills-Test-TestNG","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Test-TestNG/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Test-TestNG/","excerpt":"","text":"目录 start TestNG 使用 基本注解 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs TestNG Official Doc 易百: TestNG教程TestNG 入门教程testNG官方文档 | Github:TestNGtools 使用 基本使用Gradle使用1testCompile group: 'org.testng', name: 'testng', version: '6.14.3' 然后和Junit使用是一致的, 在方法上打上 @Test 注解即可运行注意Test注解的包为 import org.testng.annotations.Test; 基本注解 @Test","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://blog.kuangcp.top/tags/测试/"},{"name":"TestNG","slug":"TestNG","permalink":"http://blog.kuangcp.top/tags/TestNG/"}]},{"title":"Junit5","slug":"Memo-Skills-Test-Junit5","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Test-Junit5/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Test-Junit5/","excerpt":"","text":"目录 start 如何使用JUnit5 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs 如何使用JUnit5 Official doc 参考博客参考博客: JUnit 5 新特性 参考博客: JUnit5用户指南","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://blog.kuangcp.top/tags/测试/"},{"name":"Junit5","slug":"Junit5","permalink":"http://blog.kuangcp.top/tags/Junit5/"}]},{"title":"Hamcrest","slug":"Memo-Skills-Test-Hamcrest","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Test-Hamcrest/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Test-Hamcrest/","excerpt":"","text":"目录 start Hamcrest 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs Hamcrest 官网 | 开源中国介绍 测试工具, 大大简化测试时的判断, 支持多门语言","categories":[{"name":"测试","slug":"测试","permalink":"http://blog.kuangcp.top/categories/测试/"}],"tags":[{"name":"Hamcrest","slug":"Hamcrest","permalink":"http://blog.kuangcp.top/tags/Hamcrest/"}]},{"title":"Cucumber","slug":"Memo-Skills-Test-Cucumber","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Test-Cucumber/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Test-Cucumber/","excerpt":"","text":"目录 start Cucumber For Java For Groovy 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs Cucumber official For JavaFor Groovy","categories":[{"name":"测试","slug":"测试","permalink":"http://blog.kuangcp.top/categories/测试/"}],"tags":[{"name":"Cucumber","slug":"Cucumber","permalink":"http://blog.kuangcp.top/tags/Cucumber/"},{"name":"BDD","slug":"BDD","permalink":"http://blog.kuangcp.top/tags/BDD/"}]},{"title":"SpiderBase.md","slug":"Memo-Skills-Spider-SpiderBase","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Spider-SpiderBase/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Spider-SpiderBase/","excerpt":"","text":"目录 start 爬虫基础 何为爬虫 个人实践 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 爬虫基础何为爬虫个人实践2018-02-03 15:06:35 爬到了一个带有cookie验证的网站才发现以前做的爬虫都只是简单的进行分析拆分得到URL然后下载而已 然后就了解到了wget curl等工具使用cookie的情况, Python的cookie还不太会用, 不太直观","categories":[],"tags":[]},{"title":"JavaBoot.md","slug":"Memo-Skills-FrameWork-JavaBoot","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-FrameWork-JavaBoot/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-FrameWork-JavaBoot/","excerpt":"","text":"目录 start 关于Java的快速开发框架 Springboot Jboot NuzBoot 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 关于Java的快速开发框架SpringbootJbootNuzBoot","categories":[],"tags":[]},{"title":"Kotlin.md","slug":"Memo-Functional-Kotlin","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Functional-Kotlin/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Functional-Kotlin/","excerpt":"","text":"目录 start Kotlin 教程资源 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Kotlin Kotlin官网一个能够跨越多个平台和领域的语言 教程资源 Kotlin For Android中文教程 EasyKotlin组织 《Kotlin极简教程》书籍第一章","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://blog.kuangcp.top/categories/Kotlin/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://blog.kuangcp.top/tags/函数式编程/"}]},{"title":"FPBase.md","slug":"Memo-Functional-FPBase","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Functional-FPBase/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Functional-FPBase/","excerpt":"","text":"目录 start 函数式编程思想1. [和其他思想的对比](#和其他思想的对比) 函数式特性 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 函数式编程思想 码农翻身:函数式编程圣经 和其他思想的对比 面向对象的主要限制是不能在现有方法上增加额外的逻辑，函数式就能将方法（函数）作为参数传入进行扩展 和AOP的区别：AOP是重型的基于动态代理类去封装扩展原方法 关于递归 非函数式语言中尽量是使用循环而不是递归, 函数式语言就要使用递归而不是循环 还有尾递归的概念,尾递归是将当前运行栈覆盖上一个运行栈而不是新增一个,减少栈的占用 码农翻身:张大胖学递归 深入了解尾递归 面试题关于递归的层层优化 递归化循环 函数式特性 map 映射 filter 过滤","categories":[{"name":"思想","slug":"思想","permalink":"http://blog.kuangcp.top/categories/思想/"}],"tags":[{"name":"函数式编程","slug":"函数式编程","permalink":"http://blog.kuangcp.top/tags/函数式编程/"}]},{"title":"Clojure.md","slug":"Memo-Functional-Clojure","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Functional-Clojure/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Functional-Clojure/","excerpt":"","text":"目录 start Clojure 安装 基础 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Clojure 似乎是Lisp的方言 参考博客 Clojure 学习笔记 :0 零基础教程 安装 Clojure官网下载地址 解压后运行jar包进入REPL java -cp clojure-1.8.0.jar clojure.main 基础Clojure的设计原则可以概括成5个词汇：简单、专注、实用、一致和清晰。这不是我概括的，而是《The joy of clojure》概括的。（1）简单： 鼓励纯函数，极简的语法（少数special form），个人也认为clojure不能算是多范式的语言（有部分OO特性），为了支持多范式引入的复杂度，我们在C++和Scala身上都看到了。（2）专注：前缀运算符不需要去考虑优先级，也没有什么菱形继承的问题，动态类型系统（有利有弊），REPL提供的探索式编程方法（告别修改/编译/运行的死循环，所见即所得）。（3）实用：前面提到，构建在JVM之上，跟Java语言的互操作非常容易。直接调用Java方法，不去发明一套新的调用语法，努力规避Java语言中繁琐的地方(doto,箭头宏等等）。（4）清晰：纯函数（前面提到），immutable var，immutable数据结构，STM避免锁问题。不可变减少了心智的负担，降低了多线程编程的难度，纯函数也更利于测试和调试。（5）一致：语法的一致性：例如doseq和for宏类似，都支持destructring,支持相同的guard语句（when,while）。数据结构的一致性：sequence抽象之上的各种高阶函数。 命令式语言 Java Groovy Scala都是用一个内存和状态模型，把变量映射到一个内存位置 Clojure是将值作为重点，Clojure的值一旦创建就不能修改。变量和值建立映射关系，如果再次赋值，不是修改变量，而是映射到新的值上 (def &lt;名称&gt; &lt;值&gt;) Hello Worldjava -cp clojure-1.8.0.jar clojure.main进入REPL终端12user =&gt; (def hello(fn [] \"hello\"))user =&gt; (hello)","categories":[{"name":"Clojure","slug":"Clojure","permalink":"http://blog.kuangcp.top/categories/Clojure/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://blog.kuangcp.top/tags/函数式编程/"}]},{"title":"MSA.md","slug":"Memo-Skills-Ecology-MSA","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Ecology-MSA/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Ecology-MSA/","excerpt":"","text":"目录 start MSA 概念 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs MSA 微服务 概念","categories":[],"tags":[]},{"title":"RequirementsDocument.md","slug":"Memo-Skills-Document-RequirementsDocument","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Document-RequirementsDocument/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Document-RequirementsDocument/","excerpt":"","text":"目录 start 需求文档 技术文档 Java SpringBoot 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 需求文档 做一个完善的需求分析，并书写一个需求文档 参考博客 技术文档JavaSpringBoot 可以使用 swagger2 和 spring data rest hal-browser 两者是接口文档showdoc是文档的共享更方便","categories":[],"tags":[]},{"title":"MarkDown.md","slug":"Memo-Skills-Document-MarkDown","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Document-MarkDown/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Document-MarkDown/","excerpt":"","text":"目录 start Markdown 基本格式 居中 基本元素 链接 图片 列表 头信息 流程图 Github 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs layout: posttitle: “Markdown 基本语法与应用”date: 2018-09-27 21:26:29category: tooltags: markdown github Markdown markup丰富的标记性文本格式Markdown教程CSDN的Markdown案例 Markdown 编辑器语法指南 基本格式居中123&lt;center&gt; &lt;/center&gt; 注意这俩标签前后都需要一行空行 基本元素链接 name 推荐 [[name|url]] [name][targetNum] 末尾: [targetNum]: url 图片 description ![description][targetNum] 末尾: [targetNum]: url “description” 列表 注意符号和内容之间都要有空格隔开 无序列表 : - 或 * 有序列表 : 1. (markdown渲染的时候会自动排序 1 也可以换成任意非0正整数) 列表中还能嵌套 引用, 例如: - &gt; content 或者 &gt;1. content 关于有序列表中的块状结构破坏有序性的问题 当需要出现代码块, 图片, 表格 等块状结构时, 只需将整体进行缩进, 就可以保证后续的有序性 例如: a 1echo hi b 就可以改良成: a a 1echo hi b 头信息 仅仅是github的语法, gitlab 当成了代码块进行渲染, gitee 则完全是乱的. 1234567891011121314--- layout: posttitle: \"关于WEB开发中引入javascript文件方式的一点建议\"wordpress_id: 12wordpress_url: http://wsria.com/?p=12date: 2009-02-07 18:24:46 +08:00category: javascripttags: - jquery- prototype- dojo- ext- 建议--- 可以有多种数据结构 yml ini 一般用于描述文件元信息; 静态博客生成器用于生成博客的标签等信息; 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op Github 比较全面的Github格式 GFM 目录规则（页内跳转） [](#标题名) 不需要编码 【Name】看成Name 忽略这对符号 同理还有 / 中英文的 逗号 句号 冒号 小数点 问号 空格会变成 - 文件内容 一行显示上 58列 就要换行 行末加上两个空格即是换行, 直接回车键换行是没有用的 todo 未完成 [ ] 已完成 [X] 列表的折叠写法12345### Demo&lt;details&gt;&lt;summary&gt;查看全部&lt;/summary&gt;* [`chunk`](#chunk)&lt;/details&gt; md文件的头属性1234---title: 泛型tags: Java, 泛型--- 12+ fsd- 发的所发生的","categories":[],"tags":[]},{"title":"License.md","slug":"Memo-Skills-Document-License","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-Document-License/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-Document-License/","excerpt":"","text":"License 参考博客: 开源协议及知识共享协议简单介绍","categories":[],"tags":[]},{"title":"Jenkins.md","slug":"Memo-Skills-DevOps-Jenkins","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-DevOps-Jenkins/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-DevOps-Jenkins/","excerpt":"","text":"目录 start Jenkins 安装 直接运行jar Docker 配置 配置Gradle 配置Docker插件 使用 Pipeline 个人经验 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Jenkins 官网 参考博客: 用 Docker, maven, jenkins 完成 CI 安装 官方下载地址 | 由于是一个Java的Web服务, 所以也有war版本, 资源消耗都挺大的 直接运行jar直接下载最新LTS版本, java -jar XXX.war 就可以运行了 Docker DockerHub : official | 长期支持版长期支持版文档 sudo docker pull jenkins 下拉镜像(600M+) jenkins:alpine 更小点(200M+) sudo docker run --name myjenkins -p 8080:8080 -p 50000:50000 -v /home/kcp/docker/jenkins:/var/jenkins_home jenkins 构建容器 确保目录是开放了权限的, chmod 777 jenkins 最简单直接 容器启动后, 第一次访问需要初始化, 之后就是正常的容器的启动关闭了 h1kkan/jenkins-docker 由于官方镜像更新太慢,这个镜像有最新的版本 但是以上镜像都太大,更新不一定及时, 所以完全可以自动手动构建镜像 现取下载好想要的版本的jar, 然后在一个空目录下 新建一个文件 jenkins.dockerfile12345FROM frolvlad/alpine-oraclejdk8:slimCOPY . . EXPOSE 8080EXPOSE 5000CMD [\"java\", \"-jar\", \"jenkins.war\"] docker build -t jenkins:xxx -f jenkins.dockerfile . 注意最后有一个点, 是表明当前目录 配置 配置时区 Official Wiki 参考博客: Jenkins修改时区（Docker） 或者在 Script Console 中 运行 System.setProperty(‘org.apache.commons.jelly.tags.fmt.timeZone’, ‘Asia/Shanghai’); 配置Gradle 系统管理 -&gt; Global Tool Configuration 下 配置gradle, 然后新建项目的时候选择新建的gradle配置, 执行构建的时候才会去下载Gradle 配置Docker插件 使用Pipeline123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960pipeline &#123; agent &#123; label 'docker-slave' &#125; stages &#123; stage('init') &#123; steps &#123; echo 'init..' script &#123; echo \"PATH = $&#123;PATH&#125;\" echo \"env.version = $&#123;env.version&#125;\" &#125; &#125; &#125; stage('package') &#123; steps &#123; echo \"start to build\" checkout changelog: false, poll: false, scm: [$class: 'SubversionSCM', additionalCredentials: [], excludedCommitMessages: '', excludedRegions: '', excludedRevprop: '', excludedUsers: '', filterChangelog: false, ignoreDirPropChanges: false, includedRegions: '', locations: [[cancelProcessOnExternalsFail: true, credentialsId: '22f6f4c9-f19e-4120-af4b-7946ea7cc2ef', depthOption: 'infinity', ignoreExternalsOption: true, local: '.', remote: 'http://192.168.10.200/svn/hecheng/dev/server/trunk']], quietOperation: true, workspaceUpdater: [$class: 'UpdateUpdater']] sh \"mvn -B -V -U clean package -DskipTest=true\" &#125; &#125; stage('test') &#123; steps &#123; echo 'Testing..' sh \"mvn -B test\" &#125; &#125; stage('build docker image and publish into local registry') &#123; steps &#123; echo \"starting to build docker image...\" script &#123; /* This builds the actual image; synonymous to * docker build on the command line */ sh \"pwd &amp;&amp; ls . &amp;&amp; docker info\" withDockerRegistry(url: 'http://192.168.10.6:5000/') &#123; def app = docker.build \"192.168.10.6:5000/synthesizer-dev:$&#123;env.BUILD_ID&#125;\" app.push() echo \"pushed into local registry\" &#125; &#125; &#125; &#125; stage('deploy') &#123; steps &#123; echo 'killing old server and start new server....' script &#123; sh \"docker container rm -f synthesizer-dev &amp;&amp; docker run -d -p 3070:3070 -p 16888:16888 --name synthesizer-dev 192.168.10.6:5000/synthesizer-dev:$&#123;env.BUILD_ID&#125;\" &#125; &#125; &#125; stage('clean local images') &#123; steps &#123; echo \"cleaning dangling images...\" script &#123; sh \"docker images --filter \\\"dangling=true\\\" -q |xargs --no-run-if-empty docker rmi\" &#125; &#125; &#125; &#125;&#125; 个人经验 从Gitlab私有库(Maven SpringBooot项目)建好一个任务, 并构建好镜像和容器, 更新容器做法是在运行Docker的服务器上建立一个目录专门用来更新该项目, 然后在Jenkins构建完成后将 jar 包传过去, 执行该目录下的脚本完成容器和镜像的更迭 复制项目URL, Credentials 中添加一个 username/password 类型的授权即可(就是gitlab上的用户名密码) 可以选择指定的 分支 进行构建 添加一个构建, 选择Maven的版本, Goal 中添加 命令 clean package 在Build 这里添加一个Post-build step 这里 选择添加一个 Shell, 写入要执行的脚本即可123456echo \"...构建完成, 开始建立镜像...\"jarFile=$WORKSPACE/target/app.jarif [ -f $jarFile ];then scp $WORKSPACE/target/app.jar xx@xxx:/home/xxx/ ssh xx@xxx \"cd /home/xx/ &amp;&amp; sh deploy.sh dev\"fi deploy.sh1234567891011121314version=`date +%Y-%m-%d-%H-%M`num=`docker ps | grep app | wc -l`if [ $num = 1 ];then docker logs app &gt;&gt; /home/ai/xx/log/$version.log docker rm -f appfiif [ \"$1\" = \"dev\" ];then docker build -t app:$version -f /home/xx/build-dev.dockerfile .else docker build -t app:$version -f /home/xx/build-prod.dockerfile . fiecho \"版本:\"$version\"镜像构建完成\"docker run --name app -d -p 16888:16888 -p 3070:3070 app:$versionecho \"容器启动成功\" build-dev.dockerfile12345FROM frolvlad/alpine-oraclejdk8:slimCOPY . .EXPOSE 16888EXPOSE 3070CMD [\"java\", \"-jar\", \"app.jar\", \"--spring.profiles.active=jenkins\"] build-prod.dockerfile12345FROM frolvlad/alpine-oraclejdk8:slimCOPY upload/* .EXPOSE 16888EXPOSE 3070CMD [\"java\", \"-jar\", \"app.jar\", \"--spring.profiles.active=production\", \"&gt;&gt;/var/log/game.log\"]","categories":[],"tags":[]},{"title":"ContinuousIntegration.md","slug":"Memo-Skills-DevOps-ContinuousIntegration","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-DevOps-ContinuousIntegration/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-DevOps-ContinuousIntegration/","excerpt":"","text":"目录 start 持续集成 Jenkins GoCD Drone flow.ci 三方平台 代码质量管理 sonarqube 小型项目目前使用的方案 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 持续集成 参考博客: 持续集成 | 持续集成服务 Travis CI 教程廖雪峰 使用Travis进行持续集成目前个人理解: 使用jenkins 结合gradle docker ，一键上传代码之后自动构建得到镜像 利用Travis CI更新github page 使用bitbucket配置私有仓库，在hub上配置docker文件的目录，进行构建，这样就会得到一个可用的镜像 源码是过去了，构建呢，这是个问题，可以使用Jenkins么？ Jenkins 详细 GoCD Github:GoCD 参考博客: GoCD的正确打开方式 参考博客: GoCD概念篇 Drone 官网 flow.ci 官网 | 文档 三方平台 appveyor 代码质量管理sonarqube 官网 小型项目目前使用的方案 在开发机上进行开发，然后使用脚本将war上传scp到指定文件夹下，然后执行docker命令进行构建镜像，然后运行容器","categories":[],"tags":[]},{"title":"ContinuousDeployment.md","slug":"Memo-Skills-DevOps-ContinuousDeployment","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-DevOps-ContinuousDeployment/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-DevOps-ContinuousDeployment/","excerpt":"","text":"目录 start 传统部署 Continuous Deployment BUG 跟踪 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 传统部署 打包成jar或者war，下载JDK或者JRE 绿色解压即用，将jar/war文件复制到bin目录下 后台运行 start /b java -jar fileName Continuous DeploymentBUG 跟踪 bugzilla redmine","categories":[],"tags":[]},{"title":"ContinuousDelivery.md","slug":"Memo-Skills-DevOps-ContinuousDelivery","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-DevOps-ContinuousDelivery/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-DevOps-ContinuousDelivery/","excerpt":"","text":"目录 start Continuous Delivery 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Continuous Delivery Continuous Delivery Overview","categories":[],"tags":[]},{"title":"WebSecurity.md","slug":"Memo-Skills-CS-WebSecurity","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-CS-WebSecurity/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-CS-WebSecurity/","excerpt":"","text":"目录 start Web安全 Authenticate Verfication SSL和TSL ARP断网攻击 SYNFlood攻击 CSRF XSS JWT 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Web安全 关注常见的比如 XSS CSRF SQL注入 上传等问题的原理和修复方案。还有密码安全也基本上是面试必考点。作为开发人员，需要详细了解安全问题的原理。 比如XSS的原理是因为用户将它的数据变成了代码，在页面中跑起来了，所以就可以为所欲为。 CSRF则是当用户不知情时，被黑客的网页通过图片、表单等请求时，用户的登录态（Cookies）在不知情的情况下会被发送到服务器，导致用户在不知情的情况下被利用身份。 点击支持则是网页被嵌入到了其他网站中，并通过视觉隐藏的方式引导用户进行一些不知情的操作。上传导致的漏洞是因为用户的文件没有做好判断和处理，导致传上来的文件被当成程序执行了。 SQL注入是用户的数据被当成了表示SQL语义的部分，改变了原来的查询语句的语义，从而产生意料之外的结果。反向代理服务器，构建在web服务器与 客户端之间，保护web服务器，服务器发送到客户端的请求被代理 Authenticate WWW-Authenticate Verfication 最简单的就是 数字验证码了 CAPTCHA CAPTCHA 全称 “全自动区分计算机和人类的图灵测试”（Completely Automated Public Turing Test to Tell Computers and Humans Apart）它是一种区分用户是计算机还是人的计算程序，这种程序生成人类能很容易通过但计算机通不过的测试，并进行判定，人/机进行测试的过程称为一次“挑战”。 SSL和TSL SSL/TLS协议运行机制的概述 ARP断网攻击 ARP 断网攻击的原理是什么？如何完全防护？ SYNFlood攻击 洪水攻击 参考博客 SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS（分布式拒绝服务攻击）的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。参考博客 Linux: 修改文件 sudo vim /etc/sysctl.conf 将注释取消 修改值: net.ipv4.tcp_syncookies = 0 就能提高并发总量,但是并发量还是不能提高12345678910net.ipv4.tcp_syncookies = 0 #此参数是为了防止洪水攻击的，但对于大并发系统，要禁用此设置net.ipv4.tcp_max_syn_backlog=1024#参数决定了SYN_RECV状态队列的数量，一般默认值为512或者1024，即超过这个数量，系统将不再接受新的TCP连接请求，一定程度上可以防止系统资源耗尽。可根据情况增加该值以接受更多的连接请求。net.ipv4.tcp_tw_recycle=0#参数决定是否加速TIME_WAIT的sockets的回收，默认为0。net.ipv4.tcp_tw_reuse=0#参数决定是否可将TIME_WAIT状态的sockets用于新的TCP连接，默认为0。net.ipv4.tcp_max_tw_buckets#参数决定TIME_WAIT状态的sockets总数量，可根据连接数和系统资源需要进行设置。 CSRF CSRF (Cross Site Request Forgery) 跨站请求伪造 ，它讲的是你在一个浏览器中打开了两个标签页，其中一个页面通过窃取另一个页面的 cookie 来发送伪造的请求，因为 cookie 是随着请求自动发送到服务端的。 维基百科定义 CSRF |百度百科 CSRF [Web 安全] 如何通过JWT防御CSRFweb安全之token和CSRF攻击博客:CSRF漏洞的原理浅谈CSRF攻击方式参考提问下的回答 问题是 CSRF 只是非法获取Cookie做操作么, 自己用Nginx配置两个域名的web页面试试 CSRF XSS Cross Site Scripting 跨站脚本攻击 xss攻击入门 XSS攻击及防御 最新的黑客技术：详解XSS跨站脚本攻击 JWT 理解JWT的使用场景和优劣 Blog:通过使用JWT来防御CSRF Blog:介绍JWT其实JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。 Blog:单点登录 Web 安全之 XSS、CSRF 和 JWT 参考博客: 开箱即用 - jwt 无状态分布式授权 需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据","categories":[],"tags":[]},{"title":"Profile.md","slug":"Memo-Skills-CS-Profile","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-CS-Profile/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-CS-Profile/","excerpt":"","text":"目录 start 配置文件 conf或者ini properties XML YAML Java使用 JSON Jackson 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 配置文件conf或者ini1234[main]debug=true[client]timeOut=10 propertiesXML 可阅读性强, 结构清晰, 但是太繁杂, 信息承载比重小 YAML yaml is ain’t markup language 入门博客 Python使用YML Java使用 Springboot将这种配置文件引入了我的视野，使用这个用来自定义配置文件要特别注意采用小写（不然影响反射中set方法） Jackson操作yaml JSON Google 规范 Jackson Jackcon 注解的讲解","categories":[],"tags":[]},{"title":"Network.md","slug":"Memo-Skills-CS-Network","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-CS-Network/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-CS-Network/","excerpt":"","text":"目录 start 网络 基础 ISO七层模型和TCP/IP五层模型 TCP和UDP IPv4 &amp; IPv6 ARP 网络延迟 TTFB URL 移动通信技术规格 Web安全 HTTP HTTP的返回码 HTTP的缓存 Session和Cookie HTTP1.1 和 HTTP2 HTTPS HSTS CORS Websocket WSS WebDAV WebAssembly 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 网络基础 码农翻身:小白科普：从输入网址到最后浏览器呈现页面内容，中间发生了什么？ |码农翻身:我是一个路由器 |码农翻身:我是一个网卡 ISO七层模型和TCP/IP五层模型ISO制定的OSI参考模型的过于庞大、复杂招致了许多批评。与此对照，由技术人员自己开发的TCP/IP协议栈获得了更为广泛的应用。 参考博客: 对比 TCP和UDP参考博客: 区别 IPv4 &amp; IPv6 参考博客: 浏览器访问IPv6地址 ARP 将IP和MAC对应起来的协议 网络延迟 如何彻底解决「网络延迟」这个问题？ MOBA类游戏是如何解决网络延迟同步的？ 状态同步与帧同步 TTFB Time to first byte 网络请求被发起到从服务器接收到第一个字节这段时间，它包含了 TCP连接时间，发送HTTP请求时间和获得响应消息第一个字节的时间。 URL 维基百科 | 百度百科 统一资源定位符 特别注意URL的组成和编解码 url中的特殊字符问题 不能在URL的关键位置出现%号，作为参数的值是允许的。 移动通信技术规格 1g 2g 2.5g 2.75g 3g 4g 5g 参考: 1G, 2G, 3G, 4G, &amp; 5G Explained 参考: Difference Between 1G, 2G, 3G vs. 4G and 5G Web安全 完整的系统化信息 HTTP HyperText Transfer Protocol 超文本传输协议 具体格式为: head + body HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式： OPTIONS 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。 HEAD 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 向指定资源位置上传其最新内容。 DELETE 请求服务器删除Request-URI所标识的资源。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed）；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。 Header中一些主要属性的含义和使用场景HTTP的返回码 完整列表 HTTP的缓存Session和CookieHTTP1.1 和 HTTP2 目前大多国内厂商默认的还是1.1, aws和google使用了2 而且2一般也都会使用上https HTTP2的特点: 无阻塞的Multiplexing请求队列 可以异步加载CSS和JS server端可以push资源给client端 参考博客: HTTP/2 HTTPS SSL/TSL HSTS HTTP Strict Transport Security 强制让客户端使用HTTPS进行通信 CORS 跨域 mozilla CORS阮一峰 跨域资源共享 CORS 详解CORS详解.md Websocket 本质就是TCP的简单封装, 不像HTTP那样应答模式, 一次连接后就保持全双工模式 单一的TCP连接, 采用全双工模式通信 对代理, 防火墙和路由器透明 无头部信息, Cookie, 身份验证 无安全开销 通过 ping/pong 帧 保持链路激活 服务器可以主动传递消息给客户端, 不需要客户端轮询 WSSWebDAVWebDAV （Web-based Distributed Authoring and Versioning） 一种基于 HTTP 1.1协议的通信协议.它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，使应用程序可直接对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。 WebAssembly 字节码技术 WebAssembly 实践：如何写代码 MDN","categories":[],"tags":[]},{"title":"Concurrent.md","slug":"Memo-Skills-CS-Concurrent","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-CS-Concurrent/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-CS-Concurrent/","excerpt":"","text":"目录 start 并发 同步 锁 异步 线程和进程 协程 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 并发 无关语言 涉及 同步 异步 线程 协程 同步 码农翻身:那些烦人的同步和互斥问题 这种对共享变量， 共享内存，共享资源进行访问的程序片段叫做临界区， 代码在进入临界区之前一定要做好同步或者互斥的操作。 例如在Java JDK中， 已经对线程的同步做了封装了， 对于生产者-消费者问题，可以直接使用BlockingQueue 非常简单， 完全不用你去考虑这些 wait ,signal , full, empty 锁 锁是用来锁临界区资源的 , 而不是锁代码块, 锁函数. 那么在Java中: synchronized 锁住的是不同线程对同一个对象的访问 知乎: 锁代码块和锁方法有啥区别啊？ 异步 线程和进程 协程 知乎:协程的讨论 协程以及Python实现","categories":[],"tags":[]},{"title":"CharacterEncoding.md","slug":"Memo-Skills-CS-CharacterEncoding","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-CS-CharacterEncoding/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-CS-CharacterEncoding/","excerpt":"","text":"目录 start 字符编码 ascii ANSI Unicode UTF UTF-8 UTF-16 汉字编码发展史 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 字符编码 字符编码笔记：ASCII，Unicode 和 UTF-8 | 阮一峰的文章有哪些常见性错误 字符编码参考博客: Ansi,UTF8,Unicode,ASCII编码的区别 字符内码(charcter code)指的是用来代表字符的内码.读者在输入和存储文档时都要使用内码,内码分为 单字节内码 – Single-Byte character sets (SBCS), 也就是第一个字节 0-127 双字节内码 – Double-Byte character sets)(DBCS), 也就是第二个字节 128-255 ascii ascii American Standard Code for Information Interchange 美国信息交换标准代码 属于单字节内码 并等同于国际标准ISO/IEC 646 0-31 以及 127 是控制字符或通信专用字符 （其余为可显示字符） 32～126(共95个)是字符(32是空格） 其中48～57为0到9十个阿拉伯数字 65～90为26个大写英文字母 97～122号为26个小写英文字母 其余为一些标点符号、运算符号等。 同时还要注意，在标准ASCII中，其最高位(b7)用作奇偶校验位。Linux man ascii 就可以查看, 没有这个手册就安装 ascii 用这个程序来展示 参考博客: ASCII码表 ANSI ANSI/ISO8859-1-1987 或称 Latin 1 这个编码就是 ascii 的扩展, 但是只是扩展了一个字节, 然后各个国家的编码又不一致(不同的代码页), 导致了十分混乱至于简体中文编码GB2312，实际上它是 ANSI 的一个代码页 936 Unicode unicode.org | wikipedia Unicode 是一个囊括了世界上所有字符的字符集，其中每一个字符都对应有唯一的编码值, 但是并不是一个具体实现的编码方案, 不能直接使用其实现有 UTF-8 UTF-16 UTF-32 …目前最新版本 11 已经包括 137,439 个字符 UTF UTF: UCS Transformation Format, UCS: Unicode Character Set 它是将Unicode编码规则和计算机的实际编码对应起来的一个规则。现在流行的UTF有2种：UTF-8和UTF-16. UTF-8 UTF-8 是一种Unicode的实现方式, 是一种变长编码方案(1-6), 在表示中文时是采用三字节的方式, 已基本覆盖WEB领域 依据首字节的最高位来限定 1字节 0xxxxxxx 2字节 110xxxxx 10xxxxxx 3字节 1110xxxx 10xxxxxx 10xxxxxx 4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 参考博客: UTF-8编码规则（转） UTF-16 CESU-8 汉字编码发展史最早是制定的GB2312-80 兼容 ascii 采用的是双字节编码方式, 其中一共编码了6763个常用简体汉字, Big5，是台湾使用的编码标准，编码了台湾使用的繁体汉字，大概有8千多个。HKSCS，是中国香港使用的编码标准，字体也是繁体，但跟Big5有所不同。后来，由于各方面的原因，国际上又制定了针对中文的统一字符集GBK和GB18030，其中GBK已经在Windows、Linux等多种操作系统中被实现。GBK兼容GB2312，并增加了大量不常用汉字，还加入了几乎所有的Big5中的繁体汉字。但是GBK中的繁体汉字和Big5中的几乎不兼容。 GB2312、GBK到GB18030都属于双字节字符集 (DBCS) 字体编辑用中日韩汉字Unicode编码表参考博客: Unicode中文和特殊字符的编码范围参考博客: 中文标点符号具体unicode码汉字 Unicode 编码范围 类别 字数 范围 基本汉字 20902字 4E00-9FA5 基本汉字补充 74字 9FA6-9FEF 扩展A 6582字 3400-4DB5 扩展B 42711字 20000-2A6D6 扩展C 4149字 2A700-2B734 扩展D 222字 2B740-2B81D 扩展E 5762字 2B820-2CEA1 扩展F 7473字 2CEB0-2EBE0 康熙部首 214字 2F00-2FD5 部首扩展 115字 2E80-2EF3 兼容汉字 477字 F900-FAD9 兼容扩展 542字 2F800-2FA1D PUA(GBK)部件 81字 E815-E86F 部件扩展 452字 E400-E5E8 PUA增补 207字 E600-E6CF 汉字笔画 36字 31C0-31E3 汉字结构 12字 2FF0-2FFB 汉语注音 43字 3105-312F 注音扩展 22字 31A0-31BA 〇 1字 3007","categories":[],"tags":[]},{"title":"Arithmetic.md","slug":"Memo-Skills-CS-Arithmetic","date":"2018-12-17T13:25:18.703Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/17/Memo-Skills-CS-Arithmetic/","link":"","permalink":"http://blog.kuangcp.top/2018/12/17/Memo-Skills-CS-Arithmetic/","excerpt":"","text":"目录 start 算法 时间复杂度 匹配算法 排序算法 安全 密码学 Diffie-Hellman Key Exchange算法 实际问题 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 算法 《编程之法》 分治算法动态规划 最值 极值不直接找问题, 而是根据你的输入, 和答案之前关系的规律 柯里化, continuation 高阶函数, 尾递归 时间复杂度 Java中的实践 匹配算法 字符串相似度匹配 排序算法 参考博客: 九种排序算法的可视化及比较 安全密码学Diffie-Hellman Key Exchange算法 Whitfield Diffie 和 Martin Hellman ，他们于２０１５年获得了计算机科学领域的最高奖：图灵奖 码农翻身 最后神奇的魔法发生了， 我们两个得到了同样的值 s = 10！ 这个s 的值只有我们两个才知道， 其实就是密钥了， 可以用来做加密解密了（ 当然，这只是一个例子，实际的密钥不会这么短）， 我们俩的通讯从此就安全了。 “数学家小帅哥说了， 原因很简单，(gｘ mod p)ｙ mod p 和 (gｙ mod p)ｘ mod p 是相等的！ ” “那黑客不能从公开传输的 p = 17, g = 3, a = 6 , b = 12 推算出s = 10 吗？” 我问道。 “当然不能， 不过前提是需要使用非常大的p , x, y, 这样以来，即使黑客动用地球上所有的计算资源， 也推算不出来。 ” 实际问题例如存储一个部门关系, 上下级, 以及同级要有序, 并且, 这个关系树是能随意调整结构的, 每个节点和节点之间任意断开和连接 name/id, parent, index","categories":[],"tags":[]},{"title":"Java相关精彩博客","slug":"Memo-Blog-Java","date":"2018-12-16T09:32:04.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Blog-Java/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Blog-Java/","excerpt":"","text":"目录 start Java 社区 SE JavaFx 爬虫 Springboot BuildTool Test 精彩系列 码农翻身 架构师 Java语言讨论 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Java 和Java有关的博客和网页 社区 并发编程网 Java InfoQ Java IBM Java SE 菜鸟入门：Java程序员学习之路 Eclipse Collections以及Java8的特性 Java8的特性 正确使用Volatile变量 javadoc 和 javadoc注释规范 推荐！国外程序员整理的Java资源大全 oracle magazine Java动态代理机制详解 博客很细致，深入原理 使用JMockit编写java单元测试 Java(Android)线程池 Docker图形化管理 JavaFx xJavaFxTool基于JavaFX的工具集 爬虫 Java网络爬虫实操 比较全面的讲述了如何使用Java写爬虫 Springboot Springboot入门系列博客 Springboot配置详解 Springboot启动dubbo等一系列文章 spring boot完美集成dwr3.0.2 Spring Boot——开发新一代Spring Java应用 BuildTool Gradle构建多模块项目 tig gradle构建Springboot的镜像 Test 扩展 JUnit 测试并行程序 自动化测试工具 JUnit4 多线程执行测试用例 腾讯的点击验证码是什么原理? 精彩系列码农翻身 2017精华 | 精华文章 2017码农翻身文章 2016码农翻身文章 当你想学别的语言的时候看这里 上天还是入地 往深度挖掘，可以成为某个技术领域的专家，如搜索方面的专家、安全方面的专家，分布式文件的专家等等，不管是哪个领域，重点都不是学会使用某个工具和框架， 而是保证你可以自己的知识和技术去搞定这个领域的顶尖问题。往广度发展，各个技术领域都要了解，对于某种需求，能够选取合适的软件和技术架构来实现它，把需求转化成合适的技术组件，让这些组件以合适的方式连接、部署、运行，这也需要持续地学习和不断的经验积累。 前后端 JDK各个版本发布时间 架构师 通向架构师的道路(比较老) Java语言讨论 冷眼看Java参考博客: 王垠：为Java说句公道话参考博客: 比较 Rust 和 Java参考博客: Kotlin与Java的主客观比较参考博客: 10个实用的但偏执的Java编程技术参考博客: 王垠：编程的智慧","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://blog.kuangcp.top/tags/Blog/"}]},{"title":"Blog","slug":"Memo-Blog-Blog","date":"2018-12-16T09:30:58.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Blog-Blog/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Blog-Blog/","excerpt":"","text":"目录 start 博客 个人博客网 博客能人 专栏 【Blog】 搭建博客 NetWork 经验之谈 操作系统 Windows Linux 安卓 Web性能 Tool 团队开发 毕业 生活 娱乐 玩机 商业 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 只用来记录非技术类的文章,技术类的直接放到对应的笔记中去Java相关 | Go相关 | Python相关 | 解决方案 | 前端相关 | 服务器运维 博客个人博客网 王垠 ciaoshen肉身翻墙? Java大佬 阮一峰一个勤奋的布道者,Github每天都有提交 酷壳左耳朵耗子个人博客网 阿里架构师 程序员DD翟永超 Spring4all社区创立者 冰封千里Javaer,JavaFX和JVM类语言擅长 hushuang.me 猛禽 一个坚持了17年博客的程序员 折腾的创业者大学生创业 David’s blogJava程序员 http://blog.leapoahead.com经验之谈 Java和Vue前后端 Web程序猿 letus.club 海底苍鹰(tank) 前端和Linux 彭鑫Git权威指南作者,Git比较熟练 Chenxu使用Github page 以及Https 全免费搭建 Romeng’s blogedu邮箱,VPS等 如有乐享突破限制的 教程资源比较多 javabolgnutz作者的博客 chenssy 技术较新 Java博客网 java3y技术比较全面 tengjSpringBoot了解深入 dreamlikesJava后台开发 张子阳的博客 有技术,有推荐的书 绿色记忆 技术涉猎广泛 嘟嘟独立博客SpringBoot系 ityouknowJava丰富技术栈 云收藏的开发者 会飞的污熊github 搭建静态博客, 内容多 yscoderindigo主题的作者 hexo 晓风轻技术小站程序员你为什么这么累？ 作者 todo 张铁蕾总结能力强 zhangyi设计模式,TDD johng.cnDocker,算法相关 Catch简单的小知识点 importNew 漠然容器 kubernetes方面 senra 服务器, 容器等方面博客能人 赵劼 对函数式编程，并行程序开发，代码之美以及程序员能力与修养等相关问题 进击的Java新人 Java知音较多面试题 拭心安卓大佬 陈皓左耳朵耗子 于亮Java相关知识,专栏挺多,阅读量都不低 BlindingDark擅长函数式编程lisp clojure等 轮子哥博客 zhangchuzhao有深度干货 人月神话 杜琪 Java 服务端 恒宇少年 wsdjegSpaceVim作者 专栏 CSDN 知识林 三分钟教你学Git 设计模式 网络安全 【Blog】搭建博客 知乎话题：如何搭建博客 知乎专栏：使用Springboot搭建博客 solo博客系统 markdown 咖啡兔现成的模板直接用md就能生成了 Gitment：使用 GitHub Issues 搭建评论系统 NetWork 使用清华的IPV6 经验之谈 不好的编程习惯 英语的重要性 正确的学习语言 很多时候工程师们争论的问题，不再是对和错、是与否的问题，而是每个人的观点应用到相关的场景中的时候带来的优劣比较。也就是说，是不是把合适的技术用到了正确的场景中。平衡是我们在这个阶段要着重考虑的，这种平衡有时候是时间复杂度，有时候是空间复杂度。 初学者不要纠结“先学哪种语言”，这种时间花得很不值得，还不如随便挑一个语言，跳进去游几圈试试。对于工程师来说，学习第一门编程语言只是万里长征的第一步，只要你还在这个领域，就不可能只学一种语言，只会一种语言的工程师根本就不能称之为工程师。 如果你不能用一种编程语言的基本特性写出好代码，那换成另外一种语言也无济于事，你会写出同样差的代码。比如，你的 Java 代码写得很糟糕，那么换成 Go、Ruby，你的代码也会一样糟糕，甚至更差。所以，基本掌握了一门语言的功能和语法特性之后，要去做实践和练习，能写生产代码了，再回过头来去看编程语言的本质，了解这门编程语言的设计原理，能力边界和高级功能，这样有助于你更快更好掌握其他编程语言。 很多人觉得不要用脚本语言入门，我觉得不一定，尤其现在就着人工智能浪潮搞机器学习的人，用 Python 入门就很好。另外，脚本语言在面试中绝对占优势。平时工作中我对 Ruby、Python、C++、和 Java 的熟练程度差不多，但是面试中使用 Ruby 或者 Python 答题，写代码的时间估计是那两者的一半。 后端工程师要熟练掌握一门前端语言，前端工程师也要熟练掌握一门后端语言。倒不是为了提倡全栈或多个能力储备，而是两者的编程思维模式很不一样。知己知彼，在架构设计和解决具体问题时，才会有更精确的判断。另外，现在大前端的概念也比较流行，也就是大前端工程师能够同时掌握 Web 编程语言、iOS 和 Android 编程语言，原生技术（iOS 和 Android）和 Web 的配合会越来越紧密。 SQL 是一门非常非常重要并且应该熟练掌握的语言（虽然它不能被称为程序语言），我在这里用了两个非常，因为很多工程师有些过于轻视 SQL 了，并为此付出了惨重的代价。如果你平时的编程工作涉及到业务功能，而不是纯粹的技术架构，一定会使用到数据库。SQL 就是数据的语言，通过它你可以和数据建立连接和沟通。如果你的数据访问模式写得很差，轻则代码性能一塌糊涂，重则引发 Bug，而涉及数据的问题，Bug 等级都比较高，后果可能很严重。 无论使用什么语言，工程师都应该能够基于这种语言搭建测试框架，写好测试代码和写业务代码一样重要，甚至更重要。工作后你会发现，可能有时候我们只花五分钟写了一个程序，而为其写一个差不多能够覆盖所有功能路径的测试用例集却花了一个小时。 最后的，也是最重要的是：在任何时候都要用并发的、分布式的思维去看待你的程序。因为竞争条件或者并发中的不确定因素（比如调用顺序）导致的 Bug，仅仅理解语言的基本特性，根本不能解释。每种语言都有自己的并发编程模式（比如 Go 的 Goroutine，Java 的 ForkJoinPool，Swift 的 Swift Grand Central Dispatch 等）。学习每一种语言，都应该去深入了解它的并发模型，在这个多核的时代，不懂并发的程序员不可能是个好工程师。 最近几年我主要使用 Ruby 和 Java 编程，这两门语言的优缺点就不在这里说了，网上有很多类似的观点。如果你还不知道应该学习哪一门编程语言，那么就从 Java 开始吧。编程语言，你看它是山，它就是山；看它是水，它就是水。你可以把它当做一门简单的编程语言，有语法，有特性，也有优缺点，但这样的语言也可以复杂到去实现和解释各种计算模型和理论。一门编程语言到底能做什么，完全和工程师怎么去用，在什么场景中用息息相关。 码农翻身:这个动物园， 两年也逛不完 谁将会杀死 Java？ 如何将脑海中的思维火花转化为代码 先把流程大致想清楚，在 main() 中写下大致的调用结构,不一定要实现每个细节，可以先用函数分装起来。实现最少的功能，之后再想怎么改进，加功能；这个过程也可以检验一开始写下来的代码是不是具备可拓展性。比如用 js 做日历，可以先实现一个只能打印字符串日历的版本（这涉及到日期的计算，简单格式化输出），然后思考怎么把字符串适配到 html 上？或者服务端的话输出为 json ？或者其实可以跳过序列化这一步？等等。可以学习一下 TDD ，一边写代码一边写测试，切忌自以为思考完所有细节一气呵成实现完毕，这样的话基本上写代码：调试找 bug = 1:10 参考博客: 2018开发者技能报告，让你更了解自己的行业。 操作系统WindowsLinux Ubuntu放弃战斗, Linux桌面的悲哀deepin王总 一些工具软件 关于uptime输出的详解 Ubuntu安装我的世界 安卓 Android，开源还是封闭？ Web性能 ab: Apache Benchmark 的使用的个人浅薄经验 1M带宽的服务器并发问题 Tool genymotion 4.2.2 windows版 使用gitbook打造电子书 免费SSL证书获取 免费HTTPS证书 团队开发 团队开发工作流项目 参考博客: 有人向我反馈了一个bug 毕业 开题答辩的礼貌性注意事项 如何准备校招技术面试 知网毕业论文查重有关 生活 那些拿命换钱的年轻人，换着换着就死了 相关书籍 土木真的没有 IT 行业有前途吗？每一行都不容易！ 我的 2017 ：\b追逐更好未来的一年 《程序员的成长课》:少走5年弯路 阮一峰的随笔 业务分析三维度（场景+角色+时间）之程序员坐禅论道 娱乐玩机 华为全面屏手势 商业 都说在做某界的 Airbnb，Airbnb 到底做了什么","categories":[{"name":"Blog","slug":"Blog","permalink":"http://blog.kuangcp.top/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://blog.kuangcp.top/tags/Blog/"}]},{"title":"Apollo","slug":"Memo-Distributed-Middlewave-Apollo","date":"2018-12-16T09:30:10.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/16/Memo-Distributed-Middlewave-Apollo/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Distributed-Middlewave-Apollo/","excerpt":"","text":"目录 start Apollo 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Apollo Github:Apollo 研究 https://github.com/ctripcorp/apollo/blob/master/apollo-adminservice/pom.xml 怎么实现 ./*.jar 就能运行的","categories":[{"name":"分布式","slug":"分布式","permalink":"http://blog.kuangcp.top/categories/分布式/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://blog.kuangcp.top/tags/中间件/"}]},{"title":"SQLServer","slug":"Memo-Database-SQLServer","date":"2018-12-16T09:29:45.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Database-SQLServer/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Database-SQLServer/","excerpt":"","text":"目录 start SQLServer 安装配置 Docker安装2017硬是不成功 2000版本 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs SQLServer安装配置Docker安装2017硬是不成功 dockerhub网址 12345678910111213141516docker run -d -e SA_PASSWORD=&lt;passord&gt; -e SQLSERVER_DATABASE=&lt;db name&gt; -e SQLSERVER_USER=&lt;user&gt; -e SQLSERVER_PASSWORD=&lt;password&gt; -p &lt;local port&gt;:1433 exoplatform/sqlserver:ctp2-1-1docker run -d -e SA_PASSWORD=ad -e SQLSERVER_DATABASE=mythos -e SQLSERVER_USER=myth -e SQLSERVER_PASSWORD=jiushi -p 1433:1433 mssqldocker run --name mssql -e ACCEPT_EULA=Y -e SA_PASSWORD=docker888 -e SQLSERVER_USER=myth -e SQLSERVER_PASSWORD=jiushi -p 1433:1433 -d microsoft/mssql-server-linux:latestdocker run -e 'SA_PASSWORD=docker888' -p 1433:1433 -it --rm microsoft/mssql-server-linux:latest /opt/mssql/bin/sqlservr --accept-eula# 查看控制台输出docker run --name mssql -e ACCEPT_EULA=Y -e SA_PASSWORD=docker888 -e SQLSERVER_USER=myth -e SQLSERVER_PASSWORD=jiushi -p 1433:1433 -it microsoft/mssql-server-linux:2017-GAdocker run -d -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=ad' -e 'SQLSERVER_PASSWORD=jiushi' -p 1433:1433 microsoft/mssql-server-linux:2017-GA 2000版本 docker别人做的镜像","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"SQLServer","slug":"SQLServer","permalink":"http://blog.kuangcp.top/tags/SQLServer/"}]},{"title":"SQL基础","slug":"Memo-Database-SQL","date":"2018-12-16T09:29:28.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Database-SQL/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Database-SQL/","excerpt":"","text":"目录 start SQL 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs SQL 基础SQL语言的学习使用 soarSQL Optimizer And Rewriter","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.kuangcp.top/tags/SQL/"}]},{"title":"Redis进阶","slug":"Memo-Database-RedisAdvance","date":"2018-12-16T09:29:06.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Database-RedisAdvance/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Database-RedisAdvance/","excerpt":"","text":"目录 start Redis常用命令 Run Configuration 过期策略 事务 服务器 Redis的应用场景 作为日志记录 作为网站统计数据 存储配置信息 自动补全 构建锁 任务队列 数据安全和性能 持久化策略 复制 数据迁移 错误分析 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Redis常用命令 关闭数据库 shutdown 该命令会在关闭数据库前保存数据 保存内存中数据到文件 save 认证 auth 口令 测试联通性 ping 连接成功会返回pong 模糊删除 删除 6666端口 的 2数据库中detail-2018-07-0*模式的数据: ./redis-cli -p 6666 -n 2 keys &quot;detail-2018-07-0*&quot; | xargs ./redis-cli -p 6666 -n 2 del 查看所有连接 client list redis-stat Run Configuration slaveof redis-server --port 9999 --slaveof 127.0.0.1 6379 启动一个9999端口作为6379的从服务器进行同步 或者服务启动后执行 slaveof host port（如果已经是从服务器，就丢去旧服务器的数据集，转而对新的主服务器进行同步） 从服务变成主服务 slaveof no one (同步的数据集不会丢失，迅速替换主服务器) loglevel ./redis-server /etc/redis/6379.conf --loglevel debug 过期策略 expire key seconds 设置键的过期时间 PTTL/TTL key 查看键剩余过期时间（生存时间） ms/s -1 表示永久 -2 表示没有该key 事务 DISCARD 取消事务，放弃执行事务块内的所有命令。 EXEC 执行所有事务块内的命令。假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令， 那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。 MULTI 标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。 UNWATCH 取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。 因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。 WATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 服务器 BGREWRITEAOF BGSAVE CLIENT GETNAME CLIENT KILL CLIENT LIST CLIENT SETNAME CONFIG GET CONFIG RESETSTAT CONFIG REWRITE CONFIG SET DBSIZE DEBUG OBJECT DEBUG SEGFAULT FLUSHALL FLUSHDB INFO 参考: redis info 命令查看redis使用情况 info stats 中 total_commands_processed 是实际请求, 还是说redis自己执行的命令 TODO LASTSAVE MONITOR PSYNC SAVE SHUTDOWN SLAVEOF SLOWLOG SYNC TIME Redis的应用场景 参考博客: 为什么我们做分布式使用Redis？缓存的场景和应对措施 作为日志记录作为网站统计数据存储配置信息自动补全 搜索建议 构建锁任务队列 发送邮件 数据安全和性能持久化策略复制数据迁移 使用主从复制来进行数据, 或者自己写Py脚本? 错误分析 JedisConnectionException: Could not get a resource from the pool cause by java.util.NoSuchElementException: Unable to validate object 多种原因, 由于设置了 testOnBorrow 为 true, 那么在每次获取数据时, 就会先测试性的获取一个数据, 然后校验能否正常拿到该数据 如果拿不到就抛出这个异常, 原因可能有: 根本没有连接上Redis, 配置有问题 端口 bind 什么的 Redis 存放数据的 rdb 文件所在目录 没有存储空间了 没有内存空间了, 由于执行save操作时, 会进行fork子进程 然后进行持久化 TODO 验证","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.kuangcp.top/tags/Redis/"}]},{"title":"Redis","slug":"Memo-Database-Redis","date":"2018-12-16T09:28:55.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Database-Redis/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Database-Redis/","excerpt":"","text":"目录 start Redis Book 安装和配置 Windows Linux docker安装redis 命令安装 解压即用 Redis配置文件 数据类型 字符串String 列表List 集合Set 有序集合Zset 散列Hash HyperLogLog GEO地理位置 Pub/Sub发布和订阅 编程语言的使用 Java使用 Python使用 Project webdis 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Redis Official Site | Redis中文社区 | Redis教程 Redis Official doc zh Book Redis设计与实现 第二版 安装和配置Windows 注册为服务 redis-server --service-install redis.windows.conf --loglevel verbose 使用cmder cmd 中运行 E:/redis/redis-server.exe E:/redis/redis.windows.conf 配置密码 requirepass redis1104 客户端登录 auth redis1104 Linuxdocker安装redis docker-install-redis 命令安装 这样不太好做多个redis, 个人不喜欢这种方式 安装 apt install redis 开启数据库服务 redis-server 打开客户端 redis-cli 解压即用 下载我打包好的(仅适用于Linux平台)5.0.0 | 4.0.2 | 3.2.8 个人配置步骤: 从源码编译: 官网下载源码，src下执行make进行编译，编译完成后，复制src目录中的redis-cli redis-server就可以用了，redis-benchmark 可选，测性能 配置文件: 再复制下面的简化配置文件，或者使用源码中根目录下的配置文件自己配置下 简化配置文件 再创建以下两个脚本就可以便捷的使用redis了 server_redis.sh123basepath=$(cd `dirname $0`; pwd)echo $basepath$basepath/redis-server $basepath/redis.conf&gt;redis.log &amp; client_redis.sh12basepath=$(cd `dirname $0`; pwd)$basepath/redis-cli -p 6379 Redis配置文件 配置文件讲解 | 原始配置文件 使用ing简化配置文件 数据类型 社区: 中文文档 字符串String 字符串就是字节组成的序列 可以放字节串，整数，浮点数 set key newval nx存在则set失败 set key newval xx不存在则set失败 incr incrby decr decrby 只要存入的String能被解析为数值,就能执行这些命令: 递增或者递减 incr 是原子操作即并发的情况下不会有脏读(可用于主键生成策略) getset key val get旧值并且set新值 mset mget mset key val key val mget key key key 返回值组成的数组 exists key 有该值就返回1否则0 del key 返回1被删除，0 key不存在 type key 返回值的类型 expire key secondes 设置或改变超时时间，精度是秒或毫秒 set key val ex secondes set时设置超时时间 persist key 去除超时时间 ttl key 查看剩余存活时间 -1表示永久 -2表示没有该key 列表List rpush key val val val右/尾添加元素 lpush是左/头，若表不存在就新建 rpushx key value 若表不存在就什么都不做，否则尾插元素 rpop key 从list右/尾端中删除元素返回元素值 没有了就返回null lrange key 0 -1 取指定长度的list -1表示全部 ltrim key 0 2 截取当前的list lindex key index 返回偏移量为index的元素(提到偏移量一般都是0开始) linsert key BEFORE|AFTER pivot value 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。 当 pivot 不存在于列表 key 时，不执行任何操作。当 key 不存在时， key 被视为空列表，不执行任何操作。 如果 key 不是列表类型，返回一个错误。 lrem key count value 根据参数 count 的值，移除列表中与参数 value 相等的元素。 阻塞式的列表弹出命令(block) 队列很有用 blpop brpop bpoplpush brpoplpush 阻塞式先右弹再左进 集合Set SADD key member [member ...] SCARD key 返回集合 key 的基数(集合中元素的数量)。 SDIFF key [key ...] 返回一个集合的全部成员，该集合是所有给定集合之间的差集。不存在的 key 被视为空集。 SDIFFSTORE destination key [key ...] 这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。 SINTER key [key ...] 返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。 SINTERSTORE destination key [key ...] 与sdiffstore类似 SISMEMBER key member 判断 member 元素是否集合 key 的成员。 SMEMBERS key 获取某Set所有元素 SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合。 SMOVE 是原子性操作。 SPOP key 移除并返回集合中的一个随机元素 SRANDMEMBER key [count] 如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素 SREM key member [member ...] 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。 SUNION key [key ...] 返回一个集合的全部成员，该集合是所有给定集合的并集。 SUNIONSTORE destination key [key ...] SSCAN key cursor [MATCH pattern] [COUNT count] 参考 SCAN 命令 有序集合Zset 元素是键值对，键是member成员，值是score分值必须是浮点数 ZADD 将一个给定分值的成员添加到有序集合里 ZCARD 获取有序集合的成员数 ZCOUNT min max 计算在有序集合中指定区间分数的成员数 ZINCRBY key increment member 自增 ZRANGE 根据元素在有序集合中的位置，从有序集合中从小到大获取多个元素 zrange name 0 -1 withscores 获取所有并获取分值 zrange name 0 3 withscores 获取分数最少的4个键值对 ZREVRANGE 相反的, 从大到小 zrangebyscore 获取有序集合在给定范围中的所有元素 zrangebyscore name 0 200 withscores ZRANK ZREM ZREMRANGEBYRANK ZREMRANGEBYSCORE ZREVRANGEBYSCORE ZREVRANK ZSCORE ZUNIONSTORE zinterstore 进行集合之间的并集（可以看作关系型数据库的多表连接） ZSCAN ZRANGEBYLEX ZLEXCOUNT ZREMRANGEBYLEX 散列Hash (类似Map 嵌套，一个内置的微型redis) HDEL 删除散列中指定的K HEXISTS HGET HGETALL HINCRBY HINCRBYFLOAT HKEYS HLEN HMGET HMSET HSET HSETNX HVALS HSCAN HSTRLEN HyperLogLog PFADD PFCOUNT PFMERGE GEO地理位置 GEOADD GEOPOS GEODIST GEORADIUS GEORADIUSBYMEMBER GEOHASH Pub/Sub发布和订阅 PSUBSCRIBE pattern [pattern ...] 订阅一个或多个符合给定模式的频道。每个模式以 作为匹配符，比如 it 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)， news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类。 PUBLISH channel message 将信息 message 发送到指定的频道 channel 。 PUBSUB &lt;subcommand&gt; [argument [argument ...]] PUBSUB 是一个查看订阅与发布系统状态的内省命令， 它由数个不同格式的子命令组成， 以下将分别对这些子命令进行介绍。 PUBSUB CHANNELS [pattern] 列出当前的活跃频道。设置pattern参数就会匹配活跃频道，否则是列出所有频道 PUBSUB NUMSUB [channel-1 ... channel-N] 返回给定频道的订阅者数量， 订阅模式的客户端不计算在内。 PUBSUB NUMPAT 返回订阅模式的数量。注意， 这个命令返回的不是订阅模式的客户端的数量， 而是客户端订阅的所有模式的数量总和。 PUNSUBSCRIBE [pattern [pattern ...]] 指示客户端退订所有给定模式。如果没有模式被指定，也即是，一个无参数的 PUNSUBSCRIBE 调用被执行， 那么客户端使用 PSUBSCRIBE 命令订阅的所有模式都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的模式。 SUBSCRIBE channel [channel ...] 订阅给定的一个或多个频道的信息。 UNSUBSCRIBE [channel [channel ...]] 指示客户端退订给定的频道。如果没有频道被指定，也即是，一个无参数的 UNSUBSCRIBE 调用被执行， 那么客户端使用 SUBSCRIBE 命令订阅的所有频道都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的频道。 编程语言的使用Java使用 详细 Python使用 pip install redis 该模块和redis命令的用法几乎一模一样, 上手很快 redis文档 python操作redis的库的文档 Project 衍生项目 webdis 将redis变为一个简单的web接口 官网 | Github地址","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.kuangcp.top/tags/Redis/"}]},{"title":"PostgreSQL进阶","slug":"Memo-Database-PostgreSQLAdvance","date":"2018-12-16T09:28:33.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Database-PostgreSQLAdvance/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Database-PostgreSQLAdvance/","excerpt":"","text":"目录 start PostgreSQL Advance 性能分析 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs PostgreSQL Advance性能分析查询分析 同MySQL一样, 使用 EXPLAIN + SQL","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://blog.kuangcp.top/tags/PostgreSQL/"}]},{"title":"JDBC","slug":"Memo-Java-AdvancedLearning-JDBC","date":"2018-12-16T09:28:17.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/16/Memo-Java-AdvancedLearning-JDBC/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Java-AdvancedLearning-JDBC/","excerpt":"","text":"目录 start JDBC Java内置数据库Derby 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs JDBC 码农翻身:JDBC的诞生 基础的批量操作SQL pstmt.executeBatch(); //批量执行 注册driver创建 connection创建 statement执行获取 Resultset处理返回结果 resultst Statement 和 PrepareStatement 的区别， 掌握PrepareStatement的主要用法(推荐使用) Java内置数据库Derby Derby","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[]},{"title":"PostgreSQL","slug":"Memo-Database-PostgreSQL","date":"2018-12-16T09:27:21.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Database-PostgreSQL/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Database-PostgreSQL/","excerpt":"","text":"目录 start Postgresql 概述 和MySQL对比 安装 安装客户端 安装服务端 Docker方式安装服务端 pull完整版 pull精简版 Dockerfile构建 解释Dockerfile文件 使用 Postgresql终端命令行使用 用户和角色权限 创建用户 修改权限 Java使用 基础数据 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Postgresql 该公司对于PostgreSQL的缺点陈列是否属实 概述 PostgreSQL | wiki 严格SQL标准 Schemas 和表，用户的关系： Schemas相当于是一个数据库进行分类的文件夹 和MySQL对比 PostgreSQL 与 MySQL 相比，优势何在？Converting MySQL to PostgreSQL 安装安装客户端 sudo apt-get install postgresql-client 安装服务端 sudo apt install postgresql Docker方式安装服务端 官方镜像 pull完整版 或者： docker pull postgres 官方镜像 运行容器 docker run --name mypostgre -i -t -p 5432:5432 postgres 客户端连接 psql -h localhost -p 5432 -U postgres pull精简版 下拉镜像：docker pull postgres:alpine | 因为个人系统客户端是9.6, 所以用9.6-alpine镜像 构建容器： 12345docker run -d --name postgre \\-e POSTGRES_PASSWORD=jiushi \\-v gitea-db-data:/var/lib/postgresql/data \\-p 5432:5432 \\postgres:9.6-alpine 容器中连接 进入postgresql终端 docker exec -it postgre psql -U postgres 客户端连接 psql -h localhost -U postgres 连接后 输入\\l 列出所有数据库 即可查看连接成功与否 Dockerfile构建Dockerfile1234567891011121314151617FROM ubuntu:16.04RUN apt-key adv --keyserver keyserver.ubuntu.com --recv-keys B97B0AFCAA1A47F044F244A07FCC7D46ACCC4CF8RUN echo \"deb http://apt.postgresql.org/pub/repos/apt/ precise-pgdg main\" &gt; /etc/apt/sources.list.d/pgdg.listRUN apt-get update &amp;&amp; apt-get -y -q install python-software-properties software-properties-common \\ &amp;&amp; apt-get -y -q install postgresql-9.4 postgresql-client-9.4 postgresql-contrib-9.4USER postgresRUN /etc/init.d/postgresql start \\ &amp;&amp; psql --command \"CREATE USER pger WITH SUPERUSER PASSWORD 'pger';\" \\ &amp;&amp; createdb -O pger pgerdbUSER rootRUN echo \"host all all 0.0.0.0/0 md5\" &gt;&gt; /etc/postgresql/9.4/main/pg_hba.confRUN echo \"listen_addresses='*'\" &gt;&gt; /etc/postgresql/9.4/main/postgresql.confEXPOSE 5432RUN mkdir -p /var/run/postgresql &amp;&amp; chown -R postgres /var/run/postgresqlVOLUME [\"/etc/postgresql\", \"/var/log/postgresql\", \"/var/lib/postgresql\"]USER postgresCMD [\"/usr/lib/postgresql/9.4/bin/postgres\", \"-D\", \"/var/lib/postgresql/9.4/main\", \"-c\", \"config_file=/etc/postgresql/9.4/main/postgresql.conf\"] 构建容器 docker build -t mypostgresql:9.4 . 运行容器 docker run --name mypostgre -i -t -p 5432:5432 mypostgresql:9.4 使用客户端连接psql -h localhost -p 5432 -U pger -W pgerdb 口令：pger 解释Dockerfile文件 待学习解释 使用 PostgreSQL 9.6.0 手册 Postgresql终端命令行使用 PostgreSQL新手入门用熟悉的MySQL命令来解释 \\l show databases \\c dbname [user] 切换数据库 \\dt show tables \\d tablename desc tablename \\di 查看索引 \\du 查看所有用户 \\dn 查看模式列表 \\copyright 显示版权信息 \\encoding 显示编码信息 \\h SQL命令语法上的说明，用*显示全部命令 \\prompt [文本]名称 提示用户设定内部变数 \\password [username] 改密码 \\q exit 可以使用pg_dump和pg_dumpall来完成。比如备份sales数据库： pg_dump drupal&gt;/opt/Postgresql/backup/1.bak 用户和角色权限创建用户 createuser -P -D -R -e playboy //创建一个用户,-P要设置密码，-R,不参创建其他用户，-D不能创建数据库 create user myth 不带login属性 create role myth 具有login属性 psql -U playboy -d playboy 登录用户，一般默认是有用户同名数据库才能登录 修改默认登录不需要密码的配置 修改权限 参考博客参考博客_角色配置 ALTER ROLE rolename LOGIN; 设置登录权限 ALTER ROLE david WITH PASSWORD &#39;ufo456&#39;; 设置密码登录权限 但是，默认是不需要密码 查看pg_hba.conf 文件，发现local 的METHOD 为trust，所以不需要输入密码 将local 的METHOD 更改为password，然后保存重启postgresql。 博客 ALTER ROLE sandy VALID UNTIL &#39;2014-04-24&#39;; 设置角色有效期 SELECT * from pg_roles ; 查看所有角色 CREATE ROLE father login nosuperuser nocreatedb nocreaterole noinherit encrypted password &#39;abc123&#39;; 在PostgreSQL中，首先需要创建一个代表组的角色，之后再将该角色的membership 权限赋给独立的角色即可。 GRANT CONNECT ON DATABASE test to father; 角色赋予数据库test 连接权限和相关表的查询权限。 Java使用 Postgresql JDBC Driver 官方：springboot使用 参考博客 基础数据 PostgreSQL中的数据类型","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://blog.kuangcp.top/tags/PostgreSQL/"}]},{"title":"Oracle性能优化","slug":"Memo-Database-OraclePerformances","date":"2018-12-16T09:26:53.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Database-OraclePerformances/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Database-OraclePerformances/","excerpt":"","text":"目录 start 1.Oracle的体系结构 因为太详细，但是没有一个给出各个模块之间的关系，显得特别凌乱，所以还要参考大二下的书 内存讲解 Oracle服务器 = 实例+进程 Oracle实例 数据库的文件： 与实例的连接 连接方式 一个服务器进程就拥有单独的不共享的PGA 程序全局区 共享池 数据库高速缓冲区 内存缓冲区顾问 重做日志缓冲区 大池和Java池 内存缓冲区 2. 3.Oracle实例的管理 初始化参数文件1. [内容 ：](#内容-) 静态参数文件 （文本文件） 动态参数文件 （二进制文件） 3.6 启动数据库 3.7 将数据库设为限制模式（杀死普通用户，利于维护） 3.9 关闭数据库的四种方式： 4 数据字典和控制文件 数据字典简介 数据字典中存放的信息 数据字典部分使用 动态视图(v$开头) 移动控制文件的示例 5.重做日志文件 5.2 重做日志组 5.5 获取重做日志的信息 5.11 重做日志应用示例1. [1.添加重做日志组](#1添加重做日志组) 1. [2.重建原有的group 3（不活动状态）](#2重建原有的group-3（不活动状态）) 1. [3.强制切换日志组 将当前组（group 1）多切换几次成inactive状态时再删除](#3强制切换日志组-将当前组（group-1）多切换几次成inactive状态时再删除) 1. [4.操作原本的当前组，删除group 1 再添加1 不能修改1](#4操作原本的当前组删除group-1-再添加1-不能修改1) 6.表空间和数据文件的管理 6.5 创建本地管理的表空间 查询 6.8 默认临时表空间 6.9 设置表空间脱机 6.10 设置只读表空间 6.11 重置表空间的大小 6.13 移动数据文件的方法 方法一： 方法二： 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 1.Oracle的体系结构因为太详细，但是没有一个给出各个模块之间的关系，显得特别凌乱，所以还要参考大二下的书内存讲解理解计算机的基本知识 Oracle服务器 = 实例+进程Oracle实例 有5个必须的后台进程：SMON PMON DBWR LGWR CKPT 数据库的文件： 控制文件 重做日志文件 数据文件 初始化参数文件 密码文件 归档重做日志文件 与实例的连接 输入用户名和密码，就是一个用户进程，通过用户进程连接服务器进程，再连接到Oracle数据库上 一个用户可以同时拥有多个会话（用一套帐号登录多次） 连接方式 基于主机 本地模式 客户端 - 服务器模式 客户端 - 应用服务器 - 服务器 一个服务器进程就拥有单独的不共享的PGA 程序全局区 排序区 Cursor状态区 会话信息区 堆栈区 共享池 库高速缓存区（存放共享的SQL代码） LRU（least recently used） 数据字典高速缓存区 数据库高速缓冲区内存缓冲区顾问重做日志缓冲区大池和Java池内存缓冲区 2.3.Oracle实例的管理初始化参数文件 pfile 静态参数文件（文本文件） 文件名： initSID.ora spfile 动态参数文件（二进制文件）文件名：spfileSID.ora 内容 ：静态参数文件 （文本文件）动态参数文件 （二进制文件）3.6 启动数据库startup [force][restrict][pfile=文件名][ open[recover][database] | mount | nomount] 3.7 将数据库设为限制模式（杀死普通用户，利于维护）startup restrict 限制模式的启动alter system enable restricted session 将已运行的实例切换成限制模式alter system kill session 杀死用户进程 3.9 关闭数据库的四种方式： A shutdown abort 强制停库，启动需要做数据库恢复 I shutdown immediate 中断事务，中断会话，关闭文件，启动需要恢复事务 T shutdown transactional 中断会话，等待事务关闭，关闭文件 N shutdown normal 等待会话，事务关闭，关闭文件 4 数据字典和控制文件数据字典简介 数据字典是一组只读的系统表（AUD$开头的是可修改的），数据字典中存放了有关数据库和数据库对象的信息 数据字典中存放的信息 数据库的逻辑结构和物理结构 所有数据库对象定义的信息 所有数据库对象的磁盘空间分配的信息 Oracle用户名 每个用户被授予的权限和角色 完整性约束的信息 列的默认值 审计信息 数据字典部分使用 user_tables all_tables user_catalog / cat 动态视图(v$开头) 移动控制文件的示例 查看当前位置： select * from v$controlfile; 修改数据库的参数文件映射到目标地址：alter system set contro_files=’路径1’,’路径2’ scope=spfile; 停库 shutdown immediate 使用命令复制 host copy ‘原地址’ ‘目标地址’ 或者直接快捷键 启动数据库，再查看控制文件的位置 5.重做日志文件5.2 重做日志组 Oracle至少需要两个重做日志文件组（每个组最少一个重做日志文件） 重做日志写进程只能同时写一个组，写是循环写的 写满一个就切换下一个，写满的这个组就会复制到归档日志里保存 称为两级日志结构 5.5 获取重做日志的信息 重做日志组： select group#,sequence#,members,bytes,status,archived from v$log; 重做日志组成员： select group#,status,type,member from v$logfile; 5.11 重做日志应用示例 select * from v$logfile; 查看日志的状态 1.添加重做日志组 alter database add logfile(‘F:\\DB\\Oracle\\Data\\Log\\REDO04A.log’,’F:\\DB\\Oracle\\Data\\Log\\REDO04B.log’)size 10m; 2.重建原有的group 3（不活动状态） alter database drop logfile group 3; alter database add logfile group 3(‘F:\\DB\\Oracle\\Data\\Log\\REDO03A.log’,‘F:\\DB\\Oracle\\Data\\Log\\REDO03B.log’,’F:\\DB\\Oracle\\Data\\Log\\REDO03C.log’)size 15m; 3.强制切换日志组 将当前组（group 1）多切换几次成inactive状态时再删除alter system switch logfile; 4.操作原本的当前组，删除group 1 再添加1 不能修改1 alter database drop logfile group 1; alter database add logfile group 1(‘F:\\DB\\Oracle\\Data\\Log\\REDO01A.log’,‘F:\\DB\\Oracle\\Data\\Log\\REDO01B.log’,’F:\\DB\\Oracle\\Data\\Log\\REDO01C.log’)size 15m; 6.表空间和数据文件的管理6.5 创建本地管理的表空间 create tablespace 名字 datafile ‘’ size 50m,’’ size 30m extent management local uniform size 1m; 查询 select tablespace_name,block_size,extent_management,segment_space_management from dba_tablespaces where tablespace_name like ‘myth%’; 6.8 默认临时表空间 oracle 是默认的temp表空间 修改： alter database default temporary tablespace myth_temp; 注意：数据库只有一个默认的临时表空间，要根据实际需要来调整 6.9 设置表空间脱机 alter tablespace myth offline; 6.10 设置只读表空间 alter tablespace myth read only ; alter tablespace myth read write; 正常状态 6.11 重置表空间的大小 数据字典管理的表空间： alter tablespace 名 [minimum extent 2[k|m]] | [default 存储子句] 本地管理的表空间： 不能更改存储设置，但是可以重置大小： 改变数据文件的大小 创建表空间时使用autoextent on 自动改变数据文件的大小 在创建表空间之后，使用带有autoextent on 选项的alter database 命令手动开启自动扩展功能 使用alter tablespace 添加数据文件 自动扩展 alter database datafile ‘’ autoextent on next 1m; 手动重置数据文件大小 alter database datafile ‘’ resize 100m; 添加数据文件 alter tablespace myth add datafile ‘’ size 80m; 6.13 移动数据文件的方法方法一：该语句适用于没有活动的还原数据或者是临时段的非系统表空间中的数据文件，使用语句中表空间必须是脱机且目标数据文件必须存在 alter tablespace 表空间名 rename datafile ‘’[,’’] to ‘’[,’’] 1.使用数据字典查询所需信息 2.将表空间置为脱机 3.使用命令或操作系统移动或复制数据文件 4.执行alter tablespace…. 命令 5.将表空间联机 6.使用数据字典查询信息 7.使用操作系统删除无用的文件 方法二：该语句适用于系统表空间和不能置为脱机的表空间的数据文件，要求使用该语句时数据库处于mount状态 alter database 数据库名 rename file ‘’[,’’] to ‘’[,’’] 1.使用数据字典查询信息 2.关闭数据库 3.使用命令或操作系统移动或复制文件","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://blog.kuangcp.top/tags/Oracle/"}]},{"title":"MySQL进阶","slug":"Memo-Database-MySQLAdvance","date":"2018-12-16T09:26:16.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Database-MySQLAdvance/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Database-MySQLAdvance/","excerpt":"","text":"目录 start MySQL Advanced 部署 性能调优 SQL 片段 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs MySQL Advanced Mysql Redis UDF 复制 参考博客: shell 下执行mysql 命令 将需要执行的SQL写入文件 并将结果输出到文件 mysql -u root -h 192.168.10.201 -p123 &lt; query.sql &gt; result.log 部署 第一次看到MySQL内存上3G, 资源占用这么大, 还导致了内存不够, 直接MySQL自己退出了 性能调优 分析SQL运行效率: explain + SQL 查看所有连接 show processlist; MySQL下INNODB引擎的SELECT COUNT(*)性能优化及思考 SQL 片段 拼接删除库下所有表的SQL select concat(&#39;drop table &#39;,table_name,&#39;;&#39;) from information_schema.TABLES where table_schema=&#39;DATABASE_NAME&#39;;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.kuangcp.top/tags/MySQL/"}]},{"title":"MangoDB","slug":"Memo-Database-MangoDB","date":"2018-12-16T09:26:05.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Database-MangoDB/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Database-MangoDB/","excerpt":"","text":"目录 start MangoDB 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs MangoDB 非关系型和关系型混合文档型数据库 双刃剑MongoDB的学习和避坑","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"MangoDB","slug":"MangoDB","permalink":"http://blog.kuangcp.top/tags/MangoDB/"}]},{"title":"数据库初步总结","slug":"Memo-Database-Experience","date":"2018-12-16T09:25:06.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Database-Experience/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Database-Experience/","excerpt":"","text":"目录 start 数据库的使用体会 关系型数据库 SQLServer Mysql Oracle Postgresql 非关系型数据库 Redis MangoDB 两者的对比 关系型数据库设计 结构设计 基本表的设计 关于主键的设计 视图的设计 数据库中间件 非关系型数据库设计 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 数据库的使用体会 码农翻身:爱炫耀的数据库老头儿 事务,undo日志 DB-Engines Ranking 数据库评分排行 关系型数据库 参考博客: 什么是数据库ACID? SQLServerMysql 结合docker配置很快，就是默认编码为什么不直接设置utf8，每次要改 Oracle 十分的庞大, 学习了他理念的设计, 感受良多 Postgresql 听说性能强劲, 但是自己没有测试实践过, 命令行倒是很简洁, 就是数据库的逻辑理念和MySQL不一样, 迁移过去要稍微看下基础实际使用上, 如果使用Docker开一个容器运行, 所消耗的资源比MySQL少多了, MySQL大概 300M PostgreSQL只要几十M 非关系型数据库Redis 数据类型丰富,处理非关系型并且结构化的数据十分方便, 结合Python使用就行云流水一般了 MangoDB 正准备学习的文档性数据库, 混合类型: 关系型非关系型 两者的对比 为什么说SQL正在击败NoSQL，这对数据的未来意味着什么？ 关系型数据库设计结构设计基本表的设计关于主键的设计 我哥提出, 基本表中连主键的约束都不要了, 全部由后台的代码进行约束处理 如果使用的需要高并发，数据库经常迁移，拆分，分布式，使用UUID,GUID最佳 如果是小型项目，使用整型自增即可，排序方便节约内存 视图的设计数据库中间件 MyCat：开源分布式数据库中间件 非关系型数据库设计","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/tags/数据库/"},{"name":"工具使用经验","slug":"工具使用经验","permalink":"http://blog.kuangcp.top/tags/工具使用经验/"}]},{"title":"MySQL","slug":"Memo-Database-MySQL","date":"2018-12-16T09:24:50.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/16/Memo-Database-MySQL/","link":"","permalink":"http://blog.kuangcp.top/2018/12/16/Memo-Database-MySQL/","excerpt":"","text":"目录 start Mysql 安装 Ubuntu安装配置MySQL Docker安装 图形化客户端 基本数据类型 数值类型 short int decimal 字符类型 varchar text LongBlob 基本组成 数据编码 数据库 创建 导出 修改 表 创建 修改表定义 增删字段 视图 触发器 【创建单语句的触发器】 【创建多语句的触发器】 【NEW 和 OLD关键字】 存储过程 基本结构示例： 函数 【简单示例】 1.mysql常用命令集合 查看数据库参数 查看连接状况 1.1【自增长】 1.2【主键约束的修改】 1.3【修改表名】 1.4【定界符】 1.5【已有表数据，新建表】 1.6【查看所有连接状态】 1.7【查看表的状态】 1.8【关于时间 】 1.8.1【常用函数】 1.8.2【获取当前时间与i个月之间的天数】 1.8.3 datetime和timestamp区别 1.9 【插入外码】 2.【变量】 3.【基本流程语法】 7.【异常】 8.【用户管理】 查看 创建 修改 【授权】 查询 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Mysql MySQL官方下载地址 | doc 安装Ubuntu安装配置MySQL 更新列表sudo apt-get update 安装MySQL sudo apt-get install mysql-server mysql-client 检查服务是否已经开启 ： sudo netstat -tap | grep mysql （启动显示cp 0 0 localhost.localdomain:mysql : LISTEN - ） 启动服务 ： sudo /etc/init.d/mysql restart 查看编码 ： status 或者 show variables like &#39;character_set_% _配置_ 打开配置文件： sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf [mysqld]下添加一行： character-set-server=utf8 [client]下添加 default-character-set = utf8 如果要允许远程访问，就注释掉 bind-address 如果是服务器要配置远程访问 就 bind-address=服务器IP 确保skip-networking被删除或者屏蔽，否则不支持TCP/IP 访问 _重启_ 重启MySQL ：sudo systemctl restart mysql Docker安装 Docker安装MySQL | 博客：Mysql有没有必要Docker化 图形化客户端 windows上就直接 MySQL-Font HeidiSQL Linux就终端了..虽然wine也能装这俩 | 10个Mysql图形客户端 基本数据类型 MySQL 数据类型 数值类型shortintdecimal The declaration syntax for a DECIMAL column is DECIMAL(M,D). The ranges of values for the arguments are as follows: M is the maximum number of digits (the precision). It has a range of 1 to 65. D is the number of digits to the right of the decimal point (the scale). It has a range of 0 to 30 and must be no larger than M. 在MySQL 3.23 及以后的版本中，DECIMAL(M, D) 的取值范围等于早期版本中的DECIMAL(M + 2, D) 的取值范围。 当插入的整数部分的值超过了其表示范围后就直接忽略了小数部分的值，并以最大值填充。 当整数部分合法，小数部分多余的位数，直接截断。 字符类型varchartext 后期完善 LongBlob 这种数据类型可以直接把图像文件存到数据库中！创建UTF8编码数据库 CREATE DATABASEtest2DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci 基本组成数据编码utf8 最大字节为3的非标准utf8实现utf8mb4 才是真正意义上的 utf8 5.5.3才开始支持 数据库创建 create database name; 导出 以下的 -p -h 参数依数据库的配置情况而定 只导出数据库的结构 mysqldump -uroot -pmysql -d dbname &gt; /data/backup/sql/dbname.sql 导出具体的表就在数据库名后加上 表名 导出结构和数据就去掉-d参数, 导出具体的表同理 导入其实就是执行SQL文件 source /path/to/dbname.sql java操作：mysql数据库导入、导出 主要的思想是Java调用系统命令行执行命令后得到导出文件， 然后读取导出的文件 进一步操作 修改 TODO 修改数据库 表创建 create table name (field int, field varchar(32)....); 查看表的创建语句 show create table name; 修改表定义 TODO 修改表格 重命名表格 RENAME TABLE old TO new 增删字段 增加字段 alter table name add field1 int, field2 varchar(20); 删除字段 alter table name drop column field1, drop column field2; 视图 保障数据安全性，提高查询效率 参考博客: 1234CREATE [ALGORITHM]=&#123;UNDEFINED|MERGE|TEMPTABLE&#125;] VIEW 视图名 [(属性清单)] AS SELECT 语句 [WITH [CASCADED|LOCAL] CHECK OPTION]; ALGORITHM表示视图选择的算法（可选参数） UNDEFINED：MySQL将自动选择所要使用的算法 MERGE：将视图的语句与视图定义合并起来，使得视图定义的某一部分取代语句的对应部分 TEMPTABLE：将视图的结果存入临时表，然后使用临时表执行语句 视图名表示要创建的视图的名称 属性清单表示视图中的列名，默认与SELECT查询结果中的列名相同（可选参数） WITH CHECK OPTION表示更新视图时要保证在该试图的权限范围之内（可选参数） CASCADED：更新视图时要满足所有相关视图和表的条件 LOCAL：更新视图时，要满足该视图本身定义的条件即可 tips：创建试图时最好加上WITH CASCADED CHECK OPTION参数，这种方式比较严格,可以保证数据的安全性 触发器【创建单语句的触发器】 CREATE TRIGGER ins_sum BEFORE INSERT ON account FOR EACH ROW SET @sum = @sum + NEW.amount; CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt 【创建多语句的触发器】12345CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROWBEGIN .......END 【NEW 和 OLD关键字】 使用OLD和NEW关键字，能够访问受触发程序影响的行中的列（OLD和NEW不区分大小写）。在INSERT触发程序中，仅能使用NEW.col_name，没有旧行。 在DELETE触发程序中，仅能使用OLD.col_name，没有新行。在UPDATE触发程序中，可以使用OLD.col_name来引用更新前的某一行的列，也能使用NEW.col_name来引用更新后的行中的列。 用OLD命名的列是只读的。你可以引用它，但不能更改它。对于用NEW命名的列，如果具有SELECT权限，可引用它。 在BEFORE触发程序中，如果你具有UPDATE权限，可使用“SET NEW.col_name = value”更改它的值。这意味着， 你可以使用触发程序来更改将要插入到新行中的值，或用于更新行的值。 在BEFORE触发程序中，AUTO_INCREMENT列的NEW值为0，不是实际插入新记录时将自动生成的序列号。 存储过程基本结构示例：123456789101112 -- 【loop】 要有iterate 和leave才是完整的CREATE PROCEDURE doiterate(p1 INT) BEGIN label1: LOOP SET p1 = p1 + 1; IF p1 &lt; 10 THEN ITERATE label1; END IF; LEAVE label1; END LOOP label1; SET @x = p1; END call doiterate(7); select @x; 函数【简单示例】1234567891011121314151617---函数部分,修改定界符 delimiter //CREATE FUNCTION hello (s CHAR(20)) RETURNS CHAR(50)RETURN CONCAT('Hello, ',s,'!');//--将定界符改回来，是第二句SQL语句delimiter ;select hello('Myth ');drop function hello;-- 函数create function fun_test(var1 int,var2 varchar(16)) returns intbegin declare temp int; select count(*) into temp from test; return temp;end;select fun_test(8,'d'); 1.mysql常用命令集合查看数据库参数查看连接状况 查看mysql数据库连接数、并发数相关信息。show status like &#39;Threads%&#39;; 1.1【自增长】 【创建表时设置自增长，并设置起始值】 create table cc( id int auto_increment,name varchar(20),primary key(id) ) auto_increment=1000; 【设置已有字段自增长】 alter table test MODIFY id INT UNSIGNED AUTO_INCREMENT; 【自增长的修改】 alter table test auto_increment=10； 注意只能改的比当前的值大，不可以改的比当前小 【自增长字段溢出】 设置自动增长的列，只能是int类型（包含了各种int），当出现了溢出就可以改成bigint 但是如果有外键约束，可能就会更改失败，还不如删库重建，实在太大了就删约束再建约束 1.2【主键约束的修改】alter table 表名 add constraint (PK_表名) primary key (j,k,l); 关于一些约束条件constraint好像没有起到作用比如 check 1.3【修改表名】rename table table1 to table2; 切记不可随便修改表名，改了就要修改相应的 外键，触发器，函数，存储过程！！！ 1.4【定界符】delimiter 任意字符除了转义字符：\\ 1.5【已有表数据，新建表】create table temp as select * from test; 1.6【查看所有连接状态】show processlist 如果是普通用户，只能查看自己当前的连接状态 1.7【查看表的状态】show table status like ‘assitant’ 可以看到当前自动增长的id当前值 dev.mysql.com/downloads/mysql/#downloads 1.8【关于时间 】1.8.1【常用函数】 NOW()函数以 ‘YYYY-MM-DD HH:MM:SS’ 返回当前的日期时间，可以直接存到DATETIME字段中。 CURDATE()以’YYYY-MM-DD’的格式返回今天的日期，可以直接存到DATE字段中。 CURTIME()以’HH:MM:SS’的格式返回当前的时间，可以直接存到TIME字段中。 例：insert into tablename (fieldname) values (now()) insert into data values (‘Myth’,’4’,’2016-03-10’,curtime());//年月日，时间 select datediff(curdate(), date_sub(curdate(), interval i month)); 一般函数是不能作为 default默认值的，使用只能在插入修改数据时使用 1.8.2【获取当前时间与i个月之间的天数】 问题：假设当前是5月19 且（提前月份）i=1 就是计算从4月19到今天的天数 解答： 123456789-- 时间格式的简单操作：select DATE_FORMAT(produceDate, '%Y') as yeahr from historybarcodesort where DATE_FORMAT(produceDate, '%Y')='2013'select date_format('1997-10-04 22:23:00','%y %M %b %D %W %a %Y-%m-%d %H:%i:%s %r %T'); 显示结果：97 October Oct 4th Saturday Sat 1997-10-04 22:23:00 10:23:00 PM 22:23:00-- 查询指定时间：get_date = \"2006-12-07\"SELECT count(*) FROM t_get_video_temp Where DATE_FORMAT(get_date, '%Y-%d')='2006-07';SELECT count(*) FROM t_get_video_temp Where get_date like '2006%-07%'; 1.8.3 datetime和timestamp区别1234567-- 问题：为什么 5.5的环境下运行两句命令得到不同的结果（5.6不会有错误）-- 没错误creata table test1(one_time timestamp not null default current_timestamp,two_time timestamp);-- 报错：Incorrect table definition; there can be only one TIMESTAMP column with CURRENT_TIMESTAMP in DEFAULT or ON UPDATE clausecreate table test2(one_time timestamp,two_time timestamp not null default current_timestamp);或者 将timestamp 改成datetime 也不会有错，那么问题来了 区别是什么？-- 上面报错原因不明，大意是只能有一个timestamp的列有默认值 DATETIME、DATE 和 TIMESTAMP 区别： DATETIME 类型可用于需要同时包含日期和时间信息的值。MySQL以’YYYY-MM-DD HH:MM:SS’ 格式检索与显示DATETIME类型。 支持的范围是 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’。 (“支持”的含义是，尽管更早的值可能工作，但不能保证他们均可以。) DATE 类型可用于需要一个日期值而不需要时间部分时。MySQL 以 ‘YYYY-MM-DD’ 格式检索与显示 DATE 值。 支持的范围是 ‘1000-01-01’ 到 ‘9999-12-31’。 TIMESTAMP 列类型提供了一种类型，通过它你可以以当前操作的日期和时间自动地标记 Insert 或Update 操作。 如果一张表中有多个 TIMESTAMP 列，只有第一个被自动更新。 “完整”TIMESTAMP格式是14位，但TIMESTAMP列也可以用更短的显示尺寸创造最常见的显示尺寸是6、8、12、和14。你可以在创建表时指定一个任意的显示尺寸，但是定义列长为0或比14大均会被强制定义为列长14列长在从1～13范围的奇数值尺寸均被强制为下一个更大的偶数。 列如：定义字段长度 强制字段长度1234TIMESTAMP(0) -&gt; TIMESTAMP(14)TIMESTAMP(15)-&gt; TIMESTAMP(14)TIMESTAMP(1) -&gt; TIMESTAMP(2)TIMESTAMP(5) -&gt; TIMESTAMP(6) 所有的TIMESTAMP列都有同样的存储大小，使用被指定的时期时间值的完整精度（14位）存储合法的值不考虑显示尺寸。不合法的日期，将会被强制为0存储 自动更新第一个 TIMESTAMP 列在下列任何条件下发生： 列值没有明确地在一个 Insert 或 LOAD DATA INFILE 语句中被指定。 列值没有明确地在一个 Update 语句中被指定，并且其它的一些列值已发生改变。(注意，当一个 Update 设置一个列值为它原有值时，这将不会引起 TIMESTAMP 列的更新，因为，如果你设置一个列值为它当前值时，MySQL 为了效率为忽略更新。) 明确地以 NULL 设置 TIMESTAMP 列。 第一个列以外其它 TIMESTAMP 列，可以设置到当前的日期和时间，只要将该列赋值 NULL 或 NOW()。 任何 TIMESTAMP 列均可以被设置一个不同于当前操作日期与时间的值，这通过为该列明确指定一个你所期望的值来实现。这也适用于第一个 TIMESTAMP 列。这个选择性是很有用的，举例来说，当你希望 TIMESTAMP 列保存该记录行被新添加时的当前的日期和时间，但该值不再发生改变，无论以后是否对该记录行进行过更新： 当该记录行被建立时，让 MySQL 设置该列值。这将初始化该列为当前日期和时间。 以后当你对该记录行的其它列执行更新时，为 TIMESTAMP 列值明确地指定为它原来的值。 另一方面，你可能发现更容易的方法，使用 DATETIME 列，当新建记录行时以 NOW() 初始化该列，以后在对该记录行进行更新时不再处理它。 1.9 【插入外码】1alter table `Bookinfo` add constraint `F_N` foreign key `F_N`(`classno`) references `Bookclass`(`classno`) on delete cascade on update cascade; 2.【变量】 加了@ 的是用户变量， 限定当前用户，当前客户端， 在declare中声明的参数可以不加 @，那就是是局部变量 例如：declare a int ; 也可以直接就用不用声明，作为临时变量 例如这两种写法： set @name = expr; select @name:= expr; 注意：MySQL中只有基本数据类型，没有Oracle中那个绑定类型：表类型或行类型，所以处理起来有点。。不如Oracle方便，不管是触发器还是存储过程 set @a= select * from User；执行这句话就会报出 operand should contain 1 column(s)错误，就是说多值赋值的错误 3.【基本流程语法】123if ... then elseif ... then (注意elseif中间没有空格)end if; 7.【异常】8.【用户管理】 参考博客 查看 查询用户信息 select host,user,password from user ; 查看权限 show grants for zx_root; 创建 创建本地超级用户： CREATE USER ‘myth‘@’localhost’ IDENTIFIED BY ‘ad’;授予所有权限 GRANT all privileges ON . TO ‘myth‘@’localhost’;创建远程访问指定数据库用户 ： CREATE USER ‘myth‘@’%’ IDENTIFIED BY ‘ad’;授予数据库db的所有权限 GRANT all privileges ON db.* TO ‘myth‘@’%’; 创建用户 CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;; 设置密码 SET PASSWORD FOR &#39;username&#39;@&#39;%&#39; = PASSWORD(&quot;123456&quot;); 修改密码也是这个语句注意的是要 flush privileges; 删除用户 drop user &#39;username&#39;@&#39;host&#39; 如果服务器需要远程访问 修改配置文件/etc/mysql/mysql.conf.d/mysqld.cnf，注释掉 bind_address 一行1234% 匹配所有主机localhost localhost不会被解析成IP地址，直接通过UNIXsocket连接127.0.0.1 会通过TCP/IP协议连接，并且只能在本机访问；::1 ::1就是兼容支持ipv6的，表示同ipv4的127.0.0.1 修改 修改名字：rename user feng to newuser； 【授权】 grant all privileges ON databasename.tablename TO ‘username‘@’host’ all privileges 所有权限 alter | alter routine create | create routine | create temporary table | create user | create view delete | drop execute | file index | insert lock table | process | reload replication | client | replication slave select | show databases | show view shutdown | super update | usage 回收权限 revoke, 用法和 grant 一样 刷新权限缓存 flush privileges; 查询 数据库中最主要的还是查询， 多角度复杂的查询 全自段模糊查询 select * from target where concat(ifnull(host, &#39;&#39;), ifnull(username, &#39;&#39;)) like &#39;%localhost%&#39; &gt; 0 limit 0,1; 将全字段(空的替换为空串)连接成一个字符再模糊查询, select * from target where host like &#39;%localhost%&#39; or username like &#39;%localhost%&#39; limit 0,1; 这种查询虽然也能实现, 但是性能差一些","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.kuangcp.top/categories/数据库/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.kuangcp.top/tags/MySQL/"}]},{"title":"Go操作数据库","slug":"Memo-Go-GoDatabase","date":"2018-12-15T04:14:19.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/15/Memo-Go-GoDatabase/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Go-GoDatabase/","excerpt":"","text":"目录 start Go的数据库操作 Redis 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Go的数据库操作Redis github:go-redis","categories":[{"name":"Go","slug":"Go","permalink":"http://blog.kuangcp.top/categories/Go/"}],"tags":[]},{"title":"Groovy","slug":"Memo-Groovy-Groovy","date":"2018-12-15T04:13:52.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/15/Memo-Groovy-Groovy/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Groovy-Groovy/","excerpt":"","text":"目录 start Groovy 书籍 语言特性 安装配置 在IDEA中 Maven引入Groovy Docker Groovy基础 Groovy特性 默认导入 隐式return 默认生成setter getter 数字处理 变量，动态和静态类型，作用域 列表和映射语法 动态调用函数 函数 闭包 测试 调用系统命令行 强大的注解 与Java的差异 Java不具备的Groovy特性 Groovy和Java的交互 Maven中引入Groovy Groovy调用Java Java调用Groovy Groovy和Spring 坑 默认return Grails 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Groovy Groovy 官网 | 实战Groovy系列有体系的知识精通GroovyGroovy：Java 程序员的 DSLw3cschool Groovy教程并发编程网 Groovy分类文章infoQ 上Groovy相关 书籍 Groovy in Action 在线阅读英文原版 语言特性 Groovy 具有的Java所没有的语言特性 ： 函数字面值（闭包） 对集合的一等支持 对正则表达式的一等支持 对XML处理的一等支持 （一等表示内置，不需要调用类库） Groovy处理XML和循环遍历集合的方式要比Java简洁 Groovy性能：如果你需要注重性能，Groovy不是一个好的选择，Groovy的对象都派生于GroovyObject，Groovy的方法都不是直接调用的而是反射执行的。虽然有invokedynamic关键字进行优化 一些重活还是调用Java类库好些，毕竟是互通互用的，调用groovyserv类库能提高性能 安装配置 安装sdkman 然后 sdk install groovy 新建文件 println &quot;Hello World!&quot; 然后 groovy 文件 或者groovy -e &quot;println &#39;Hello World!&#39;&quot; 在IDEA中 因为构建工具Gradle中就已经包含了Groovy的库,所以最好就是只配置好一个Gradle, 然后配置Groovy时选择Gradle的目录即可 Maven引入Groovy 参考博客 Docker Docker官方文档 Groovy基础 作为一个脚本语言，和Python Ruby Smalltalk语法相似 groovyc groovy 类似于 javac java Groovy特性默认导入这一些导入是默认隐含在Groovy代码中12345678import groovy.lang.*import groovy.util.*import java.lang.*import java.io.*import java.math.BigDecimalimport java.math.BigIntegerimport java.net.*import java.util.* 添加额外的JAR可以使用@Grab注解或者和Java一样加入到ClassPath中去 隐式return 如果方法是具有返回值的, Groovy会在代码块的行末缺省return null, 如果末行有一个表达式, 并有返回值, 就会return该值, 略坑 默认生成setter getter 类当中的属性, 只要不是使用private修饰, 就能自动生成getter setter, 并且直接.引用属性, 相当于调用了对应的get set 数字处理 Groovy默认浮点数使用BigDecimal，Java中BigDecimal构造器入参是字符串，Groovy是数值，底层转换了一下，看起来更自然 因为是脚本语言，可以在控制台直接运行。Groovy对BEDMAS是支持的 （括号，次方，除，乘，加，减） 变量，动态和静态类型，作用域变量 如果要让Groovy和Java互操作，Groovy也能使用静态类型 def static，因为他简化了类型重载和调度机制 注意 普通类状态：在类中不能出现没有类型的变量 至少要有def这个无类型，其他的和Java一致 def private static name = &quot;90&quot; Groovy里的动态类型和静态类型 如果变量不在定义时声明类型，那么就是一个动态类型，反之则是静态类型，静态类型就和Java的语法是一致的了，类型不可变 作用域（通常这是指脚本状态时的普通类就是和Java一致） 绑定域：是脚本的全局作用域。就是在脚本顶层没有声明类型的变量 本地域：变量的作用域局限于声明他们的代码块。就是在顶层声明了类型或者在代码块里 变量作用域学习代码 列表和映射语法 Groovy将列表和映射结构当做语言中的一等类型，列表和映射在底层是ArrayList 和 LinkedHashMap实现的 列表：lists = [&#39;2&#39;, 2, new Date()] 其实这个和Python的语法差不多，同样的支持负索引 映射：maps = [Java:&quot;2&quot;, A:2] 声明Maps 列表和映射的学习代码 动态调用函数123456// 当前类, 可以这么用def test(name) &#123; return \"Hi \"+name&#125;String a = \"test\"print(\"$&#123;a&#125;\"(\"myth\")) 1234567891011121314151617181920212223class Condition&#123; static isLevelMore(int level)&#123; return level &gt; 30 &#125;&#125;class Use &#123; static void main(String[]a)&#123; // 跨类, 需要使用反射 // 1 MetaMethod method = Condition.metaClass.getMetaMethod(\"isLevelMore\", 20) println method println method.invoke(Condition.class, 20) // 2 Method method1 = Condition.class.getMethod(\"isLevelMore\", int.class) println method1.invoke(Condition.class, 40) // 3 Condition.getDeclaredMethods().toList().toSet().each &#123;if(it.toString().contains(\"isLevelMore\"))&#123; println it.invoke(Condition.class, 40) &#125;&#125; &#125;&#125; 函数 参考博客: Groovy进阶之函数、闭包和类 闭包12345// 简单示例 def plus = &#123; x, y -&gt; println \"$x plus $y is $&#123;x + y&#125;\" &#125; plus(2, 3) 测试参考博客: 用 Groovy 更迅速地对 Java 代码进行单元测试 调用系统命令行 Groovy 执行”cp *”shell 命令 字符串.execute() 字符串数组.execute() 这种更好些，尤其是多个参数的时候 写法和Dockerfile一致 [&quot;sh&quot;, &quot;-c&quot;, &quot;cp src/*.txt dst/&quot;].execute() 强大的注解 和Java不同的是, Groovy提供具有功能性的注解, Java大多是接口规范性注解 @ToString 自动实现toString方法, 但是字符串有点冗余 参考博客: Groovy中那些神奇注解之ToString 日志相关 只需要引入对应的依赖, 就和lombok一样的使用123@Log4j@Log4j2@Slf4j 与Java的差异 简化输出语句：println() print() printf() Groovy的省略语法: 语句结束处的分号： 结束的分号是可选的，除非一行多条语句 返回语句 return： 方法中返回对象可以不使用return，会默认返回最后一个表达式的计算结果 方法参数两边的括号： 如果方法里的方法调用至少有一个参数，且没有二义性，则可以省略括号 public访问限定符： 默认是public修饰符, 只有private public protected 这类设计是为了让源码更为简洁，快速原型设计时体现出优势 脚本文件和类文件的差异 一个文件定义了文件同名class 类（默认加上public） 就不能当脚本运行 因为作为一个脚本文件运行的时候，是创建一个与文件同名的类 并且 继承了 groovy.lang.Script 将你写的语句封装起来 当你显式的定义了同名类 也会隐性继承于Groovy超类 groovy.lang.GroovyObject 类似与Java的Object，就会当一个正常的类文件，不能写脚本了 脚本文件中方法不能命名为 run，对于类是没有限制，和Java一样使用 异常处理 Groovy不区分已检查异常和未检查异常。Groovy会忽略方法签名中的所有throws Groovy中的相等 Groovy把 == 当做equals方法，检查真实对象是否相等需要使用Groovy的内置函数 is。但是仍然可以使用 == 来判断 null 两种方式对于基本类型是一样的， == 用于对象时就是比较内存了，equals是比较值 内部类 Groovy支持内部类，但大多数情况下我们应该使用函数字面值（下面有更为详细的学习）替代它。 示例代码 Java不具备的Groovy特性 GroovyBean，更简单的bean 用操作符?.实现null对象的安全访问 猫王操作符(Elvis operator)，更短的if/else结构 Groovy字符串，更强的字符串抽象 函数字面值（闭包），函数当值传递 对正则表达式的本地支持 更简单的XML处理 GroovyBean 虽然很像JavaBean但是省略了显式声明的getset方法，提供了自动构造方法（采用映射来作为入参，很方便），允许使用.引用私有成员变量。修改默认行为显式重定义即可 封装性得以保留，语法更精简, new Person().name=&quot;myth&quot;，其实就是隐式调用了set方法1234class Person&#123; String name int age&#125; 安全解引用 ?. 如果对象是null，就什么都不做，理解为当做该次调用不存在。 函数也是支持这种安全解引用，所以Groovy的默认集合方法，例如max() 能自动处理好null引用 猫王操作符 可以把带有默认值的 if/else 结构写的极其短小，因为这个符号看起来很像猫王鼎盛时期梳的大背头。用猫王操作符不用检查null，也不用重复变量。 增强型字符串 Groovy有一个GString类，他比String要灵活 特别注意，这个GString和String没有任何继承关系，不能将GString作为映射中的键，或者用来比较相等，这些使用的结果都是不可预料的 和Python一样的有个 三引号多行字符串 函数字面值 函数当成一等类型可以赋值等操作，要活用就没这么简单了 内置集合操作 集合内置函数 each : 遍历集合，对其中的每一项应用函数字面值 collect : 收集在集合中每一项应用函数字面值的返回结果 相当于其他语言 map/reduce的map函数 inject : 用函数字面值处理集合并构建返回值 相当于其他语言 map/reduce的reduce函数 findAll : 找到集合中所有与函数字面值匹配的元素 max : 返回集合中的最大值 min : 返回集合中的最小值 对正则表达式的内置支持 ~ 创建一个模式 （创建一个编译的Java Pattern） =~ 创建一个匹配器 （创建一个Java Matcher对象） ==~ 计算字符串 （相当于在Pattern上调用Java match()方法） 对XML的处理 XML是一个卓越的详细的数据交换语言，这不是一个图灵完备(必须能做条件判断，修改内存数据)的语言，所以只能用来交换数据 Groovy有构建器的概念，用其原生语法可以处理任何树形结构的数据 HTML XML JSON等 解析XML： XMLParser 支持XML文档的GPath表达式 GPath是一种表达式语言 XMLSlurper 跟XMLParser类似，但是以懒加载的方式工作 DOMCategory 用一些语法支持DOM的底层解析 示例代码 Groovy和Java的交互Maven中引入Groovy 参考文档 此方法不能打包, 只是在idea中能成功运行123456789101112131415161718&lt;!-- 添加插件--&gt;&lt;plugin&gt; &lt;groupId&gt;org.codehaus.gmaven&lt;/groupId&gt; &lt;artifactId&gt;groovy-maven-plugin&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt; &lt;artifactId&gt;groovy-all&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/plugin&gt;&lt;!-- 添加Groovy依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt; &lt;artifactId&gt;groovy-all&lt;/artifactId&gt; &lt;version&gt;2.4.7&lt;/version&gt;&lt;/dependency&gt; 参考博客 eclipse开发Groovy代码，与java集成，maven打包编译 | Groovy file does not compile in Intellij IDEA 12345678910111213141516171819202122232425&lt;plugin&gt; &lt;!-- 编译插件 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;compilerId&gt;groovy-eclipse-compiler&lt;/compilerId&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt; &lt;artifactId&gt;groovy-eclipse-compiler&lt;/artifactId&gt; &lt;version&gt;2.9.3-01&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt; &lt;artifactId&gt;groovy-eclipse-batch&lt;/artifactId&gt; &lt;version&gt;2.5.0-01&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/plugin&gt; 这样的配置就能 mvn clean package Groovy调用Java 只要将JAR放入classpath中，只要java能调用到，groovy也能调用到，也就是说直接用，无需特别配置 也可以使用@Grab注解，来加载JAR Java调用Groovy 参考博客参考 在 Java 应用程序中加一些 Groovy 进来 从Java调用Groovy需要将Groovy及其相关的JAR放到这个程序的CLASSPATH下 Java调用Groovy代码的几种方法 使用Bean Scripting Framework(BSF) 即JSR223 使用GroovyShell 使用GroovyClassLoader 使用GroovyScriptEngine 使用嵌入式的Groovy控制台 示例代码 Groovy和Spring 参考博客: Groovy 使 Spring 更出色，第 1 部分 坑 因为是动态的, 所以, 当Java或Groovy类更改了一些接口, 属性名, 调用方那里不会报错, 直到运行才报错, 而且 eclipse idea 都不报错, 只是会把错误的属性和调用变成带有下划线的灰色… 默认return 只要在方法最后一行放入表达式, 就会自动return, 这就导致了Groovy不会对方法进行检查, 逻辑复杂时如果少了一个return, 不会报编译错误, 方法直接返回null.这个坑, 硬是Debug了近一个小时, debug功力要提升了 Grails 入门博客 入门视频","categories":[{"name":"Groovy","slug":"Groovy","permalink":"http://blog.kuangcp.top/categories/Groovy/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"GroovySpring","slug":"Memo-Groovy-GroovySpring","date":"2018-12-15T04:13:46.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/15/Memo-Groovy-GroovySpring/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Groovy-GroovySpring/","excerpt":"","text":"目录 start Groovy Spring 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Groovy Spring Groovy 使 Spring 更出色，第 2 部分 在运行时改变应用程序的行为","categories":[{"name":"Groovy","slug":"Groovy","permalink":"http://blog.kuangcp.top/categories/Groovy/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.kuangcp.top/tags/Spring/"},{"name":"Groovy","slug":"Groovy","permalink":"http://blog.kuangcp.top/tags/Groovy/"}]},{"title":"浏览器","slug":"Memo-Skills-Application-WebBrowser","date":"2018-12-15T04:11:56.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/15/Memo-Skills-Application-WebBrowser/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Skills-Application-WebBrowser/","excerpt":"","text":"目录 start 浏览器 FireFox 开发版本 必备插件 配置 使用 seamonkey Chrome 主题 插件 Vivaldi Opera 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 浏览器FireFox 所有桌面版 | 所有正式版正式版本和夜更新版FTP下载地址 | 所有开发者版本 57为全新的Quantum版本， 因为插件标准的缘故和之前的56版本插件不兼容 分为 正式版， beta， Nightly 开发版 如果要配置多个火狐在电脑上 终端中 ./firefox -P 就会进入配置文件的编辑（关闭所有火狐的情况下） 新建一个就好了，之后就用新建的打开该火狐./firefox -P name 如果要同时运行多种版本的火狐 加上--no-remote参数，但是我这个deepin不要诶，只要配置不同即可，但是Ubuntu mint加上也没有用 火狐和Chrome都支持在控制台的网络中直接右击一个请求然后复制, 就可以出来复制成cURL命令的选项, 比较好用 火狐性能优化贴 开发版本 开发者版本链接 | 开发工具使用说明文档 必备插件 开发自己的插件 Saka Key 快捷键神器 大幅度脱离鼠标 官方文档 浏览器默认: 脱离输入框焦点 Esc | 切换标签 ctrl-Tab shift-ctrl-Tab | 关闭标签 ctrl-w 滑动: 下滑 d/j 上滑 s/k 上下滑半屏幕 Shift d/s | 上下滑全屏 Shift j/k 滑到底/顶 Shift-g / gg 滑左/右 alt-s or alt-k / alt-d or alt-j 缩放: 放大/缩小 z/shift-z | 重置大小 shift-alt-z 前进/后退: cc/vv | 跳上级URL uu | 跳URL域名 u shift-u 标签页: 新建 t | 恢复关闭 shift t | 复制 b 关闭 xx | 关闭其他 x shift x | 关闭左边 x [ | 关闭右边 x ] 刷新 rr | 刷新全部标签 r shift r | 深度刷新 shift r shift r 切换: 左右 q/w 或者 [/] | 第一个/最后一个 1/0或者shift-q/shift-w or 0 移动: 左右 i/o 或者 shift-[ / shift-] 第一个/最后一个 shift-i/shift-o 或者 alt-[/alt-] 静音: m 静音所有标签 shift-m 窗口: 新建 n | 新建隐私 shift n 页面上所有页面链接 ff 神操作 文档 传递快捷键即绕过插件的事件监听 ; 文档 比如要在网页上敲英文的时候,就需要每次都要输入分号,才能绕过监听, 真是麻烦 剪贴板: 复制当前页面的URL:yy 当前标签页打开链接 yf| 后台打开 yb | 新窗口打开 yn | 隐私窗口 y shift-n 附加组件管理器: 只有正式版会内置该插件, 别的版本都没有, 插件的功能是 地址栏二维码,拖拽链接, 如果想在开发版以及Nightly上用上该插件, 只需要去 ~/.mozilla/ 下找到正式版的配置文件里的 extension 目录就能找到 cpmanager.xpi 了, 拖入浏览器就可以了 Greasemonkey 传说中的油猴, 可以自己写脚本 wiki New Tab Tools 新建标签页的自定义工具 有一定bug cliget 能将下载中的任务转化为 curl wget命令 牛 eolinker 接口测试工具 Simple Tab Groups 58版本有bug rester rest客户端工具 Download all Images下载图片 octotree github 目录查看 Web Developer 各种Web调试开发工具 One Tab tab归组,十分好用 Remove Cookies Button 围脖是个好图床哟 方便的图床,但是要登录微博 滴答清单 全平台可使用 Auto Reload Tab 定时自动刷新标签页 轻灵划译 即刻翻译, 多种平台 配置 主要是 about:config 配置火狐访问80以外的端口 地址栏 : about:config 右键新建字符串 network.security.ports.banned.override 输入值 81,88,98 也可以是 6000-6005, 省事就 0-65535(不建议) 对于自己喜欢多开火狐的习惯, 整理如下习惯 安装开发版本, 使用一个默认的配置 使用开发版本的可执行文件, 配置一个新的配置目录, 也就是一个新的火狐 前者是重度使用(往往很多标签20+), 常用的标签页全部固定, 一些TODO的tab也放在这里, 用于开发和娱乐(1000M-2000M) 后者是轻度使用(开10个以下标签), 仅在内存不够时, 只用于内存不足时开发必需 (一般400M左右) 使用 地址栏 @bing @baidu… 即可使用指定的搜索引擎进行搜索 地址栏 * Java 即可在所有书签中搜索 Java seamonkey Mozilla基金会另一个项目 seamonkey 亮点在于内置IRC Chrome 的确快,几乎没有各种兼容和诡异问题，就是内存占用高, 还有就是主题被墙,fq才能配置好 插件网 chromefor 52crx 主题 Aero Trans Brushed Metal Theme Material Dark Morpheon Dark 炭黑+銀色金屬 Modern Flat 插件 Saka key crxMouse TabsFolder Chrome Download Manager Vivaldi 感觉采用的是chrome内核，做的更漂亮了，而且是内置了很多常用插件，的确很方便，相比于chrome更符合国内使用 Opera","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/categories/工具/"}],"tags":[]},{"title":"VirtualBox","slug":"Memo-Skills-Application-VirtualBox","date":"2018-12-15T04:11:48.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/15/Memo-Skills-Application-VirtualBox/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Skills-Application-VirtualBox/","excerpt":"","text":"目录 start VirtualBox 安装Linux Manjaro Deepin KDE 安装Windows Windows7 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs VirtualBox安装LinuxManjaro 官网下载好对应的镜像文件 DeepinKDE 创建好系统, 选好ISO, 进入后, 选择图形化安装方式, 也就是选 Boot:***ISO 那一项 安装WindowsWindows7","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/categories/工具/"}],"tags":[{"name":"VirtualBox","slug":"VirtualBox","permalink":"http://blog.kuangcp.top/tags/VirtualBox/"}]},{"title":"编辑器","slug":"Memo-Skills-Application-Editor","date":"2018-12-15T04:11:10.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/15/Memo-Skills-Application-Editor/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Skills-Application-Editor/","excerpt":"","text":"目录 start 文本编辑器 Ghex Kate/KWrite(Kate的轻量版) Geany scite textadept 快捷键 Sublime 快捷键 crack VSCode 快捷键 代码片段 插件 实践 Atom Gedit 小书匠 Moeditor|Typora|CuteMarkEd Cmd 终端中的文本编辑器 Vi/Vim Nano fte-terminal 在线编辑器 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 文本编辑器Ghex 十六进制文件编辑器 Kate/KWrite(Kate的轻量版) 安装markdown预览插件 码Python也挺方便，也有常用快捷键，自动提示，终端整合，而且是自动切目录 Geany 码C 编译方便 有Ctag辅助 scite 简洁的编辑器，可配置挺多，打开速度快 textadept 基于前者进行开发，十分简洁，有着和sublime的外观和速度，没有他的功能强大但也没有他的烦心bug！ 但是自己定制时难度有点大官方手册 Github 地址textadept 主题仓库 textadept-themes个人配置1234567if not CURSES then ui.set_theme('base16-solarized-light') endui.set_theme('light', &#123;font = 'Monospace', fontsize = 13&#125;)-- print(ui.size)-- for k,v in ipairs(ui.size) do-- print(k,v)-- endui.size = &#123;[1] = 800, [2] = 650&#125; 快捷键 Alt Shift 列编辑 Sublime 常用配置 如果出现小bug，就直接删除 ～.config 下的 sublime文件夹注意注册证书拷出来 中文不兼容解决方法： 3143版本号下： 搜索安装插件 ChineseLocalizations 就能汉化 修改配置文件 添加&quot;font_face&quot;: &quot;DeJaVu Sans Mono&quot;, 就解决了字体错位的问题 保存为项目来切换管理更为方便 主题安装 Boxy Theme 以及 A File Icon 就能切换多种主题了 参考博客 配置C/C++开发环境 关闭自动检查升级 setting 中 “update_check”:false快捷键 参考博客: Sublime Text 3 快捷键sublime的常用快捷键 crack 3143码 参考博客 3143 1 | 3143 2 | 3176 VSCode 官网 码笔记，码Python 比较方便，目录树，预览，整合终端 | 中文手册 其所有用户自定义配置都缓存在此目录 ~/.config/Code/User/ vscode 书写 markdown 官方文档 快捷键 快捷键官方PDF说明 Ctrl P 快速命令 直接输入文件名就是搜文件 &gt; 作为前缀则等同 Ctrl Shift P # 作为前缀则等同 Ctrl T Ctrl T 搜索打开所有Markdown文件的所有标题 1.25+ Ctrl Shift P 执行命令 Ctrl+K Ctrl+S 设置用户快捷键 Keyboard Shortcuts Ctrl Shift C在当前打开的文件夹下打开系统默认终端 Ctrl Space 智能提示 变量,代码片段… 需要注意这个快捷键和Windows以及Linux上切换输入法快捷键有冲突,修改即可 Alt Shift 列编辑 C S . 显示面包屑 版本:1.26+ 参考博客: 快捷键大全参考博客: VS Code 使用小技巧 代码片段 配置地点 文件-首选项-用户代码片段 可以新建一个代码片段默认是放在用户的配置目录下 ~/.config/Code/User/snippets/ 参考博客: VS Code 折腾记 - (6) 基本配置/快捷键定义/代码片段的录入（snippet） 巧用VScode“用户代码片段”来提高效率 然后自定义一下insert snippet的快捷键,就很方便使用了 个人配置为Ctrl L, 其实 直接 Ctrl Space 直接提示就行了 注意,每次修改片段配置文件,都需要重启Vscode才会生效最新修改…emm 插件美化 vscode-icons Material Icon Theme One Dark Pro snazzy operator Gruvbox Theme 工具 Beautify Prettier Auto Rename Tag Todo Tree GitLens 方便查看更改 vscode-proto3 实践 参考博客: 用Git在Visual Studio Code内进行版本控制[指导]参考博客: 使用vscocd进行python开发 Atom Github 推出的编辑器 淘宝Mirror 配置apm命令镜像~/.atom/.atomrc 12registry=https://registry.npm.taobao.org/strict-ssl=false 或者直接clone 进行安装 在~/.atom/packages下clone仓库, 然后 apm install Gedit Github地址 安装markdown预览插件 该插件早已经停止维护了，还是只用来简单的查看修改文件就好了 小书匠 在线使用 | github地址 本来是很合适的，但是对文件操作不干净，总有些bug不好用,文件闪退出错,终端不方便 不适合编程适合写作,所支持的md的格式非常强大 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y Moeditor|Typora|CuteMarkEd Moeditor 书写单个md文件方便，美观，没有目录树侧栏是硬伤, 但是typora 导出很强大 Cmd 官网 终端中的文本编辑器Vi/Vim Github地址Vim 学习笔记 Nano 模式没有vi系列复杂，使用简单，安装占用小 fte-terminal 文件树浏览，快速打开文件进行修改是比较方便的 在线编辑器stackedit.io Github地址 CMD编辑器","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/categories/工具/"}],"tags":[]},{"title":"Shell学习","slug":"Memo-Script-ShellLearn","date":"2018-12-15T04:10:46.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/15/Memo-Script-ShellLearn/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Script-ShellLearn/","excerpt":"","text":"目录 start 学习Shell shell类别 Shell内建命令 Tips 执行 输入输出 输入 输出 彩色输出 变量 变量作用域 嵌套 数据类型 整型 字符串 数组 结构 传递参数 判断 if case 循环 函数 配置文件 脚本的参数自动补全 Bash Zsh 常用模块 时间 工具 shyaml 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 学习Shell 首先语法不像别的语言可读性好，比如Python，然后方言众多，学习比Python2，3还恶心Shell 编程之语法基础 | Shell 编程之执行过程Shell 教程 shell类别 sh 大多Linux都支持的shell类别 bash zsh 十分现代化 配置oh my zsh dash 它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准 速度确实要快,输入上的交互确实交互不了 fish linux shell dash&amp;bash参考博客: 常见shell类型 Github: zsh guide Shell内建命令 学习内建命令的使用 Tips 常用代码片段 获取当前shell脚本的绝对路径 12345671. 命令嵌套 只要在 命令中用 两个反引号 `` 将子命令包住即可1. 检查当前用户为Root用户 ```sh if [ $(id -u) != &quot;0&quot; ]; then printf $red&quot;Please use root to run this script\\n&quot;$end exit 1 fi kill 脚本进程 123456id=`ps -ef | grep \"WithRedis.py\" | grep -v \"grep\" | grep -v \"\\-d\" | awk '&#123;print $2&#125;'`if [ \"$&#123;id&#125;1\" = \"1\" ];then printf $red\"not exist background running script\\n\"$endelse kill -9 $idfi 得到脚本绝对路径; 如果只是执行 pwd 只是得到执行脚本时的当前绝对路径而已 1basepath=$(cd \\`dirname $0\\`; pwd) 执行 source命令 | 点和source命令 文件头部 #!/bin/sh表示要使用sh解释器来执行, 可以替换成bash dash 只要该文件具有执行权限就可以直接运行了 ./a.sh 或者绝对路径 输入输出输入 read answer 并且在处理管道的输入也是一样的使用 read123while read line; do echo $linedone 输出echo printf 彩色输出 参考博客,比较详细 12345678red='\\033[0;31m'green='\\033[0;32m'yellow='\\033[0;33m'blue='\\033[0;34m'purple='\\033[0;35m'cyan='\\033[0;36m'white='\\033[0;37m'default='\\033[0m' 变量变量作用域 比Python的作用域更加恶心 嵌套1234# 实现了读取 A_host变量的值perfix='A_'name=$&#123;perfix&#125;hosthost=$&#123;!name&#125; shell将变量当命令执行问题 ${command} echo ${command}|awk &#39;{run=$0;system(run)}&#39; 最好 数据类型整型 自增： i=$(( $i + 1 )) dash sh 都有效 ((a++)) 123456789101112131415161718192021 - let i+=1; - i=$[$i+1];- 取余 - i=$(( $i % 3))&gt; [取随机数](http://www.cnblogs.com/chengmo/archive/2010/10/23/1858879.html)- 四则运算 [参考博客 ](https://blog.csdn.net/taijianyu/article/details/6907288) - ((i=$j+$k)) 等价于 i=`expr $j + $k` - ((i=$j-$k)) 等价于 i=`expr $j -$k` - ((i=$j*$k)) 等价于 i=`expr $j \\*$k` - ((i=$j/$k)) 等价于 i=`expr $j /$k`_判断变量是否为数值_&gt; [博客 判断是否为数值](http://www.jb51.net/article/67468.htm)```sh if [ &quot;$1&quot; -gt 0 ] 2&gt;/dev/null ;then echo &quot;$1 is number.&quot; else echo &apos;no.&apos; fi 字符串 字符串截取 | Blog:变量字符串截取 | Shell正则 [ ] 重新整理 12345678$&#123;varible##*string&#125; 从左向右截取最后一个string后的字符串$&#123;varible#*string&#125; 从左向右截取第一个string后的字符串$&#123;varible%%string*&#125; 从右向左截取最后一个string后的字符串$&#123;varible%string*&#125; 从右向左截取第一个string后的字符串vars=$&#123;vars%%#*&#125; # 截取#左边vars=$&#123;vars#*cd&#125; # 截取最左的cd的右边vars=$&#123;vars%\\'*&#125; # 截取 右边引号 之左 获取命令的输出 使用 保存结果的变量名=需要执行的linux命令 这种方式来获取命令的输出时，注意的情况总结如下： 1）保证反单引号内的命令执行时成功的，也就是所命令执行后$?的输出必须是0，否则获取不到命令的输出 2）即便是命令的返回值是0，也需要保证结果是通过标准输出来输出的，而不是标准错误输出，否则需要重定向 因此我们推荐使用 保存结果的变量名=需要执行的linux命令 2&gt;&amp;1的方式来获取命令的执行结果。 输出变量时: $var会丢失换行和空格 &quot;$var&quot;不会 字符串的包含问题1234567891011isGithub=`expr match \"$line\" \".*\"$2`# 简单的就是使用grepisGithub=`echo $line | grep \"github\" `# return 0 is $1 is substring of $2, otherwise 1strIsSubstring()&#123; local x=1 case \"$2\" in *$1*) x=0;; esac echo $x&#125; _求长_ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253_字符串拆分成数组_&gt; [修改分隔符](http://www.cnblogs.com/FlyFive/p/3640243.html) | [三种方法概述](https://blog.csdn.net/bitcarmanlee/article/details/50973454)1. 如果是空格分割的字符串 - 直接 `for element in $target`************************### 数组*********************## 结构### 传递参数&gt; [参考博客](http://www.cnblogs.com/FrankTan/archive/2010/03/01/1634516.html) `命令行选项 参数处理`| 参数 | 说明 ||:----:|:----|| `$#` | 传递到脚本的参数个数| `$*` | 以一个单字符串显示所有向脚本传递的参数。以&quot;$1 $2 … $n&quot;的形式输出所有参数。| `$$` | 脚本运行的当前进程ID号| `$!` | 后台运行的最后一个进程的ID号| `$@` | 与$*相同，但是使用时加引号 以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。| `$-` | 显示Shell使用的当前选项，与set命令功能相同。| `$?` | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。&gt; 读取脚本参数 ```sh # 1. 简单的方式 case $1 in -h | h) echo &quot;help&quot; ;; *) echo &quot;default&quot; ;; esac # 2. 规范化的参数 while getopts &quot;hup:&quot; opt; do case &quot;$opt&quot; in h) usage exit 0 ;; u) UPCASE=true ;; d) DATE=$OPTARG ;; esac done 判断if 参考博客 判断文件 文件 if [ -f path ] 链接 if [ -L path ] 目录 if [ -d path ] 整数比较 -eq 等于,如:if [ “$a” -eq “$b” ] -ne 不等于,如:if [ “$a” -ne “$b” ] -gt 大于,如:if [ “$a” -gt “$b” ] -ge 大于等于,如:if [ “$a” -ge “$b” ] -lt 小于,如:if [ “$a” -lt “$b” ] -le 小于等于,如:if [ “$a” -le “$b” ] 大于 (需要双括号),如:((“$a” &gt; “$b”)) &gt;=大于等于(需要双括号),如:((“$a” &gt;= “$b”))case 12345678case $content in -h|h) echo \"help\" ;; *) echo \"前面全部不匹配才会执行\" ;;esac 循环 参考博客 简易循环123for i in $(seq 1 5); do echo $idone 12345i=1while [ \"$i\" -le 10 ];do echo $i i=$(($i+1))done 函数 Shell的函数只能返回整型数据类型 123simple()&#123; echo \"simple\"&#125; 配置文件 参考博客 脚本的参数自动补全 参考博客: 命令行自动补全原理 BashZsh 更为直观, 简单 学习怎么使用的话, 可以看上面的博客(虽然有点简陋), 但是如果是 oh-my-zsh 的用户, 可以直接看别人的插件, 模仿就行了, 例如 redis-cli 插件的自动补全, 就很简单直接 #compdef redis-cli rec 这第一行很重要, 定义了是对哪个命令或脚本的自动补全 常用模块时间 shell处理时间格式 工具 更多工具 shyaml 参考","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://blog.kuangcp.top/tags/Shell/"}]},{"title":"LinuxBash","slug":"Memo-Script-LinuxBash","date":"2018-12-15T04:10:18.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/15/Memo-Script-LinuxBash/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Script-LinuxBash/","excerpt":"","text":"目录 start Linux Bash 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 从ShellLearn 中整理过来 参考博客: bash实现“多进程”","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://blog.kuangcp.top/tags/Shell/"}]},{"title":"Dos","slug":"Memo-Script-Dos","date":"2018-12-15T04:10:06.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/15/Memo-Script-Dos/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Script-Dos/","excerpt":"","text":"目录 start DOS批处理 Tips 基础命令 常用基础 基础语法 变量 服务 实用性脚本 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs DOS批处理Tips windows下使用VmWare创建的虚拟机如果报错 就找到虚拟机目录下vmx后缀的文件 用记事本打开，手动找到vmci0.present=‘TRUE’,把true改为false 即可。 基础命令常用基础cd 路径 ： 跳转到本盘符下的路径cd /d 路径 ：跳转到别的盘符下的路径“盘符：” ： 切换盘符netstat -an ：查看开启了哪些端口netstat -v : 查看正在进行的工作netstat -ano ：查看端口占用 基础语法变量 参考博客 服务记一次在windows上配置服务 将jar程序配置为服务 将bat后台运行，隐藏黑窗口 按端口找到进程然后杀掉 手动方式 实用性脚本 本人写的bat因为后期转用Linux了,所以就没有写了 其中用的多的就是服务管理的脚本","categories":[{"name":"Windows","slug":"Windows","permalink":"http://blog.kuangcp.top/categories/Windows/"}],"tags":[{"name":"DOS","slug":"DOS","permalink":"http://blog.kuangcp.top/tags/DOS/"}]},{"title":"Scala","slug":"Memo-Scala-Scala","date":"2018-12-15T04:09:46.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Scala-Scala/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Scala-Scala/","excerpt":"","text":"目录 start Scala 安装 基础了解 基础语法 适合Scala使用的场景 Scala和Java的比较 Scala特性 类型推断 方法 导入 循环控制结构 函数式编程 Scala对象模型 数据结构和集合 actor 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Scala Official tour Groovy创始人：Java面临终结 Scala将取而代之 参考博客: 20 Best Scala Books To Go From Beginner To Expert 安装 通过sdkman安装，或者下载解压配置环境变量 sdkman使用 基础了解特性 Scala语言的精炼，包括类型推断的能力 match 表达式， 以及模式和case类等相关概念 Scala的并发，采用消息和acto机制，而不是像Java代码那样用老旧机制的锁机制 简洁的基础语法 类的定义和类的构造方法是同一个东西。Scala中可以有其他的辅助构造方法， 类默认是公开的，所以没必要加上public关键字 方法的返回类型是通过类型推断确定的，但要在定义的方法的def从句中用等号高数编译器做类型推断 如果方法体只是一条语句或表达式， 那就没有必要用大括号括起来 Scala不像Java一样有原始类型。数字类型也是对象 123456object HelloWorld &#123; def main(args:Array[String])&#123; val hello = \"Hello World!\" println(hello) &#125;&#125; 针对这个简单示例的语法特性 关键字object声明这个类是单例类 main方法 缺省了关键字 public static 不必声明hello的类型，编译器会自行推断 无需声明main方法的返回类型 编译器会自动设为 Unit 等价于Java中的void 和Java Groovy不一样的是，变量的类型在变量之后 方括号 [] 表示泛型，所以类型参数的表示方法是Array[String] 不是 String[] Array是纯正的泛型 集合类型必须指明泛型 不能像Java那样声明生类型（指不带类型参数的泛型类或接口。） 例如泛型类 Box&lt;T&gt; 创建其参数化类型时要指明类型参数的真实类型 BoxintBox = new Box&lt;&gt;(); 如果忽略了类型参数，Box rawBox = new Box();则是创建了一个生类型 分号绝对是可选的 val 就相当于Java中的final变量，用于声明一个不可变量 Scala应用程序的初始入口总是在Object中 match表达式 最简单的match用法跟Java的switch差不多，但是match表达力更强 123456var transFer = args(0) match&#123; case \"one\" =&gt; \"1\" case \"Two\" =&gt; \"2\" case _ =&gt; \"Error: '\"+args(0)+\"' \"&#125;println(transFer) 从语言的纯粹性来看，Scala语法比Java更清晰，也更正规： 默认case 不需要另外一个不同的关键字 单个case 不会像Java那样进入下一个case，所以也就不需要break 关键字var 用来声明一个可变（非final）变量。没有必要尽量不要使用它 数组用圆括号访问 argvs(0) 就是main方法的第一个参数 默认case 就是case _ Scala支持间接方法调用，所以可以把args(0).match({…}) 写成 args(0) match({…}) 12345def autoType(obj: Any) = obj match&#123; case s: String =&gt; s.length case i: Int =&gt; 4 case _: =&gt; -1&#125; 这个方法以一个未知类型值为参数，然后用模式分别处理String Int类型的值 case类 match 表达式的最强用法之一就是和case类（可以看成是枚举概念面向对象的扩展）相结合 例如一个 温度过高发出警告的例子： case class TemperatureAlarm(temp: Double) 这一行就定义个一个有效的case类，相比于Java简化了很多 var alarm = TemperatureAlarm(99.9) 创建case实例不需要关键字 new 这进一步强化了case类是类似于 参数化枚举类型 或某种形式的值类型的观点 Scala中的相等：Scala认为Java用 == 表示引用相等是个错误。所以在Scala中，== 和 equals是一样的，如果需要判断引用相等，可以用 === case类 equals 方法只有在两个实例的所有参数值都一样时才会返回true caes类和构造器模式非常合 actor Scala选择actor机制来实现并发编程。提供了一个异步并发模型，通过在代码单元间传递消息实现并发。这种并发模型比Java提供的基于锁的机制，默认共享的并发模型更易用，不过Scala的底层模型也是JVM 基础语法运行 可以进入REPL终端，和Python类似 也可以使用scalac scala就像javac java先进行编译然后再运行字节码 或者scala 文件解释运行 包 第一种方法和 Java 一样，在文件的头定义包名，这种方法就后续所有代码都放在该包中。 比如： 12package com.runoobclass HelloWorld 第二种方法有些类似 C#，如： 123package com.runoob &#123;class HelloWorld &#125; Scala数据类型|数据类型|描述||:—|:—||Byte |8位有符号补码整数。数值区间为 -128 到 127||Short |16位有符号补码整数。数值区间为 -32768 到 32767||Int |32位有符号补码整数。数值区间为 -2147483648 到 2147483647||Long |64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807||Float |32位IEEE754单精度浮点数||Double |64位IEEE754单精度浮点数||Char |16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF||String |字符序列||Boolean |true或false||Unit |表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。||Null |null 或空引用||Nothing |Nothing类型在Scala的类层级的最低端；它是任何其他类型的子类型。||Any |Any是所有其他类的超类||AnyRef |AnyRef类是Scala里所有引用类(reference class)的基类| 定义变量 定义无类型 变量 var name 常量 val name 定义变量加上类型 var VariableName : DataType [= Initial Value] 常量同理 如果在没有指明数据类型的情况下声明变量或常量必须要给出其初始值，否则将会报错。 变量var myVar = 10; 常量val myVal = &quot;Hello, Scala!&quot;; 声明多个变量 val xmax, ymax = 100 // xmax, ymax都声明为100 Scala 访问修饰符基本和Java的一样，分别有：private，protected，public Scala操作符 函数 函数签名： def functionName ([参数列表]) : [return type] ={} 如果你不写等于号和方法主体，那么方法会被隐式声明为”抽象(abstract)”，包含它的类型于是也是一个抽象类型。 方法定义由一个def关键字开始，紧接着是可选的参数列表，一个冒号&quot;：&quot; 和方法的返回类型，一个等于号&quot;=&quot;，最后是方法的主体。 以上代码中 return type 可以是任意合法的 Scala 数据类型。参数列表中的参数可以使用逗号分隔。 如果函数没有返回值，就是返回为 Unit，这个类似于 Java 的 void, 函数调用： functionName( 参数列表 ) [instance.]functionName( 参数列表 ) 函数的概念解析 适合Scala使用的场景Scala和Java的比较 比较Scala和Java 该表主要对这两种语言的主要差异做了汇总，语言的表皮层是指该语言关键字的数量和开发人员用它干活必须掌握的独立语言结构的数量 Scala特性类型推断 Scala是静态语言，但是Scala能根据上下文推断变量类型，所以让Scala更有动态语言的感觉 Java也有类型推断，例如泛型钻石语法，Java的类型推断通常是用在赋值语句等号右边的值上。 Scala通常是推断变量而不是值的类型，但是Scala的确也能推断值的类型 123def len(obj: AnyRef) = &#123; obj.toString.length&#125; 这是一个类型推断的方法。通过检查返回代码中的java.lang.String#length的类型（int），编译器知道这个方法要返回Int类型的值。 注意这个方法没有显式的指定返回类型，不需要return关键字，如果用了return反而是错误的 如果连def中的 = 也省略，编译器就会返回Unit 类型推断有两个受限的情况： 方法声明中参数的类型，传给方法的参数必须指定类型 递归函数，Scala不能推断递归函数的返回类型 方法 Scala没有static关键字，与之相对应的是 object结构中的方法，其中有个 伴生对象 与Groovy和Clojure相比，Scala语言的运行要重的多，Scala类，会有很多由平台自动生成的额外方法 方法调用是Scala的核心概念， Scala中没有Java那种意义上的操作符 Scala的方法名是灵活的，甚至可以出现操作符，例如 + 这个方法。Scala不再把操作符当做一个独立概念 Scala认为所有的东西都是对象，所以可以在任何东西上调用方法，即使是Java里的原始变量 1234567891011def fact(base: Int) : Int = &#123; if(base &lt; 0)&#123; print(\"负数没有阶乘 ：\") return base &#125; if(base == 0)&#123; return 1 &#125;else&#123; return base * fact(base - 1) &#125;&#125; 这个方法的定义和Java很相似，都有返回值，并用return关键字明确返回值，唯一的差别就是 函数代码块定义之前加 = Scala还有一个Java中没有的概念：局部函数。像一个私有的内部类，封装了具体细节 导入 import java.io.File 普通导入 import java.net._ 通配导入 import scala.collection.{Map, Seq} 导入包下多个类 import java.util.{Date =&gt; UDate} 导入类并取别名 import语句不像Java一样只能放在文件顶部，可以将import单独分离出来，Scala也有默认导入 即：scala._ 循环控制结构 for循环 Scala采用函数式编程中的概念 列表推导式 来实现for循环 1234567891011// 条件for循环for (i &lt;- 1 to 10; if i%2 ==0)&#123; println(i)&#125;// 多变量循环for(x&lt;- 1 to 16; y&lt;- 1 to x)&#123; println(\" \"*(x-y) + x.toString * y)&#125;// 一次新建，多次使用val xs = for(x &lt;- 2 to 11) yield xfor(factx &lt;- xs) println(factx) 列表推导式的一般概念是对一个列表中的元素进行转换，这会产生一个新列表。 例如上的的例子，就是先生成一个xs集合，然后第二个for进行遍历。 创建一次，使用多次 函数式编程 函数字面值或者是匿名函数， 其中的关键是 =&gt; Scala用它来表示取得参数列表并传递到代码块中 (&lt;函数参数列表&gt;) =&gt; {...} 普通函数，入参是int，返回值是int：val doubler = (x: Int) =&gt; {2*x} 入参是函数字面值，返回值是函数字面值： val adder = (n: Int) =&gt; {(x: Int) =&gt; x+n}定义一个可以加任意数的函数 val plus2 = adder(2) 定义一个将入参 加2的函数 Scala对象模型数据结构和集合actor 何时以及如何开始使用Scala 有信心评估所需的工作量 问题域边界明确，定义清晰 需求说明明确 与其他组件的互操作需求已知 确定了愿意学习新语言的开发人员 可能不适合当前项目的迹象 受到了业务小组和其他程序支持小组的抵制或缺乏动力 开发团队没有明显的学习Scala的动力 小组中存在分帮结派或政治上存在巨大分歧 小组中高级技术人员的支持力度不够 截止日期太紧张","categories":[{"name":"Scala","slug":"Scala","permalink":"http://blog.kuangcp.top/categories/Scala/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"SBT","slug":"Memo-Scala-SBT","date":"2018-12-15T04:09:32.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Scala-SBT/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Scala-SBT/","excerpt":"","text":"目录 start SBT 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs SBT Scala 的构建工具 Official doc | scaladex类似于 MvnRepos 参考博客: Building Java Projects With Sbt 配置代理 Official Doc~/.sbt/repositories123[repositories]localaliyun: http://maven.aliyun.com/nexus/content/groups/public/","categories":[{"name":"Scala","slug":"Scala","permalink":"http://blog.kuangcp.top/categories/Scala/"}],"tags":[]},{"title":"Python网络编程","slug":"Memo-Python-PythonNet","date":"2018-12-15T04:08:54.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Python-PythonNet/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Python-PythonNet/","excerpt":"","text":"目录 start 网络编程 Socket 基于TCP 基于UDP 邮件 Web工具 爬虫1. [安装所需模块](#安装所需模块) 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 网络编程Socket 作为网络编程的抽象概念，用于描述IP地址和端口，表示打开了一个网络连接，一个socket绑定到一个端口上基于Socket的编程，需要知道目标计算机的IP地址，端口，以及协议类型 基于TCP基于UDP邮件Web工具 pip3 install httpie 我的用不了，奇怪？？ 这个sudo apt install httpie才能用 http --json URL 格式化输出json URL会转小写。。。 curl URL|python -m json.tool 格式化输出JSON 爬虫安装所需模块解析HTML bs4 ：sudo pip3 install bs4 lxml :sudo pip3 install lxml","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.kuangcp.top/categories/Python/"}],"tags":[]},{"title":"Python 操作 Offices文档","slug":"Memo-Python-PythonOffices","date":"2018-12-15T04:08:39.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/15/Memo-Python-PythonOffices/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Python-PythonOffices/","excerpt":"","text":"目录 start Offices文档 Word Excel xlrd pandas 目录 end|2018-12-13 20:53| 码云 | CSDN | OSChina | cnblogs Offices文档WordExcel 参考: Python-Excel 模块哪家强？ xlrd Github addr 123456789import xlrd data = xlrd.open_workbook('monster.xlsx')table = data.sheets()[0] nrows = table.nrowsfor i in range(nrows): for cell in table.row_values(i): print(cell, ' | ', end='') print() pandas Official Site","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.kuangcp.top/categories/Python/"}],"tags":[{"name":"Offices","slug":"Offices","permalink":"http://blog.kuangcp.top/tags/Offices/"}]},{"title":"PythonWeb","slug":"Memo-Python-PythonWeb","date":"2018-12-15T04:08:21.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/15/Memo-Python-PythonWeb/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Python-PythonWeb/","excerpt":"","text":"目录 start Web 简单Web服务器 Django Flask 开发一个简易RESTful风格的服务器 跨域 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Web 对比五种Web框架 简单Web服务器 python内置一个简易的Web服务器 只需在静态资源的根目录下执行 python2 python -m SimpleHTTPServer [8000] 即可启动 缺省端口为8000 python3 python3 -m http.server [8000] Djangopython3.5 建立虚拟环境 sudo apt install python3-venv 在某目录 python3 -m venv first_env 激活环境 source first_env/bin/activate 停用环境 deactivate 安装Django pip install Django 创建项目 django-admin.py startproject first_pro . ls first_pro查看到创建的默认文件 创建SQLite数据库 python manage.py migrate 启动项目python3 manage.py runserver Flask开发一个简易RESTful风格的服务器 官方文档 但是这个内置的web服务器性能很渣教程文档 跨域 解决方式pip install flask-cors 1234from flask_cors import *app = Flask(__name__)CORS(app, supports_credentials=True)","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.kuangcp.top/categories/Python/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://blog.kuangcp.top/tags/Web/"}]},{"title":"PyCharm","slug":"Memo-Python-Tool-PyCharm","date":"2018-12-15T04:08:04.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/15/Memo-Python-Tool-PyCharm/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Python-Tool-PyCharm/","excerpt":"","text":"目录 start PyCharm 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs PyCharm 参考博客: PyCharm安装及使用","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/categories/工具/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://blog.kuangcp.top/tags/IDE/"}]},{"title":"Zsh","slug":"Memo-Linux-Tool-Zsh","date":"2018-12-15T04:06:10.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Tool-Zsh/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Tool-Zsh/","excerpt":"","text":"目录 start Zsh 为什么要使用 安装 配置 oh-my-zsh 插件 主题 自己定制 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Zsh arch zsh wiki 为什么要使用 知乎:mac 装了 oh my zsh 后比用 bash 具体好在哪儿？终极 Shell——ZSH 安装 debian系 apt install zsh 配置 某人的配置 oh-my-zsh Github | 参考博客进行安装 关于PS1环境变量的折腾 因为含特殊字符GitBook构建通不过,只能放出去了 安装好 zsh wget git sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; vi ~/.zshrc 进行配置 123plugins=( git mvn gradle autojump) 插件 wiki: pluginszsh oh-my-zsh 插件推荐 个人常用 git autojump go docker kubectl 主题 官网主题列表 自带主题: 个人偏好 amuse clean wedisagree, muse也还好,就是没时间 额外安装 额外主题列表 powerlevel9k 官方文档 git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k powerlevel9k/powerlevel9k Bullet Train (桌面在用) | Github repo Source Code Pro for Powerline + Powerline + Awesonme 的 Bold 字体搭配最合适 spaceship 地址 安装步骤 mkdir $ZSH_CUSTOM/themes/ wget http://raw.github.com/caiogondim/bullet-train-oh-my-zsh-theme/master/bullet-train.zsh-theme config .zshrc to ZSH_THEME=&quot;bullet-train&quot; Maglev Github地址 自己定制 Github doc","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://blog.kuangcp.top/tags/Shell/"}]},{"title":"Vim","slug":"Memo-Linux-Tool-Vim","date":"2018-12-15T04:05:58.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Tool-Vim/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Tool-Vim/","excerpt":"","text":"目录 start Vim Tips 基本配置 基础操作 跳转 搜索匹配 复制粘贴 插入模式 命令模式 vim-init spf13 SpaceVim space-vim 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Vim 学习曲线很高，但是学会熟练使用后就效率很高 vim galore Vim galore 中文翻译 bytefluent.com/vivify方便的自制主题 Tips 误按 Ctrl S 终止屏幕输出（即停止回显）你敲的依然有效，只是看不见 Ctrl Q 即可恢复 /usr/share/vim/vim80/macros/less.sh vim版less 具备语法高亮 路径中间是依据vim版本来的,按实际情况改动 vim输出的信息123456系统 vimrc 文件: &quot;$VIM/vimrc&quot;用户 vimrc 文件: &quot;$HOME/.vimrc&quot;第二用户 vimrc 文件: &quot;~/.vim/vimrc&quot;用户 exrc 文件: &quot;$HOME/.exrc&quot;defaults file: &quot;$VIMRUNTIME/defaults.vim&quot;$VIM 预设值: &quot;/usr/share/vim&quot; 基本配置 在文件 全局：/etc/vim/vimrc 先备份一下 sudo cp /etc/vim/vimrc /etc/vim/vimrc.bak 或者当前用户：~/.vimrc 中添加如下内容12345678910111213141516171819202122set showcmd &quot; Show (partial) command in status line.set autowrite &quot; Automatically save before commands like :next and :makeset nocompatibleset numberfiletype on syntax onset history=1000set autoindentset smartindentset tabstop=4set expandtabset shiftwidth=4set showmatchset guioptions=Tset rulerset hlsset backspace=2imap jk &lt;Esc&gt; set relativenumber &quot; 设置相对行号&quot; 逗号后追加空格inoremap , ,&lt;space&gt; ~/.gvimrc1234:set guifont=IBM\\ Plex\\ Mono\\ 12colorscheme desertsyntax enablesyntax on 基础操作 参考博客高效率编辑器 Vim——操作篇，非常适合 Vim 新手 v 可视化操作 参考博客: vim中执行shell命令小结 跳转 K J H L 上下左右 Ctrl+F 上翻一页 Ctrl+B 下翻一页 H M L 跳转到屏幕 顶 中 尾 2H 第二行 3L 倒数第三行 * 当光标在某单词上 会进行搜索跳转到下一个 # 与* 一样，不过是跳转到上一个 /)和/( 跳转到 后和前 语句的位置 为了() 跳转方便 /}和/{ 跳转到 后和前 段落的位置 g_ 跳转到最后一个不是空格的字符的位置 gg 跳转到文件第一行的起始位置 G 跳转到文件最后一行起始位置 5gg或5G :5 跳转到 5 行的起始位置 number 正数则是往下，负数则是往上 (相对) 行内移动 w 右移到下一个字的开头 e 右移到下一个字的末尾 b 左移到前一个字的开头 0 左移光标到本行的开始 $ 右移光标到行末尾 ^ 移动到本行第一个非空字符 fg 在光标所在处(如果是有效的目录或者文件,就能直接跳转过去) 搜索匹配 /name 正向搜索字符串 name n 搜索后跳下一个 N 搜索后跳上一个 ?name 反向搜索字符串 复制粘贴 :reg 查看寄存器 yy 复制当前行 nyy 是复制该行开始的共n行(是vim内的剪贴板) yn 加换行 等效 &quot;+nyy 同理复制n行，操作系统级的剪贴板 &quot;+yn 等效 P/p 将剪贴板的内容粘贴在 前/后 &quot;+p 将系统的剪贴板内容粘贴进来 u 撤销上一条命令的效果 . 重复最后一条修改正文的命令 插入模式 i 在光标左侧插入 a 在光标右侧插入 o 在光标该行下一行新增一行 O 在光标该行上一行新增一行 I 在光标该行开头插入 A 在光标该行末尾插入 命令模式 :e path 打开指定路径下文件 :w 保存当前编辑的文件 后接文件名就是另存为 ZZ 退出Vim 并将所做修改覆盖原始文件 :q 未修改的情况下退出 :q! 放弃所有修改，退出 wq x 先保存后退出 vim-init Github: spf13 official site SpaceVim 参考博客: SpaceVim 中文手册主要看评论, 两个作者理念不同参考博客: 如何评价Vim配置文件SpaceVim? Space Vim把Vim玩上天了 GitBook : Space Vim Guide quick start 中文 文档 space-vim Github:","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/categories/工具/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://blog.kuangcp.top/tags/Vim/"}]},{"title":"终端工具","slug":"Memo-Linux-Tool-Terminal","date":"2018-12-15T04:05:21.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Tool-Terminal/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Tool-Terminal/","excerpt":"","text":"目录 start Terminal 终端模拟器对比 终端工具命令 Shell内建命令 需用户安装 效率工具 Autojump tmux notes todo.txt-cli starDict 文本操作 xclip uniq 文件操作 iconv zssh 分享 asciinema 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs Terminal 终端模拟器是吸引我放弃习惯的Windows而转投Linux怀抱的主要原因 终端模拟器对比 列举出系统可安装终端 sudo apt search terminal | grep -E terminal.+amd64 qterminal 可定制标签页位置以及透明度，很简洁,挺好用,但是不能内容和窗体大小自适配, 0.7.1已没有这个bug, 还是很好用的模拟器, 但是多标签的时候, 会有内存泄露 mate-terminal 和gnome-terminal 基本配置什么的几乎一样，只是标题栏简洁一丢丢，如果使用选择即复制,那么在跨标签页复制粘贴有bug gnome-terminal 很简洁，但是多标签时，标签栏太大,标签页底部有白边 sakura 外观上和前两个几乎一样，标签页可以更简洁，但是设置不好调, 而且不能自定义快捷键 deepin-terminal 功能很多，主题很多，功能最为强大，但是字体可以选的很少 terminator 可以定制背景图片，但是在我这deppin系统里有bug，多标签是假的，命令全是在共享的，不能用。。 tmux 运维必备软件，入门有些繁琐 tilda 内嵌于桌面上, 小命令方便, 需要查看文件就不方便了 更多可安装终端 终端工具命令 /bin/* 系统自带命令 which 命令的位置 false 以失败码退出程序 stty -a 查看键映射 Shell内建命令 whence 查看命令的真实面貌 (zsh中的内建命令) where 查找命令的位置 (Zsh中内建命令) 需用户安装 最终都会安装到 /usr/bin/* 目录下 wc -l file 统计文件行数 md5sum 报文摘要算法 Message-Digest Algorithm 5 的实现 md5sum file 计算出md5值 md5sum -c file.md5 file 和 file.md5 在同一目录下, 执行这个命令就是检查md5是否匹配, 确保文件的完整性和正确性 last 查看Linux登录信息 last -n 5 最近五次登录 w | uptime 查看启动情况 colrm ps | clorm 20 30 colrm 删除输出的20 到30 列 xsel cat a.md | xsel -b 将文件所有内容复制到剪贴板 但是处理大文件时会失效 xclip 更有效 htop 终端里的任务管理器 strace -p PID 查看系统调用 cmatrix 装13,字符雨 logkeys 记录键盘输入 Github expect 用于自动输入密码 WTF | Github Repo 丰富的功能, 一个方便的终端控制面板 ag 快速当前目录下, 全文内容搜索, 快到可怕 ubuntu:silversearcher-ag alpine:the_silver_searcher The Silver Searcher when-changed 监控文件变化 执行命令 pip install when-changed dircolors Linux dircolors命令用于设置 ls 命令输出时的色彩 效率工具 提高工作和开发效率 Autojump 统计cd 目录，方便目录跳转 *shrc 中要有 : . /usr/share/autojump/autojump.sh apt install autojump 设置为自动运行 echo &#39;. /usr/share/autojump/autojump.sh&#39; &gt;&gt; ~/.bashrc j -v 查看安装版本 j --stat 查看统计信息 j --help jo code 打开code文件夹 jco c 打开子目录 ls -l ~/.local/share/autojump/ 统计信息的目录，清除就相当于卸载重装了 tmux 好用的管理会话的软件, 在服务器上是很有用的 学习使用 tmux 入门 新建会话 tmux new -s myth 连接会话 tmux a -t test 显示所有 tmux ls Ctrl B 再 C 新建一个窗口 Ctrl B 数字键切换指定窗口 断开会话但是后台运行 ctrl+B D notes 管理笔记Github todo.txt-cli 终端内的 todoGithub starDict 终端内字典 文本操作xclip 便捷的文本复制 cat README.md | xclip -sel clip 将文件复制到剪贴板 uniq report or omit repeated lines 统计出现次数 cat log.log | grep WARN | awk &#39;{print $5}&#39; | sort | uniq -c 文件操作iconv 可以将一种已知的字符集文件转换成另一种已知的字符集文件 zssh 便捷的文件传输 参考博客 分享asciinema asciinema 终端屏幕录制和分享网 执行 asciinema或asciinema rec 即可开始录制 要注册就运行 asciinema auth 进入输出的网址，填邮箱和名字即可（每次登录都要这样。或者使用邮件来确认，麻烦ing）","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/categories/工具/"}],"tags":[{"name":"工具使用经验","slug":"工具使用经验","permalink":"http://blog.kuangcp.top/tags/工具使用经验/"}]},{"title":"Nginx","slug":"Memo-Linux-Tool-Nginx","date":"2018-12-15T04:05:09.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Tool-Nginx/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Tool-Nginx/","excerpt":"","text":"目录 start Nginx Nginx的安装 命令安装 编译安装 Docker安装并做反向代理 命令使用 配置使用 本地静态文件Web服务器 反向代理多个服务 配置https certbot来配置Https 配置Websocket反向代理 防盗链 负载均衡 跨域问题的配置 静态服务器将后台反代理 问题 目录 end|2018-12-17 20:45| 码云 | CSDN | OSChina | cnblogs NginxNginx的安装命令安装 安装sudo apt install nginx 启动服务 sudo nginx或者sudo /etc/init.d/nginx start 关闭 sudo nginx -s quit 或者 sudo /etc/init.d/nginx stop 编译安装 不建议使用这种方式进行安装，很容易出现兼容问题 下载 nginx，pcre，zlib，openssl 的压缩包 进入解压根目录（按实际情况配置）配置各个包12345678./configure --sbin-path=/usr/local/nginx/nginx \\--conf-path=/usr/local/nginx/nginx.conf \\--pid-path=/usr/local/nginx/nginx.pid \\--with-http_stub_status_module \\--with-http_ssl_module \\--with-pcre=/home/kuang/pcre-8.20 \\--with-openssl=/home/kuang/openssl \\--with-zlib=/home/kuang/zlib-1.2.11 Docker安装并做反向代理 nginx hub 官方镜像 运行命令创建容器运行 docker run --name youhuigo -d -p 80:80 -v /home/kuang/nginx/conf/:/etc/nginx/conf.d/:ro --link you:web nginx conf 基础配置文件12345678910111213141516upstream gitea &#123; server 127.0.0.1:6001;&#125;server &#123; listen 80; server_name git.kuangcp.top; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxt true; proxy_pass http://gitea; proxy_redirect off; &#125;&#125; 配置多域名反向代理 其实也就是多了 俩 upstream 监听80的server 命令使用nginx -h 输出12345678910111213nginx version: nginx/1.13.3Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload -p prefix : set prefix path (default: /usr/share/nginx/) -c filename : set configuration file (default: /etc/nginx/nginx.conf) -g directives : set global directives out of configuration file -s signal stop 停止 quit 退出 reopen 重新打开 reload 重载（修改配置文件常使用） -t 测试配置 使用 指定配置文件，或者默认配置文件 进行测试 配置使用 知乎专栏nginx基本配置 | ngrok nginx docker本地搭建服务器 实验楼课程 个人理解 server_name 是一个域名或者ip, 如果是ip和公网的域名就没什么好解释的, 但是如果只是局域网的修改host文件生成的域名, 自己使用该域名访问是没有问题的, 别人访问不了,但是如果也同样的修改host文件后, 也能正确使用域名访问 server是一个门路, 不会冲突, 所以才能有很多个监听80端口的配置而互不影响. 本地静态文件Web服务器 最简单的使用 参考博客 123456789server &#123; # listen 6050; client_max_body_size 4G; listen 80; ## listen for ipv4; this line is default and implied server_name static.me.com; root /home/mini/Sync; location / &#123; &#125;&#125; 再在 /etc/hosts文件中配置下域名即可访问 在服务器中配置， 出现403错误, 将 /etc/nginx/nginx.conf 中第一行的 user nginx; 改成 root 反向代理多个服务 修改默认配置文件 /etc/nginx/nginx.conf 或者更好的就是在 /etc/nginx/conf.d/下新建 *.conf 文件，文件名任意 该配置文件配置了服务器反向代理，80端口上：/路径的请求转发到9991端口 /myth转发到7898端口12345678910111213141516171819202122232425upstream xxxuthus &#123; server 127.0.0.1:9991;&#125;upstream youhui &#123; server 127.0.0.1:7898;&#125;server &#123; listen 80; server_name 1.1.1.1; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxt true; proxy_pass http://xxxuthus; proxy_redirect off; &#125; location /myth&#123; proxy_pass http://youhui; proxy_redirect off; &#125;&#125; 测试配置文件 再 重启nginx nginx -s reload 配置https 参考博客 nginx搭建https服务 | nginx http/2 先签发证书 命令运行1234567891011121314############ 证书颁发机构# CA机构私钥openssl genrsa -out ca.key 2048# CA证书openssl req -x509 -new -key ca.key -out ca.crt############ 服务端# 生成服务端私钥openssl genrsa -out server.key 2048# 生成服务端证书请求文件openssl req -new -key server.key -out server.csr# 使用CA证书生成服务端证书 关于sha256，默认使用的是sha1，在新版本的chrome中会被认为是不安全的，因为使用了过时的加密算法。openssl x509 -req -sha256 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650 -out server.crt # 打包服务端的资料为pkcs12格式(非必要，只是换一种格式存储上一步生成的证书) 生成过程中，需要创建访问密码，请记录下来。openssl pkcs12 -export -in server.crt -inkey server.key -out server.pkcs12 *.conf配置文件 配置HTTPS1234567891011121314151617181920upstream youhui &#123; server 127.0.0.1:8888;&#125;server &#123; listen 443; server_name wx.jjyouhuigo.com; # 主要就是添加了这一块 ssl on; ssl_certificate /home/youhuigo/https/server.crt; ssl_certificate_key /home/youhuigo/https/server.key; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxt true; proxy_pass https://youhui; proxy_redirect off; &#125;&#125; certbot来配置Https 免费的网站, 并且现在支持泛域名了! 参考博客 | 参考博客Nginx反向代理https1234wget https://dl.eff.org/certbot-autochmod a+x certbot-auto./certbot-auto 进行安装 但是过程中会有一些设置，./certbot-auto certonly --email kuangcp@aliyun.com --nginx -d wx.kuangcp.top 生成证书 SSL 接收到一个超出最大准许长度的记录 要在端口后加上SSL nginx1234567891011121314151617181920212223242526272829303132upstream youhui &#123; server 127.0.0.1:8080;&#125;upstream git&#123; server 127.0.0.1:55443;&#125;server &#123; listen 80; server_name git.kuangcp.top;location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxt true; proxy_pass http://git; proxy_redirect off; &#125; access_log /home/kuang/log/youhui.log;&#125;server&#123; listen 443 ssl; server_name wx.kuangcp.top ssl on; ssl_certificate /etc/letsencrypt/live/wx.kuangcp.top/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/wx.kuangcp.top/privkey.pem; ssl_trusted_certificate /etc/letsencrypt/live/wx.kuangcp.top/chain.pem; ssl_dhparam /etc/nginx/ssl/dhparam.pem; location / &#123; proxy_pass https://youhui; &#125; access_log /home/kuang/log/https.log;&#125; 配置Websocket反向代理1234567891011121314151617181920212223242526# 配置连接的配置信息map $http_upgrade $connection_upgrade&#123; default upgrade; &apos;&apos; close;&#125;upstream youhui &#123; server 127.0.0.1:8888;&#125;server &#123; listen 80; server_name 127.0.0.1; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_set_header X-Nginx-Proxt true; # 设置接收到的请求类型 proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_pass http://youhui; proxy_redirect off; proxy_read_timeout 300s; &#125;&#125; 防盗链负载均衡 Nginx 反向代理 负载均衡 虚拟主机配置 跨域问题的配置需要被跨域访问的一端， 添加如下配置123add_header Access-Control-Allow-Origin *;add_header Access-Control-Allow-Headers X-Requested-With;add_header Access-Control-Allow-Methods GET,POST,OPTIONS; 静态服务器将后台反代理 极大地省去了后台的配置！！Nginx反向代理解决跨域问题 | nginx简易使用教程,使用nginx解决跨域问题配置静态端123456789101112server &#123; client_max_body_size 4G; listen 80; ## listen for ipv4; this line is default and implied server_name view.kcp; location /api/ &#123; # add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; proxy_pass http://127.0.0.1:8889; &#125; location / &#123; root /home/kcp/IdeaProjects/Base/graduate/static; &#125;&#125; 将静态文件交由Nginx进行处理， 后台的服务统一用一个前缀和前台进行区分， 然后将服务端的真实host和ip或者域名配置进来 这样在于前端看来就是访问 view.kcp/api 而已， 实际上访问的是 127.0.0.1:8889/api 由于我原先用了nginx反向代理tomcat， 配置一个修改本地host得到的域名， 然后填在这里就没用了， 所以最好使用真实IP或者外网可访问的域名 问题 文件上传报错 413 http{}中添加 client_max_body_size 80M;","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/categories/工具/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.kuangcp.top/tags/Nginx/"}]},{"title":"输入码","slug":"Memo-Linux-Tool-IME","date":"2018-12-15T04:04:24.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Tool-IME/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Tool-IME/","excerpt":"","text":"目录 start IME 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs IME 输入法 参考博客: Linux安装搜狗拼音和谷歌拼音输入法","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/categories/工具/"}],"tags":[]},{"title":"HAProxy","slug":"Memo-Linux-Tool-HAProxy","date":"2018-12-15T04:04:13.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Tool-HAProxy/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Tool-HAProxy/","excerpt":"","text":"目录 start HAProxy 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs HAProxy 企业级工具","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/categories/工具/"}],"tags":[]},{"title":"Caddy","slug":"Memo-Linux-Tool-Caddy","date":"2018-12-15T04:02:10.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Tool-Caddy/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Tool-Caddy/","excerpt":"","text":"目录 start Caddy 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Caddy official website | 0.11.0 具有丰富的插件支持, 配置简洁 参考博客: 使用 Caddy 替代 Nginx，全站升级 https，配置更加简单","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/categories/工具/"}],"tags":[]},{"title":"Java初始化环境搭建","slug":"Memo-Linux-JavaDevInit","date":"2018-12-15T04:01:26.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-JavaDevInit/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-JavaDevInit/","excerpt":"","text":"目录 start 配置Deepin的Java开发环境 新增用户 安装Docker 在Linux上配置Java环境 配置JDK 解压配置 sdkman方式 mythsdk 配置MySQL 配置Redis 从源码编译运行并测试 问题以及解决方案： 双硬盘的折腾记录 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 配置Deepin的Java开发环境修改Hostname需要重启, 设置java默认需要重启, docker添加用户组需要重启 新增用户 详细 安装Docker 详细文档 在Linux上配置Java环境配置JDK解压配置 下载地址 在文件 /etc/profile 中添加 1234export JAVA_HOME= 绝对路径例如： /home/kcp/Application/sdk/jdk1.8.0_131export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 让修改立即生效source /etc/profile 或者修改 .bashrc 文件, 就会在当前用户的终端生效 root用户的环境 指定默认的jdk，因为系统预装了openJdk ,为了稳妥建议先进入JDK的bin目录,然后执行 12sudo update-alternatives --install /usr/bin/java java `pwd`/java 300sudo update-alternatives --install /usr/bin/javac javac `pwd`/javac 300 或者不执行命令, 直接修改链接文件即可完成同样的目的 后期更新JDK版本, 普通用户的话, 就只是需要更改 .bashrc 文件, root用户就执行以上命令, 或者直接重建软链接文件 root 用户下 which java 然后 ls -l 显示的路径 一直往下找, 找到 /etc/alternatives/java 和 /etc/alternatives/javac 重建这两个软链接. sdkman方式 jdk不推荐使用sdkman安装，这里的jdk是开源版估计，会少javafx等一些闭源包 Oracle版本才是完整的但是最近SDKMAN出了一个oracle的版本貌似是完整的，因为有个同意协议的过程 sdk install java 8u144-oracle 安装sdkman curl -s &quot;https://get.sdkman.io&quot; | bash 12345Looking for a previous installation of SDKMAN...Looking for unzip...Not found.Please install unzip on your system using your favourite package manager.Restart after installing unzip. 遇到这种提示就是需要安装zip sudo apt install zip unzip 然后重新执行命令 执行脚本：source &quot;/home/kuang/.sdkman/bin/sdkman-init.sh&quot; 或者重启终端就可以使用 sdk命令了 查看sdkman 版本 ：sdk version 查看可用版本 sdk list java 不指定版本就是安装最新版 sdk install java 指定默认版本 sdk default java 8u131-zulu 验证是否成功：java -version mythsdk 个人用py开发的脚本， 实现了和sdkman一致的内容， 并且很简单 | 使用文档 配置MySQL 安装MySQL 配置Redis 安装Redis 从源码编译运行并测试 新建文件夹将源码下拉下来运行，然后就可以将该目录删除 123456wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gzsudo tar xzvf tcl8.6.1-src.tar.gz -C /usr/local/cd /usr/local/tcl8.6.1/unix/sudo ./configuresudo makesudo make install 问题以及解决方案： QQ sudo apt-get install deepin-crossover deepinwine-qq 安装QQ 显卡问题 联想G4070 安装 deepin 15.4.1 显卡兼容失败（15.4还能正常用）, 15.5 15.6 是正常使用的 15.7 有点缺陷 因为合上盖子休眠就会导致打开电脑直接死机， 找了半天原因是驱动问题 安装 nvidia-driver, nvidia-setting, bumblebee-nvidia 即可解决 手残，按到关闭窗口特效后，就无法打开了，各种用着不爽， 然后重装了最新版系统，然后就装驱动，重启就不能开特效了。。。。。虽然各种小bug, 也花费了很多时间来解决这些问题(因为自己有强迫症), 但是还是学到了很多东西 双硬盘的折腾记录 记录","categories":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/categories/基础/"}],"tags":[{"name":"工具使用经验","slug":"工具使用经验","permalink":"http://blog.kuangcp.top/tags/工具使用经验/"}]},{"title":"Ubuntu","slug":"Memo-Linux-Debian-Ubuntu","date":"2018-12-15T03:30:32.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Debian-Ubuntu/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Debian-Ubuntu/","excerpt":"","text":"目录 start Ubuntu Tips 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs UbuntuTips 设置默认语言编码 sudo dpkg-reconfigure locales 检查本机已有语言包 locale -a","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.kuangcp.top/tags/Ubuntu/"}]},{"title":"Debian基础","slug":"Memo-Linux-Debian-Debian","date":"2018-12-15T03:29:14.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Debian-Debian/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Debian-Debian/","excerpt":"","text":"目录 start Debian 软件管理 软件源列表 包管理器 源码编译安装 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Debian Debian系 包含 Debian *buntu Deepin 等等 配置配置语言环境 apt install locales dpkg-reconfigure locales 进入选择界面 zh_CN.UTF-8 UTF-8 空格选择, 换行 继续 软件管理软件源列表 apt 的默认配置文件是 /etc/apt/source.list 以及 sources.list.d/ 目录下的 .list 文件 (最好将list文件都进行备份 备份文件为 .save) 参考博客 阿里云的软件源 wiki-源列表说明 源 URL 后的单词: main: 完全的自由软件。 restricted: 不完全的自由软件。 universe: Ubuntu官方不提供支持与补丁，全靠社区支持。 multiverse: 非自由软件，完全不提供支持和补丁。 添加私有源ppa 若不能添加私有源ppa： debain：sudo apt install software-properties-common python-software-properties Ubuntu sudo apt install python-software-properties 添加：sudo add-apt-repository ppa:dotcloud/lxc-docker 删除ppa : cd /etc/apt/sources.list.d/ 打开该目录下文件把对应的ppa的一行注释掉或删掉就行了 添加一个源列表 例如添加 nginx: 新建文件 /etc/apt/sources.list.d/nginx.list 12deb http://nginx.org/packages/mainline/debian/ jessie nginxdeb-src http://nginx.org/packages/mainline/debian/ jessie nginx curl http://nginx.org/keys/nginx_signing.key | apt-key add - 把签名添加进来才能正常 apt update 包管理器dpkg 查看已安装的应用 dpkg --list 显示已安装包的详情 dpkg -s package 安装deb包 sudo dpkg -i *.deb apt-get / apt install 包名 安装指定包的最新版 -y 参数可以省去确认 -s 模拟安装 package=version 安装指定版本的包 list 列出所有可安装的包 –installed 已安装的包 package 列出已安装的 该package 的信息 加上 -a: 所有版本 只卸载程序，保留配置文件 sudo apt remove 包名 彻底卸载应用 sudo apt--purge remove 包名 若已经卸载, 清理配置: apt purge 包名 (不会清理home/.config里的内容) apt-cache showpkg/policy/madison/show package showpkg (特别详细) 列出所有版本以及来源, MD5 … policy (基本信息) 列出所有版本以及来源 madison (简略显示) 内容同上 show 查询指定包的详情(已安装的版本信息) search 搜索包 snap official doc: snap 提供一个类似容器的环境,将所有依赖打包，隔离运行 源码编译安装 make install 源代码安装 1.解压缩 tar -zxf nagios-4.0.2.tar.gz 2.进入目录 cd nagios-4.0.2 3.配置 ./configure --prefix=/usr/local/nagios 4.编译 make all 5.安装 make install &amp;&amp; make install-init &amp;&amp; make install-commandmode &amp;&amp; make install-config","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"Debian","slug":"Debian","permalink":"http://blog.kuangcp.top/tags/Debian/"}]},{"title":"Kubernetes","slug":"Memo-Linux-Container-Kubernetes","date":"2018-12-15T03:28:19.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Container-Kubernetes/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Container-Kubernetes/","excerpt":"","text":"目录 start Kubernetes 相关博客 安装 简单使用 容器编排 Kubeless 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Kubernetes 又称K8s Official site | Github: 相关博客 浅谈k8s+docker 资源监控 | 基于Kubernetes构建Docker集群管理详解Kubernetes 学习笔记 参考博客: Kubernetes会不会被自身的复杂性压垮？ 安装 official doc 参考博客: kubeadm 搭建 kubernetes 集群 参考博客: Kubernetes国内镜像、下载安装包和拉取gcr.io镜像 参考博客: 国内服务器安装kubernetes一路坑，求大神指点 注意 Deepin上不要安装 kubernetes-client 这个是 1.7 版本, 类似于 docker.io 这样的老旧版本 使用阿里云的镜像进行安装12345678# 均以 root 运行apt update &amp;&amp; apt install -y apt-transport-httpscurl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -echo \"deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main\" &gt; /etc/apt/sources.list.d/kubernetes.list apt install kubelet kubeadm kubectl deb http://apt.kubernetes.io/ kubernetes-xenial main 虽然这才是官方源,奈何是Google服务器 简单使用容器编排Kubeless Official","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://blog.kuangcp.top/categories/Kubernetes/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"应用容器化","slug":"Memo-Linux-Container-DockerSoft","date":"2018-12-15T03:27:31.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Container-DockerSoft/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Container-DockerSoft/","excerpt":"","text":"目录 start Docker 安装应用 个人镜像 Linux发行版 Ubuntu-ssh Alpine-ssh Centos-ssh 编程语言 Java Jib Node Go 数据库 PostgreSQL Oracle MySQL MongoDB Redis 持续集成 flow.ci Jenkins Protobuf git服务器 简易git-daemon Gogs Gitea 配置 在线IDE Coding平台的WebIDE 图形化管理工具 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Docker 安装应用 如何创建尽可能小的Docker容器教程 Docker Hub: explore Official: Docker in docker Official: registry 个人镜像百度云 配置好SSH服务器的 alpine 3.6 | docker hub地址 | 百度镜像源: hub.baidubce.com/mythos/alpine-ssh:1.0 docker run --name sshd -p 8989:22 hub.baidubce.com/mythos/alpine-ssh:1.0 设置root用户密码 docker exec -it sshd passwd 登录 ssh -p 8989 root@localhost Jenkins 镜像 hub.baidubce.com/mythos/jenkins:2.138.1 protobuf的编译环境以及2.5的源码在内 hub.baidubce.com/mythos/protoc-alpine-src:2.5 protobuf 的 Alpine 的 2.5版本 hub.baidubce.com/mythos/protoc-alpine:2.5 protobuf 的 Ubuntu 的 2.5版本 hub.baidubce.com/mythos/protoc:2.5 protobuf 的 Alpine 的 3.5.1版本 hub.baidubce.com/mythos/protoc-alpine:3.5.1 Linux发行版 只适合自己折腾, 不应该用于应用的镜像, 应用不该开放ssh Ubuntu-ssh 最为简单的是：docker run -i -t --name ubuntu17 -p 34433:22 ubuntu /bin/bash 为这些软件预留端口 ssh tomcat mysql postgresql mysql oracle nginx reids 直接跑一个Ubuntu出来,预留出要用的端口，容器运行不会退出 进终端之后就 apt update 才能安装软件，现在才知道这个命令的重要性 现在的问题是：能不能在已经运行的容器中添加端口映射？？要是用到途中发现端口少了就麻烦了，解决方法可以是commit成镜像再跑出一个容器出来， 最好是一个服务（应用）一个容器 [ ] 日后更新, Dockerfile现在还有bug 自己写构建文件，安装相应的软件 12345678910111213FROM ubuntuMAINTAINER kuangcp myth.kuang@gmail.comENTRYPOINT echo \"Welcome login server by ssh\"ENV DEBIAN_FRONTEND noninteractiveADD id_rsa.pub /root/.ssh/authorized_keysRUN apt-get update; \\ apt-get install -y apt-utils debconf-utils iputils-ping wget curl mc htop ssh; \\ chmod 700 /root/.ssh; \\ chmod 600 /root/.ssh/authorized_keys; \\ service ssh start; \\ EXPOSE 22 docker build . -t myth:ssh docker run -d -t --name myth -p 8989:22 myth:ssh docker start myth Alpine-ssh alpine-ssh 也可以使用百度云镜像 docker pull hub.baidubce.com/mythos/alpine-ssh:1.0 Centos-ssh centos-ssh 编程语言Java Official:Java Oracle openJDK oracle-jdk8非常精简 Github:可以学习一波Dockerfile jdk-alpine-cst设置好CST时区的JDK基础镜像 参考博客: Java和Docker限制的那些事儿描述了一个天坑 Jib 参考博客: GOOGLE JIB | Github:jib Node Official Go Official 数据库PostgreSQL Docker 安装 PostgreSQL Oracle 社区文档简单粗暴 MySQL 官方文档 docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 挂载自定义配置文件 主要是配置编码 以及设定时区 docker run --name mysql-5.6 -v 配置文件目录:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=mythos1104 -e TZ=Asia/Shanghai -p 3360:3306 -d mysql:5.6 连接mysql -h 127.0.0.1 -P 3360 -uroot -pmythos1104 MongoDB Official Redis Official 获取镜像：docker pull redis 如果使用redis:alpine镜像可以更小，但是稳定就。。 运行默认配置的容器：docker run --name test-redis -d redis 使用本地配置文件启动redis容器 sudo docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name myredis redis redis-server /usr/local/etc/redis/redis.conf port-redis容器的端口映射：sudo docker run -d -p 6379:6379 --name port-redis redis 左本机右容器 持续集成 参考博客: 如何Docker化端到端验收测试 flow.ci flow.ci 可以学习compose Jenkins 详情 Protobuf 创建一个Ubuntu/alpine 容器运行起来 下载 https://github.com/google/protobuf/releases 安装 g++ make 编译安装下载的源码 进入目录 ./configure --prefix=/usr &amp;&amp; make &amp;&amp; make check &amp;&amp; make install git服务器简易git-daemon 基于git-daemon构建一个Docker镜像, 跑起来直接做git服务器 | 学习使用git-daemon命令 123456789# 创建一个挂载了本地文件夹的git仓库，并关联到nginx，目录结构和上文一致docker run --name git-repos -it -v /home/kuang/Repository/:/root/Repository/ --link mynginx:mynginx alpine# 进入容器docker exec -it git-repos ash# 安装gitapk updateapk add git git-daemon# 启动服务git daemon --export-all --base-path=\"/root/Repository\" --port=55443 GogsGitea docker 安装 gitea gitea是一个自助git服务，基于git 中文版 gitea配置文件说明 配置 配置SSH只要没有禁用掉SSH, 就能和Github一样使用SSH操作仓库, 但是,由于使用的Docker, 所以端口不是默认的22所以在本机需要配置下 例如我的就是 6002映射到了22上~/.ssh/config12345Host git.kuangcp.comHostName 111.111.111.111User gitPort 6002IdentityFile /home/kcp/.ssh/id_rsa 然后就能正常使用了 在线IDECoding平台的WebIDE图形化管理工具DockerUI Portainer","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.kuangcp.top/categories/Docker/"}],"tags":[{"name":"工具使用经验","slug":"工具使用经验","permalink":"http://blog.kuangcp.top/tags/工具使用经验/"}]},{"title":"DockerFile","slug":"Memo-Linux-Container-DockerFile","date":"2018-12-15T03:27:03.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Container-DockerFile/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Container-DockerFile/","excerpt":"","text":"目录 start Dockerfile 使用入门案例 Tips Dockerfile命令 FROM MAINTAINER RUN 修改容器时区设置 CMD ENTRYPOINT USER EXPOSE ENV LABEL ARG COPY ADD VOLUME WORKDIR STOPSIGNAL ONBUILD Practice Exercises 打包最新版git Dockerfile中新建用户 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Dockerfile使用入门案例 mkdir test &amp;&amp; cd test &amp;&amp; touch Dockerfile 输入如下文本 123456#随意写的FROM alpineMAINTAINER MythosENV DIRPATH /pathWORKDIR $DIRPATH/$DIRNAMERUN pwd docker build . 如果成功则会得到一个没有名字的镜像 none:none docker build -t image:tag . 给镜像指定名字, 注意标签不设置就是默认的latest 创建镜像成功后 docker run --name ContainerName -d image:tag 新建容器来运行镜像 Tips Reducing Your Docker Image Size Dockerfile命令 Dockerfile是一个镜像的表示，可以通过Dockerfile来描述构建镜像的步骤，且可以自动构建一个容器 所有的 Dockerfile 命令格式都是: INSTRUCTION arguments 最好在运行这个配置文件的时候新建一个空目录目录下放dockerfile，不要使用根目录，不然全部的东西都传到守护进程里去了 因为生成过程的第一件事是将整个上下文 (递归) 发送到守护进程。 同样的可以使用.dockerignore文件来忽略不要上传的文件 docker build 如果文件名是默认的Dockerfile 就使用 . 否则就是 docker build -t image:tag- &lt; 文件名 或者使用-f参数: -f 指向任意位置的文件进行配置 docker build -f /path/to/a/Dockerfile . -t如果构建成功 可以指定保存新镜像的image和tag (多个的话就多个 -t就行了，例如 docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .) FROM 基于某镜像构建,这是整个文件的第一条指令，一定是基于某镜像构建的，如果是空镜像就使用特殊的 FROM scratch允许多个FROM命令，其后的命令就是基于该FROM的镜像构建的，但是一个dockerfile只能得到一个有名字的镜像(最后一个FROM构建的镜像)，之前的FROM就是none:none FROM image FROM image:tag FROM image@digest 如果FROM使用中，找不到对应的版本的镜像，整个Dockerfile就会报错返回 在 17.05 版本开始, 支持分步构建, Multiple stage 例如基于一个编译环境镜像, 编译得到结果文件, 然后基于运行环境, 将结果文件复制过来, 构建成新的镜像 构建出来的镜像是不包含编译环境的 MAINTAINER 留开发者名字 例如 MAINTAINER kuangcp myth.kuang@gmail.com 可以放多个信息，但是建议只有开发者信息，其他的放在Labels里 RUN 每条RUN命令在当前镜像的基础上执行指定命令，并提交为新的镜像层，所以尽量将所有命令放在一个RUN里 RUN command 这种写法中的command是shell /bin/sh -C负责执行，所以就会有限制，必须要有 /bin/sh RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ... ] 一定要双引号（JSON字符串的格式来解析的） 这种写法适用任意一个二进制程序 例如bash执行 RUN [&quot;/bin/bash&quot;, &quot;-C&quot;, &quot;echo hello&quot;] 例如 ui-docker 就是基于空镜像的直接二进制文件执行的。 环境变量的问题： RUN [&quot;echo&quot;,&quot;$HOME&quot;] 是不会正常输出的，因为此时不会加载环境变量中的数据 RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$HOME&quot;] 就可以正常输出了 当RUN命令执行完毕后，就会生成一个新的文件层。这个文件层会保存在缓存中作为下一个指令的基础镜像存在，如果不需要缓存就加上 --no-cache 所以就尽量是将所有的命令 放在一个RUN命令里减少镜像层数。 修改容器时区设置 参考博客: Docker修改默认时区 123456789101112# Alpine RUN apk --no-cache add tzdata &amp;&amp; \\ ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \\ echo \"Asia/Shanghai\" &gt; /etc/timezone# UbuntuRUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \\ echo \"Asia/Shanghai\" &gt; /etc/timezone &amp;&amp; \\ dpkg-reconfigure -f noninteractive tzdata# CentosRUN echo \"Asia/shanghai\" &gt; /etc/timezone; 对于 alpine 以及 Ubuntu ln -s 建立到时间文件的软链接就已经够了, 但是确保没问题就最好还是修改下 时区文件 关于Java的时区问题 docker run ... -e JAVA_OPTS=-Duser.timezone=Asia/Shanghai java读取的是 /etc/timezone 文件 所以修改为 Asia/Shanghai 就可以了 CMD 指定 容器启动时默认执行的命令 三种格式 CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (like an exec, preferred form) 推荐 CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT) 作为默认参数提供给ENTRYPOINT CMD command param1 param2 (as a shell) 作为shell命令 依靠bin/sh -C执行 一个Dockerfile里只能有一个CMD，如果有多个，只有最后一个生效。 如果用户在docker run 中带了运行的命令，就会覆盖CMD命令 与RUN命令一样如果要环境变量就要使用 sh -C : CMD [&quot;sh&quot;, &quot;-C&quot;, &quot;echo $HOME&quot;] ENTRYPOINT 容器入口点 命令设置在容器启动时执行命令 一般用来做初始化容器，或者运行持久软件 ENTRYPOINT echo &quot;Welcome!&quot; 那么每次启动容器都有这个输出 ENTRYPOINT cmd param1 param2 ... ENTRYPOINT [&quot;cmd&quot;, &quot;param1&quot;, &quot;param2&quot;...] USER 切换用户，其后的命令都将以该用户执行 如果在这个镜像上的容器需要安装软件就会需要提权，就要至少创建额外的两个层，层限制是42, 所以，所有其他的操作在root用户执行 减少层数 更好的方法是在基础镜像中创建用户和用户组，然后在完成构建时再设置默认的用户 指定 mysql 的运行用户 ENTRYPOINT [&quot;mysql&quot;, &quot;-u&quot;, &quot;daemon&quot;] 更好的方式是：12ENTRYPOINT [&quot;memcached&quot;]USER daemon EXPOSE 对外开放端口 例如 EXPOSE 22 但是还不能被外部访问到，只能被容器内或主机的其他容器访问，加上-p 开放端口才可以 ENV 设置环境变量 ENV &lt;key&gt; &lt;value&gt; 这种方式会将第一个字符串看作key，后面所有的字符串看成value 所以只能设置一个变量 ENV name kuang cheng ping ENV &lt;key&gt;=&lt;value&gt; 可以设置多个，但是空格要转义 ENV name=myth\\ kuang 例如：设置时区 ENV TZ=Asia/Shanghai ENV命令之后的RUN命令都可以使用这里配置的环境变量 如果docker run --env &lt;key&gt;=&lt;value&gt;则会覆盖dockerfile中同名key的值 docker run -e 重设环境变量 一个ENV命令一个新层，所以也是尽量使用一个ENV命令 ENV TIME_ZONE Asiz/Shanghai LABEL 用来定义键值对， 相当于是一个内置的配置文件 LABEL key=value 两种方式 前者更好，可以使用空格LABEL version=&quot;java 1.8&quot; LABEL test=other 同样的 一个LABEL命令就会构建一个新的层，所以建议一个LABEL 旧镜像中LABEL设置的key会被新镜像中的相同的key的值进行覆盖 ARG 用来指定一些镜像中使用的参数，例如版本信息 ARG &lt;name&gt; [=&lt;default value&gt;] 使用docker build --build=-arg&lt;name&gt;=&lt;value&gt; 来传入值 COPY 当复制本地目录时，推荐使用copy 参考博客 copy &lt;src&gt; &lt;dest&gt; src是当前Dockerfile的相对路径的文件或目录,也可以是远程URL dest 是目标容器中的绝对路径。 例如: copy [&quot;./log&quot;, &quot;${APPROOT}&quot;] ADD 相当于copy命令 ADD &lt;src&gt; &lt;dest&gt; src 和 dest 和上面COPY命令使用是一样的 VOLUME VOLUME [&quot;&lt;mountpoint&gt;&quot;] VOLUME [&quot;/data&quot;] 创建挂载点 用于共享目录 WORKDIR WORKDIR /path/to/workdir 配置RUN, CMD, ENTRYPOINT 命令设置当前工作路径，如果目录不存在就新建 可以设置多次，如果是相对路径，则相对前一个 WORKDIR 命令 例如：WORKDIR /a WORKDIR b WORKDIR c RUN pwd 其实是在 /a/b/c 下执行 pwd STOPSIGNALONBUILD 注入下游镜像。如果生成的镜像是作为另一个镜像的基础镜像，则该指令定义了需要被执行的那些指令 Practice alpine构建ssh docker-wordpress-nginx rails-meets-docker 官方文档 dockerfile 官方文档 builder Exercises打包最新版git 注意其运行环境是容器内，不是宿主机，入口点的命令运行完了就退出了，不能当成宿主机上的git使用，只能说是学习一些操作 所以不可能说在容器中安装软件然后在宿主机上交互运行 1234567FROM ubuntuMAINTAINER \"your email\"RUN apt-get update \\ &amp;&amp; apt-get install -ysoftware-properties-common \\ &amp;&amp; add-apt-repository ppa:git-core/ppa \\ &amp;&amp; apt-get update &amp;&amp; apt-get install -y gitENTRYPOINT [\"git\"] 构建镜像docker build -t git:new . 将镜像容器化执行命令后自动删除容器docker run --rm git:new Dockerfile中新建用户1234RUN useradd -ms /bin/bash mythos;\\ echo \"mythos:jiushi\" | chpasswd;USER mythosWORKDIR /home/mythos 参考博客: 在 Docker 上开发应用 - 编写 Dockerfile 的最佳实践 | 英文原文","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.kuangcp.top/categories/Docker/"}],"tags":[{"name":"DockerFile","slug":"DockerFile","permalink":"http://blog.kuangcp.top/tags/DockerFile/"}]},{"title":"Docker进阶","slug":"Memo-Linux-Container-DockerAdvance","date":"2018-12-15T03:25:27.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Container-DockerAdvance/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Container-DockerAdvance/","excerpt":"","text":"目录 start Docker Advance 文件系统 AUFS OverlayFS 配置 更改数据的存放目录 提供底层接口访问 暴露守护进程端口 持有套接字文件 Tips 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Docker Advance文件系统 Docker支持 AUFS、Btrfs、Device mapper、OverlayFS、Overlay2FS、ZFS AUFS Docker旧版本 采用的是 AUFS 文件系统 参考博客: 剖析Docker文件系统：Aufs与Devicemapper参考博客: 理解Docker（7）：Docker 存储 - AUFS 参考博客: Docker: Just Stop Using AUFS OverlayFS 最新的Docker都是采用这种文件系统, 并具有 overlay overlay2 两代驱动 参考博客: docker 存储驱动之overlay 查看占用大小 docker system df 配置更改数据的存放目录 docker 默认是将数据放在了 /var/lib/docker 下, 包括所有的镜像, 容器, 卷… 挂载新的目录到 /var/lib/docker 上 参考博客: Docker数据将跟分区磁盘占满了 参考博客: Docker 常见问题 (FAQ) 12345678service docker stopcp -prf /var/lib/docker /data/rm -rf /var/lib/dockervi /etc/fstab # 追加一下内容：/data/docker /var/lib/docker none bind 0 0mount -aservice docker start 还尝试过将文件复制出去, 然后用软链接的方式, 但是失败了 报的错也没怎么看懂 修改配置文件12345678910111213141516-g, --graph=&quot;&quot; Path to use as the root of the Docker runtime. Default is /var/lib/docker.如 docker -d --graph=/opt/dockerdocker daemon 的启动参数修改方法rhel/centos 下, 默认启动参数在 /etc/sysconfig/docker, 如:6.x:other_args=&quot;--graph=/opt/docker &quot;7.x: (update: 2015-01-21)OPTIONS=&quot;--graph=/opt/docker &quot;debian/ubuntu 下, 默认启动参数在 /etc/default/docker, 如:DOCKER_OPTS=&quot;--graph=/opt/docker &quot; 提供底层接口访问暴露守护进程端口 systemctl edit docker.service123[Service]ExecStart=ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock 以上所处文件为: /etc/systemd/system/docker.service.d/override.conf 注意: -H unix:///var/run/docker.sock 如果少了这个配置, Docker客户端就失效了, 什么都干不了 systemctl restart docker 而那些不是使用systemd管理服务的才要在 /etc/docker/ 下配置 daemon.json official doc 持有套接字文件 将 /var/run/docker.sock 的访问权限 提供给使用方即可 Tips WARNING: No swap limit support Edit the /etc/default/grub file. Set the GRUB_CMDLINE_LINUX value as follows: GRUB_CMDLINE_LINUX=”cgroup_enable=memory swapaccount=1” sudo update-grub Reboot your system.","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.kuangcp.top/categories/Docker/"}],"tags":[{"name":"进阶","slug":"进阶","permalink":"http://blog.kuangcp.top/tags/进阶/"}]},{"title":"Docker","slug":"Memo-Linux-Container-Docker","date":"2018-12-15T03:24:44.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Container-Docker/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Container-Docker/","excerpt":"","text":"目录 start Docker 简介 个人理解 学习资源 安装与卸载 Linux 安装包安装 Ubuntu Debian Centos Arch 不加sudo执行docker命令 Windows 初步使用 镜像仓库 搭建本地仓库 基础命令 镜像命令 容器命令 create run exec commit port 端口映射 数据卷 数据卷容器 Dockerfile dockerignore文件的使用 使用启动脚本和多进程容器 容器编排 Docker-Compose 安装 Docker-Machine Docker-Swarm 网络 None Host Bridge User-defined 跨主机容器通信 overlay 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Docker Official Doc | docker-cnDocker中国 docker中文社区 Gitbook: docker 从入门到实践 简介 Docker 是一个开源的应用容器引擎 理解为加强版虚拟机 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 个人理解 docker中的容器是动态的，随时创建和销毁，只有镜像是持久化的 而且容器是一个虚拟出来的功能完备的Linux操作系统可以进行登录运行命令 docker images来得到所有的本地镜像名 使用docker run --name {name} -d {image-name}新命名一个容器来启动某个镜像 然后docker ps查看容器运行状况 镜像的命名： 如果要push到仓库就要遵循这个规范，本地用就无所谓了，而且以后也可以取新的名字 docker tag 原名 新名 官方的hub： 用户名/镜像名：tag 非官方的例如阿里 registry.cn-hangzhou.aliyuncs.com/myth/jdk8:alpine jdk8是镜像名，前面的是仓库地址 学习资源 PMD: player with docker啥都不说了, 直接干 码云上Docke相关资源 docker-training 开源项目 第二课 Dockerfile集锦 Oracle的Dockerfile仓库 具有中国特色的docker折腾记（上） 具有中国特色的docker折腾记（下） docker资源汇总 简述 Docker todo Use multi-stage builds 17.05+ 安装与卸载 daocloud安装帮助 | Docker 加速器 Linux Official doc 所有的发行版 docker.io 是旧版本 现在新的Docker分为 docker-ce docker-ee 安装包安装 官方文件地址 Debian系 deb包选择 进去后选择debain的版本，deepin15.4 的版本是stretch 然后pool/stable/amd64/选版本即可 例如：Deepin 15.4直接点这里 这两种方式装的是同一个版本号 双击或者sudo dpkg -i deb文件 测试安装成功 sudo docker run hello-world Ubuntu Official: Ubuntu安装最新版 sudo apt install docker-ce 关闭服务则是标准服务操作, service docker stop snap 安装snap sudo apt install snapd 查看适用于当前系统的包：snap install find 安装： snap install dockerDebian 参考 sudo echo &quot;deb http://http.debian.net/debian jessie-backports main&quot; &gt;&gt; /etc/apt/sources.list sudo apt-get install docker-ce 前置软件 sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg2 \\ lsb-release \\ software-properties-common 使用清华大学镜像源安装 使用阿里云镜像源 curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo apt-key add - sudo add-apt-repository \\ “deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/debian \\ $(lsb_release -cs) stable” 特别注意 lsb_release -cs 命令的执行结果, 本应该获取到的是发行代号 jessie stretch 等等, 但是Deepin15.8执行结果是 unstable … 所以要手动添加 或修改为 jessie deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/debian jessie stable 使用官方源 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - sudo add-apt-repository \\“deb [arch=amd64] https://download.docker.com/linux/debian \\ $(lsb_release -cs) stable” Centos sudo yum install docker Ubuntu的话,Docker没有启动, 只要一执行Docker相关命令就会自动启动, 但是Centos要手动启动 service docker start 设置开机启动: chkconfig docker on Arch pacman -S docker 不加sudo执行docker命令 官方文档 如果没有docker组，添加组 sudo groupadd docker 将当前用户加入用户组 sudo gpasswd -a $USER docker 然后重新注销登录，或者退出会话重新登录即可 Windows Windows上本质是用了VirtualBox创建虚拟机来跑Docker, 屎一般的体验, 然而Win10的WSL因为不能模拟aufs 以及 cgroup 所以能装不能用只能装上docker for windows 然后把Docker守护进程的套接字文件配置给wsl用。。。。。 参考博客 官方toolbox 下载 然后双击安装，勾选上virtualbox 记住cpu要开虚拟化 安装完成后就会有三个图标在桌面上，然后进入Docker Quickstart Terminal后 docker run hello-world 有正常输出即可 初步使用 docker 所有的数据默认存储在 /var/lib/docker 镜像仓库 默认的DockerHub因为在国外所以网络不太稳定 Docker中国 Official doc 三种使用的方式 使用指定的URL docker pull registry.docker-cn.com/myname/myrepo:mytag 仅仅配置当前守护进程, 重启就失效了docker --registry-mirror=https://registry.docker-cn.com daemon 修改 /etc/docker/daemon.json文件, 永久性更改1&#123;\"registry-mirrors\": [\"https://registry.docker-cn.com\"]&#125; 时速云 sudo docker pull index.tenxcloud.com/&lt;namespace&gt;/&lt;repository&gt;:&lt;tag&gt; 下载后可以用别名 docker tag index.tenxcloud.com/docker_library/node:lastest node:lastest 然后为了控制台干净可以直接将原来的长命名tag直接删除 阿里云 开发者平台 配置命名空间，仓库，然后使用文档的配置即可 百度云 个人较为推荐使用 | 官方文档 登录百度云镜像仓库 sudo docker login –username=[username] hub.baidubce.com username:镜像仓库名称，即是开通镜像仓库时填写的用户名。输入密码后完成登录。 上传镜像 sudo docker tag [ImageId] hub.baidubce.com/[namespace]/[ImageName]:[镜像版本号] sudo docker push hub.baidubce.com/[namespace]/[ImageName]:[镜像版本号] ImageId和镜像版本号根据镜像信息补充 namespace是开通镜像仓库时填写的命名空间 ImageName是在控制台创建的镜像名称 下载镜像 登录到镜像仓库，需输入密码 sudo docker pull hub.baidubce.com/[namespace]/[ImageName]:[镜像版本号] 使用加速器 docker软件源地址：https://mirror.baidubce.com 搭建本地仓库 Official doc 参考：Docker Registry V1 与 V2 的区别解析以及灵雀云的实时同步迁移实践 Github:v1 | Github:v2 v1 服务器上运行 并映射到本地目录 docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry 对服务器中docker已经有的镜像 设置别名 docker tag 镜像 ip:port/镜像名 docker push ip:port/镜像名 查看服务器上仓库的镜像 curl http://IP:5000/v1/search v2 启动镜像 docker run -d -p 5000:5000 --name registry registry:2 一样的设置好别名， 然后push上去 查看仓库中的镜像 curl IP:5000/v2/_catalog 注意 由于 docker client 默认是用的 HTTPS 方式通信， 但是这个本地的 registry 默认是 HTTP 的， 所以有几种解决方案 直接将本地仓库的IP和端口 设置为本地Docker的白名单 给dockerd 添加参数 DOCKER_OPTS=&quot;--insecure-registry ip:port&quot; 或者配置 /etc/docker/daemon.json { &quot;insecure-registries&quot;:[&quot;IP:PORT&quot;] } 重启Docker服务 配置 registry 为 HTTPS， 那么就需要配置SSL证书， 使用本地证书或者公网证书 基础命令 直接运行 docker, 就会有命令的使用提示 例如查看docker版本 docker version 登录镜像仓库 登录hub.docker ：docker login 或者 docker login -u username -p password 登录时速云：sudo docker login index.tenxcloud.com 登录百度云： docker login --username=[username] hub.baidubce.com 镜像命令 查看所有 ： docker images docker images -a 查看所有镜像(包括中间镜像) 搜索 ： docker search 镜像名 安装 ： docker pull 镜像名 删除 ： docker rmi 镜像名 查看详细： docker inspect [-f .Architesture] -f 查看JSON格式的具体节点的数据值 查看历史：docker history imagename 添加标签（别名）： docker tag originname newname 导出镜像文件：docker save -o ubuntu.tar ubuntu:14.04 导入镜像文件： docker load --input ubuntu.tar 或 docker load &lt; ubuntu.tar 上传镜像： docker push mythos/test:lastest 容器命令_ps_ 查看当前运行的容器：docker ps 查看所有容器 ：docker ps -a 查看占用 :docker ps -s ps formatting 12345678910111213.ID Container ID.Image Image ID.Command Quoted command.CreatedAt Time when the container was created..RunningFor Elapsed time since the container was started..Ports Exposed ports..Status Container status..Size Container disk size..Names Container names..Labels All labels assigned to the container..Label Value of a specific label for this container. For example &apos;&#123;&#123;.Label &quot;com.docker.swarm.cpu&quot;&#125;&#125;&apos;.Mounts Names of the volumes mounted in this container..Networks Names of the networks attached to this container. 查看所有容器的状态：docker stats 能看到正在运行的容器内存 cpu io net等信息 -a 所有容器 --no-stream 不阻塞标准输出流，只输出一次信息 停止容器：docker stop 容器name 重启容器：docker restart 容器name 启动容器：docker start 容器name -i 交互模式，也可以进入终端 删除容器：docker rm 容器name -f 强行停止正在运行的容器并删除 -l 删除容器的连接，但是保留容器 -v 删除容器挂载的数据卷 删除所有容器：docker rm ${docker -a -q} 删除所有容器和挂载的目录：docker system prune --volumes -f 容器日志(终端所有输入输出)：docker logs 容器name或id 重命名 ： docker rename origin new 导入导出 （容器快照）： 导出： docker export -o test.tar 容器名 docker export 容器name &gt; test.tar 导入： docker import [-c |--change=[]] [-m | --message=[]] file|URL - [repository]:[tag] -c | –change=[] 选项在导入的同时执行对容器就行修改的Dockerfile指令。 create 官方文档 run Docker run 命令的使用方法等价于 docker create 再 docker start docker run -d --name conrainer-name image-name touch a.md ，如果镜像本地没有会自动pull --name 配置容器名字 -d 后台启动程序 -i 交互模式运行容器(标准输入和标准输出) docker run -it ubuntu /bin/bash -t 容器启动后进入其命令行 -v 将本地文件夹建立映射到容器内 -v 本机:容器 -p 端口映射左本机右容器：-p 44:22主机容器端口相同就：-p 22 将容器所有EXPOSE的端口映射到宿主机随机端口-P -f 文件？ --env name=&quot;tanky&quot; 设置环境变量 --memory 限制最大内存 --cpu-shares 设置CPU的相对权重，只在link之间容器的权重比例 --cpuset-cpus 限制只能运行在某标号的CPU上 --user -u 限制用户 --cap-drop 去除能力 --link 链接其他容器 --rm 容器运行结束退出就自动删除该容器 注意和-d不能共存 --restart=always 设置该容器随dokcer 服务自启动 --hostname 容器hostname 指定容器的hostname exec 登录容器： docker exec -it 容器name或id bash docker attach 容器id 这个命令虽然简单，但是退出会话就自动关闭了容器 这些选项不加就是默认值，加上短参数形式就是设为另一个值 如 -t -i，--interactive=ture|false 打开标准输入接受用户输入命令 --privileged=true|false 是否给以最高权限 -t，--tty=true|false 是否分配伪终端 -u，--user=&quot;&quot; 执行命令的用户或ID 使用 nsenter 连接到容器: PID=${docker-pid 容器id} nsenter –target $PID –mount –uts –ipc –net –pid commit docker commit 容器id 镜像name 将容器为id的当前容器 保存为name镜像 port 查看容器的端口映射情况， 输出是左容器右本机， 和使用相反 端口映射 当不指定对应的参数容器默认不开放任何端口给外部，可以使用 -P 或 -p 参数来开放 -P 随机映射一个 49000-49900 的端口到容器开放的端口 -p IP:HostPort:ContainerPort | IP::ContainerPort | HostPort:ContainerPort 映射到指定IP的指定端口IP:HostPort:ContainerPort 映射到指定IP的任意端口IP::ContainerPort 映射到所有接口的地址的指定端口HostPort:ContainerPort 还可以使用 udp来标记为udp类型 docker run -d -p 127.0.0.1::5000/udp ubuntu apt update 查看端口 查看容器内5000对应的外端口 docker port ubuntu17 5000 查看容器的具体信息 docker inspect 容器id 数据卷 Docker 中管理数据参考博客: 给一个正在运行的Docker容器动态添加Volume 数据卷是一个可供容器使用的特殊目录，它将宿主机操作系统目录映射进容器 类似于 mount操作 数据卷可以在容器之间共享重用 数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作 对数据卷的更新不会影响镜像，解耦了应用和数据 卷会一直存在，直到没有容器使用，才可以安全的卸载 docker run -v dir:dir[:ro] 一般是创建容器时使用，和-p类似可以多个，左本机右容器 默认rw权限可以指定 ro只读 可以将一个文件挂载为数据卷，但是文件夹更好，文件可能会有问题出现 数据卷容器 docker run -it -v /test --name data ubuntu 运行一个挂载了数据卷的容器 引用数据卷容器 来挂载数据卷：docker run -it --volumes-from data --name db1 ubuntu 从已经挂载了数据卷容器的容器 来挂载数据卷：docker run -it --volumes-from db1 --name db2 ubuntu 使用 --volumes-from 参数所挂载数据卷的容器并不需要保持在运行状态 如果删除了挂载的容器，数据卷并不会自动删除，而是要在删除最后一个容器时 使用 docker rm -v 来声明删除容器并删除关联的数据卷 利用数据卷容器来迁移数据 备份： docker run --volumes-from data -v $(pwd):/backup --name worker ubuntu tar cvf /backup/backup.tar /data 先基于Ubuntu创建一个worker容器并引用了数据卷容器data，然后将当前目录作为数据卷挂载进去，并执行tar命令，打包到数据卷容器的目录下 实现了将当前目录归档到数据卷容器下 恢复： 创建一个带有数据卷的容器（目标容器）docker run -v /data --name reuse ubuntu /bin/bash 解压当前目录的tar文件到数据卷容器中 docker run --volumes-from reuse -v $(pwd):/backup busybox tar xvf /backup/backup.tar 这个就是实现了将本地的归档数据放到指定的容器内，如果要从数据卷容器中恢复到别的容器就只要挂载对应的数据卷容器然后进目录直接解压即可 Dockerfile Dockerfile文件学习 dockerignore文件的使用 .dockerignore文件是依据 Go的PathMatch规范来的，使用和.gitignore类似 使用启动脚本和多进程容器 容器编排Docker-Compose 声明式环境，管理多容器， 并处理好相关资源的关系 案例 1 安装 sudo pip install -U docker-compose Docker-Machine 创建一个docker集群环境 官方文档安装 Error with pre-create check: “VBoxManage not found. Make sure VirtualBox is installed and VBoxManage is in the pathError with pre-create check: “This computer doesn’t have VT-X/AMD-v enabled. Enabling it in the BIOS is mandatory” Docker-Swarm 网络 Official Doc 分为 none host brige user-defined 几种类型 None docker run -it –network none busybox 不联网的容器, ifconfig 可以看到只有 lo Host docker run -it –network host busybox 采用宿主机的网络, 也就是说和宿主机使用同一个网络环境, hostname都是host的 特点是性能, 但是不够灵活, 要考虑和host上的端口冲突问题 直接配置host的网络: 例如配置防火墙容器 Bridge 安装 Docker 的时候, 都会创建一个 docker0 的网桥 Linux bridge 如果没有指定 --network 或者使用 --network default 创建容器 都会默认挂载到 docker0 上 通过 docker network inspect bridge 命令可以看到子网掩码是 172.17.0.0/16 网关是 172.17.0.1 也就是说能容纳 2的16次幂 -2 个容器 (65534), 容器创建时会依次分配ip 注意: 此方式下容器之间是互通的, 通常使用的 --link containerName:aliasName 也只不过是在 /etc/hosts 文件中添加了容器的 dns 而已 验证 特别容易出现锁，一个没有启动，其他的都启动不了 尝试？ sudo service docker restart 例如: 创建一个MySQL容器供一个Ubuntu容器使用 创建MySQL容器 docker run --name mysql2 -e MYSQL_ROOT_PASSWORD=ad -d mysql 创建Ubuntu容器 docker run -d --name test --link mysql2:db ubuntu link参数说明 ：--link name:alias 在父容器中会将该映射加入host文件，所以无需找ip，直接使用别名 docker会连接两个容器，而不用通过暴露端口来实现，web容器的host文件以及环境变量都会追加上mysql2的配置 所以在Ubuntu容器中连接MySQL容器， mysql -h db -u root -pad 即可连接上mysql 如需看IP就 cat /etc/hosts 中myslq容器别名为db值的IP地址 或者直接 ping db apt install inetutils-ping ifconfig就要安装net-tools 例如：创建一个Nginx和一个Springboot搭建的web服务 构建Springboot应用镜像，构建应用容器 开放8888端口 新建nginx容器：docker run --name youhuigo -d -p 80:80 -v /home/kuang/nginx/conf/:/etc/nginx/conf.d/:ro --link you:web nginx 配置文件：一样的cat /etc/hosts 查看容器的IP， 其实最简单就是用link配置时的别名即可，因为Docker已经帮我们配置好了host。。。123456789101112131415161718upstream youhui &#123; server 172.17.0.4:8888;&#125;server &#123; listen 80; server_name youhui; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxt true; proxy_pass http://youhui; proxy_redirect off; &#125;&#125; weave 能解决跨宿主机的容器互联问题 User-defined Docker 提供三种 网络驱动 bridge overlay macvlan, 后两者可用于跨主机的容器通信 跨主机容器通信overlay 参考博客: DOCKER的内置OVERLAY网络","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.kuangcp.top/categories/Docker/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"Centos","slug":"Memo-Linux-Centos-CentosBase","date":"2018-12-15T03:24:04.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Centos-CentosBase/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Centos-CentosBase/","excerpt":"","text":"目录 start Centos 安装 docker安装 基础命令 用户管理 新增 BUG 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Centos 主流服务器 安装docker安装 hub的官方镜像 docker pull centos 得到镜像，然后跑起来即可 cat /etc/redhat-release 查看当前centos版本（适用于redhat centos） 参考博客 docker 中 centos7systemctl命令失效的解决方案： docker run --name centos2 --privileged -ti -e &quot;container=docker&quot; -v /sys/fs/cgroup:/sys/fs/cgroup centos /usr/sbin/init 基础命令 采用的是yum rpm 管理包 用户管理新增 和Ubuntu类似, 但是adduser会新建用户并且建立home目录,而且没有废话的交互, ubuntu就有 adduser kuang 新增用户和对应目录passwd kuang 修改密码 , 奇怪的是使用gpasswd就更改成功了用不了 BUG 2018-04-01 16:34:17 稳定?呵呵1234567891011121314151617181920212223已安装: nginx.x86_64 1:1.12.2-2.el7 作为依赖被安装: fontconfig.x86_64 0:2.10.95-11.el7 fontpackages-filesystem.noarch 0:1.44-8.el7 gd.x86_64 0:2.0.35-26.el7 gperftools-libs.x86_64 0:2.4-8.el7 libX11.x86_64 0:1.6.5-1.el7 libX11-common.noarch 0:1.6.5-1.el7 libXau.x86_64 0:1.0.8-2.1.el7 libXpm.x86_64 0:3.5.12-1.el7 libjpeg-turbo.x86_64 0:1.2.90-5.el7 libpng.x86_64 2:1.5.13-7.el7_2 libunwind.x86_64 2:1.2-2.el7 libxcb.x86_64 0:1.12-1.el7 libxslt.x86_64 0:1.1.28-5.el7 lyx-fonts.noarch 0:2.2.3-1.el7 nginx-all-modules.noarch 1:1.12.2-2.el7 nginx-mod-http-geoip.x86_64 1:1.12.2-2.el7 nginx-mod-http-image-filter.x86_64 1:1.12.2-2.el7 nginx-mod-http-perl.x86_64 1:1.12.2-2.el7 nginx-mod-http-xslt-filter.x86_64 1:1.12.2-2.el7 nginx-mod-mail.x86_64 1:1.12.2-2.el7 nginx-mod-stream.x86_64 1:1.12.2-2.el7 失败: nginx-filesystem.noarch 1:1.12.2-2.el7 完毕！16:28:02 ~/frp/frp_0.16.1_linux_amd64 → nginxnginx: relocation error: /lib64/libc.so.6: symbol _dl_starting_up, version GLIBC_PRIVATE not defined in file ld-linux-x86-64.so.2 with link time reference16:28:06 ~/frp/frp_0.16.1_linux_amd64 → sudo yum install nginxsudo: relocation error: /lib64/libc.so.6: symbol _dl_starting_up, version GLIBC_PRIVATE not defined in file ld-linux-x86-64.so.2 with link time reference16:28:14 ~/frp/frp_0.16.1_linux_amd64 → sudo yum install gitsudo: relocation error: /lib64/libc.so.6: symbol _dl_starting_up, version GLIBC_PRIVATE not defined in file ld-linux-x86-64.so.2 with link time reference16:28:30 ~/frp/frp_0.16.1_linux_amd64 → su rootsu: relocation error: /lib64/libc.so.6: symbol _dl_starting_up, version GLIBC_PRIVATE not defined in file ld-linux-x86-64.so.2 with link time reference","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"Centos","slug":"Centos","permalink":"http://blog.kuangcp.top/tags/Centos/"}]},{"title":"SSH使用总结","slug":"Memo-Linux-Base-Ssh","date":"2018-12-15T03:20:07.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-Ssh/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-Ssh/","excerpt":"","text":"目录 start SSH 1.安装软件 2.复制粘贴建立密钥对 2.使用脚本更简单 3.遇到的问题 4.SSH配置文件 5.多密钥对 6.访问图形化 7.ssh登录并执行一系列命令 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs SSH Linux启动或禁止SSH用户及IP的登录ssh和ssh2之间的免密码登陆详解SSH原理与运用（一）：远程登录SSH原理与运用（二）：远程操作与端口转发 ssh user@host 默认22端口登录系统 ssh -p port user@host 指定端口登录 ssh -T user@host 测试能否登录上 ssh -i 私钥绝对路径 user@host 采用指定私钥登录(一般默认是.ssh/id_rsa) 私钥一定要是 600 权限去除私钥的口令 openssl rsa -in ~/.ssh/id_rsa -out ~/.ssh/id_rsa_new 在GitForWindows里面虽然有openssl,但是这个命令却执行不了 使用密码方式免去密码登录(因为一些奇怪的需求, 又想省事) 安装sshpass 完整教程 sshpass -p ‘密码’ 后接正常的ssh命令 ssh user@host ssh登录然后执行一系列命令, sudo会执行不了 需要加 -t 参数才行 1.安装软件客户端安装软件 sudo spt-get install openssh-client 生成密钥对 ssh-keygen 可以设置密码，为了方便也可以全部采用默认 服务端安装软件 安装：sudo apt-get install openssh-server 启动：sudo /etc/init.d/ssh start 或者 service ssh start 更改配置文件修改默认端口 /etc/ssh/sshd_config 查看对否启动sshdps -e |grep ssh 关闭服务 /etc/init.d/ssh stop 2.复制粘贴建立密钥对客户端 进入.ssh文件夹下 gedit id_rsa.pub 然后复制该公钥内容 或者 cat ~/.ssh/id_rsa.pub | xclip -sel clip 将文件复制到剪贴板 或者 cat ~/.ssh/id_rsa.pub | xsel -b 也是文件复制到剪贴板 在各种平台服务上添加这个公钥即可免密登录 服务器端 进入.ssh文件夹下 sudo vim authorized_keys 粘贴客户端公钥内容 更改文件权限 sudo chmod 600 authorized_keys 确保 其 group和other位没有 w 权限 2.使用脚本更简单 两方安装好软件 客户端生成好了秘钥对之后 默认端口:ssh-copy-id &quot;username@host&quot; 输密码就可以了 指定端口 ssh-copy-id ”-p port username@host“ 或者:ssh-copy-id &quot; username@host&quot; -p port 成功后 客户端登录 ssh -p 22 username@ip root用户一般需要修改: /etc/ssh/sshd_confg 文件中PermitRootLogin no 改为yes 重新启动ssh服务。 注意: 一个端口和IP如果之前记录过相关信息,然后服务器重装了系统或者别的原因, 修改了服务器秘钥 再次连接新的系统按着提示来运行一条命令即可 例如 ssh-keygen -f &quot;/home/kcp/.ssh/known_hosts&quot; -R 120.78.154.52 3.遇到的问题 终端抛出ssh_exchange_identification: Connection closed by remote host 错误: 12echo \"PermitRootLogin without-password\" &gt;&gt; /etc/ssh/sshd_config ;\\echo \"PermitRootLogin yes\" &gt;&gt; /etc/ssh/sshd_config ;\\ 或者尝试 echo &quot;sshd: ALL&quot; &gt;&gt; /etc/hosts.allow &amp;&amp; service sshd restart 这是什么问题,这么6的么, 配置好了公钥12345678$ ssh -p 8888 git@184.170.220.117 The authenticity of host '[184.170.220.117]:8888 ([184.170.220.117]:8888)' can't be established. ECDSA key fingerprint is SHA256:Ha9k9dsMxtTaDgN4maUy1VoNzzsm+uMb84zcib6U5jU. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '[184.170.220.117]:8888' (ECDSA) to the list of known hosts. PTY allocation request failed on channel 0 Welcome to GitLab, Carlsiry Chen! Connection to 184.170.220.117 closed. emmm.出现这样的输出竟然是连接上了,,, 4.SSH配置文件vim ~/.ssh/config123456Host aliyun HostName www.ttlsa.com Port 22 User root IdentityFile ~/.ssh/id_rsa.pub IdentitiesOnly yes 参数解释123456HostName 指定登录的主机名或IP地址Port 指定登录的端口号User 登录用户名IdentityFile 登录的公/私钥文件 奇怪的是有时候用公有时候用私??IdentitiesOnly 只接受SSH key 登录PubkeyAuthentication ssh aliyun 即可登录 但是要输入生成公钥时的密码， 方便多公钥的情况 如果生成公钥时_没有_设置密码就要错三次，然后输入用户密码， 不觉得有多方便，还不如 alias进行配置 修改欢迎信息 /etc/motd 5.多密钥对 参考博客 ssh-keygen 生成SSH密钥对 然后在询问中输入新的文件名 ssh-add 私钥文件绝对路径 若执行ssh-add时出现Could not open a connection to your authentication agent 就先执行 ssh-agent bash 对应自己的解释器环境 如上 创建配置文件 config 在git项目中使用别名:正常的项目，我们clone下来之后，origin对应的URL假设为: git@git.:Rusher/helloworld 现在需要做个改动，将git, 要换成rusher_gitlab: git remote set-url origin git@rusher_gitlab:Rusher/helloworld 如果是root用户的项目: git remote set-url origin git@root_gitlab:root/helloworldconfig1234Host defaultHostName github.comUser gitIdentityFile ~/.ssh/default_id_rsa.pub 测试配置是否正确: ssh -T git@default 6.访问图形化在/etc/ssh/sshd_config添加以下信息，然后重启ssh服务12X11Forwarding yesX11DisplayOffset 10 ssh -X -p port user@host 登录即可 使用过一次,发现了严重的内存泄露,也不知道是什么原因 7.ssh登录并执行一系列命令12ssh user@host 'cmd \\ &amp;&amp; cmd \\'","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"工具使用经验","slug":"工具使用经验","permalink":"http://blog.kuangcp.top/tags/工具使用经验/"}]},{"title":"Linux发行版","slug":"Memo-Linux-Base-ReleaseExperience","date":"2018-12-15T03:19:21.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-ReleaseExperience/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-ReleaseExperience/","excerpt":"","text":"目录 start Linux各个发行版本使用体验 基础知识 安装系统 服务器系统之争 Debian系 Debian Ubuntu Ubuntu Mint Deepin 关于显卡 双系统安装 raspberry-pi arch系 manjaro redhat系 Fedora Centos openSUSE FreeBSD Solaris alpine Gentoo Mageia CDLinux 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Linux各个发行版本使用体验 论最适合开发用的几款Linux桌面系统发行版热度对比Linux的发行版本及不同版本的联系和区别。Linux十大顶级发行版本linux 的不同的发行版区别和联系 谈 Linux，Windows 和 Mac 基础知识 下载安装时要选平台 参考相关博客 64: x86-64 = x64 = amd6432: x86 = i386 查看发行版 2018年wine QQ最完美解决方案（多Linux发行版通过测试并稳定运行） 安装系统 制作U盘启动盘 Manjaro rufus: 在windows上制作, 选用dd模式 Deepin 系统内置的 启动盘制作工具, 或者官网下Windows版 或者用软碟通 Ubuntu 软碟通 系统安装 现在大多电脑都是预装win10, 所以为了方便, 双系统更好用 首先一点就是引导模式 现在大多是 UEFI, 所以为了不影响 windows, 关闭 UEFI, 使用 Legacy模式安装Linux 这样的话, 打开UEFI就进了Windows 关闭就进了Linux 对Windows没造成任何影响 在Windows上 我的电脑-&gt; 硬盘管理 -&gt; 选择一个分区,压缩出空闲空间出来 用于安装Linux(日常用最少80g 尽管系统最低占用大概10g左右) 将U盘插上, 进入系统安装的引导, 选好语言, 用户 密码什么的 分区 分为 / 和 /home 就行了, / 40g 其余给/home (个人分100g才够用) 千万注意不要选错分区 引导会自动追加到硬盘引导分区, 不会覆盖原有系统, 目前 manjaro deepin windows10 三系统双硬盘并存 安装完成, 重启前拔掉U盘 即可 参考博客: 迁移到 GRUB 2 服务器系统之争 服务器操作系统应该选择 Debian/Ubuntu 还是 CentOS？CentOS vs CoreOS – Which OS to choose for your Docker web hosting services 2018-04-01 17:17:19个人来讲, 菜鸡一个,但是习惯了Ubuntu16,也尝试过centos7, 还行之匆匆的两个服务器都装了centos, 然后俩都出问题了,都不想去百度找解决方案了,正常操作都能报错? 很棒棒正在尝试Debian8 还是debian系习惯了 Debian系Debian 很古老但是很好用的系统 官网 参考博客: Debian8最小安装 奇怪的是我在虚拟机里装了好几个好几次装不上, 装完一登录就只有壁纸 服务器 2018-04-01 17:19:50 作为服务器系统安装完Debian8.2 85M内存占用 docker 是1.6 2018-04-10 10:35:54 服务器安装Ubuntu16.04 71M内存 docker是1.13 Ubuntu 很多人的入门系统, 作为个人服务器也是首选, 软件比较新 Ubuntu Server Tutorial | 网易镜像源只有网易有server版的镜像 Ubuntu Mint 作为桌面版系统, 该有的都有了, 个人比较喜欢 Deepin 官方wiki参考博客: 一些工具 FAQ 优点: 界面美观,自带CrossOver深度家族的软件也挺好用,自定义命令的快捷键 缺点: 基本是Linux的共性了,就是驱动问题, NVIDIA 显卡 因为驱动问题重装四五次系统,重启就不知道多少次了 输入法现在这几天也在作妖 fcitxCPU占用高,输入窗口消失等问题 蓝牙模块时隐时现 遇到的bug记录 2018-01-09 19:29:25 休眠结束系统卡死,然后重启输入法没有窗口,然后升级到最新重启还是没有,杀掉搜狗进程再启动解决 2018-03-15 09:25:47 公司电脑安装Windows10 和 Deepin双系统 2018-05-24 15:08:49 Gtk-WARNING **: 无法在模块路径中找到主题引擎：“adwaita”， 安装 这个包 gnome-themes-standard 2018-06-15 19:50:40 deepin-wm 进程, 也就是Deepin的桌面管理器, 启动久了之后就会发生内存占用非常大的情况, 关闭窗口特效, 再打开就好了 2018-08-21 20:34:07 更新到15.7, 然后就是一堆的小问题, 任务栏和屏幕边缘有空隙, 多任务切换方式的变化, 原先用Wine安装的企业QQ不能启动… 但是确实Deepin 现在更快了 使用闭源驱动方案, 休眠一会就卡死了, 只能强制关机, 尝试了开源驱动后, 也是一样 显卡是 Nvidia GTX1050 2018-08-23 09:55:15 遭遇用过的最大问题, 笔记本升级到15.7后有显卡明显不兼容, 各种显示上的卡顿, 切换Prime解决方案后, 内核load不进来, 启动不了了 配置是 显卡 NVIDIA 840m 也许重装Deepin15.7, 也许装Manjaro-KDE 最终是进的恢复模式, 卸载了无用的包就成功进入了, 但是发现自动挂载分区的文件都被注释了, 如果手动添加, 即使mount -a 没有报错, 但是启动时就加载不了分区 又得进恢复模式注释掉, 才能进入系统 2018-09-02 21:44:21 Driver &#39;pcspkr&#39; is already registered, aborting, 参考博客: 社区帖子 2018-11-22 10:19:27 升级到 15.8 后 xorg 和 deepin-wm 内存泄露, 显卡是 GTX1060x 笔记本的 820m 没有这种情况出现 用上半天, 这俩内存能占用到 3个g 关于显卡 参考博客: 显卡驱动作死录 个人折腾的整理当前系统为 Deepin15.7 已经支持多种解决方案了, 还有一个 深度显卡驱动管理器 Intel默认驱动(也就是集显) NVIDIA开源驱动 性能不好, 解析闭源驱动而来 大黄蜂方案 采用闭源驱动, 省电 PRIME方案 高性能 但是和我笔记本完美兼容的是 大黄蜂方案, 也就是之前安装的 nvidia-driver, nvidia-setting, bumblebee-nvidia 这一系列包PRIME方案切换后差点把内核挂了, 一顿瞎操作把系统救活了 双系统安装 首先进入BIOS关闭 安全启动, 选择引导方式为Legacy关闭UEFI win8以上则要关闭快速启动, 制作启动U盘, 然后选择从U盘启动, 进行安装, 分区 / 和 /home / 30-40g就足够, 如果你所用的软件都习惯性解压运行的话 安装完成后一般是Deepin的默认引导取代了winsows引导, 即可正常使用, 进入windows,Deepin的引导也有该入口 如果想默认进windows, 那么修改BIOS 改回UEFI即可 固态加机械的电脑: 一样的关闭 安全启动, UEFI 在固态中划分出300M左右的空间出来, 在安装的时候设为 /Boot 然后将 / 和 /home照常放在机械上即可 在启动时, 打开引导菜单, 选择固态即可正常启动Deepin 同样的修改BIOS 回 UEFI 就默认进WIndows了 但是有时候有的电脑打开UEFI也能正常安装, 所以装系统要大胆的尝试, Deepin安装没有造成过数据损失 raspberry-pi 树莓派桌面版下载 分辨率不知道怎么调, 资源的消耗倒是低 arch系 滚动发行，包管理机制优秀 打造完美的 Linux 桌面 — Arch Linux 2007.08-2 (1) 打造完美的 Linux 桌面 — Arch Linux 2007.08-2 (2) 打造完美的 Linux 桌面 — Arch Linux 2007.08-2 (3) 打造完美的 Linux 桌面 — Arch Linux 2007.08-2 (4) manjaro 官网人生苦短我用Manjaro | 什么Linux发行版软件最多？| Manjaro: 一种不同的野兽 | 为什么要用Manjaro？ 因为基于arch, 并且简化了很多操作, 还兼容了Deepin桌面, 真是稳了, 但是日常生活中 因为滚动更新的特性, 所以在安装一个新软件的时候, 需要更新到最新版, 这样就比较烦, redhat系 大厂支持 Fedora redhat的试验场 不太感冒 Centos 在阿里云上装了一个, 开机82M Centos7.4 然后装个nginx就挂了 稳定?不管,就是要黑一波, 命令都没有提示 openSUSE FreeBSD Solaris alpine 特别小，在docker中使用有优势 Gentoo 入门难度大，适合资深玩家，据说是特能折腾的系统，处于鄙视链顶端 Mageia 官网 CDLinux 小巧的Linux发行版, 带有很多工具","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"工具使用经验","slug":"工具使用经验","permalink":"http://blog.kuangcp.top/tags/工具使用经验/"}]},{"title":"LinuxUI.md","slug":"Memo-Linux-Base-LinuxUI","date":"2018-12-15T03:18:48.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-LinuxUI/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-LinuxUI/","excerpt":"","text":"目录 start UI Font 字体渲染 Theme 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs UIFont 笔记: 字体只需将字体 复制 到 ~/.local/share/fonts/ 目录下 字体渲染 Debian8安装Infinality改善字体渲染，安装Ubuntu字体一条命令搞定Linux字体渲染 Theme 主题的安装, 美化 参考博客: 10 Great Linux GTK Themes For 2018 mac theme Github:vimixmaterial design theme GTK3主题：OSX-Arc 解压到 /usr/share/themes/ 下即可,或者 ~/.themes/","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"工具使用经验","slug":"工具使用经验","permalink":"http://blog.kuangcp.top/tags/工具使用经验/"},{"name":"美化","slug":"美化","permalink":"http://blog.kuangcp.top/tags/美化/"}]},{"title":"Linux流编辑器","slug":"Memo-Linux-Base-LinuxStreamEditor","date":"2018-12-15T03:17:35.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-LinuxStreamEditor/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-LinuxStreamEditor/","excerpt":"","text":"目录 start 流编辑器 grep tr cut paste sed awk 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 流编辑器 参考博客: 比较linux下各种流编辑器的用法 grep g (globally) search for a re (regular expression ) and p (print ) the results. tr 转换字符 替换：可以使用字符集的形式。如tr [a-z] [A-Z] 或者 tr a-z A-Z 压缩：-s 如echo “you are a man ”|tr -s ‘ ‘ ‘ ‘ 结果you are a man 删除：-d 如echo “you are a man”| tr -d ‘ ‘结果youareaman cut man cut paste 粘贴，也就是合并文件用的使用制表符来合并多个文件对应的行，也可以使用 -d 指定合并符实例：默认制表符paste p3.txt p2.txt p1.txt指定paste -d ‘*‘ p3.txt p2.txt p1.txtso，也不需要和其他的对比了，其他都是拆分，而paste是合并。 sed 组成模式: 参数 命令 文件 | sed –help 查看详细 参考：sed 查找与替换 sed 正则的精确控制 echo Tolstoy is worldly | sed &#39;s/T.*y/Camus/&#39; 这里的pattern就有问题， 会把整行替换掉 echo Tolstoy is worldly | sed &#39;s/T[a-z]*y/Camus/&#39; 只把第一个单词替换 处理管道流 echo syx is a good body | sed &#39;s/syx/zsf/&#39; 参数 -n suppress automatic printing of pattern space -e 只在控制台输出的操作的结果内容(全部)，源文件不变 -i 直接在源文件中进行修改 -f file 执行一个 sed 脚本文件中的指令 命令 p 打印 sed -n Np 文件名 a 新增 在下一行 i 插入 在上一行 将hello插入到第4行：sed -in &quot;4i hello&quot; test.md c 替换 整行 s 替换 行内字符串的替换 命令结构为: &#39;s/pattern/relacement/flags&#39; pattern 是正则的 pattern 写法 注意会匹配到首尾的空字符 echo abc | sed &#39;s/a*/l/g&#39; 就很费解 replacement 是需要替换成的内容 flags 是动作(可以为空) 整数: 一行中的第几处符合 pattern 将被替换 g : 全部替换 p : 输出修改的行内容 w filename : 替换后的文件写入到新文件 将文件中所有aaa换为bbb, sed -e &quot;s/aaa/bbb/g&quot; test.md d 删除 行级别, 删除2-4行 sed -i &quot;2,4d&quot; test.md 1234567891011121314151617b ：label 将执行的指令跳至由 : 建立的参考位置。D ：删除 pattern space 内第一个 newline 字母 前的资料。g ：拷贝资料从 hold space。G ：添加资料从 hold space 至 pattern space 。h ：拷贝资料从 pattern space 至 hold space 。H ：添加资料从 pattern space 至 hold space 。l ：印出 l 资料中的 nonprinting character 用 ASCII 码。i ：插入添加使用者输入的资料行。n ：读入下一笔资料。N ：添加下一笔资料到 pattern space。p ：印出资料。P ：印出 pattern space 内第一个 newline 字母 前的资料。q ：跳出 sed 编辑。r ：读入它档内容。w ：写资料到它档内。x ：交换 hold space 与 pattern space 内容。y ：转换（transform）字元。 截取指定行数到新文件 sed -n ‘开始行数，结束行数p’ info.log &gt; newFile.log 修改配置文件中name的值为123 sed -i &quot;s/name=.*/name=123/g&quot; config.conf CRLF -&gt; LF sed -i &#39;s/\\r//g&#39; file 配合git 就是 git ls-files| sed -i &#39;s/\\r//g&#39; 参考博客: linux sed 命令单行任务快速参考 awk awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。 截取输出 cat log.log | awk ‘{print $2}’ 只输出某列之后的列 忽略第一列:awk &#39;{$1=&quot;&quot;;print $0}&#39; 忽略1到4: awk &#39;{ for(i=1; i&lt;=4; i++){ $i=&quot;&quot; }; print $0 }&#39;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/tags/工具/"}]},{"title":"Linux遇到问题总结","slug":"Memo-Linux-Base-LinuxProblem","date":"2018-12-15T03:16:42.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-LinuxProblem/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-LinuxProblem/","excerpt":"","text":"目录 start 遇到的常见问题 命令找不到 其他 终端响铃 Ubuntu与Windows10时间相差8小时的解决 终端开启慢 Deepin的NVIDIA驱动问题 笔记本突然断电导致开机报错 输入法 fcitx Flash 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 遇到的常见问题命令找不到 sudo找不到 安装 sudo locale-gen 找不到 安装 locales 使用locale-gen --purge命令进行更新编码 Linux上的报错, 提示说找不到共享库 | 参考解决方式 其他终端响铃 参考博客: Linux中关闭响铃 临时关闭：rmmod pcspkr 临时开启：modprobe pcspkr 编辑 /etc/inputrc，找到#set bell-style none这一行，去掉前面的注释符号 xset -b 下面的方法不敢试 对于Debian/Ubuntu系统，使用root身份执行： sudo echo &quot;blacklist pcspkr&quot; &gt;&gt; /etc/modprobe.d/blacklist 对于CentOS/Redhat/RHEL/Fedora系统，使用root身份执行： echo &quot;alias pcspkr off&quot; &gt;&gt; /etc/modprobe.conf Ubuntu与Windows10时间相差8小时的解决 timedatectl set-local-rtc true 终端开启慢 检查 .bashrc 文件 看是否有可疑脚本, 这次就是因为 sdkman 的原因导致巨慢,那上次搞得我新建用户,重装系统是什么原因呢? Deepin的NVIDIA驱动问题 论坛博客 sudo apt-get install bumblebee-nvidia nvidia-driver nvidia-settings 笔记本突然断电导致开机报错 报错信息: fsck exited with status code 4 根据报错提示的分区, 进行修复, 由于我的Linux是ext3文件系统 fsck.ext3 -y /dev/sda9 分区根据实际情况 完成后重启即可 输入法fcitx fcitx单核满载:三种（搜狗拼音导致） 杀掉，fcitx -r 先把进程杀掉再fcitx-autostart &amp; fcitx再fcitx-qimpanel相关网页： 某引擎搜索结果页| 几种方式| 卸载搜狗安装拼音 知乎问题 | ubuntu论坛 | ubuntu论坛 输入法没有显示打字窗口 直接杀掉 sogou-qimpanel 然后点击图标进行启动 Flash 点击官网下载地址下载,然后解压, 将文件复制进火狐插件目录:sudo cp libflashplayer.so /usr/lib64/mozilla/plugins 添加其他用户可执行权限chmod 755 /usr/lib64/mozilla/plugins/libflashplayer.so","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"工具使用经验","slug":"工具使用经验","permalink":"http://blog.kuangcp.top/tags/工具使用经验/"}]},{"title":"Linux性能分析","slug":"Memo-Linux-Base-LinuxPerformance","date":"2018-12-15T03:16:27.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-LinuxPerformance/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-LinuxPerformance/","excerpt":"","text":"目录 start Linux 性能分析和管理 运行状况信息 工具 内存情况 性能监测 vmstat mpstat top htop iostat 进程管理 pidof sar lsof fuser ps kill killall 作业控制 trap 后台运行 nohup disown setid screen 系统管理 uname who service chkconfig dmidecode lsmod chroot 关机重启 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs Linux 性能分析和管理运行状况信息 系统实时状态信息 uptime 执行结果 系统当前时间 | 主机已运行时间 | 用户连接数 | 1,5,15,分钟的系统平均负载 cat /proc/loadavg 运行结果 : 1,5,15分钟的平均负载 | 当前运行的进程/总进程 | 最近一个启动的进程的id 常规: 单核:平均负载0.7以下是安全的,大于就需要优化了,多核则是 0.7*N(核心数) Glances Linux 系统实时监控的瑞士军刀 —— Glances 工具 vectorCPU-X | Github:repo简洁而详细 内存情况 对于Linux来说, 都是有内存就去分配, 然后就用, 只有内存不够了才会去回收, 对于服务器来说, 交换内存会带来性能的明显下降 一般是不会配置的 空闲内存, 已使用, buffers, cached 共同构成了整个内存容量 free 直接运行得到的就是内存情况,默认是kb为单位,可以指定 -b -m -g (后两种不推荐,因为向下取整的特性,出来的数据有点诡异,) -h 人类可读形式 推荐,能快速看到大略,精准的话还是用 -b 运行结果解析: 注意: 如果是新版的free, shared 那一栏总是为0, 因为shared本就是说明进程共享内存容量, free认为不能显示数有效信息, 就抛弃了这个指标,总是显示为0 buffers,cached: buffers 是为了写时,解决内存和硬盘巨大速度差存在的缓冲区(块设备IO相关的缓存页) cache 是为了读时,为了尽量减少内存从硬盘读数据的次数,缓冲区(普通文件相关的缓存页) cached 就是cache内存区域已经使用量 used 内存已使用量(不含buff/cache), free空闲内存, available 可用内存 设置交换分区:可以单独建立一个分区,也可以使用交换文件, 交换文件的设置在Linux_file中, 分区的设置就不多讲了, 主要是fdisk 性能监测vmstat 最初是设计为查看虚拟内存的,现在用于性能监测 vmstat 1 4 输出信息,间隔1s 共4次 特别注意第一行数据是指开机以来的平均值,后面的才是当前值 输出内容: procs 区域: r 进程运行队列中的进程个数 b 处于不可中断的睡眠状态的进程个数 memory 区域: swpd 虚拟内存使用量 free 空闲内存,不含buffer cache buff cache swap 区域: si 每秒从交换分区写入内存的量 so 每秒从内存写入交换分区的量 io 区域: bi 每秒从块设备读取的块数量 bo 每秒向块设备写入的块数量 system 区域: in 每秒中断数(含时钟中断) cs 每秒上下文切换次数 cpu 区域: us 用户进程 cpu消耗时间百分比 sy 内核进程 cpu消耗百分比 id cpu空闲状态时间百分比 wa IO等待消耗时间百分比 st 虚拟管理程序占用时间百分比 更多参数用法: -a 输出中,原来的 buff 和cache 被 inact 和 active 取代了 inact (inactive memory) 非活跃内存, 一段时间没有使用的内存(优先置换到交换分区的内存) active 活跃内存, 正在被使用的内存 -f 查看启动以来创建的fork(或者称为task)总数 -m 展示内存 slabinfo -s 展示内存指标以及系统事件 -d 展示各磁盘的统计信息 -p /dev/sda1 展示某一特定分区的 IO信息 p135 p136 mpstat 对多处理器的统计, 和iostat同属于systat软件下,可能需要手动安装 mpstat -P ALL 1 1 查询所有CPU信息,后两个参数是和vmstat一样的,如果只看0号CPU 就ALL改成0即可 运行结果: %user 用户进程 % %nice 进程降级时CPU % %sys 内核进程 % %iowait 等待IO的CPU时间 % %irq 处理系统中断 % %soft 软件中断 % %steal 虚机管理程序占用的 CPU % %guest 运行虚拟处理器占用的CPU % %idle CPU空闲时间 参数 -I 值可选, SUM CPU ALL 分别表示 CPU总的中断数, 展示每一个CPU的中断数 SUM和CPU数据综合展示 top 感觉 htop 就是基于这个开发的, 使用htop更简单些, 这个强大但是好多参数 htop 其中主要是看 RES 真实内存, VIRT 是虚拟内存(也就是进程和线程以为自己能拥有的内存大小) iostat 执行iostat输出信息: 第一部分, 系统信息 第二部分, CPU信息 第三部分, 磁盘信息 参数: -d 只显示磁盘信息,不显示CPU信息 -k 统计使用KB为单位 最后两个数值参数和vmstat一样 例如iostat -d -k 1 3 输出结果: tps: 每秒进程的IO读写请求总数 KB_read/s, KB_wrtn/s 每秒读取,写入的字节数单位KB KB_read, KB_wrtn 写入读取的总数 同样的, 第一行数据是系统启动到现在的统计结果 -y 可以去除第一行 -x 显示更多信息 p162 p163 p164 进程管理 按程序名字找到id ps -ef | grep &quot;$NAME&quot; | grep -v &quot;grep&quot; | awk &#39;{print $2}&#39; pidof 查询ssh服务启动的进程的pid pidof sshd 找出shell脚本执行的pid, pidof -x 脚本文件名 -s 只显示一个pid, 有的软件会有多个进程,就有多个pid 忽略指定的pid -o pid p167 sar 默认持续执行除非Ctrl C退出,指定参数后就和vmstat一样 sar 2 3 输出到指定文件中: -o filename 注意这个不是文本结构,是特殊的结构化方式, 查看需要 sar -f filename 多核的支持:sar -P ALL 1 1 与mpstat 大致相同 指定结束时间 -e 18:00:00 一般和 -o -f一起用 搭配 -o 指定存储结束的时间点 搭配 -f 指定从文件读取的数据的结束时间点 查看网络信息 -n 参数有: DEV EDEV SOCK FULL p172 p173 p174 p175 p176 lsof 这个命令使用时最好是 sudo或者root用户, 不然就会警告说显示信息不完全 lsof -d 3 查看打开标准错误输出的进程 (标准错误输出是3) lsof file/dir 查看打开某文件或目录(不关注子文件夹)的进程 通过进程查询打开的文件 sudo lsof -p pid sudo lsof -u username 查看某一用户打开的文件 输出结果说明: Command 进程名过长会简略显示, PID 进程标识符, USER 进程拥有者 FD 一般是文件描述符: 两类: 一.文件描述符,二.描述文件特征的标识 第一类: 0 表示标准输入, 1 标准输出, 2 标准错误输出, n 其他文件描述符 第二类: cwd 应用程序的当前工作目录 txt 程序代码或是数据 mem 内存映射文件 pd 父目录 rtd 根目录 DEL 文件已经被进程删除, 但是还在内存中存在 TYPE 文件类型: DIR 目录, REG 普通文件, CHR 字符类型, BLK 块设备, UNIX unix域套接字 FIFO 先进先出 队列, IPv4/Ipv6 网际协议套接字 DEVICE 磁盘的名称, SIZE 文件大小, NODE 索引节点(文件在磁盘上的标识), NAME 打开文件的确切名字 端口占用查询 lsof -i [4/6] [protocol][@hostname|hostaddr] [:service|port] 4/6 IPv4/Ipv6 protocol TCP/UDP 缺省TCP :service 服务名 可以多个 逗号分隔 :port 端口 可以多个 逗号分隔 删除文件的问题，利用lsof解决 创建一个0填充的1g文件 dd if=/dev/zero bs=1024 count=1000000 of=./1gb.file 就能看到硬盘的显著变化 df -h 然后写一个简单的程序一直占用他, 例如 python 删除rm -f 1gb.file 再ls 一下也能发现文件不见了, 但是对硬盘的占用还在 原因就是,Linux系统中,rm命令删除文件实际上只是减少文件的link数, 当link数为0时,文件才会被删掉,当进程打开某文件,该文件link就加1, 因为脚本一直占用着文件,所以删除没有看到硬盘的占用下降,只是目录中找不到该文件而已 lsof | grep 1gb.file或者 lsof 1gb.file 就能找到占用该文件的进程了,杀掉就能真正的删除文件了 可以试试两个多个Python脚本同时占用, 那么要将进程全部杀掉,才有用 fuser 和lsof功能差不多,但是这个是符合posix标准的命令 (POSIX:可移植操作系统接口) fuser -v /home/kuang/sdk 列出正在打开这个目录的进程(和lsof一样不关注子文件夹) 输出信息 详解: USER 用户, PID 进程号, COMMAND 程序名 ACCESS 访问关系: c 作为当前目录使用， e 作为可执行对象使用， r 作为根目录使用， s 作为共享库或其他装载对象 使用 m 作为映射文件或共享库使用， f 打开文件, 默认不显示， F 打开文件,用于写操作 默认不显示常用选项 -a 显示所有命令行中指定的文件，默认情况下被访问的文件才会被显示。 -c 和-m一样，用于POSIX兼容。 -k 杀掉访问文件的进程。如果没有指定-signal就会发送SIGKILL信号。 -i 杀掉进程之前询问用户，如果没有-k这个选项会被忽略。 -l 列出所有已知的信号名称。 -m name 指定一个挂载文件系统上的文件或者被挂载的块设备（名称name）。这样所有访问这个文件或者文件系统的进程都会被列出来。如果指定的是一个目录会自动转换成”name/“,并使用所有挂载在那个目录下面的文件系统。 -n space 指定一个不同的命名空间(space).这里支持不同的空间文件(文件名，此处默认)、tcp(本地tcp端口)、udp(本地udp端口)。对于端口， 可以指定端口号或者名称，如果不会引起歧义那么可以使用简单表示的形式，例如：name/space (即形如:80/tcp之类的表示)。 -s 静默模式，这时候-u,-v会被忽略。-a不能和-s一起使用。 -signal 使用指定的信号，而不是用SIGKILL来杀掉进程。可以通过名称或者号码来表示信号(例如-HUP,-1),这个选项要和-k一起使用，否则会被忽略。 -u 在每个PID后面添加进程拥有者的用户名称。 -v 详细模式。输出似ps命令的输出，包含PID,USER,COMMAND等许多域,如果是内核访问的那么PID为kernel. -V 输出版本号。 -4 使用IPV4套接字,不能和-6一起应用，只在-n的tcp和udp的命名存在时不被忽略。 -6 使用IPV6套接字,不能和-4一起应用，只在-n的tcp和udp的命名存在时不被忽略。 - 重置所有的选项，把信号设置为SIGKILL. 查询占用端口 fuser -v -n tcp 22 或者 fuser -v 22/tcp fuser中含三种协议, file默认, tcp, udp 得到一些进程信息 fuser -v -n tcp 0 还能发送信号 fuser -v -k /home/kuang/sdk 就把占用该文件夹的进程全部杀掉了(如果是ssh登录的服务器,当前目录就是这个的话, 就直接下线了) ps 参考博客: ps命令输出 输出的信息解释 直接运行 ps 就会显示当前会话中的进程 ps aux 显示系统中所有进程的状态信息 可根据需要自由组合 a 显示各终端(会话)上的所有进程, u 会展示进程所属用户, x 对于没有关联到终端运行的进程也展示出来 ps aux和ps -aux的区别: 虽然执行结果看起来是一模一样的, 但是 ps -aux 其实应该理解为 ps -a -u x 显示用户名为 x 的用户的所有进程 当 x 用户不存在时ps就将其理解为 ps aux 原因,因为他的三种格式: BSD 选项前不加短横线 - ps aux UNIX 选项前加短横线 - ps -aux GNU 选项前加双短横线 – ps --format BSD格式的 ps aux 等价于 ps -eF e 显示全部进程, 包含了未在终端运行的进程 F 显示详尽的进程信息 -o 输出指定列 ps -eo pid,user,cmd,start man ps 可以看到可以指定的列 若要取别名 pid=进程号 p200 对范围进行筛选 根据用户 ps -u root ps -U root -u root u -U 实际用户 RUID -u 有效用户 EUID u 按用户名和进程号的顺序来显示进程, 多列构成 根据命令名称查找pid ps -C sshd 这个实用!!! 排序 : ps aux --sort -pcpu/+pcpu/ 按CPU使用率,进行降序/升序排列 多个条件 --sort=+pcpu, -pmem CPU升序,内存降序排列 查询线程信息: ps -ef | grep mysql ps -L pid 显示某id的线程的具体信息 其中的LWP (轻量级进程, 可以理解为用户进程) Light Weight Process ps -T pid 显示 将-L的LWP替换为SPID (系统中的线程ID) 进程树: BSD格式 : ps axjf a 所有进程, x 显示没有控制终端的进程, j 任务格式显示进程, f ascaii字符显示树状结果 UNIX : ps -ejH e 显示所有进程, j 任务格式来显示进程, H 显示数状结构 实践 列出Java进程 ps aux | grep RSS | grep -v &quot;grep&quot; &amp;&amp; ps aux | egrep -v &quot;grep&quot; | grep -i java 统计所有java进程内存使用 ps aux|grep java | grep -v grep | awk &quot;{sum+=$6};END {print sum &quot;K &quot; sum/1024&quot;M &quot;}&quot; 按内存排序 列出所有进程 ps aux | grep -v RSS | awk &quot;{print $6 &quot;\\t&quot; $11 }&quot; | sort --human-numeric-sort -r | less kill kill -l 或者 trap -l 显示kill可以向进程发送的信号 kill是通过发送信号让进程自己决定做什么，而不是kill去做什么 | 那要是有恶意屏蔽信号的进程怎么办 信号名称 信号编号 说明 HUP 1 终端断线，关闭所有其从属的子进程 INT 2 中断 同Ctrl+C 结束前台进程,输入阻塞的程序应该退出(自己做清理)并清除阻塞状态 QUIT 3 退出 同Ctrl+\\ 也有点强制退出的意思 FPE 8 发生算术运算错误时发出 TERM 15 终止 程序自己做清理工作,然后退出 缺省的信号值 KILL 9 强制终止 退出 CONT 18 继续 fg/bg 命令 STOP 19 暂停/停止 同 Ctrl+Z 例如 reids的服务端:INT/TERM 信号就相当于在客户端的shutdown命令,是正常的退出QUIT/KILL 信号是强制退出STOP 信号就是暂停挂在后台 kill命令格式kill [选项] [进程号] 选项: -l 列出所有的信号,如果-l后加上信号名称看到对应的数字,反之亦然 -s 可以指定发出的信号,等同于 -信号 向目标进程发送指定的信号类型 缺省会发送默认的终止信号, SIGTERM 信号 15 进程号: 大于0: 向目标进程发送指定信号,多个逗号隔开 等于0: 向当前进程组的所有进程发送信号 等于-1: 向除kill进程和init进程(1)之外的所有进程发送信号 小于-1: 向进程组对应的PGID的所有进程发送信号 9号信号: 能对所有的进程起作用, 除了1号init进程 副作用:进程运行中,突然终止,可能会导致系统资源无法释放, 数据没有同步到磁盘等情况(3信号就好点) 杀掉指定id（需要sudo）kill -9 pid 0号信号: 测试信号,测试目标进程是否存在,测试是否具有向指定进程发送信号的权限 终结后台作业: 命令格式: kill -信号 %作业号 编号就是运行jobs后方括号内编号 killall 通过名字来发送信号,其他和kill是一致的 杀掉指定名字 不需要sudo killall -9 name 要十分谨慎的使用, 避免误杀进程 作业控制 在Linux中, 作业是由一个或多个进程构成的, 作业控制就是对作业的行为进行控制, 前后台的切换, 终止等操作 常用的操作: 命令后的&amp;: 让作业后台运行 作业如果是多个命令构成,会返回最后一个命令对应进程的pid和作业号 Ctrl Z: 作业转到后台并暂停 STOP状态 jobs: 列出当前作业列表 fg: 将一个作业切换到前台并运行 bg: 将一个作业切换到后台并运行 kill: 终止一个作业 前台和后台: 从标准输入读取用户输入, 标准输出展示数据, 后台就是脱离了标准输入和标准输出 fg bg 都是会发送具有继续执行的信号 前台切换到后台: Ctrl Z 切换到后台,但是会暂停的状态,可以使用jobs查看作业号 再kill -18 %作业 或者 bg %作业号 后台切回前台: fg %作业 指定作业 符号 含义 示例 %Number 根据编号来指定作业 fg %1 %String 匹配命令以String开头的作业,如果匹配到多个就会报错 kill %deng %?String 命令行中含有String字符串的作业,如果是通过管道连接的多个命令,则仅匹配第一个命令 kill %?ng %% 指代作业列表中最近一个被切换到后台的作业 kill %% %+ 和%%作用完全相同 kill %+ %- 排在%%所指代的作业前面的那个作业 kill %- 也就是说,这个匹配也是只能匹配一个作业,不能通配 trap 捕捉信号并响应， 格式：trap “commands” signal-list动态读取并更新配置文件定期清除临时文件忽略信号对程序可能的影响 trap &quot;&quot; 2: 忽略 Ctrl+C可以针对用户的退出操作，询问用户是否真的确认要退出 123#!/bin/bashtrap 'echo \"hello\"' 2tail -f ~/.bashrc 监控文件的变化，当按下快捷键Ctrl+C 就会执行trap中的命令 屏蔽信号 trap &quot;&quot; INT 屏蔽中断信号 trap INT 恢复 后台运行 运行的命令不因 用户注销，网络中断等因素而中断 让进程对hup信号免疫 nohup disown 让进程在新的会话中运行 setid screen nohup 在命令前 加上hohup 忽略所有hup信号 并将标准输出重定向到 nohup.out 若当前目录不可写，就会重定向到 $HOME/nohup.out nohup 命令&gt;result.txt 2&gt;&amp;1 2&gt;&amp;1 表示将标准错误(2)重定向到标准输出(1) 将标准输出(1)重定向到 result.txt 等同于 nohup 命令&gt;result.txt 2&gt;/dev/null 1&gt;&amp;2 &amp; 命令运行到后台， PID=$! 得到子进程ID 得到ID后 通过执行这两条命令得到原命令的返回值wait $PID echo $? 一般返回值就是原命令的返回值，但是特殊： 125 nohup命令失败，并且POSIXLY_CORRECT环境变量没有设置 126 指定命令能找到，但是不能调用 127 找不到指定命令 disown 执行中的命令，Ctrl+Z 暂停到后台去了 jobs查看作业编号 disown %作业号 就能在后台运行，且屏蔽hup信号了 setid 命令前 setid 命令 就会让进程在一个新的会话运行 screen 在一个真实的终端运行多个伪终端，认为是开启了多个新会话 命令参考 会话恢复 只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。 只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。 多窗口 在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。Screen实现了基本的文本操作，如复制粘贴等； 还提供了类似滚动条的功能，可以查看窗口状况的历史记录。窗口还可以被分区和命名，还可以监视后台窗口的活动。 会话共享 Screen可以让一个或多个用户从不同终端多次登录一个会话， 并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。 verb param comment -A 将所有的视窗都调整为目前终端机的大小。 -d &lt;作业名称&gt; 将指定的screen作业离线。 -h &lt;行数&gt; 指定视窗的缓冲区行数。 -m 即使目前已在作业中的screen作业，仍强制建立新的screen作业。 -r &lt;作业名称&gt; 恢复离线的screen作业。 -R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。 -s 指定建立新视窗时，所要执行的shell。 -S &lt;作业名称&gt; 指定screen作业的名称。 -v 显示版本信息。 -x 恢复之前离线的screen作业。 -ls或–list 显示目前所有的screen作业。 -wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业。 系统管理uname uname -a 输出所有信息 -s 内核名称 -n 主机名称 -r 内核发行版号 -v 操作系统具体版本 -m 机器硬件名称 -p 处理器名称 -i 硬件平台名称 -o 操作系统名称 who who 和 w who是按照不同tty来显示信息 查看系统的真实用户， 例如当普通用户 使用su 切换用户，这条命令就显示了真正的用户，而不是su切换后的用户 whoami 查看有效用户，就是当前会话的拥有者 groups 查看所有组 service service 服务名 status/start/stop/restart 查看所有service掌控的服务 cd /etc/init.d/ &amp;&amp; ls -F which service 结果显示这是个脚本 service 服务名 stop 等价于 /etc/init.d/服务名 stop chkconfig 掌控等级制度 LSB dmidecode 输出机器的 BIOS CPU 内存等硬件信息 （DMTF DMI） 运行 dmidecode -t就会提示你后接类别 lsmodchroot change root directory 更改root目录 最古老的容器技术 mkdir 目录 复制相关目录过来，就能把系统迁移过来了 p262 p263 p264 p265 关机重启 shutdown | reboot | halt | poweroff | init 命令 作用 shutdown 可用于关机，重启，支持定时和通知 reboot 重启系统 halt 停止系统","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"Linux网络管理","slug":"Memo-Linux-Base-LinuxNet","date":"2018-12-15T03:15:55.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-LinuxNet/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-LinuxNet/","excerpt":"","text":"目录 start 【网络管理】 Tips 查看端口占用情况 DNS 修改DNS 刷新本地缓存 IPv4和IPv6 Bridge 基础命令工具 1.ping 2.curl 3.iproute2 4.tcpdump 5.netcat 6.scp 7.rsync 8.wget 【常用网络服务】 邮件服务器postfix和devecot FTP 基础 使用 手机和电脑之间传输管理文件 手机 电脑 配置FTP服务器 Ssh telnet VPN shadowsocks 防火墙 iptables 目录 end|2018-12-13 20:53| 码云 | CSDN | OSChina | cnblogs 【网络管理】Tips查看端口占用情况 netstat lsof fuser ps 都有一定效果 linux_performance 参考博客: linux下常用命令查看端口占用 netstat工具 或者 更好用的 iproute2 lsof -i:端口号 用于查看某一端口的占用情况，缺省端口号显示全部 或者 cat /etc/services 查看系统以及使用的端口 netstat -tunlp | grep 端口号 用于查看指定的端口号的进程情况 -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -p 显示建立相关链接的程序名 查询端口占用的pid 三种： netstat -aonp |grep &quot;^[a-z]\\+[ ]\\+0[ ]\\+0[ ]\\+[0-9\\.]\\+:80[ ]\\+&quot;|awk -F&quot; &quot; {&#39;print $0&#39;} netstat -aonp |grep &quot;:80[ ]\\+&quot;|awk -F&quot; &quot; {&#39;print $0&#39;} sudo netstat -aonp |grep &quot;:6379[ ]\\+&quot;|awk -F&quot; &quot; {&#39;print $0&#39;} sudo kill -9 pid 杀掉指定pid ps aux 查看当前执行中的程序 似乎能看到更多 netstat -tpanl | grep 127.0.0.1 DNS 域名和资源转换的服务 解析域名的顺序一般是， 先在本机找，找不到去找上连DNS服务器， 然后根域DNS服务器 这时候就有了几种方式，递归， 迭代， 递归加迭代（为了减轻全球13台根的压力） 假设是访问这个域名 scs.bupt.edu.cn （bupt.三级 机构域名， edu 二级行业域名， cn 一级国家域名） 递归： 本机-&gt;上连-&gt;根-&gt;cn-&gt;edu.cn-&gt;bupt.deu.cn 然后得到解析结果后，递归返回到上连，上连DNS服务器会进行缓存该结果，再返回本机 迭代：本机-&gt;上连，上连-&gt;根，根-&gt;cn cn-&gt;edu.cn, edu.cn-&gt;bupt.deu.cn 最终返回了结果 到上连 递归加迭代， 区别在于，先迭代根， 得到下级一级服务器节点后，下级就是递归的入口和出口 授权和非授权， 还是上面那个URL， 其他的都不是授权的， 只有离URL最近的DNS才是授权的 即 bupt.deu.cn nslookup 强大的调试DNS工具 nslookup - 8.8.8.8 进入循环模式， 方便调试 8.8.8.8 是Google开放的DNS 备选 8.8.4.4 结果解释：Non-authoritative answer: 表示这是从缓存得到的结果，不一定准确 Server：上连DNS服务器的IP， Address：上连DNS的IP#端口 通常是53 canonical name 即CNAME 别名dig 比nslookup更强大 Domain Information Groper 例如：dig +tcp @8.8.8.8 www.baidu.com 采用TCP进行DNS通信（默认UDP） +short 精简输出 +nocmd+nocomment+nostat 输出最核心内容 drill whois 查询域名详细信息修改DNS sudo vim /etc/resolv.conf 添加Google的DNS 12nameserver 8.8.8.8 nameserver 8.8.8.4 刷新本地缓存 参考博客 IPv4和IPv6 IPv4 只有32bit IPv6 有128bit IPv6 零省略 ：如果有一位是 000C 可以直接写C 零压缩 ：如果FE04:0:0:0:0:0:0:DA 写成 FE::DA Bridge 网桥, 通常使用 bridge-utils 的 brctl 进行管理 Learn 增加 删除 配置开机启动 基础命令工具 参考书籍 《Linux 大棚命令百篇》 1.ping inetutils-ping ping URL ： Linux是默认无休止的 -c 次数 -q 安静模式 不输出 -s 默认64字节， 可以指定大小 -t 设定 TTL值，Linux默认是64或255 经过一个路由器就会减一 -i 每次ping的时间间隔 默认1s root用户才可以设置 0.2 以下 -f 暴力尽可能大量包的传送 至少每秒100个 注意：得到的结果中的 mdev 表示ICMP包的RTT偏离平均值的程度，mdev 越大表示网速不稳定 Linux有，mac下叫stddev win系列没有 prettyping 2.curl 不输出，重定向到黑洞设备 curl -s -o /dev/null URL 格式化返回的json数据：curl xxxx|python -m json.tool 使用基础认证 发送JSON数据 curl -i -H &quot;Content-Type:application/json&quot; -u admin:secret -X POST --data &#39;{&quot;title&quot;:&quot;1&quot;,&quot;content&quot;:&quot;1&quot;}&#39; http://tomcat.kcp/email/content 123456789101112131415 # 如果没有认证则会收到如下结果$ curl -i -u admin:secret -X POST http://tomcat.kcp/email/content HTTP/1.1 401 Server: nginx/1.13.3 Date: Thu, 26 Jul 2018 12:17:18 GMT Content-Length: 0 Connection: keep-alive Set-Cookie: JSESSIONID=D863FC575140E9B1A0A2505410617487; Path=/; HttpOnly X-Content-Type-Options: nosniff X-XSS-Protection: 1; mode=block Cache-Control: no-cache, no-store, max-age=0, must-revalidate Pragma: no-cache Expires: 0 X-Frame-Options: DENY WWW-Authenticate: Basic realm=\"Realm\" curl cookie | curl使用Cookie 参考博客: curl返回常见错误码 56错误码参考博客: 使用cURL和用户名和密码？ 3.iproute2 代替 netstat 的强大工具 替代方案 用途 net-tool iproute2 地址和链路配置 ifconfig ip addr, ip link 路由表 route ip route ARP表 arp ip neigh VLAN vconfig ip link 隧道 iptunnel ip tunnel 组播 ipmaddr ip maddr 统计 netstat ss _ss_ 参考博客: Linux网络状态工具ss命令使用详解 查看网络连接统计 ss -s 查看打开的端口 ss -l 查看打开的端口以及进程pid ss -pl 查看所有socket连接 ss -a 隧道术： 网络协议的数据包被封装在另一种网络协议的数据包之中 这是VPN的技术理论基础 别说的那么神乎其神, 用的时候, 连个Tomcat开的8080都查不到 net-tools 和 iproute 对应关系 作用 net-tools用法 iproute2用法 展示本机所有网络接口 ifconfig ip link [show] 开启/停止某个网络接口 ifconfig ech0 up/down ip link up/down eth0 给网络接口设置/删除IP ipconfig eth0 10.0.0.0.1/24 / ifconfig eth0 0 ip addr add/del 10.0.0.1/24 dev eth0 显示某个网络接口的IP ifconfig eth0 ip addr show dev eth0 显示路由表 route -n ip route show 添加删除默认网关 route add/del default gw 192.168.1.2 eth0 ip route default via 192.168.1.2 eth0 / ip route replace default via 192.168.1.2 dev eth0 添加ARP arp -s 192.168.1.100 00:0c:29:c5:5a:ed ip neigh add 192.168.1.100 lladdr 00:0c:29:c5:5a:ed dev eth0 删除ARP arp -d 192.168.1.100 ip neigh del 192.168.1.100 dev eth0 展示套接字状态 netstat -l ss -l 默认网关： 如果主机找不到准发规则， 就把数据包发给默认的网关 增加/删除一条路由规则 ip route add/del 192.168.2.0/24 via 192.168.1.254 4.tcpdump tcpdump -i eth0 -nn -X &#39;port 53&#39; -c 1 root用户才有运行权限 -i 指定监听的网络接口（网卡） -nn 将协议号或端口号，显示数字，而不是名称例如：21 而不显示 FTP -X 将协议头和包内容完整的显示出来 port 53 过滤，只显示53端口相关的包 -c 抓包的数量 -e 输出以太网帧头部信息输出 （能看到mac地址） -l 输出变为行缓冲 -t 输出不打印时间戳 -v 输出更详细信息 -F 指定过滤表达式所在的文件 -w 将流量保存到文件中 -r 读取raw packets 文件 列出可以选择的抓包对象 tcpdump -D（USB设备也能抓？） 5.netcat sudo apt install netcat 开始监听端口 ： nc -l 11044 建立连接 nc 127.0.0.1 11044 任一方退出nc 就终止了连接 端口扫描 nc -z -v -n -w 2 127.0.0.1 20-33 扫描22-33端口， -z 一旦连接立马断开，不发送接收任何数据 -v 输出详细信息 -n 直接使用IP地址，不适用域名服务器来查询其域名 -w 设置连接超时时间 s -u 使用UDP 默认缺省则是TCP 连接开放的端口 nc -v host port 传输文件 （相同的还有 ftp scp） 服务端开启端口，准备好发送的文件 nc -v -l 12345 &lt; temp_out.md 客户端接收文件：nc -v -n host port &gt; temp_in.md 单次连接，传输完毕自动断开 服务端也可以是接收文件，将&lt; &gt;互换即可 没有进度提示,大文件也不支持 传输文件夹 服务端 tar -cvPf - /root/book/ | nc -l 12345 客户端 nc -n host port | tar -xvPf - 这是未压缩的， 压缩再加上参数即可 例如 gzip -czvPf -xzvPf 6.scp scp命令用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，认证用的是ssh 所以也能使用sshpass 1234567891011121314-1：使用ssh协议版本1； -2：使用ssh协议版本2； -4：使用ipv4； -6：使用ipv6； -B：以批处理模式运行； -C：使用压缩； -F：指定ssh配置文件； -l：指定宽带限制； -o：指定使用的ssh选项； -i: 指定私钥文件-P：指定远程主机的端口号； -p：保留文件的最后修改时间，最后访问时间和权限模式； -q：不显示复制进度； -r：以递归方式复制。 远程到本地 scp root@10.10.10.10:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/ 本地到远程 scp /opt/soft/nginx-0.5.38.tar.gz root@10.10.10.10:/opt/soft/scptest 注: scp rcp wget rsync 几种传输文件的方式 7.rsync 同步命令 (个人倾向于本地和远程， 书上称为源端和目的端) 命令参数详解| 本地和VPS0之间同步数据 同步到 rsync file user@host:path 上， 是将这里的file文件覆盖远程的目录下的file文件，不像git那样 同步当前目录 将file 换成 `ls` -t 不加该参数：不会同步文件的修改时间，采用的quick check策略。使用后：让修改时间也同步，如果修改时间一致，就不同步（它不考虑文件内容，这是个坑）。 -I 就能解决上面的问题，每个文件都进行同步，代价是速度慢 -v 输出更多信息 v可以多个，v越多输出的日志信息也越多 -r 文件夹递归同步，这种是采用上面的I策略的 -l 同步软链接文件，默认是忽略该类文件的 -L 同步软链接文件及其目标文件 -z 压缩数据，提高传输速度 -p 缺省该参数时，如果远程没有该文件，权限会和本地的文件一致， 如果远程已经有该文件，权限和本地的不同， 那么命令不作更改。使用参数后，就会让权限尽力保持一致 -a 这个命令等价于 -rlptgoD 归档选项，采用递归方式，尽可能保持各方面的一致，但是不能同步硬链接，得加上 -H 只要文件不一样，就会触发同步，该命令确保远程的是和本地的一致，本地的直接覆盖远程的 只要rsync命令对本地有读权限，对远程有写权限，就能确保目录是一致的 rsync只能以登录远程的账号来创建文件，它不可能将文件的组信息，用户信息也一致，除非是root用户可以做到 【其他特别参数】 --delete 如果本地没有该文件 远程就会删掉 --delete-exclude删除远程指定的文件 --delete-after 默认是先清理远程文件再同步，使用该选项就相反了先同步再删除需要删除文件 --exclude 排除掉某些文件不同步 可以使用多次 --excule-from 如果要排除的文件很多，可以将文件名放在一个文本文件里，然后使用该选项读取该文件 --partial 断点续传 可以简写-P --progress 显示传输进度信息 8.wget 特性和优势：支持 HTTP HTTPS FTP协议 能够跟踪 HTML 和 XHTML 即可以下载整站，但是注意wget会不停的去下载HTML中的外链，无休无止 遵守 robots.txt 标准的工具 支持慢速网路和不稳定的下载，当下载失败就会不断重试，直到下载成功 支持断点续传 wget 配置文件 /etc/wgetrc ~/.wgetrc 两个文件配置（区别是全局和当前用户）wget的默认行为 例如 -X配置：wget -X js,css URL 排除两个文件夹不下载 如果要默认排除，到.wgetrc文件里配置 exclude_directories=js,css 这时候就出了一个问题，你不知道配置文件的情况时，发现总有目录下载不下来，就可以排除两个文件的作用： wget -X &#39;&#39; -X js,css URL 注意：-X，两个配置文件。这三者的配置，wget是取并集的， 使用了-X &#39;&#39; 后就只看后面的-X 参数 参数: 目录下载 -r 递归选项 后台下载 --background 即使 你Ctrl D/exit也不会中断执行 -o 指定日志输出。默认当前目录的 wget-log -O 将下载的所有文件的内容追加到指定的文件 -c 断点续传 但是有潜在bug,当源站的文件头部分或者已下载部分修改了,wget是不知道的,只会继续下载之前没下载的内容 避开robots.txt 协议 --execute robots=off 尝试使用tomcat构建一个有robots协议的网站，然后wget还是绕过了协议。。。。。。 对github测试这个参数是正常的 简化wget获取到的文件 -nH 去除wget将域名作为文件夹的情况,只得到域名下相对路径的文件 –cut-dirs=number 去除前缀路径 只用 -r : URL:a/b/c/ -r 再用上 --cut-dirs=1 : URL:/b/c/ -r 再用上 -nH :a/b/c/ -r 再用上 -nH --cut-dirs=1 : /b/c/ -r 再用上 -nH --cut-dirs=2 : /c/ 平铺,不使用源站的目录结构: -nd 若有重名文件,自动重命名 强制处处文件夹 -x 例如:github.com/a/b/ –&gt; github/com/a/b/ 协议命名的根文件夹 –protocol-directories 例如 ftp://baidu.com/a/b/ 自动重试 --tries=number 设置下载失败后重试的次数 拒绝重复下载同名文件,即使这个文件不是最新的 -nc, wget会先比较时间戳,然后下载,且多次下载同名文件会自动添加.1.2这样的后缀 自动分析是否下载同名文件, -N 会考虑时间戳以及文件大小,但是不能和 -nc 同时设置 限速 --limit-rate=N 默认单位是b,可以指定单位 k m , 这个限速的实现原理是通过在进行一次网络读取后,就线程睡眠一会儿,将速度降下来,如果下载是超小文件就可能无法达到限速的效果 限制频率 -w 即 –wait=seconds 可以指定m h d 等单位,效果是每两个请求间隔指定时间 请求重试 --waitretry 设置请求重试的秒数, 如果设置的是10秒, 第一次失败后就会等1s,然后第二次失败就等2s…直到递增到10s,然后结束 其效果 其实应该是 设置值的累加 (理解为重试次数似乎更好) wget cookie参考博客: wget命令详解 镜像整站 wget --mirror -p --convert-links -P . URL –miror: 镜像下载 -p: 下载所有为了html页面显示正常的文件 –convert-links: 下载后，转换成本地的链接 -P .： 保存所有文件和目录 到当前目录 【常用网络服务】邮件服务器postfix和devecotFTP基础使用 登录ftp host port 手机和电脑之间传输管理文件 前提是两个设备处于同一个局域网, 也就是说连同一个WIFI, 或者电脑开热点给手机连? 手机 手机安装 FeelFTP , 然后设置编码为utf-8, 开启服务器或者安装ES文件浏览器, 也带有FTP服务器, 但是不稳定, 切出去就停了, 而且不能选择上SDK卡 电脑 安装FileZila 建立连接, 然后就能方便的用鼠标进行传输了 配置FTP服务器 sudo apt-get install vsftpd -y sudo systemctl start vsftpd.service 创建用户 sudo useradd -d /home/uftp -s /bin/bash uftp 设置密码 sudo passwd uftp 删除掉 pam.d 中 vsftpd，因为该配置文件会导致使用用户名登录 ftp 失败：sudo rm /etc/pam.d/vsftpd 限制用户 uftp 只能通过 FTP 访问服务器，而不能直接登录服务器 sudo usermod -s /sbin/nologin uftp 修改配置文件 sudo chmod a+w /etc/vsftpd.conf /etc/vsftpd.conf12345678910111213# 限制用户对主目录以外目录访问chroot_local_user=YES# 指定一个 userlist 存放允许访问 ftp 的用户列表userlist_deny=NOuserlist_enable=YES# 记录允许访问 ftp 用户列表userlist_file=/etc/vsftpd.user_list# 不配置可能导致莫名的530问题seccomp_sandbox=NO# 允许文件上传write_enable=YES# 使用utf8编码utf8_filesystem=YES 新建文件 sudo touch /etc/vsftpd.user_list 修改权限 sudo chmod a+w /etc/vsftpd.user_list 添加用户名 uftp 设置用户目录只读 sudo chmod a-w /home/common 新建公共目录 设置权限 mkdir /home/common/public &amp;&amp; sudo chmod 777 -R /home/common/public 重启服务 sudo systemctl restart vsftpd.service 123456789101112~$ sudo mkdir /home/common~$ sudo touch /home/common/welcome.txt~$ sudo useradd -d /home/common -s /bin/bash common~$ sudo passwd common~$ sudo rm /etc/pam.d/vsftpd~$ sudo usermod -s /sbin/nologin common~$ sudo chmod a+w /etc/vsftpd.conf~$ sudo vim /etc/vsftpd.conf~$ sudo vim /etc/vsftpd.user_list~$ sudo chmod a-w /home/common~$ sudo mkdir /home/common/public &amp;&amp; sudo chmod 777 -R /home/common/public~$ sudo systemctl restart vsftpd.service Ssh 详细 telnet linux telnet命令参数每天一个linux命令（58）：telnet命令 VPNshadowsocks服务端 安装服务端sudo pip install shadowsocks 启动服务sudo ssserver -p 443 -k sd -m aes-256-cfb 后台运行sudo ssserver -p 443 -k sd -m aes-256-cfb --user nobodu -d start 停止 sudo ssserver -d stop 日志 sudo less /var/log/shadowsocks.log 客户端 sudo vim /etc/ss.json 12345678&#123; \"server\":\"127.0.0.1\", \"server_port\":443, \"localport\":1080, \"password\":\"password\", \"timeout\":600, \"method\":\"aes-256-cfb\"&#125; sslocal -c /etc/ss/json 设置代理是1080端口即可 防火墙iptables 参考博客: linux下IPTABLES配置详解 其主要配置文件为: /etc/sysconfig/iptables 查看配置情况 iptables -L -n 开启端口 iptables -A INPUT -p tcp --dport 8000 -j ACCEPT -A 参数表示添加规则，此外-D表示删除规则 -p 表示协议，一般都是tcp –dport 就是指定端口号 -j 指定是ACCEPT还是DROP，接收还是抛弃 有时候会发生这样的事情 服务器的服务是正常启动的, 但是客户端连不上, 然后使用curl 去访问那个端口, 报错说 curl: (7) Failed to connect to 192.168.10.201 port 16888: 没有到主机的路由 那么这时候就要检查防火墙了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"网络","slug":"网络","permalink":"http://blog.kuangcp.top/tags/网络/"}]},{"title":"Linux 命令手册","slug":"Memo-Linux-Base-LinuxManual","date":"2018-12-15T03:15:10.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-LinuxManual/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-LinuxManual/","excerpt":"","text":"目录 start Linux Command Manual 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Linux Command Manualtroff man","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"Linux文件系统","slug":"Memo-Linux-Base-LinuxFile","date":"2018-12-15T03:14:54.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-LinuxFile/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-LinuxFile/","excerpt":"","text":"目录 start 【文件管理】 Tips 设置交换分区 清空交换内存 清除缓存 善用*shrc文件 善用alias desktop文件 基本命令 查找文件 查看文件 比较两个文件 不同 diff 相同 文件管理命令 合并文件 磁盘 文件系统 安装系统时基本分区 设备列表 常用命令 dd mount fdisk df du 日志 用户日志 系统日志 应用日志 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 【文件管理】 Linux中认为万物皆文件 清空文件内容 true &gt; a.txt 安装上传下载文件的工具 sudo apt install lrzsz cat ~/.ssh/id_rsa.pub | xsel -b 将文件复制到剪贴板 Tips设置交换分区 查看内存 free -h 创建一个4g 交换文件 dd if=/dev/zero of=/swapfile bs=1024k count=4096 格式化成交换文件的格式 mkswap /swapfile 启用该文件作为交换分区的文件 swapon /swapfile /swapfile swap swap defaults 0 0 写入/etc/fstab文件中，让交换分区的设置开机自启 sudo sysctl vm.swappiness=15 临时修改重启注销失效， 查看：cat /proc/sys/vm/swappiness 永久修改：/etc/sysctl.conf 文件中设置开始使用交换分区的触发值： vm.swappiness=10 表示物理内存剩余10% 才会开始使用交换分区 建议，笔记本的硬盘低于 7200 转的不要设置太高的交换分区使用，大大影响性能，因为交换分区就是在硬盘上，频繁的交换数据 12# 完整命令: root身份运行dd if=/dev/zero of=/swapfile bs=1024k count=4096 &amp;&amp; mkswap /swapfile &amp;&amp; swapon /swapfile &amp;&amp; echo \"/swapfile swap swap defaults 0 0\" &gt;&gt; /etc/fstab 清空交换内存 1.关闭交换分区 sudo swapoff 交换分区文件 2.开启交换分区 sudo swapon 交换分区文件 或者 swapoff -a &amp;&amp; swapon -a 清除缓存 参考: 如何在 Linux 中清除缓存（Cache）？ 注意要切换到root再运行命令仅清除页面缓存（PageCache） sync; echo 1 &gt; /proc/sys/vm/drop_caches清除目录项和inode sync; echo 2 &gt; /proc/sys/vm/drop_caches清除页面缓存，目录项和inode sync; echo 3 &gt; /proc/sys/vm/drop_caches 有时候, 因为缓存的问题会引发一些很诡异的问题, 有应用缓存和系统缓存的分别 例如构建工具Maven, 也会因为在一个项目空间下, 多个同名项目的缓存问题 (巨诡异 if(true){} 都能不执行, 一个变量的值莫名其妙的时刻被修改 ) 然后操作系统的缓存问题也有出现: 例如 启动一个web项目, 运行到某一行, 突然运行不下去了, 前端阻塞在了等待请求这里 重新编译 和请求target目录都没有用, 重启IDEA也没有用 然后找到了上面的博客, 清除了下缓存就OK了 善用*shrc文件 注意加载顺序 /etc/profile -&gt; ~/.*shrc 各种sh的rc文件 bash zsh ash 善用alias123if [ -f ~/.bash_aliases ]; then . ~/.bash_aliasesfi 在~/.bashrc添加这段，然后在 .bash_aliases 文件中设置别名 例如 ： alias Kg.notes=&#39;cd ~/Documents/Notes/Code_Notes/&#39; 更改文件后，想当前终端就生效就 source ~/.bashrc 不执行命令就重启终端即可 注意_你会发现 当前用户 下 Kg.notes 是正常运行的, 但是 sudo Kg.note 就会报错说找不到命令神奇的是 配置一个别名 alias sudo=&#39;sudo &#39; 就可以解决这个问题了 stackoverflow官方说明如下_ 123456The first word of each simple command, if unquoted, is checked to see if it has an alias. If so, that word is replaced by the text of the alias. The characters ‘/’, ‘$’, ‘`’, ‘=’ and any of the shell metacharacters or quoting characters listed above may not appear in an alias name. The replacement text may contain any valid shell input, including shell metacharacters. The first word of the replacement text is tested for aliases, but a word that is identical to an alias being expanded is not expanded a second time. This means that one may alias ls to &quot;ls -F&quot;, for instance, and Bash does not try to recursively expand the replacement text. If the last character of the alias value is a space or tab character, then the next command word following the alias is also checked for alias expansion. 如我的配置文件 将配置文件分类放 K.h就能显示出每个命令的说明 其实现脚本： python3脚本 在别名文件目录时, 建立链接就可以用了 ln -spwd/.bash_aliases ~/.bash_aliases desktop文件12345678910[Desktop Entry] #每个desktop文件都以这个标签开始，说明这是一个Desktop Entry文件Version = 1.0 #标明Desktop Entry的版本（可选）Name = Firefox #程序名称（必须），这里以创建一个Firefox的快捷方式为例GenericName = Web Browser #程序通用名称（可选）Comment = A Web Browser #程序描述（可选）Exec = firefox %u #程序的启动命令（必选），可以带参数运行,当下面的Type为Application，此项有效Icon = firefox #设置快捷方式的图标 svg(更好) pngTerminal = false #是否在终端中运行（可选），当Type为Application，此项有效Type = Application #desktop的类型（必选），常见值有“Application”和“Link”Categories = GNOME;Application;Network; #注明在菜单栏中显示的类别（可选） 示例文件 如要将快捷方式放在启动菜单内 将 desktop 文件复制到 /usr/share/applications/ 目录下即可 注意：目录不能有空格 等特殊字符 基本命令 cd_ cd - 跳转到上一个目录 cd !$ 把上个命令的参数作为cd参数使用。 cd // 系统根目录 查找文件 silversearcher-ag_ 快速搜索文件内容 find find . -name &quot;*.txt&quot; 查找当前目录的txt后缀的文件 sudo find / -name a.java 全盘查找 find -type f -name README.md 默认当前目录查找 d 文件夹 f 普通文件 l 符号链接文件 b 块设备 c 字符设备 p 管道文件 s 套接字 exec 嵌入一个命令 找到所有pdf移动到指定目录 find . -name &quot;*.pdf&quot; -exec mv {} /home/test \\; 把当前目录下面的file（不包括目录)，移动到/opt/shell find . -type f -exec mv {} /opt/shell \\; find . -type f | xargs -I &#39;{}&#39; mv {} /opt/shell 解压目录下所有zip文件 find . -name &quot;*.zip&quot; -exec unzip {} \\; 实践 递归删除目录下所有run后缀的文件 find . -name &quot;*.run&quot; | xargs rm -f 递归当前文件夹下所有 log 找到 ERROR日志 find -name &quot;*.log&quot; | xargs grep ERROR 查找文件内容 find etc/ |xargs grep -i java 查看文件 stat 查看文件详细信息 stat filename tree 展示目录结构 -p 匹配 -h 可读的显示文件大小 -F 和ls一样 -L 目录深度 ls 参数 i 详情 a 全部包含隐藏文件 &lt;&gt; A 不显示当前目录和上级目录 . .. l 使用较长格式列出信息 详细信息 h 人类可阅读 F 标明文件夹,文件,可执行文件 w 100 限制输出每行的字符长度 0 则是无限制 和 l 共用就则无视该限制 R 递归显示所有子文件夹 r 逆序 B 不列出以〜结尾的隐含条目 t 按修改时间从顶至下,一般不单用,和 g|l 结合一起用 c 按ctime(创建时间)一般是文件夹,文件则是修改时间排列 和 lt|gt 一起用 即 ls -clt 同上的排列顺序 执行ls -l 命令后的输出 输出类型：d 目录 l 软链接 b 块设备 c 字符设备 s socket p 管道 - 普通文件 输出权限信息：r 读权限 w 写权限 x 执行权限 rwx有三个，是因为 拥有者，所属用户组 其他用户 代表的rwx权限 权限输出图 权限计算图 chmod 700 文件 就是只设置拥有者具有读写权限 加减权限操作 chmod go-rw 文件 g group o others u user +- 增减权限 硬链接数 一般你可以理解成子目录数（对于普通文件，总是1，对于目录来说，为对应目录的 下一级子目录的个数 +2 (+2是由于 . 和 .. 的原因）） 最后是归属用户和用户组, 大小, 最后修改日期 ls -lFh 列出所有文件的详细信息, 并且文件大小是人类可阅读的 file file a.txt 查看文件类型 -i 输出文件的MIME类型 -F “#” 修改输出分隔符 wc wc [-lmw] 参数说明： -l :多少行-m:多少字符 -w:多少字 cat mul.sh | wc -l wc -l mul.sh cat 类似的还有 nl more less 带行号输出 cat -n file 或者 nl file但是空行不会编号, 除非这样: nl -b a file nl 参考博客: 每天一个linux命令(11)：nl命令 less 该命令的导航是和Vi体系一样的, 建议打开大文件使用less或者more 如果用vim,文件全加载到内存了 诸多软件使用到了分页, 怀疑就是借助less实现的, 因为快捷键一模一样, 例如 man命令, 各个软件的-h, git的log 等等..优点很多 less命令简介 h 查看帮助文档 z/b 上下翻页 g/G 文件首/尾 F 监听文件 tail tail命令用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。 来自: http://man.linuxde.net/tail --retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。此选项需要与选项“——follow=name”连用； -c或——bytes=：输出文件尾部的N（N为整数）个字节内容； -f或；--follow：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效； -F：与选项“-follow=name”和“–retry”连用时功能相同； -n或——line=：输出文件的尾部N（N位数字）行内容。 --pid=&lt;进程号&gt;：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令； -q或——quiet或——silent：当有多个文件参数时，不输出各个文件名； -s&lt;秒数&gt;或——sleep-interal=&lt;秒数&gt;：与“-f”选项连用，指定监视文件变化时间隔的秒数； -v或——verbose：当有多个文件参数时，总是输出各个文件名； 123tail file （显示文件file的最后10行） tail +20 file （显示文件file的内容，从第20行至文件末尾） tail -c 10 file （显示文件file的最后10个字符） head 查看文件头部, 默认前十行 使用 -n 指定行数 比较两个文件不同 grep -vwf 文件1 文件2diff 参考博客 相同文件管理命令 renamerename命令的使用(基于perl) rename &quot;s/.html/.php/&quot; * //把.html 后缀的改成 .php后缀 rename &quot;s/$/.txt/&quot; * //把所有的文件名都以txt结尾 rename &quot;s/.txt//&quot; * //把所有以.txt结尾的文件名的.txt删掉 rename &quot;s/AA/aa/&quot; * //把文件名中的AA替换成aa rename &quot;s/ - 副本/_bak/&quot; * 将文件-副本结尾改成_bak结尾 chown chown [-R] 账号名称 文件或目录 chown [-R] 账号名称:用户组名称 文件或目录 chgrp 更改文件所属用户组 chgrp group file -R 递归子目录 ln ln -s 源文件或目录 目标绝对路径 生成软链接（快捷方式）1ln -s `pwd`/a.md ~/a.md cp cp cp -ri 目录或正则 目录 目录所有文件复制过去 a 该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR选项的组合。 d 拷贝时保留链接。 f 删除已经存在的目标文件而不提示。 i 和f选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答y时目标文件将被覆盖，是交互式拷贝。 p 此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。 r 若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。 l 不作拷贝，只是链接文件。 rm rm rm -rf 目录 不提示性删除 f 忽略不存在的文件，从不给出提示。 r 指示rm将参数中列出的全部目录和子目录均递归地删除。 i 进行交互式删除(y/n的询问)。 特别注意 rm -rf link 文件时, 如果只是想删除link文件 那么就不要在link文件后加上 / 例如:rm -rf linkDir/ 这个命令是将 link到的目录下的文件全部删除而不是 删除link文件本身 wc wc [-lmw] 参数说明： -l :多少行-m:多少字符 -w:多少字 cat mul.sh | wc -l wc -l mul.sh mv mv mv 目录或正则 目录 移动 I 交互方式操作。如果mv操作将导致对已存在的目标文件的覆盖，此时系统询问要求用户回答y或n，这样可以避免误覆盖文件。 f 禁止交互操作。在mv操作要覆盖某已有的目标文件时不给任何指示，指定此选项后，i选项将不再起作用。 合并文件 最简单就是 cat file1 file2 &gt; result 磁盘 附: Linux系统基本目录结构 文件系统 参考博客: Linux 文件系统剖析参考博客: 详解NTFS文件系统参考博客: 使用 FUSE 开发自己的文件系统 安装系统时基本分区 / 根目录, 操作系统安装的目录 /home 普通用户的主目录分配路径 /boot 系统引导目录 设备列表 /dev/random 产生随机数的设备 常用命令 将虚拟磁盘镜像格式化为指定的文件系统 sudo mkfs.ext4 virtual.img 查看支持的文件系统 ls -l /lib/modules/$(uname -r)/kernel/fs 重命名USB磁盘挂载分区卷标 格式化分区 格式化为ext4 mkfs -t ext4 /dev/sdc1 dd 使用 dd 命令进行硬盘 I/O 性能检测 例如创建一个空4G文件: dd if=/dev/zero of=/testfile bs=1024k count=4096 mount mount [options] [source] [directory] mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点] 查看已挂载信息 mount 挂载这个镜像到 /mnt ：mount -o loop -t ext4 virtual.img /mnt 只读方式挂载 mount -o loop --ro virtual.img /mnt 卸载挂载的磁盘 sudo umount /mnt 自动挂载分区 (root身份运行命令) blkid 查看设备详情, 找到要挂载的硬盘的 UUID 文件系统类型 vim /etc/fstab 在文件中添加, 记得要 先创建该目录 /media/kcp/Data1 UUID=42168DE83BC5EDAD /media/kcp/Data1 ntfs defaults 0 1 类似配置 mount -a 切记要先用该命令测试下该文件是否正确, 如果有错误, 系统关机后就开不了机了(可以使用U盘进系统进行修改该文件) fdisk 查看磁盘分区表信息 ：sudo fdisk -l df df -h 查看挂载文件系统信息 du du -sh 目录 查看磁盘占用总大小 h 自动搭配单位（human read ） du --max-depth 一级子目录使用情况 du -sm * | sort -n //统计当前目录大小 并安大小 排序 du -sk * | sort -n du -sk * | grep guojf //看一个人的大小 du -m | cut -d “/“ -f 2 //看第二个/ 字符前的文字 获取当前目录最大的6个目录或文件 du -hsx * | sort -rh | head -6 -hsx – （-h）更易读的格式，（-s）汇总输出，（-x）跳过其他文件系统的文件 sort – 对文本文件按行排序 -rf – （-r）将比较的结果逆序输出，（-f）忽略大小写 head – 输出文件的头几行 日志 基本都在 /var/log 下 用户日志 last 查看用户最后登录时间 系统日志 系统启动日志 /var/log/boot.log 系统消息日志 /var/log/messages journalctl -xe 应用日志 处理Apache日志的Bash脚本","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"Linux目录结构","slug":"Memo-Linux-Base-LinuxDirectoryStructure","date":"2018-12-15T03:14:08.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-LinuxDirectoryStructure/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-LinuxDirectoryStructure/","excerpt":"","text":"目录 start Linux 目录结构 /root /home /proc 网络 /etc /etc/alternatives /etc/apt 使用 查看发行版 查看系统所有用户信息 /tmp 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Linux 目录结构 Linux 系统目录结构的大致分布以及说明 /root root用户的默认用户目录 /home 非root用户的默认用户目录 /proc 进程的目录, 一个个进程看起来是一个个目录(并不是真正的目录,这是一个虚拟文件系统), 使用进程号作为目录名 网络 ARP: /proc/net/arp cat该文件, 如果发现里面有重复的mac地址, 并且有机器伪装成了网关的mac 就说明遭受了ARP攻击 或者 arp -a arping 10.91.255.254 能查看到真实的mac地址 /etc 系统以及应用的配置目录 /etc/alternativesalternative是可选项的意思.首先，因为依赖关系的存在，一个软件包在系统里面可能出现新旧版本并存的情况.在以前，要想用旧版本作为默认值就必须要手动修改配置文件，有些软件比较简单，有些却要修改很多文件，甚至一些相关软件的配置文件也要相应修改。 update-alternatives 命令就是操作的这个目录, 实现的步骤往往是在该目录建立一个软链接, 然后又从这里建立软链接到 /usr/bin 下, 实现将命令加入到 PATH 中的目的 学习 /etc/apt Debian 系 apt 包管理器的配置目录 /etc/apt/sources.list.d/ 这个目录是放别的应用需要的软件列表 使用 具体配置文件的使用 查看发行版 cat /etc/issue 通用 cat /etc/redhat-release redhat系 screenfetch 先安装 lsb_release -a 查看内核版本cat /proc/versionuname -a 查看系统所有用户信息 /etc/passwd 包含了用户,用户组,用户home目录 shell类型等信息看第三个参数:500以上的,就是后面建的用户了.其它则为系统的用户. /tmp 应用缓存目录, 在使用时存放缓存文件, 在计算机重启后就会被清理 在安装Linux时如果没有明确的分区, 就会属于 / 分区, 那么就要给 / 留有足够的大小, 不然 /tmp 分区不足会导致应用运行异常 例如 Tomcat 在运行时就需要使用, 然后Deepin的截图也会将截图缓存到该目录下 …","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"Linux平台上压缩和解压工具","slug":"Memo-Linux-Base-LinuxCompressFile","date":"2018-12-15T03:12:34.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-LinuxCompressFile/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-LinuxCompressFile/","excerpt":"","text":"目录 start Linux操作压缩文档 tar tar归档和压缩 rar zip gzip xz 7Z 总结 目录 end|2018-12-13 20:53| 码云 | CSDN | OSChina | cnblogs Linux操作压缩文档 Linux默认自带ZIP压缩，最大支持4GB压缩，RAR的压缩比大于4GB. tar1 这五个是独立的参数, 五个参数之间互斥 c : 打包 压缩 x : 解压 t : 查看内容 不解压 r : 向压缩归档文件末尾追加文件 u : 更新原压缩包中的文件 2 可选参数2.1 下面的参数是根据需要在压缩或解压档案时可选的。 z：有gzip属性的 j：有bz2属性的 Z：有compress属性的 v：显示所有过程 O：将文件解开到标准输出 2.2 其他可选参数 -p 保留绝对路径符 -v 将压缩或解压的过程输出 3 最后 -f 是必须的,-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接文件或目录 以上则组合出了 tar 的所有使用场景 示例 : tar -rf all.tar *.gif这条命令是将所有.gif的文件增加到all.tar的包里面去。 tar -uf all.tar logo.gif这条命令是更新原来tar包all.tar中logo.gif文件， tar -tf all.tar 这条命令是列出all.tar包中所有文件， tar -xf all.tar 这条命令是解出all.tar包中所有文件， 保留文件属性和跟随链接， -p 保留属性 -h 备份的源文件而不是链接本身 tar -cphf etc.tar /etc tar归档和压缩 压缩 tar -cf a.tar *.txt 仅仅归档,没有压缩 -czf tar.gz gz压缩 -cjf tar.bz2 -cZf tar.Z -cJf tar.xz 解压 tar -xf file.tar // 解压 .tar tar -xzf file.tar.gz // 解压 .tar.gz 或者 .tgz tar -xjf file.tar.bz2 // 解压 .tar.bz2 tar -xZf file.tar.Z // 解压 .tar.Z rar 压缩 rar a jpg.rar *.jpg // rar格式的压缩 解压 unrar x file.rar // 解压 rar e 不保留目录结构,平铺解压 zip 压缩 zip images.zip *.jpg //zip格式的压缩 zip -r file.zip code/* 压缩code目录下所有文件 zip -r ./a.zip ./* 压缩当前目录所有文件 -q安静模式, 终端不输出 -o 输出文件` -r 表示递归 -l 兼容Windows的换行符 -e 加密 -d filename 在zip中删除某文件 删除某目录dir/* _注意_: 所有的文件和目录都是相对于zip的根目录的完整路径 解压 unzip file.zip//解压zip -q 终端不输出 -d 指定解压目录 -l 不解压,查看所有文件 -O 指定编码 gzip gzip gunzip. 常见压缩包格式: .tar.gz .tgz 由于只能操作单个文件, 所以一般是借助于 tar 归档后再压缩 压缩 gzip 文件 解压 gzip -d 文件 或者 gunzip 文件 xz xz. 常见压缩包格式: .xz .txz .lzma .tlz 和 gzip 类似, 只能操作单个文件, 但是压缩率高于 gzip, 伴随的是压缩时间要长一些 压缩 xz 文件 解压 xz -d 文件 7Z 安装 apt install p7zip-full 或者 p7zipman 7z 查看帮助文档 7z &lt;command&gt; [&lt;switches&gt;... ] &lt;archive_name&gt; [&lt;file_names&gt;... ] [&lt;@listfiles&gt;... ] b benchmark 评测分数 个人电脑评测 压缩 a 压缩包名 文件名 解压 7z x file -o 路径 7z命令的 学习使用 总结 文件名模式 解压方式 *.tar 用 tar -xvf 解压 *.gz 用 gzip -d或者gunzip 解压 .tar.gz和.tgz 用 tar -xzf 解压 *.bz2 用 bzip2 -d或者用bunzip2 解压 *.tar.bz2 用tar -xjf 解压 *.Z 用 uncompress 解压 *.tar.Z 用tar -xZf 解压 *.rar 用 unrar e 解压 *.zip 用 unzip 解压","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/tags/工具/"}]},{"title":"Linux常用命令","slug":"Memo-Linux-Base-LinuxCommand","date":"2018-12-15T03:11:55.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-LinuxCommand/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-LinuxCommand/","excerpt":"","text":"目录 start 系统常用基础命令 输入输出 重定向 管道 xargs time date grep 定时任务 crontab Systemd 实用的工具 终端工具 图形化工具 剪贴板管理 练习打字 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs 系统常用基础命令输入输出重定向 输出重定向 &gt; a.log 2&gt;&amp;1 表示为将2也输出到标准输出 为了方便记忆也可以将&amp;理解为C中的取地址符:2重定向到1的地址 2是错误输出 1是标准输出 管道 参考博客: linux 管道 参考博客: linux shell 管道命令(pipe)使用及与shell重定向区别 学习管道的使用 xargs 常在管道中使用 能将输入流转为 命令 的参数 输出所有的md文件的内容 find . -name &quot;*.md&quot; | xargs cat | less time 可以用于统计命令运行消耗的时间 bash内置简易time time 和 /usr/bin/time \\time \\time -v ls -aldate 获取日期和时间 date +%Y_%m_%d_%H:%M:%S 获取前一天日期 date --date=&#39;1 day ago&#39; -R 将秒时间戳转换为日期 date --date=&#39;@1524738626&#39; grep egrep 相关网页 与 grep -E 等价 正则 grep -E &quot;[1-9]+&quot; 注意[] 和 ()的区别 [] 是里面单个字符 ()是里面的全部 -o 一行内多次匹配 grep -o 的 total.md | wc -l 统计所有的的数量 -i 忽略大小写 定时任务crontab 参考博客 shell定时任务crontabminute hour day-of-month month-of-year day-of-week commands cron 脚本中的操作命令 最好都使用绝对路径, 必须注意环境变量问题 1234567891011SHELL=/bin/shPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed Systemd 参考博客: Systemd 定时器教程 配置和使用上比Crontab更繁杂, 但是有更多的可控制项 实用的工具 命令行：增强版 终端工具 详细 图形化工具剪贴板管理 参考博客: 面向 Linux 的 10 款最佳剪贴板管理器 CopyQ 比较好用 参考博客: 这9个Linux命令非常危险 请大家慎用 参考博客: 关于 Linux 你可能不是非常了解的七件事 练习打字 gtypist","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.kuangcp.top/tags/工具/"}]},{"title":"Linux基础","slug":"Memo-Linux-Base-LinuxBase","date":"2018-12-15T03:11:23.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/15/Memo-Linux-Base-LinuxBase/","link":"","permalink":"http://blog.kuangcp.top/2018/12/15/Memo-Linux-Base-LinuxBase/","excerpt":"","text":"目录 start Linux系统 系统管理 文件系统对比 桌面环境对比 窗口管理器对比 文件管理器对比 终端模拟器对比 用户管理 用户组管理 时间管理 服务管理 自启服务管理 终端命令 Shell内建命令 终端快捷键 Delete Convert Jump Search Control Tips 一行执行多条命令 让命令在后台运行 关闭ssh回话不能运行 关闭ssh回话仍能运行 修改主机名 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Linux系统 只是记录了debian系的Linux, 不过也是大同小异 新手的话特别注意不要随意用sudo然后更改配置文件，容易导致系统crash（除非你明确的知道这个更改操作的作用） 运维生存时间含大量运维干货 撸Linux非理性言论? Linux命令大全 Linux命令教程 RUNOOB.COM 各种技术学习 文档资源 Linux中国开源社区 LinuxTOY 是一个致力于提供 Linux 相关资讯的专题站点。 内容Github源 系统管理 sudo 其实是软件 早该意识到的，所有的命令都是可执行文件笔记: 发行版之别 文件系统对比 参考博客: 如何选择文件系统：EXT4、Btrfs 和 XFS 目前 Linux 大多采用 ext3,往 ext4 过渡 桌面环境对比 Arch Doc: desktop environment)参考: Linux下15款桌面环境 gnome 占用资源中等，个人对该桌面不感冒 xfce 占用资源少，操作类似于xp kde 功能强大，占用资源中等 Arch Doc: KDE 知乎 KDE如何配置得漂亮大气？ dde deepin设计的桌面环境，小bug略多，但是美观操作方便 dde kde gnome X窗口系统的协议和架构Arch Doc: Xorg) 窗口管理器对比 Arch Doc: window manager) awesome window manager 平铺式的 文件管理器对比 有单窗口，双列，命令，简洁轻量，笨重完整 各种各样的选择 nautilus Gnome默认 挺好用，但是不能自动挂载分区 deepin-filemanager deepin默认，较为方便，但是打开手机会卡根本打不开 pcmanfm 左边侧栏目录树 会同步nautilus的配置5m rox-filer 特别小，单击打开，迅速定位文件，适合找东西用 thunar 解决了nautilus的缺点，内存也很省 21M dolphin 多标签页，目录树方式查看 nemo mint默认的，功能齐全，会同步nautilus的配置，同样有目录树而且是两边都有 21M tuxcmd Tux Commander 双列，小，直接的目录树，学习成本高点 2M 终端模拟器对比 详细 用户管理 添加用户 sudo adduser username 对比 useradd只是新建一个用户不会创建主目录 添加到sudo组 ，使用命令更安全：sudo gpasswd -a $USER sudo 但是要注销或者重启才生效貌似 或者：添加用户到用户组：adduser user group 或者：使用修改文件的方式：（不推荐） 但是在docker中跑Ubuntu新建用户时很有用，也可以不用动文件，添加进组是有效的，看情况吧 chmod 777 /etc/sudoers 然后直接sudo visudo就是调用vi来打开文件的简写 找不到文件说明没有安装sudo -&gt; root用户 apt install sudo 添加一行 kuang ALL=(ALL:ALL)ALL Centos:kuang ALL=(ALL) ALL chmod 440 /etc/sudoers rwx 对应一个三位的二进制数， 1/0 表示开关 查看是否设置成功 ： groups username 删除用户以及对应的home目录：sudo deluser username --remove-home 切换用户 su su -l username 当前用户的环境下登录用户（当成一个程序一样可以退出登录） 修改密码 passwd passwd user echo &quot;root:caishi&quot; | chpasswd 如果是普通用户就是 sudo chpasswd 修改相关信息 usermod verb long verb comment -d –home HOME_DIR 用户的新主目录 -e –expiredate EXPIRE_DATE 设定帐户过期的日期为 EXPIRE_DATE -f –inactive INACTIVE 过期 INACTIVE 天数后，设定密码为失效状态 -g –gid GROUP 强制使用 GROUP 为新主组 -G –groups GROUPS 新的附加组列表 GROUPS -a –append GROUP 将用户追加至上边 -G 中提到的附加组中，并不从其它组中删除此用 户 -l –login LOGIN 新的登录名称 -L –lock 锁定用户帐号 -m –move-home 将家目录内容移至新位置 (仅于 -d 一起使用) -p –password PASSWORD 将加密过的密码 (PASSWORD) 设为新密码 -R –root CHROOT_DIR chroot 到的目录 -s –shell SHELL 该用户帐号的新登录 shell -U –unlock 解锁用户帐号 所有参数说明 passwd 选项 用户名 更改口令(密码) -l 锁定口令，禁用账号 -u 口令解锁 -d 账号无口令 -f 强迫用户下次登录时修改口令 当前用户 passwd 就是修改当前用户口令 超级用户就可以命令后接用户名，修改任意用户 pwcov 注：同步用户从/etc/passwd 到/etc/shadow pwck 注：pwck是校验用户配置文件/etc/passwd 和/etc/shadow 文件内容是否合法或完整; pwunconv 注：是pwcov 的立逆向操作，是从/etc/shadow和 /etc/passwd 创建/etc/passwd ，然后会删除 /etc/shadow 文件; finger 注：查看用户信息工具 id 注：查看用户的UID、GID及所归属的用户组 chfn 注：更改用户信息工具 visudo 注：visodo 是编辑 /etc/sudoers 的命令;也可以不用这个命令，直接用vi 来编辑 /etc/sudoers 的效果是一样的; 用户组管理 相关总结网页 修改用户至指定组 sudo usermod -G 用户组 用户 显示用户所在组 groups 缺省是当前用户, 若指定即输出指定用户的用户组 添加用户组 groupadd 缺省参数 就是新建用户组 -g GID 指定新用户组的组标识号GID -o 一般和g共用 表示新用户组的GID可以与系统已有用户组的GID相同。 删除用户组 groupdel groupmod 选项 用户组 -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n 新用户组 将用户组的名字改为新名字 grpck 检查/etc/group文件是否正确 grpconv 注：通过/etc/group和/etc/gshadow 的文件内容来同步或创建/etc/gshadow ，如果/etc/gshadow 不存在则创建; 注：通过/etc/group 和/etc/gshadow 文件内容来同步或创建/etc/group ，然后删除gshadow文件 时间管理 同步Linux服务器时间 Linux 的时间由两部分组成, 时区和时间: /etc/timezone 和 /etc/localtime 同步时间 修改时区 cp -y /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 同步时间 /usr/sbin/ntpdate -u cn.pool.ntp.org | 没有就先安装 ntpdate 查看硬件时间 hwclock -r 如果不同步就需要写入时间 hwclock -w 因为系统重启是参考硬件时间的 自动同步时间 配置开机自动校验 vim /etc/rc.d/rc.local /usr/sbin/ntpdate -u cn.pool.ntp.org&gt; /dev/null 2&gt;&amp;1; /sbin/hwclock -w 配置定时任务 crontab -e 00 10 * * * root /usr/sbin/ntpdate -u cn.pool.ntp.org &gt; /dev/null 2&gt;&amp;1; /sbin/hwclock -w 服务管理 采用 systemd 方式进行管理 Arch Doc: systemd) systemctl start/stop/restart/reload/edit … 详情见 man systemctl 修改服务的配置 systemctl edit docker.service 当发现文件不存在时,这个是创建文件 对应的文件是 /etc/systemd/system/docker.service.d/ 自启服务管理 /etc/init.d/ 是服务的存放目录 列出所有服务的状态 service --status-all 移除MySQL的自启 sudo update-rc.d -f mysql remove 设置MySQL随机启动 sudo update-rc.d mysql defaults 设定MySQL启动顺序 update-rc.d mysql defaults 90 数字越小, 启动顺序越前 sysv-rc-conf 略微图形化的管理服务的开机自启 chkconfig 简单的输出服务自启状态 系统运行级别12340 系统停机状态1 单用户或系统维护状态2~5 多用户状态6 重新启动 终端命令 /bin/* 系统自带的命令例如 which命令, 查找到命令的位置 /usr/bin/* 用户安装终端应用的目录 以下往往是系统自带的 wc -l file 统计文件行数 md5sum 报文摘要算法 Shell内建命令 更多常用工具列表 终端快捷键 鼠标中键 粘贴鼠标左键已选择的文本 VSCode中也适用 !num history 中第 num 条命令 !! 上一条命令 ls !$ 执行命令ls，并以上一条命令的参数为其参数 !?string? 执行含有string字符串的最新命令 Ctrl L 清屏等价于clear，清除所有这个 shell 提示屏幕中显示的数据。 Mysql也适用 reset 刷新 shell 提示屏幕。如果字符不清晰或乱码的话，在 shell 提示下键入这个命令会刷新屏幕。 Ctrl ； 显示最近五条剪贴板内容 Ctrl Alt Backspace : 杀死你当前的 X 会话。杀死图形化桌面会话，把你返回到登录屏幕。如果正常退出步骤不起作用，你可以使用这种方法。 Ctrl Alt Delete : 关机和重新引导 Red Hat Linux。关闭你当前的会话然后重新引导 OS。只有在正常关机步骤不起作用时才使用这种方法。 Ctrl Alt Fn: 切换屏幕。 根据默认设置，从 [F1] 到 [F6] 是 shell 提示屏幕， [F7] 是图形化屏幕。但是deepin是F1为图形化 Delete Controller Key comment Ctrl D 删除光标后字符,等价于Delete键（命令行若无任何字符，则相当于exit；处理 多行标准输入时也表示EOF） Ctrl H 退格删除一个字符，相当于通常的Backspace键 Ctrl U 删除光标之前到 行首 的字符 (Zsh中是删除整行) Esc W 删除光标之前到 行首 的字符 Ctrl K 删除光标之前到 行尾 的字符 Ctrl W 删除光标之前的一个单词 Alt D 删除光标之后的一个单词 Ctrl Y 粘贴上次删除的所有字符 Ctrl _ 撤销修改 等价于 Ctrl x u Convert Controller Key comment Ctrl T 互换当前字符,光标后移 Alt T 互换当前单词与前一个单词,光标后移 等价于 Esc T Alt D 将当前单词全部转为大写,光标后移 Alt C 将当前单词首字母转为大写,光标后移 Alt L 将当前单词全部转为小写,光标后移(zsh无效) Jump Controller Key comment Ctrl C 取消运行当前行输入的命令，相当于Ctrl + Break Ctrl A 光标移动到行首（Ahead of line），相当于通常的Home键 Ctrl E 光标移动到行尾（End of line） Ctrl F 光标向前(Forward)移动一个字符位置 Ctrl B 光标往回(Backward)移动一个字符位置 Alt F 光标向前(Forward)移动一个单词位置 Alt B 光标往回(Backward)移动一个单词位置 Esc F 光标向前(Forward)移动到当前单词的头部 Esc B 光标往回(Backward)移动到当前单词的尾部 Search Controller Key comment Ctrl P 调出命令历史中的前一条（Previous）命令，相当于通常的上箭头 Ctrl N 调出命令历史中的下一条（Next）命令，相当于通常的下箭头 Ctrl O 运行上翻下翻出来的命令, 并且自动将下一条命令填入 Ctrl R 向上搜索相关命令（reverse-i-search）继续按 Ctrl R 则继续搜索上一条 Ctrl S 与 Ctrl R 类似, 但是是向下搜索 Control Controller Key comment Ctrl Z 暂停程序 Ctrl S 停止回显当前Shell Ctrl Q 恢复回显当前Shell Tips man help 后接使用的命令，就可以得到用户手册和帮助文档 一行执行多条命令 &amp;&amp; 第2条命令只有在第1条命令成功执行之后才执行 根据命令产生的退出码判断是否执行成功（0成功，非0失败） || 执行不成功（产生了一个非0的退出码）时，才执行后面的命令 ; 顺序执行多条命令，当;号前的命令执行完（不管是否执行成功），才执行;后的命令。 &amp; 并行执行命令，没有顺序 tty 虚拟终端等概念 Centos上which并不是命令, 而是别名! which=&#39;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#39; 让命令在后台运行 原博客 命令后接 &amp; （只是让进程躲到当前终端的后台去了 hup信号仍然影响） nohup， disown, screen, setid 运行的命令不因 用户注销，网络中断等因素而中断 让进程对hup信号免疫 nohup disown 让进程在新的会话中运行 setid screen 关闭ssh回话不能运行 1.没有使用任何修饰原有命令2.只在原有命令后加&amp; 关闭ssh回话仍能运行 使用nohup就能屏蔽hup信号，默认输出到 nohup.out nohup 命令 &amp; 将所有输出重定向到空设备 nohup 命令&gt;/dev/null 2&gt;&amp;1 例如 在当前目录后台打开文件管理器 (dde-file-manager . &amp;) &gt;/dev/null 2&gt;&amp;1 (命令 &amp;) 屏蔽了hup信号 修改主机名 sudo hostname linux 重启终端即可看到修改 但是重启电脑会恢复原有名字修改如下文件永久： sudo gedit /etc/hostname 也许需要更改/etc/hosts 立即生效,也要重新登录 hostname -F /etc/hostname","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.kuangcp.top/categories/Linux/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"GoRestful","slug":"Memo-Go-GoRestful","date":"2018-12-14T01:26:23.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/14/Memo-Go-GoRestful/","link":"","permalink":"http://blog.kuangcp.top/2018/12/14/Memo-Go-GoRestful/","excerpt":"","text":"目录 start Go-Restful 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Go-Restful Go 的 Restful web框架 参考博客: Building a REST Service with Golang - Part 2 (Basic Webserver) 参考博客: Making a RESTful JSON API in Go Github:go-restful","categories":[{"name":"Go","slug":"Go","permalink":"http://blog.kuangcp.top/categories/Go/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://blog.kuangcp.top/tags/Web/"},{"name":"Restful","slug":"Restful","permalink":"http://blog.kuangcp.top/tags/Restful/"}]},{"title":"Go基础","slug":"Memo-Go-GoBase","date":"2018-12-14T01:25:49.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/14/Memo-Go-GoBase/","link":"","permalink":"http://blog.kuangcp.top/2018/12/14/Memo-Go-GoBase/","excerpt":"","text":"目录 start Go 社区 教程 书籍 安装 Docker 环境变量解释 基本开发环境搭建 数据类型 基本类型 int int64 Array Slice Map Set 基本语法 标准输入输出 函数 参数 返回值 接口 文件操作 Test JSON Tips 通过字符串调用指定函数 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs Go 官网 | 镜像官网 | Github Repo | Go Doc Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 Go语言资料收集 学习Go的知乎话题 Go相关书籍的知乎话题 Go1.0的吐槽 Java 20年：转角遇到Go 参考博客: Golang官网被墙解决办法参考博客: why is go popular in china参考博客: 我为什么放弃Go语言参考博客: 使用Go语言工作400天后的感受 docker golang lantern kubernetes awesome-go gogs synching hugo grafana etcd hub influxdb caddy beego martini cayley nsq codis delve cobra shadowsocks-go phcolus 社区 GoCN Forum Go语言中文网 教程 Go Programming &amp; Concurrency in Practice golang教程 书籍 Go语言高级编程(Advanced Go Programming)Go 语言学习资料与社区索引 安装 下载|官方教程 | 参考 教程 | _ sudo tar -C /usr/local -xzf go1.10.3.linux-amd64.tar.gz *shrc或者 /etc/profile 中添加1234export GOROOT=/usr/local/goexport GOPATH=$HOME/Code/go # workspaceexport GOBIN=$GOPATH/bin # 'go install' command install direxport PATH=$PATH:$GOBIN:$GOPATH:$GOROOT/bin 查看版本 go version正常输出go的版本则是配置成功 在 /home/kcp/code/go 下 新建 test.go12345package mainimport \"fmt\"func main() &#123; fmt.Printf(\"hello, world\\n\")&#125; go run test.go 或者 go build Docker 使用Docker安装和部署 Docker image 这里的镜像都是用于 从源码编译构建成可执行文件的 环境go 的 Docker镜像的讨论 实际运行的时候, 如果不需要调用外部Linux命令 就直接 from scratch 需要则 from alpine 更精简一点 更好是使用 frolvlad/alpine-glibc 环境变量解释 关于GOROOT、GOPATH、GOBIN、project目录GOPATH 深度解析 Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之间就已经设置好他们。如果你使用的是 Windows 的话，你完全不用进行手动设置，Go 将被默认安装在目录 c:/go 下。这里列举几个最为重要的环境变量： $GOROOT 表示 Go 在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。 $GOARCH 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。 $GOOS 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。 $GOBIN 表示编译器和链接器的安装位置，默认是 $GOROOT/bin，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。 为了区分本地机器和目标机器，你可以使用 $GOHOSTOS 和 $GOHOSTARCH 设置目标机器的参数，这两个变量只有在进行交叉编译的时候才会用到， 如果你不进行显示设置，他们的值会和本地机器（$GOOS 和 $GOARCH）一样。 $GOPATH 默认采用和 $GOROOT 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径， 而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。 $GOARM 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。 $GOMAXPROCS 用于设置应用程序可使用的处理器个数与核数，详见第 14.1.3 节。 基本开发环境搭建 Github:Golang 入门时使用 VSCode 是比较方便的, VSCode 会推荐我们安装如下工具 tools 工具集 guru golang.org/x/tools/cmd/guru gorename golang.org/x/tools/cmd/gorename lint golang.org/x/lint golint golang.org/x/lint/golint go-outline github.com/ramya-rao-a/go-outline go-symbols github.com/acroca/go-symbols goreturns github.com/sqs/goreturns dep github.com/golang/dep 由于 golang.org 用的是Google的服务器, 所以…, 这几个工具不能直接安装 guru gorename imports(goreturns要用到) lint golint但是本质上都是获取源码而已, 所以可以从github获取 汇总一下命令123456789101112131415161718cd $GOPATHmkdir -p src/golang.org/x/toolsgit clone --deepth 1 https://github.com/golang/tools src/golang.org/x/toolsmkdir -p src/golang.org/x/lintgit clone --deepth 1 https://github.com/golang/lint src/golang.org/x/lintmkdir -p src/github.com/golang/depgit clone --deepth 1 https://github.com/golang/dep src/github.com/golang/depgo get golang.org/x/tools/cmd/guru go get golang.org/x/tools/cmd/gorename go get golang.org/x/lintgo get golang.org/x/lint/golintgo get github.com/ramya-rao-a/go-outlinego get github.com/acroca/go-symbolsgo get github.com/sqs/goreturnsgo get github.com/golang/dep 可以利用码云来加速下载 lint https://gitee.com/gin9/golang-lint.git tools https://gitee.com/gin9/golang-tools.git 数据类型有关类型后置 螺旋形（C/C++）和顺序（Go）的声明语法Why do a lot of programming languages put the type after the variable name? 基本类型intint6412345678// string到intint,err:=strconv.Atoi(string)// string到int64int64, err := strconv.ParseInt(string, 10, 64)// int到stringstring:=strconv.Itoa(int)// int64到stringstring:=strconv.FormatInt(int64,10) ArraySliceMapSet 基本语法标准输入输出 参考博客: golang中的格式化输入输出 函数基本结构1234// 函数名 (参数 ) 返回值&#123;函数体&#125;func functionName (param1 int) int &#123;&#125; 函数作为参数 functionName func(string, string) 参数返回值 接口 参考:接口的定义和使用 文件操作递归读取当前目录的文件123456789101112131415package mainimport ( \"fmt\" \"os\" \"path/filepath\")func main() &#123; filepath.Walk(\"./\", walkfunc)&#125;func walkfunc(path string, info os.FileInfo, err error) error &#123; if(!info.IsDir())&#123; fmt.Println(path) &#125; return nil&#125; Test Github: assert JSON 结构体必须是大写字母开头的成员才会被处理(大写字母开头才有对外权限) 参考博客: Go操作JSON参考博客: go and json参考博客: 在Go语言中使用JSON website: json to go struct 1234567891011121314151617181920212223242526272829303132333435363738394041424344 type GridConfig struct &#123; ID int `json:\"id\"` Row int `json:\"row\"` Col int `json:\"col\"` Data []int `json:\"data\"` &#125;// 第一种func (*GenerateGrid) ReadConfig() []GridConfig &#123; var datas []GridConfig fp, _ := os.Open(\"grid.json\") dec := json.NewDecoder(fp) for &#123; err := dec.Decode(&amp;datas) if err != nil &#123; fmt.Println(err) break &#125; //use v // fmt.Printf(\"%+v\", datas) for _, line := range datas &#123; fmt.Println(\" \", line) &#125; &#125; // 第二种方式 var datas []GridConfig raw, err := ioutil.ReadFile(\"./grid.json\") // fmt.Println(raw) if err != nil &#123; fmt.Println(err.Error()) os.Exit(1) &#125; err = json.Unmarshal(raw, &amp;datas) if err != nil &#123; fmt.Println(\"error:\", err) &#125; for _, line := range datas &#123; fmt.Println(\" \", line) &#125; return datas&#125; Tips通过字符串调用指定函数 参考博客: Go 根据字符串调用指定函数参考博客: WebAssembly 和 Go语言：对未来的观望","categories":[{"name":"Go","slug":"Go","permalink":"http://blog.kuangcp.top/categories/Go/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://blog.kuangcp.top/tags/函数式编程/"}]},{"title":"SVG.md","slug":"Memo-FrontEnd-SVG","date":"2018-12-14T01:24:04.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/14/Memo-FrontEnd-SVG/","link":"","permalink":"http://blog.kuangcp.top/2018/12/14/Memo-FrontEnd-SVG/","excerpt":"","text":"目录 start SVG 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs MDN:SVG 可缩放矢量图形（Scalable Vector Graphics，SVG)，是一种用来描述二维矢量图形的 XML 标记语言。 简单地说，SVG 面向图形，HTML 面向文本。","categories":[{"name":"Web","slug":"Web","permalink":"http://blog.kuangcp.top/categories/Web/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"CSS3.md","slug":"Memo-FrontEnd-CSS3","date":"2018-12-14T01:23:37.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/14/Memo-FrontEnd-CSS3/","link":"","permalink":"http://blog.kuangcp.top/2018/12/14/Memo-FrontEnd-CSS3/","excerpt":"","text":"目录 start CSS 选择器 类选择器 ID选择器 类和ID选择器的区别 子选择器 包含(后代)选择器 通用选择器 伪类选择符 案例 复选框 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs CSS选择器类选择器 类选择器在css样式编码中是最常用到的，如右侧代码编辑器中的代码:可以实现为“胆小如鼠”、“勇气”字体设置为红色。 语法： .类选器名称{css样式代码;} 注意： 1、英文圆点开头 2、其中类选器名称可以任意起名（但不要起中文噢） 第一步：使用合适的标签把要修饰的内容标记起来，如下：&lt;span&gt;胆小如鼠&lt;/span&gt; 第二步：使用class=”类选择器名称”为标签设置一个类，如下：&lt;span class=&quot;stress&quot;&gt;胆小如鼠&lt;/span&gt; 第三步：设置类选器css样式，如下：.stress{color:red;}/*类前面要加入一个英文圆点*/ ID选择器 在很多方面，ID选择器都类似于类选择符，但也有一些重要的区别： 1、为标签设置id=”ID名称”，而不是class=”类名称”。 2、ID选择符的前面是井号（#）号，而不是英文圆点（.）。 类和ID选择器的区别 相同点：可以应用于任何元素 不同点： 1、ID选择器只能在文档中使用一次。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。 2、可以使用类选择器词列表方法为一个元素同时设置多个样式。我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（不能使用 ID 词列表）。 子选择器 还有一个比较有用的选择器子选择器，即大于符号(&gt;),用于选择指定标签元素的第一代子元素。如： .food&gt;li{border:1px solid red;} //就是指定一个CSS样式名为food，但是这个是对其子元素li实施的样式 这行代码会使class名为food下的子元素li（水果、蔬菜）加入红色实线边框。 包含(后代)选择器 包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。如右侧代码编辑器中的代码： .first span{color:red;} //作用于所有嵌套关系的 span标签 )（first格式下的全部span标签） （犹如父子关系） 这行代码会使第一段文字内容中的“胆小如鼠”字体颜色变为红色。 请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一代后代。 而后代选择器是作用于所有子后代元素。后代选择器通过空格来进行选择，而子选择器是通过“&gt;”进行选择。 【总结】：&gt;作用于元素的第一代后代，空格作用于元素的所有后代。 通用选择器 通用选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中所有标签元素，如下使用下面代码使用html中任意标签元素字体颜色全部设置为红色： * {color:red;} 伪类选择符 更有趣的是伪类选择符，为什么叫做伪类选择符，它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色： a:hover{color:red;} 上面一行代码就是为 a 标签鼠标滑过的状态设置字体颜色变红。这样就会使第一段文字内容中的“胆小如鼠”文字加入鼠标滑过字体颜色变为红色特效。 关于伪选择符： 关于伪类选择符，到目前为止，可以兼容所有浏鉴器的“伪类选择符”就是 a 标签上使用 :hover 了 （其实伪类选择符还有很多，尤其是 css3 中，但是因为不能兼容所有浏览器，本教程只是讲了这一种最常用的）。 其实 :hover 可以放在任意的标签上，比如说 p:hover，但是它们的兼容性也是很不好的，所以现在比较常用的还是 a:hover 的组合。 案例复选框 纯CSS+HTML自定义checkbox效果","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.kuangcp.top/categories/前端/"}],"tags":[]},{"title":"LearnPS.md","slug":"Memo-FrontEnd-LearnPS","date":"2018-12-14T01:22:56.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/14/Memo-FrontEnd-LearnPS/","link":"","permalink":"http://blog.kuangcp.top/2018/12/14/Memo-FrontEnd-LearnPS/","excerpt":"","text":"目录 start 快捷键1. [Ctrl](#ctrl) 1. [Alt](#alt) 钢笔抠图技巧 Banner案例 形状和路径 形状层编辑： 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs #快捷键 ###Ctrl Ctrl+N 新建文件 Ctrl+H 隐藏辅助线 视图菜单栏有清除所有辅助线 Ctrl+D 取消选框 Ctrl+Alt+Z 一直撤销 Ctrl+Z 只撤销上一步 Ctrl+T 拖放选框大小，若锁定当前比例 加上shift Ctrl+R 标尺 Ctrl+J 通过拷贝的图层 Ctrl+Alt 复制当前选择框 Ctrl 剪切当前选择框 Ctrl+Del 填充背景 Ctrl+Enter 路径变选框 Ctrl+Shift+N 新建图层###Alt Alt 移动当前选择框 Alt+Del 填充前景 Alt+鼠标 去掉钢笔的手柄 使用时间轴可以制作gif动图 先羽化再抠图或者填充 渐变工具的使用 ##钢笔抠图技巧 一定要选择路径状态 钢笔定点要向对象轮廓内定1-2像素； 钢笔拖动方向，沿着弧度方向相切； 抠图出现错误时按撤销键 不能按Delete键，会删除锚点断开路径； 抠图要放大图像； 路径变选框 Ctrl+Delete； 钢笔的手柄不能太长，图片会乱窜； ##Banner案例 标尺 扩展画布 Ctrl+Alt+C 存储路径： 扣好图像后，双击工作路径 就会保存路径了 使用文案 ：复制粘贴过来 再提交就行了 修改文字（新建图层才能做一些美化操作）##形状和路径 路径： 只是回执一个路径（辅助功能） 需要后期制作（变选框，填充，描边等） 形状：会自动建立图层 （形状图层） 填充前景色；（UI构型） ##形状层编辑： 1 双击形状图缩略图，快速换色 2 属性栏 ，填色属性，描边属性，可以修改尺寸","categories":[{"name":"工具使用经验","slug":"工具使用经验","permalink":"http://blog.kuangcp.top/categories/工具使用经验/"}],"tags":[{"name":"PS","slug":"PS","permalink":"http://blog.kuangcp.top/tags/PS/"}]},{"title":"Hexo","slug":"Memo-FrontEnd-Hexo","date":"2018-12-14T01:21:42.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/14/Memo-FrontEnd-Hexo/","link":"","permalink":"http://blog.kuangcp.top/2018/12/14/Memo-FrontEnd-Hexo/","excerpt":"","text":"目录 start Hexo 安装 hexo 主配置文件 插件 文章相关 配置 tags categories 新建文章 目录 end|2018-12-13 20:53| 码云 | CSDN | OSChina | cnblogs Hexo Official Doc 参考 博客 | 部署Hexo 在docker中下拉笔记仓库, 然后构建, 然后推送到github的page上 其实可以更为简单, 使用travi.ci 进行构建和发布 参考 安装 hexo npm install -g hexo 新建一个目录然后初始化 hexo init 根据md生成静态资源文件 hexo generate | hexo g 本地试运行 hexo server | hexo s 清除静态文件hexo clean 发布到远程 hexo deploy | hexo d 主配置文件 官网配置说明 当前目录下的_config.yml是主配置文件 Site 部分 subtitle: 对自己的描述或者对网站的描述 description: 对网站的描述，提供给搜索引擎看的 author: 作者 language: 中文是zh-CN timezone: 不填就好，系统自己会计算时区 URL url: 填写你自己网站的域名 root: 如果你的网站首页就在你github仓库的根目录下，则不用修改，否则改成你网站首页所在目录即可。 后面默认。 Extensions theme 填写/thems文件夹下的主题文件夹名字 官方主题 选好对应的主题只要 git clone 在/themes文件夹下即可 例如 next主题 官方使用文档 Deployment type: git repo: 仓库URL branch: master 分支，一般是master 安装 工具 npm install hexo-deployer-git --save 更多发布方式 插件 indigo 一个Material Design风格的Hexo主题 next 文章相关配置tags source/tags/index.md 12345---title: &quot;tags&quot;type: tagslayout: &quot;tags&quot;--- categories source/categories/index.md 12345---title: \"categories\"type: categorieslayout: \"categories\"--- 新建文章 hexo new &quot;postName&quot; #postName是文章的名字 文章的开头具有 时间，标题，分类， 标签等信息 然后生成hexo g 发布 hexo d [ ] 搭建一个可用的博客, 然后将博客通过该方式书写","categories":[{"name":"工具使用经验","slug":"工具使用经验","permalink":"http://blog.kuangcp.top/categories/工具使用经验/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://blog.kuangcp.top/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"http://blog.kuangcp.top/tags/Hexo/"}]},{"title":"Font.md","slug":"Memo-FrontEnd-Font","date":"2018-12-14T01:21:37.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/14/Memo-FrontEnd-Font/","link":"","permalink":"http://blog.kuangcp.top/2018/12/14/Memo-FrontEnd-Font/","excerpt":"","text":"目录 start 字体 资源 终端中常用字体 操作系统默认字体 编辑器 终端 符号 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 字体 有哪些适合用于写代码的西文字体？ 资源 Github IBM字体2017年发布的新字体 codefont常用的代码字体 nerd-fonts系列字体图标 Font-Awesome一大堆字体图标 website https://www.fontsquirrel.com/ https://www.urbanfonts.com/ https://www.1001fonts.com/ https://www.ffonts.net/ 终端中常用字体 powerline fonts终端中常用字体 操作系统默认字体 微软雅黑 Adobe 楷体 Std 编辑器 Fira Code Retina IBM Plex Mono SemiBold Download 终端 Source Code Pro for Powerline 并且 + Powerline + Awesonme 的 Bold 最适合ZSH的 Bullet Train 主题 Droid Sans Mono for Powerline Roboto Mono for Powerline Bold Hack 符号 符号 制表符1234567891011┌ ┬ ┐ ┏ ┳ ┓ ╒ ╤ ╕ ╭ ─ ╮├ ┼ ┤ ┣ ╋ ┫ ╞ ╪ ╡ │ ╳ │└ ┴ ┘ ┗ ┻ ┛ ╘ ╧ ╛ ╰ ─ ╯┏ ┳ ┓ ┏ ━ ┓ ┎ ┰ ┒ ┍ ┯ ┑┣ ╋ ┫ ┃ ┃ ┠ ╂ ┨ ┝ ┿ ┥┗ ┻ ┛ ┗ ━ ┛ ┖ ┸ ┚ ┕ ┷ ┙┏ ┱ ┐ ┌ ┲ ┓ ┌ ┬ ┐ ┏ ┳ ┓┡ ╃ ┤ ├ ╄ ┩ ┟ ╁ ┧ ┞ ┴ ┦└ ┴ ┘ └ ┴ ┘ ┗ ╁ ┛ └ ┴ ┘─ ━ ┄ ┅ ┈ ┈ ╲ │ ┃ ┆ ┇ ┊ ┋ ╱","categories":[{"name":"资源","slug":"资源","permalink":"http://blog.kuangcp.top/categories/资源/"}],"tags":[{"name":"字体","slug":"字体","permalink":"http://blog.kuangcp.top/tags/字体/"}]},{"title":"Java异常处理","slug":"Memo-Java-AdvancedLearning-Exception","date":"2018-12-13T08:15:05.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/13/Memo-Java-AdvancedLearning-Exception/","link":"","permalink":"http://blog.kuangcp.top/2018/12/13/Memo-Java-AdvancedLearning-Exception/","excerpt":"","text":"目录 start 异常 异常的继承关系 异常常见问题 应该使用大块的try还是细颗粒度的try? try和for谁包住谁更好? 异常的处理 Web应用中全局异常统一处理 Restful应用的全局异常统一处理 异常和日志的结合 自定义异常 自定义异常的错误码 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 异常 相关博客:Java异常浅谈下面的部分文字内容来源于 JPM的GitChat 群里的交流 异常的继承关系 异常结构 Java将所有非正常情况分为两种 异常（Exception）和错误（Error） 它们都继承Throwable父类。Err错误，一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断，通常应用程序无法处理这些错误;因此应用程序不应该使用catch块来捕获Error对象,在定义该方法时，也无须在其throws子句中声明该方法可能抛出Error及任何子类。所以异常处理更多的是指Exception类,而经常处理的一般是RunTimeException 而Exception又分为2种:校验异常 和 运行时异常 异常常见问题应该使用大块的try还是细颗粒度的try? 为了避免我们遗漏掉一些可能会出现异常的代码, 所以建议使用大块的try, 因为检查型异常是容易发现的, 但是运行时异常却往往不能在编码的第一时间发现 检验异常在开发中如果不进行处理(捕获处理或声明抛出)编译器就会报错不让通过的, 如果平时没有注意异常的系统性学习,开发就会有这样一种现象: 程序中通篇只有校验异常. 一般这种校验异常默认的处理方式(使用IDE)是颗粒度小的.但是程序运行出问题的大多是运行时异常, 空指针, 数组越界, 类型不匹配, 除数为0 等等.使用大try就不会遗漏运行时异常,但是不能仅仅依靠他, 运行时异常还是尽量使用好的编程习惯来规避的.当然也是可以在大try中使用小try进行开发这样就能对异常进行具体的捕获和处理以及响应 按下葫芦浮起瓢, 关于异常, 可以从另一个角度: 性能方面的维度去考虑:异常机制的设计初衷是用于不正常的情形, JVM很少对其生成的字节码进行优化, 把尽可能多的代码放在try块中就会阻止了JVM实行原本可以执行的某些特定优化 try和for谁包住谁更好? 具体业务具体分析, 如果要求循环一出问题后续的循环还是要继续执行, 那么就把try写到for中;如果要求后续的循环不执行就用try包住for 另外: 使用多线程实现的定时任务在循环处理数据时出现异常必须要及时处理, 否则执行时就会退出 异常的处理 一般来说, 异常都是层层上抛, 中央处理 针对 Service Dao Controller 这种结构的设计, 在Service层进行统一异常处理除非这个异常是无关大局的, 就是局部发生对其他模块和代码没有影响, 那么就可以就地捕获不需要上抛 不建议使用判断语句进行异常的处理, 这样的维护很费劲, 可读性也不好大的try块中 一些需要特别说明的就是 特别处理的就要看情况抛出了, 一般进行封装后, 抛出自定义异常, 上层接收后, 进行二次处理和转化,直到最外层的调用处, 由最外层调用者决定最终如何处理 只要在使用对象前进行对象的非空判断, 基本就能杜绝空指针异常, TODO 这样的话要引入大量的if块, 希望能找到更好的解决方案 Web应用中全局异常统一处理Restful应用的全局异常统一处理方法一，nginx上设置拦截，配置对应的跳转页面。方法二，添加监听器捕获输出异常，然后按自己需要组织返回Json 异常和日志的结合 异常一定要和日志结合使用, 日志记录的简约优雅, 维护才越轻松, 日志的存在就是为了解决问题的方便和有迹可循,所以要记录的任何信息都是为了解决问题, 无关信息就没有必要放进来了 目前个人用到的就是所在类 方法 行数 时间 报错信息, 根据业务需要还可以加上用户id, 订单id之类的 自定义异常 虽然Java提供了大量的异常类, 但是这些异常类还是难以满足业务的需求, 这个需求可能是用户, 客服, 我们自身 通常自定义异常只要继承Exception 重写相关构造器即可.一般来说自定义异常具有以下类型: 业务异常, 用户异常, 系统异常, 接口异常, 网络异常, 参数异常等等.根据项目需要, 可以将异常细分, 比如写一个订单保存, 那么针对订单保存的业务可以在不同的代码逻辑里提示不同的异常信息, 接口级异常也是如此目的是为了将Exception进行封装, 形成易于理解的异常信息. 自定义异常的设计原则 用户层面: 用户提示信息要优雅 系统层面: 让自己维护起来更方便 接口层面: 查询问题更直观, 轻松, 为自己留证据, 避免推诿扯皮 网络层面: 及时发现问题, 及时进行处理 自定义异常的错误码 正规项目中都会有接口文档, 也会有规范注释, 在项目中也会有一些静态常量假设定义一个错误码 00X1 表示空指针, 这个错误码不是给客户或者使用者看的, 而且定义要有规律不能让其他人猜到, 方便查询和管理规划的越详细, 就会有更为便利的维护方式","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"异常","slug":"异常","permalink":"http://blog.kuangcp.top/tags/异常/"}]},{"title":"Java8","slug":"Memo-Java-AdvancedLearning-Java8","date":"2018-12-13T08:05:51.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/13/Memo-Java-AdvancedLearning-Java8/","link":"","permalink":"http://blog.kuangcp.top/2018/12/13/Memo-Java-AdvancedLearning-Java8/","excerpt":"","text":"目录 start Java8 Funcational Lambda 行为参数化 Lambda基础 原始类型特化 类型检查、类型推断以及限制 类型检查 同样的Lambda 不同的函数式接口 类型推断 使用局部变量 方法引用 复合 Lambda 表达式 比较器复合 谓词复合 函数复合 利用Lambda开发DSL框架 Stream Stream与集合 只能遍历一次 外部迭代和内部迭代 Stream操作 中间操作 终端操作 使用Stream 筛选 映射 查找和匹配 归约 求和 极值 归约的优势与并行化 总结 数值流 原始类型特化 数值范围 构建流 由值创建流 由数组创建流 由文件生成流 由函数生成流：创建无限流 使用流收集数据 预定义收集器 汇总 规约 分组 多级分组 按子组收集数据 分区 Optional Optional类和Stream接口的相似之处 Tips 实践:读取Properties某属性 集合 时间处理 Instant LocalDateTime 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs Java8 doc: Java8 | APIJava8 JDK Readme | Jre8 Readme有说明哪些是JRE运行不必要的文件 Java8 tools介绍目录 bin/* 下的工具 | jdk structure Oracle:Java8故障排除指南 参考书籍 Java8 in action Funcational 参考 Java8函数接口实现回调及Groovy闭包的代码示例Function接口 – Java8中java.util.function包下的函数式接口 @FunctionalInterface An informative annotation type used to indicate that an interface type declaration is intended to be a functional interface as defined by the Java Language Specification. 这个标注用于表示该接口会设计成一个函数式接口。如果你用@FunctionalInterface定义了一个接口，而它却不是函数式接口的话，编译器将返回一个提示原因的错误。 如果使用此批注类型对类型进行批注，则编译器需要生成错误消息，除非： 类型是接口类型，而不是注释类型，枚举或类。 带注释的类型满足功能接口的要求。 但是，无论接口声明中是否存在功能接口注释，编译器都会将满足功能接口定义的任何接口视为 FunctionalInterface。 函数式接口很有用，抽象方法的签名可以描述Lambda表达式的签名。函数式接口的抽象方法的签名称为函数描述符。 常用函数接口: (详细可参考 java.util.function; 包下的类) Consumer (接收单参数无返回值的函数或lambda表达式)， 方法是 void accept(T t); BiConsumer (接收双参数无返回值的函数或 lambda表达式)，方法是 void accept(T t, U u); Function (接收单参数有返回值的函数或lambda表达式)， 方法是 R apply(T t); BiFunction (接收双参数有返回值的函数或lambda表达式)，方法是 R apply(T t, U u); Predicate （接收单参数返回布尔值的函数或lambda表达式），方法是 boolean test(T t); BiPredicate （接收双参数返回布尔值的函数或lambda表达式），方法是 boolean test(T t, U u); Supplier (无参数但具有返回值的函数或 lambda表达式)， 方法是 T get(); 为什么要使用 Function 以及闭包呢？ 在语法上比定义回调接口、创建匿名类更加简洁； 尝试使用新的语言特性，理解多样化的编程思想，提升编程表达能力。 Lambda Lambda表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常的列表。 Lambda表达式让你可以简洁地传递代码。 函数式接口就是仅仅声明了一个抽象方法的接口。 只有在接受函数式接口的地方才可以使用Lambda表达式。 Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。 Java 8自带一些常用的函数式接口，放在java.util.function包里，包括Predicate&lt;T&gt;、 Function&lt;T,R&gt;、 Supplier&lt;T&gt;、Consumer&lt;T&gt; 和BinaryOperator&lt;T&gt; 为了避免装箱操作，对Predicate&lt;T&gt;和Function&lt;T, R&gt;等通用函数式接口的原始类型特化： IntPredicate、 IntToLongFunction等。 环绕执行模式（即在方法所必需的代码中间，你需要执行点儿什么操作，比如资源分配和清理）可以配合Lambda提高灵活性和可重用性。 Lambda表达式所需要代表的类型称为目标类型。 方法引用让你重复使用现有的方法实现并直接传递它们。 Comparator、 Predicate和Function等函数式接口都有几个可以用来结合Lambda表达式的默认方法。 参考博客: 你真的了解lambda吗？一文让你明白lambda用法与源码分析 参考博客: 级联 lambda 表达式的函数重用与代码简短问题 学习常见排序 Comparator int float double time string… 参考博客: Java8：Lambda表达式增强版Comparator和排序 行为参数化 行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们， 完成不同行为的能力。 行为参数化可让代码更好地适应不断变化的要求，减轻未来的工作量。 传递代码，就是将新行为作为参数传递给方法。但在Java 8之前这实现起来很啰嗦。为接 声明许多只用一次的实体类而造成的啰嗦代码，在Java 8之前可以用匿名类来减少。 Java API包含很多可以用不同行为进行参数化的方法，包括排序、线程和GUI处理。 这种模式可以把一个行为（一段代码）封装起来，并通过传递和使用创建的行为, 将方法的行为参数化。前面提到过，这种做法类似于策略设计模式Java API中的很多方法都可以用不同的行为来参数化。这些方法往往与匿名类一起使用 Lambda基础 可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。 匿名 我们说匿名，是因为它不像普通的方法那样有一个明确的名称：写得少而想得多！ 函数 我们说它是函数，是因为Lambda函数不像方法那样属于某个特定的类。但和方法签名的组成是一致的 传递 Lambda表达式可以作为参数传递给方法或存储在变量中。 简洁 无需像匿名类那样写很多模板代码。 Lambda基础语法: (parameters) -&gt; expression 或者 (parameters) -&gt; { statements; } 例如 () -&gt; void 是一个参数列表为空 返回值为void的函数, Runnable 的 run 方法12345678910public Callable&lt;String&gt; fetch() &#123; // 返回的方法的方法签名是 () -&gt; String return () -&gt; \"Tricky example ;-)\";&#125;// 方法签名为 () -&gt; voidexecute(() -&gt; &#123;&#125;);public void execute(Runnable r)&#123; r.run();&#125; 实践 资源处理（例如处理文件或数据库）时一个常见的模式就是打开一个资源，做一些处理，然后关闭资源。这个设置和清理阶段总是很类似 并且会围绕着执行处理的那些重要代码。这就是所谓的环绕执行（execute around） 模式1234567891011121314151617// 简单的从文件读取一行public static String processFile() throws IOException &#123; try (BufferedReader br = new BufferedReader(new FileReader(\"data.txt\"))) &#123; return br.readLine(); &#125;&#125;// 如果将行为参数化, 就能通用的完成需求@FunctionalInterfacepublic interface BufferedReaderProcessor &#123;String process(BufferedReader b) throws IOException;&#125;public static String processFile(BufferedReaderProcessor p) throws IOException &#123;&#125;// 处理一行String twoLines =processFile((BufferedReader br) -&gt; br.readLine());// 处理两行String result = processFile((BufferedReader br) -&gt; br.readLine() + br.readLine()); 原始类型特化 Primitive Specializations Java类型要么是引用类型（比如Byte、 Integer、 Object、 List） ，要么是原始类型（比如int、 double、 byte、 char）。但是泛型（比如Consumer&lt;T&gt;中的T）只能绑定到引用类型。这是由泛型内部的实现方式造成的。因此，在Java里有一个将原始类型转换为对应的引用类型的机制。这个机制叫作装箱（boxing） 。相反的操作，也就是将引用类型转换为对应的原始类型，叫作拆箱（unboxing）。 Java还有一个自动装箱机制来帮助程序员执行这一任务：装箱和拆箱操作是自动完成的。但这在性能方面是要付出代价的。装箱后的值本质上就是把原始类型包裹起来，并保存在堆里。因此，装箱后的值需要更多的内存，并需要额外的内存搜索来获取被包裹的原始值。Java 8为我们前面所说的函数式接口带来了一个专门的版本，以便在输入和输出都是原始类型时避免自动装箱的操作。比如，在下面的代码中，使用IntPredicate就避免了对值1000进行装箱操作，但要是用Predicate就会把参数1000装箱到一个Integer对象中 – Java8 in action 一般来说，针对专门的输入参数类型的函数式接口的名称都要加上对应的原始类型前缀，比如DoublePredicate、 IntConsumer、 LongBinaryOperator、 IntFunction等。Function接口还有针对输出参数类型的变种： ToIntFunction、 IntToDoubleFunction等。请记得这只是一个起点。如果有需要，你可以自己设计一个。请记住， (T,U) -&gt; R的表达方式展示了应当如何思考一个函数描述符。表的左侧代表了参数类型。这里它代表一个函数，具有两个参数，分别为泛型T和U，返回类型为R。 函数式接口 函数描述符 原始类型特化 Predicate&lt;T&gt; T-&gt;boolean IntPredicateLongPredicate DoublePredicate Consumer&lt;T&gt; T-&gt;void IntConsumerLongConsumer DoubleConsumer Function&lt;T,R&gt; T-&gt;R IntFunction&lt;R&gt; IntToDoubleFunction IntToLongFunction LongFunction&lt;R&gt; LongToDoubleFunction LongToIntFunction DoubleFunction&lt;R&gt; ToIntFunction&lt;T&gt;ToDoubleFunction&lt;T&gt;ToLongFunction&lt;T&gt; Supplier&lt;T&gt; ()-&gt;T BooleanSupplierIntSupplier LongSupplier DoubleSupplier UnaryOperator&lt;T&gt; T-&gt;T IntUnaryOperatorLongUnaryOperatorDoubleUnaryOperator BinaryOperator&lt;T&gt; (T,T)-&gt; T IntBinaryOperatorLongBinaryOperatorDoubleBinaryOperator BiPredicate&lt;L,R&gt; (L,R)-&gt;boolean BiConsumer&lt;T,U&gt; (T,U)-&gt;void ObjIntConsumer&lt;T&gt;ObjLongConsumer&lt;T&gt;ObjDoubleConsumer&lt;T&gt; BiFunction&lt;T,U,R&gt; (T,U)-&gt;R ToIntBiFunction&lt;T,U&gt;ToLongBiFunction&lt;T,U&gt;ToDoubleBiFunction&lt;T,U&gt; Lambdas及函数式接口的例子 使用案例 Lambda例子 对应的函数式接口 布尔表达式 (List list) -&gt; list.isEmpty() Predicate&lt;List&lt;String&gt;&gt; 创建对象 () -&gt; new Apple(10) Supplier&lt;Apple&gt; 消费一个对象 (Apple a) -&gt;System.out.println(a.getWeight()) Consumer&lt;Apple&gt; 从一个对象中 选择/提取 (String s) -&gt; s.length() Function&lt;String, Integer&gt; 或 ToIntFunction&lt;String&gt; 合并两个值 (int a, int b) -&gt; a * b IntBinaryOperator 比较两个对象 (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()) Comparator&lt; Apple &gt; 或 BiFunction&lt;Apple, Apple, Integer&gt; 或 ToIntBiFunction&lt;Apple, Apple&gt; 请注意，任何函数式接口都不允许抛出受检异常（checked exception）。如果你需要Lambda 表达式来抛出异常，有两种办法： 定义一个自己的函数式接口，并声明受检异常， 或者把Lambda 包在一个try/catch块中。 比如函数式接口BufferedReaderProcessor，它显式声明了一个IOException： 12345@FunctionalInterfacepublic interface BufferedReaderProcessor &#123; String process(BufferedReader b) throws IOException;&#125;BufferedReaderProcessor p = (BufferedReader br) -&gt; br.readLine(); 但是你可能是在使用一个接受函数式接口的API，比如Function&lt;T, R&gt;，没有办法自己创建一个。这种情况下， 你可以显式捕捉受检异常： 1234567Function&lt;BufferedReader, String&gt; f = (BufferedReader b) -&gt; &#123; try &#123; return b.readLine(); &#125; catch(IOException e) &#123; throw new RuntimeException(e); &#125;&#125;; 类型检查、类型推断以及限制当我们第一次提到Lambda表达式时，说它可以为函数式接口生成一个实例。然而， Lambda 表达式本身并不包含它在实现哪个函数式接口的信息。 类型检查 Lambda的类型是从使用Lambda的上下文推断出来的。上下文（比如，接受它传递的方法的参数，或接受它的值的局部变量）中Lambda表达式需要的类型称为目标类型。请注意，如果Lambda表达式抛出一个异常，那么抽象方法所声明的throws语句也必须与之匹配。 同样的Lambda 不同的函数式接口 有了目标类型的概念，同一个Lambda表达式就可以与不同的函数式接口联系起来，只要它们的抽象方法签名能够兼容。 比如，前面提到的Callable和PrivilegedAction，这两个接口 都代表着什么也不接受且返回一个泛型T的函数。 因此，下面两个赋值是有效的：12Callable&lt;Integer&gt; c = () -&gt; 42;PrivilegedAction&lt;Integer&gt; p = () -&gt; 42; 特殊的void兼容规则如果一个Lambda的主体是一个语句表达式， 它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。例如，以下两行都是合法的，尽管List的add方法返回了一个 boolean，而不是Consumer上下文（T -&gt; void） 所要求的void：1234// Predicate返回了一个booleanPredicate&lt;String&gt; p = s -&gt; list.add(s);// Consumer返回了一个voidConsumer&lt;String&gt; b = s -&gt; list.add(s); Object o = () -&gt; {System.out.println(&quot;Tricky example&quot;); }; 不能通过编译 Lambda表达式的上下文是Object（目标类型）。但Object不是一个函数式接口。 为了解决这个问题，你可以把目标类型改成Runnable，它的函数描述符是() -&gt; void 既可以利用目标类型来检查一个Lambda是否可以用于某个特定的上下文. 也可以用来做一些略有不同的事：推断Lambda参数的类型。 类型推断 你还可以进一步简化你的代码。 Java编译器会从上下文（目标类型）推断出用什么函数式接口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。这样做的好处在于，编译器可以了解Lambda表达式的参数类型，这样就可以在Lambda语法中省去标注参数类型。 1234// 无类型推断Comparator&lt;Apple&gt; c = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());// 有类型推断Comparator&lt;Apple&gt; c = (a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight()); 使用局部变量我们迄今为止所介绍的所有Lambda表达式都只用到了其主体里面的参数。但Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作捕获Lambda。例如，下面的Lambda捕获了portNumber变量：12int portNumber = 1337;Runnable r = () -&gt; System.out.println(portNumber); 尽管如此，还有一点点小麻烦：关于能对这些变量做什么有一些限制。 Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。换句话说， Lambda表达式只能捕获指派给它们的局部变量一次。（注：捕获实例变量可以被看作捕获最终局部变量this。） 例如，下面的代码无法编译，因为portNumber 变量被赋值两次：123int portNumber = 1337;Runnable r = () -&gt; System.out.println(portNumber);portNumber = 31337; 对局部变量的限制 你可能会问自己，为什么局部变量有这些限制。 第一，实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。 如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。 因此， Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。 第二，这一限制不鼓励你使用改变外部变量的典型命令式编程模式（这种模式会阻碍很容易做到的并行处理）。 闭包 你可能已经听说过闭包（closure，不要和Clojure编程语言混淆）这个词，你可能会想Lambda是否满足闭包的定义。用科学的说法来说，闭包就是一个函数的实例，且它可以无限制地访问那个函数的非本地变量。例如，闭包可以作为参数传递给另一个函数。它也可以访问和修改其作用域之外的变量。现在， Java 8的Lambda和匿名类可以做类似于闭包的事情：它们可以作为参数传递给方法，并且可以访问其作用域之外的变量。但有一个限制：它们不能修改定义Lambda的方法的局部变量的内容。这些变量必须是隐式最终的。可以认为Lambda是对值封闭，而不是对变量封闭。如前所述，这种限制存在的原因在于局部变量保存在栈上，并且隐式表示它们仅限于其所在线程。如果允许捕获可改变的局部变量，就会引发造成线程不安全的新的可能性，而这是我们不想看到的（实例变量可以，因为它们保存在堆中，而堆是在线程之间共享的） 。 方法引用 通过 :: 操作符 简化代码 Lambda 方法引用 (Apple a) -&gt; a.getWeight() Apple::getWeight () -&gt; Thread.currentThread().dumpStack() Thread.currentThread()::dumpStack (str, i) -&gt; str.substring(i) String::substring (String s) -&gt; System.out.println(s) System.out::println 构建方法引用 指向静态方法的方法引用（例如Integer的parseInt方法，写作Integer::parseInt） 指向任意类型实例方法的方法引用 （ 例 如 String 的 length 方 法 ， 写作String::length）。 指向现有对象的实例方法的方法引用 假设你有一个局部变量expensiveTransaction 用于存放Transaction类型的对象，它支持实例方法getValue， 那么你就可以写expensiveTransaction::getValue 构造函数的引用 空构造函数 等价于 () -&gt; T 例如 Supplier&lt;Apple&gt; c1 = Apple::new; 之后 Apple a1 = c1.get(); 调用接口的get方法实例化Apple对象 不将构造函数实例化却能够引用它，这个功能有一些有趣的应用。例如，你可以使用Map来将构造函数映射到字符串值。你可以创建一个giveMeFruit方法，给它一个String和一个Integer，它就可以创建出不同重量的各种水果：123456789static Map&lt;String, Function&lt;Integer, Fruit&gt;&gt; map = new HashMap&lt;&gt;();static &#123; map.put(\"apple\", Apple::new); map.put(\"orange\", Orange::new);// etc...&#125;public static Fruit giveMeFruit(String fruit, Integer weight)&#123; return map.get(fruit.toLowerCase()).apply(weight);&#125; 利用JDK提供的函数式接口 可以实现将一个,两个参数的构造函数转变为构造函数引用, 那么可以自定义实现三个参数的接口1234public interface TriFunction&lt;T, U, V, R&gt;&#123; R apply(T t, U u, V v);&#125;TriFunction&lt;Integer, Integer, Integer, Color&gt; colorFactory = Color::new; 复合 Lambda 表达式在实践中，这意味着你可以把多个简单的Lambda复合成复杂的表达式。比如，你可以让两个谓词之间做一个or操作，组合成一个更大的谓词。而且，你还可以让一个函数的结果成为另一个函数的输入。窍门在于，我们即将介绍的方法都是默认方法，也就是说它们不是抽象方法。 比较器复合 单一属性比较 Comparator&lt;Apple&gt; c = Comparator.comparing(Apple::getWeight); (实用的Comparator.comparing方法) 顺序(小到大) 逆序则再调用下 reversed() 按重量排序, 重量一致则再按国家排序 inventory.sort(comparing(Apple::getWeight).thenComparing(Apple::getCountry)); 谓词复合 谓词接口包括三个方法： negate、 and和or，让你可以重用已有的Predicate来创建更复杂的谓词。请注意， and和or方法是按照在表达式链中的位置，从左向右确定优先级的。因此， a.or(b).and(c)可以看作(a || b) &amp;&amp; c。 不红 Predicate&lt;Apple&gt; notRedApple = redApple.negate(); 红且重Predicate&lt;Apple&gt; redAndHeavyApple = redApple.and(a -&gt; a.getWeight() &gt; 150); 红且重或者是绿的 Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = redApple.and(a -&gt; a.getWeight() &gt; 150).or(a -&gt; &quot;green&quot;.equals(a.getColor())); 函数复合可以把Function接口所代表的Lambda表达式复合起来。 Function接口为此配了andThen和compose两个默认方法，它们都会返回Function的一个实例。 123456789Function&lt;Integer, Integer&gt; f = x -&gt; x + 1;Function&lt;Integer, Integer&gt; g = x -&gt; x * 2;Function&lt;Integer, Integer&gt; h = f.andThen(g); // g(f(x))int result = h.apply(1);Function&lt;Integer, Integer&gt; f = x -&gt; x + 1;Function&lt;Integer, Integer&gt; g = x -&gt; x * 2;Function&lt;Integer, Integer&gt; h = f.compose(g); // f(g(x))int result = h.apply(1); 使用场景 用String表示的一封信做文本转换：现在你可以通过复合这些工具方法来创建各种转型流水线了比如创建一个流水线：先加上抬头，然后进行拼写检查，最后加上一个落款，1234Function&lt;String, String&gt; addHeader = Letter::addHeader;Function&lt;String, String&gt; transformationPipeline = addHeader .andThen(Letter::checkSpelling) .andThen(Letter::addFooter); 和数学对比例如 根据给定的某个函数 以及上下限, 求积分: 定义函数 integrate integrate(f, 3, 7) 123public double integrate(DoubleFunction&lt;Double&gt; f, double a, double b) &#123; return (f.apply(a) + f.apply(b)) * (b-a) / 2.0;&#125; 利用Lambda开发DSL框架 可以将mythpoi改造一下 Stream 参考博客: Java 8 中的 Streams API 详解 Java 8中的Stream API可以让你写出这样的代码 声明性, 更简洁, 更易读 可复合, 更灵活 可并行, 性能更好 Stream 简短的定义就是“从支持数据处理操作的源生成的元素序列” 元素序列 就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。 因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和素（如ArrayList与LinkedList）。 但流的目的在于表达计算，比如你前面见到的filter、sorted 和map。集合讲的是数据，流讲的是计算。 源 流会使用一个提供数据的源，如集合、数组或输入/输出资源。请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。 数据处理操作 流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行 内部迭代 与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。 Stream与集合粗略地说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。（你可以往集合里加东西或者删东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素都得先算出来才能成为集合的一部分）相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。 例如构建一个质数流, 对所有的质数处理, 如果使用集合就要把所有的质数构建出来, 然后做下一步操作, 但是流只会按需生成。这是一种生产者－消费者的关系. 从另一个角度来说，流就像是一个延迟创建的集合：只有在消费者要求的时候才会计算值 只能遍历一次 和迭代器类似，流只能遍历一次, 遍历完之后，我们就说这个流已经被消费掉了从哲学的角度看, 集合是空间中分布的一组值, 而流是时间中分布的一组值 外部迭代和内部迭代 使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。 相反，Streams库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数声明迭代中执行的操作即可。 外部迭代 显式的迭代集合, 命令式的执行操作 内部迭代 将迭代的细节隐藏起来, 方便优化 Stream操作因为filter、sorted、map 和collect 等操作是与具体线程模型无关的高层次构件, 所以它们的内部实现可以是单线程的，也可能透明地充分利用你的多核架构 中间操作诸如 filter 或 sorted map flatMap limit distinct 等中间操作会返回另一个流。这让多个操作可以连接起来形成一个查询。重要的是，除非流水线上触发一个终端操作，否则中间操作不会执行任何处理因为中间操作一般都可以合并起来，在终端操作时一次性全部处理 (循环合并) filter 满足该条件的元素保留下来 map 将一个流中的每个元素通过 一种映射 得到新的元素组成的流 flatMap 使用流时， flatMap方法接受一个函数作为参数，这个函数的返回值是另一个流。这个方法会应用到流中的每一个元素，最终形成一个新的流的流。 终端操作 操作 目的 forEach 消费流中的每个元素并对其应用 Lambda。这一操作返回 void count 返回流中元素的个数。这一操作返回 long collect 把流归约成一个集合，比如List、Map甚至是Integer 使用Stream 流的使用一般包括三件事： 一个数据源（如集合）来执行一个查询； 一个中间操作链，形成一条流的流水线； 一个终端操作，执行流水线，并能生成结果。 流的流水线背后的理念类似于构建器模式 在构建器模式中有一个调用链用来设置一套配置（对流来说这就是一个中间操作链），接着是调用 build方法 （对流来说就是终端操作） 筛选 利用 filter 使用谓词 Predicate 筛选 去重 distinct() 截断 limit(n) 只能按流的长度单向截断 跳过元素 skip(n) 映射 流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素 （使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”而不是去“修改”） 12List&lt;Integer&gt; dishNameLengths = menu.stream() .map(Dish::getName) .map(String::length) .collect(toList()); flatMap12345List&lt;String&gt; uniqueCharacters = words.stream() .map(w -&gt; w.split(\"\")) // Stream&lt;Arrays&gt; .flatMap(Arrays::stream) // 扁平化流 (合并) .distinct() .collect(Collectors.toList()); 使用流的方式嵌套迭代1234567// 给定两个数字列表，如何返回所有的数对呢？例如，给定列表[1, 2, 3]和列表[3, 4]，应该返回[(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)]List&lt;Integer&gt; numbers1 = Arrays.asList(1, 2, 3); List&lt;Integer&gt; numbers2 = Arrays.asList(3, 4); List&lt;int[]&gt; pairs = numbers1.stream() .flatMap(i -&gt; numbers2.stream() .map(j -&gt; new int[]&#123;i, j&#125;) ).collect(toList()); 查找和匹配 allMatch、anyMatch、noneMatch、findFirst findAny 都是接受一个 谓词 函数, 都用到了我们所谓的短路,不需要处理所有的流，这就是大家熟悉的Java中&amp;&amp;和||运算符短路在流中的版本 allMatch、anyMatch、noneMatch 是 匹配 返回值是boolean findFirst findAny 是查找 返回 Optional&lt;T&gt; findFirst 针对有序的流 如果你不关心返回的元素是哪个，请使用 findAny ，因为它在使用并行流时限制较少。 归约 如何把一个流中的元素组合起来，使用 reduce 操作来表达更复杂的查询 此类查询需要将流中所有元素反复结合起来，得到一个值 这样的查询可以被归类为归约操作（将流归约成一个值）。用函数式编程语言的术语来说，这称为折叠（fold） map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名，因为它很容易并行化。 求和123456789101112int sum = 0; for (int x : numbers)&#123; sum += x;&#125;// reduce 参数: 初始值 函数int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b);int sum = numbers.stream().reduce(0, Integer::sum);// 无初始值 返回 Optional 对象Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b)); 极值123456// 最大值Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);// 最小值Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min);Optional&lt;Integer&gt; min = numbers.stream().reduce((x, y) -&gt; x &lt; y ? x : y); 归约的优势与并行化相比于前面写的逐步迭代求和，使用 reduce 的好处在于，这里的迭代被内部迭代抽象掉了，这让内部实现得以选择并行执行reduce 操作。而迭代式求和例子要更新共享变量 sum ，这不是那么容易并行化的。如果你加入了同步，很可能会发现线程竞争抵消了并行本应带来的性能提升！这种计算的并行化需要另一种办法：将输入分块，分块求和，最后再合并起来。 int sum = numbers.parallelStream().reduce(0, Integer::sum); 但要并行执行这段代码也要付一定代价，传递给 reduce 的Lambda不能更改状态（如实例变量），而且操作必须满足结合律才可以按任意顺序执行。 总结 操作 类型 返回类型 参数 函数描述符 filter 中间 Stream&lt;T&gt; Predicate&lt;T&gt; T -&gt; boolean distinct 中间 有状态 无界 Stream&lt;T&gt; skip 中间 有状态 有界 Stream&lt;T&gt; long limit 中间 有状态 有界 Stream&lt;T&gt; long map 中间 Stream&lt;R&gt; Function&lt;T, R&gt; T -&gt; R flatMap 中间 Stream&lt;R&gt; Function&lt;T, Stream&lt;R&gt;&gt; T -&gt; Stream&lt;R&gt; sorted 中间 有状态 无界 Stream&lt;T&gt; Comparator&lt;T&gt; (T,T) -&gt; int anyMatch 终端 boolean Predicate&lt;T&gt; T -&gt; boolean noneMatch 终端 boolean Predicate&lt;T&gt; T -&gt; boolean allMatch 终端 boolean Predicate&lt;T&gt; T-&gt;boolean findAny 终端 Optional&lt;T&gt; findFirst 终端 Optional&lt;T&gt; forEach 终端 void Consumer&lt;T&gt; T -&gt; void collect 终端 R Collector&lt;T, A, R&gt; reduce 终端 有状态 有界 Optional&lt;T&gt; BinaryOprator&lt;T&gt; (T, T) -&gt; T count 终端 long joining 替换 字符串直接拼接 1234// 该方案 效率不高, 所有字符串被反复连接, 每次迭代都需创建新String对象strings.stream().sorted().reduce(\"\", (a,b) -&gt; a+b);// joining 内部会使用 StringBuilderstrings.stream().sorted().collect(Collectors.joining()); 数值流原始类型特化Java8 引入了三个原始类型特化流接口来解决这个问题： IntStream、DoubleStream 和 LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。 映射到数值流12345// 例如求和, 里面有一个隐含的拆箱操作 再求和numbers.parallelStream().reduce(0, Integer::sum);// 请注意，如果流是空的，sum默认返回 0numbers.parallelStream().mapToInt(Integer::intValue).sum() 映射到对象流使用 boxed() 方法即可 默认值OptionalInt1OptionalInt maxCalories = menu.stream().mapToInt(Dish::getCalories).max(); 数值范围IntStream和LongStream 的 range() 或者 rangeClose() 方法能产生一个数值流 例如 IntStream.rangeClose(1,100).filter(num-&gt;num%2==0).count() 统计100以内的偶数 获取勾股数流1234567Stream&lt;int[]&gt; pythagoreanTriples = IntStream.rangeClosed(1, 100).boxed() .flatMap(a -&gt; IntStream.rangeClosed(a, 100) .filter(b -&gt; Math.sqrt(a*a + b*b) % 1 == 0) .mapToObj(b -&gt; new int[]&#123;a, b, (int)Math.sqrt(a * a + b * b)&#125;) ); pythagoreanTriples.limit(5) .forEach(t -&gt; System.out.println(t[0] + \", \" + t[1] + \", \" + t[2])); 构建流 从值序列、数组、文件来创建流，甚至由函数创建无限流 由值创建流Stream&lt;String&gt; stream = Stream.of(&quot;Java 8 &quot;, &quot;Lambdas &quot;, &quot;In &quot;, &quot;Action&quot;); 由数组创建流12int[] numbers = &#123;2, 3, 5, 7, 11, 13&#125;; int sum = Arrays.stream(numbers).sum(); 由文件生成流Java中用于处理文件等I/O操作的NIO API（非阻塞I/O）已更新，以便利用Stream API。java.nio.file.Files中的很多静态方法都会返回一个流。 1234long uniqueWords = 0; try(Stream&lt;String&gt; lines = Files.lines(Paths.get(\"data.txt\"), Charset.defaultCharset()))&#123; uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(\" \"))).distinct() .count(); &#125;catch(IOException e)&#123;&#125; 由函数生成流：创建无限流 Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。这两个操作可以创建所谓的 无限流同样，你不能对无限流做排序或归约，因为所有元素都需要处理，而这永远也完不成！ 迭代123456Stream.iterate(0, n -&gt; n + 2).limit(10).forEach(System.out::println); // 获取斐波那契序列 元组Stream.iterate(new int[]&#123;0, 1&#125;, t -&gt; new int[]&#123;t[1], t[0]+t[1]&#125;) .limit(20) .forEach(t -&gt; System.out.println(\"(\" + t[0] + \",\" + t[1] +\")\")); 生成1234567891011121314Stream.generate(Math::random).limit(5).forEach(System.out::println); // 很重要的一点是，在并行代码中使用有状态的供应源是不安全的。因此下面的代码仅仅是为了内容完整，应尽量避免使用！IntSupplier fib = new IntSupplier()&#123; private int previous = 0; private int current = 1; public int getAsInt()&#123; int oldPrevious = this.previous; int nextValue = this.previous + this.current; this.previous = this.current; this.current = nextValue; return oldPrevious; &#125; &#125;; IntStream.generate(fib).limit(10).forEach(System.out::println); 使用流收集数据 函数式编程相对于指令式编程的一个主要优势：你只需指出希望的结果——“做什么”，而不用操心执行的步骤——“如何做” 预定义收集器Collectors所提供的工厂方法 它们主要提供了三大功能：将流元素归约和汇总为一个值 元素分组 元素分区 toList toMap toSet 等方法 汇总 Collectors类专门为汇总提供了一个工厂方法：Collectors.summingInt 它可接受一个把对象映射为求和所需int的函数，并返回一个收集器；该收集器在传递给普通的collect方法后即执行我们需要的汇总操作求平均数 Collectors.averagingIntsummarizing操作你可以得出元素的个数，并得到总和、平均值、最大值和最小值 12IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories)); // toString(): IntSummaryStatistics&#123;count=9, sum=4300, min=120, average=477.777778, max=800&#125; 连接字符串joining工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。String shortMenu = menu.stream().collect(joining()); 规约事实上，我们已经讨论的所有收集器，都是一个可以用reducing工厂方法定义的归约过程的特殊情况而已。Collectors.reducing工厂方法是所有这些特殊情况的一般化。 例如 计算总热量 int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i, j) -&gt; i + j)); 第一个参数: 规约操作的起始值 也是当流为空时的返回值 第二个参数: 转换函数 第三个参数: BinaryOperator 将两个项目累积成一个同类型的值 你可以把单参数reducing工厂方法创建的收集器看作三参数方法的特殊情况，它把流中的第一个项目作为起点，把恒等函数（即一个函数仅仅是返回其输入参数）作为一个转换函数。这也意味着，要是把单参数reducing收集器传递给空流的collect方法，收集器就没有起点;它将因此而返回一个Optional对象。 收集框架的灵活性：以不同的方法执行同样的操作 使用Integer的sum方法简化以上的求和 int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories,Integer::sum)); 将对象映射为 int 然后规约求和 int totalCalories = menu.stream().map(Dish::getCalories).reduce(Integer::sum).get(); 或者转为 IntStream int totalCalories = menu.stream().mapToInt(Dish::getCalories).sum(); 根据情况选择最佳解决方案 函数式编程（特别是Java 8的Collections框架中加入的基于函数式风格原理设计的新API）通常提供了多种方法来执行同一个操作。这个例子还说明，收集器在某种程度上比Stream接口上直接提供的方法用起来更复杂，但好处在于它们能提供更高水平的抽象和概括，也更容易重用和自定义。 分组一个常见的数据库操作是根据一个或多个属性对集合中的项目进行分组。 使用 groupingBy Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType = menu.stream().collect(groupingBy(Dish::getType)); groupingBy 方法的入参为一个 Function 一般称为分类函数 12345678910111213// 实现复杂的分类函数public enum CaloricLevel &#123; DIET, NORMAL, FAT &#125; Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCaloricLevel = menu.stream().collect( groupingBy(dish -&gt; &#123; if (dish.getCalories() &lt;= 400)&#123; return CaloricLevel.DIET; &#125; else if (dish.getCalories() &lt;= 700)&#123; return CaloricLevel.NORMAL; &#125;else&#123; return CaloricLevel.FAT; &#125; &#125;)); 多级分组 要实现多级分组，我们可以使用一个由双参数版本的 Collectors.groupingBy 工厂方法创建的收集器，它除了普通的分类函数之外，还可以接受collector类型的第二个参数。 1234567891011121314Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel = menu.stream().collect( groupingBy(Dish::getType, groupingBy(dish -&gt; &#123; if (dish.getCalories() &lt;= 400)&#123; return CaloricLevel.DIET; &#125;else if (dish.getCalories() &lt;= 700) &#123; return CaloricLevel.NORMAL; &#125;else&#123; return CaloricLevel.FAT; &#125; &#125; ) ) ); 按子组收集数据 可以把第二个groupingBy收集器传递给外层收集器来实现多级分组。但进一步说，传递给第一个groupingBy的第二个收集器可以是任何类型 例如: Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().collect(groupingBy(Dish::getType, counting())); 1234567Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt; mostCaloricByType = menu.stream() .collect(groupingBy( Dish::getType, maxBy( comparingInt(Dish::getCalories) ) )); 这个分组的结果显然是一个map，以Dish的类型作为键，以包装了该类型中热量最高的Dish的Optional作为值 但是这里的 Optional 存在的意义不大, 因为先有的类型 进行分组, 才会进行 maxBy 所以值是一定存在的 把收集器的结果转换为另一种类型 因为前述例子中的Optional存在意义不是很大, 所以 把收集器返回的结果转换为另一种类型，你可以使用Collectors.collectingAndThen工厂方法返回的收集器 1234567Map&lt;Dish.Type, Dish&gt; mostCaloricByType = menu.stream() .collect(groupingBy( Dish::getType, collectingAndThen( maxBy(comparingInt(Dish::getCalories)), Optional::get) )); 这个工厂方法接受两个参数——要转换的收集器以及转换函数，并返回另一个收集器。 这个收集器相当于旧收集器的一个包装，collect操作的最后一步就是将返回值用转换函数做一个映射。 在这里，被包起来的收集器就是用maxBy建立的那个，而转换函数Optional::get则把返回的Optional中的值提取出来。 前面已经说过，这个操作放在这里是安全的，因为reducing收集器永远都不会返回Optional.empty()。 与 groupingBy 联合使用的其他收集器的例子 一般来说，通过groupingBy工厂方法的第二个参数传递的收集器将会对分到同一组中的所有流元素执行进一步归约操作。123// 对每一组Dish求和Map&lt;Dish.Type, Integer&gt; totalCaloriesByType = menu.stream().collect(groupingBy(Dish::getType, summingInt(Dish::getCalories))); 然而常常和groupingBy联合使用的另一个收集器是mapping方法生成的。这个方法接受两个参数：一个函数对流中的元素做变换，另一个则将变换的结果对象收集起来。其目的是在累加之前对每个输入元素应用一个映射函数，这样就可以让接受特定类型元素的收集器适应不同类型的对象。我们来看一个使用这个收集器的实际例子。比方说你想要知道，对于每种类型的Dish，菜单中都有哪些CaloricLevel。我们可以把groupingBy和mapping收集器结合起来，如下所示：123456Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType = menu.stream().collect( groupingBy(Dish::getType, mapping(dish -&gt; &#123; if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET; else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; &#125;, toSet()))); 这里，就像我们前面见到过的，传递给映射方法的转换函数将Dish映射成了它的CaloricLevel：生成的CaloricLevel流传递给一个toSet收集器，它和toList类似，不过是把流中的元素累积到一个Set而不是List中，以便仅保留各不相同的值。如先前的示例所示，这个映射收集器将会收集分组函数生成的各个子流中的元素1234567// 可以给它传递一个构造函数引用来要求 HashSetMap&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType = menu.stream().collect( groupingBy(Dish::getType, mapping(dish -&gt; &#123; if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET; else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; &#125;,toCollection(HashSet::new) ))); 分区 Optional null引用在历史上被引入到程序设计语言中，目的是为了表示变量值的缺失。 Java 8中引入了一个新的类java.util.Optional，对存在或缺失的变量值进行建模。 你可以使用静态工厂方法Optional.empty、 Optional.of以及Optional.ofNullable创建Optional对象。 Optional类支持多种方法，比如map、 flatMap、 filter，它们在概念上与Stream类中对应的方法十分相似。 使用Optional会迫使你更积极地解引用Optional对象，以应对变量值缺失的问题，最终，你能更有效地防止代码中出现不期而至的空指针异常。 使用Optional能帮助你设计更好的API，用户只需要阅读方法签名，就能了解该方法是否接受一个Optional类型的值。 能够显式的在方法签名上就表明返回值可能为 “空” (下文中的空都指 Optional.empty()) 增强了建模的表达能力 域模型中使用Optional，将允许缺失或者暂无定义的变量值用特殊的形式标记出来 约束调用方需判断才能使用, 但是这个并不是万能的, 例如集合类型的返回的时候, 就不用 Optional 包住 显得繁琐, 直接返回 new 空集合即可 如果Optional约束了返回值, 就在语义上表明该方法的返回值可能为空, 如果这个方法是初始化方法等具有特殊含义的方法, 不能返回空, 那就不能使用Optional 这样虽然代码安全了, 但是将该方法的语义混淆了.所以 不仅不能用 Optional, 还需在方法中加上 断言 以尽早暴露该方法的异常 虽然该方法在设计上是不能返回空, 但是还是有可能返回空, 为了健壮性, 还是需要调用方做非空检查 常用方法 of(T value) 封装对象到Optional内部, 若对象为null会立即抛出 NPE ofNullable(T value) 同上但是允许放入null get() 获取封装内的对象值, 但是若Optional为空 抛出 NoSuchElementException 异常 orElse(T other) 当Optional为空时提供默认值 orElseGet(Supplier&lt;? extends T&gt; other) 延迟提供默认值, 当为空执行传入的函数得到默认值 orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) 与 get() 一致,但是可以自定义异常 ifPresent(Consumer&lt;? super T&gt;) 当不为空执行传入的函数 Optional类和Stream接口的相似之处 map 使用 map 从 Optional 对象中提取和转换值: 可以将 Optional 看成只有一个元素的集合, 像Stream一样的使用 map 处理两个Optional对象: person.flatMap(p -&gt; car.map(c -&gt; findCheapestInsurance(p, c))); 原始的写法就是要判断两个对象同时存在(person 和 car )才调用find…方法 flatMap 流式获取 Optional 约束的属性 Optional&lt;String&gt; name = a.flatMap(A::getB).flatMap(B::getC).map(C::getName) 其中 C是B的成员属性, B是A的成员属性, 且都是 Optional 的, 如果直接使用 map 就会发生 Optional 嵌套, 所以需要 flatMap filter persion 存在且满足条件就返回自身否则返回空 person.filter(o -&gt; &quot;name&quot;.equals(o.getName())) Tips 注意: Optional 无法序列化, 也就是说不能作为 PO 的字段, 但是可以在get上下功夫: public Optional&lt;String&gt; getName(){return this.name} 异常与Optional的对比 当一个方法由于某些原因无法返回期望值, 常见的做法是抛出异常, 或者返回null(不建议). 但是这时候多了一个选择, 返回Optional 例如 Integer.parseInt() 方法 若参数字符串不合法就会抛出异常, 这时候就可以自己定义一个工具方法, catch住异常 返回 空 (如下 stringToInt 方法) 应该避免使用使用基础类型的 Optional 对象 OptionalInt OptionalLong OptionalDouble, 因为他们不支持 Stream 操作 即使 OptionalInt 能简化 Optional 实践:读取Properties某属性 从properties文件中读取某个属性, 正整数就返回该值, 否则返回0 12345678910111213141516171819202122232425262728// 原始写法public int readDuration(Properties props, String name) &#123; String value = props.getProperty(name); if (value != null) &#123; try &#123; int i = Integer.parseInt(value); if (i &gt; 0) &#123; return i; &#125; &#125; catch (NumberFormatException nfe) &#123; &#125; &#125; return 0;&#125;// 改进public static Optional&lt;Integer&gt; stringToInt(String s) &#123; try &#123; return Optional.of(Integer.parseInt(s)); &#125; catch (NumberFormatException e) &#123; return Optional.empty(); &#125;&#125;public int readDuration(Properties props, String name) &#123; return Optional.ofNullable(props.getProperty(name)) .flatMap(OptionalUtility::stringToInt) .filter(i -&gt; i &gt; 0) .orElse(0);&#125; 集合集合的Lambda迭代方式 参考博客: List、Map的循环迭代 对集合中的对象进行求和 时间处理Instant 暂时没有学会怎么用上 LocalDateTime 方便的新时间处理类, 用于替代Date 123456// LocalDateTime 获取毫秒以及秒 也可以手动指定中国的时区 ZoneOffset.of(\"+8\")ZonedDateTime zonedDateTime = datetime.atZone(ZoneOffset.systemDefault());Instant instant = zonedDateTime.toInstant();long seconds = instant.getEpochSecond(); long millis = instant.toEpochMilli();Date date = Date.from(instant);","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"},{"name":"Java8","slug":"Java8","permalink":"http://blog.kuangcp.top/tags/Java8/"}]},{"title":"JavaWeb性能调优","slug":"Memo-Java-AdvancedLearning-WebPerformance","date":"2018-12-13T08:02:57.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/12/13/Memo-Java-AdvancedLearning-WebPerformance/","link":"","permalink":"http://blog.kuangcp.top/2018/12/13/Memo-Java-AdvancedLearning-WebPerformance/","excerpt":"","text":"目录 start Java性能调优 Web性能 性能基准 测试工具 压力测试 ApacheBenchMark Jmeter wrk 数据库性能 MySQL 主从复制以及读写分离 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs JavaWeb性能调优 查看详情&gt;&gt; Web性能性能基准 参考博客: 系统吞吐量（TPS）、用户并发量、性能测试概念和公式 测试工具压力测试ApacheBenchMark 简称 ab 安装:sudo apt install apache2-utils 简单使用 ab -c 并发数 -n 总请求数 URL 查看文档:man ab 或 ab -h ab apt安装这个包即可apache2-utils Jmeter 具有图形化客户端 jmeter apache 下的开源压测工具 wrk Github地址参考博客: wrk 压力测试 http benchmark POST接口参考博客: 性能测试之－wrk(转) 需要手动编译安装 make 数据库性能MySQL主从复制以及读写分离 读写分离博客","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.kuangcp.top/categories/Java/"}],"tags":[{"name":"Performance","slug":"Performance","permalink":"http://blog.kuangcp.top/tags/Performance/"}]},{"title":"PythonGUI","slug":"Memo-Python-PythonGUI","date":"2018-12-13T08:02:20.000Z","updated":"2018-12-17T13:25:18.703Z","comments":true,"path":"2018/12/13/Memo-Python-PythonGUI/","link":"","permalink":"http://blog.kuangcp.top/2018/12/13/Memo-Python-PythonGUI/","excerpt":"","text":"目录 start 【GUI】 GTK3 Tkinter PyQt kivy wxPython 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 【GUI】GTK3 教程 | pygtkpygtk wiki 自从忘掉如何安装后, 就不会安装了!!! Tkinter 官网 | 官网教程 教程网 安装 python2: sudo apt install python-tk python3: sudo apt install python3-tk 引入 python2：import Tkinter | import Tkinter as tk | from Tkinter import * 但是python3.5的环境下，import tkinter 才是正确的 PyQtkivy 官网Kivy中文编程指南 wxPython 坑多","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.kuangcp.top/categories/Python/"}],"tags":[{"name":"GUI","slug":"GUI","permalink":"http://blog.kuangcp.top/tags/GUI/"}]},{"title":"PythonGame","slug":"Memo-Python-PythonGame","date":"2018-12-13T08:01:52.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/13/Memo-Python-PythonGame/","link":"","permalink":"http://blog.kuangcp.top/2018/12/13/Memo-Python-PythonGame/","excerpt":"","text":"目录 start pygame 安装 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs pygame安装python2 安装 pygame sudo apt install python-pygamepython3 安装 pygame sudo apt install python3-dev mercurial sudo apt install libsdl-image1.2-dev libsdl2-dev libsdl-ttf2.0-dev安装一些声音的功能 sudo apt install libsdl-mixer1.2-dev libimportmidi-dev sudo apt install libswscale-dev libsmpeg-dev libavformat-dev libavcode-dev sudo apt install python-numpy 执行这个安装pygame 如果必要换成 pip3 pip install --user hg+http://bitbucket.org/pygame/pygame我使用上面的方式安装报错，使用这个完成了安装 sudo pip install pygame 检验是否安装成功 import pygame 查看版本 pygame.ver","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.kuangcp.top/categories/Python/"}],"tags":[{"name":"Game","slug":"Game","permalink":"http://blog.kuangcp.top/tags/Game/"}]},{"title":"Python 基础","slug":"Memo-Python-Python","date":"2018-12-13T08:00:45.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/13/Memo-Python-Python/","link":"","permalink":"http://blog.kuangcp.top/2018/12/13/Memo-Python-Python/","excerpt":"","text":"目录 start Python 简介 关于Python2与3的使用 安装配置 Docker安装 sys.path 基础 代码风格 包 基础语法 基础数据类型 内置模块 http virtualenv pip Requirements files 发布包到 pypi 变量 基本运行结构 序列 列表 元组 字符串 字符串编码问题(python2问题) 字典（键值对） 运算符 模块 输入输出 输入 输出 读取命令行参数 docopt Python Fire 函数 类 继承 异常 文件操作 JSON conf或者ini 测试 数据库 MySQL Redis 部署 Docker部署 绘图 matplotlib 常见函数 常见库 内置库 时间处理 三方库 QT 目录 end|2018-12-14 20:38| 码云 | CSDN | OSChina | cnblogs Python Official SiteDoc: Python2 | Doc: Python3 Python初学者（零基础学习Python、Python入门）书籍、视频、资料、社区推荐参考博客: Python3的主要应用 Python中的多态 python输出带颜色的字体 Anaconda一站式集成环境 python-gtk3 python-gtk3的开发 httpie 好用的类curl工具 文档 一译翻译了大量Python文档 简介关于Python2与3的使用 摘自 Python核心编程 第三版 Wesley Chun著 print 变为 print() 默认字符的编码是 Unicode 增加单类 类型 更新异常的语法 更新了整数 迭代无处不在 列出所有已安装模块 pydoc pydoc3 安装配置Debian系安装3.6 sudo add-apt-repository ppa:jonathonf/python-3.6 sudo apt update sudo apt install python3.6 Docker安装 docker hub sys.path Doc: Python path sys.path 是 指定模块的搜索路径的字符串列表。类似于Java的 ClassPath, Go的 GOPATH, 让解释器知道去哪找包 查看系统的 sys.path 进入交互解释器12import sysprint(\"\\n\".join(sys.path)) 修改sys.path 代码中直接添加, 执行就生效, 程序结束就失效 123456789# 假如有如下两个文件 在不同的包下# /src/configs/config.py# /src/common/Database.pyparent_path = os.path.dirname(sys.path[0])# 避免重复添加if parent_path not in sys.path: sys.path.append(parent_path)import configs.config 添加 *.pth 文件 在 /usr/local/lib/ 目录下有众多 Python 版本 例如在 2.7 添加 python2.7/site-packages/test.pth 写入工程目录即可 python3.x 则是在 dist-packages 目录下 修改环境变量 修改或添加 环境变量 PYTHONPATH 路径用分号分隔 基础代码风格 PEP8 官方建议 一行只写一句 表达式尽量不要省略括号，有助于理解 函数的行数不要超过100行 尽量使用系统函数 尽量使用局部变量，不要使用全局 循环，分支，最好不要超过5层 尽量减少否定的条件语句 对输入的数据进行合法性检查 巨坑: tab和空格不能混用,如果你复制别人的代码是tab,自己敲空格,就会缩进错误!!!!, 天灭tab空格保平安, 要不是kate编辑器显示了tab字符,找半天都不知道错在哪 Google 开源项目风格指南 (中文版) import this 就会输出Zen Of Python | 官方文档1234567891011121314151617181920优美胜于丑陋（Python 以编写优美的代码为目标）明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）可读性很重要（优美的代码是可读的）即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）当存在多种可能，不要尝试去猜测而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） 包 official tutorial When importing the package, Python searches through the directories on sys.path looking for the package subdirectory. 注意不能出现 import 循环依赖 A.py import B.py then B.py import A.py 基础语法 缩进来表示代码块的嵌套关系 单行注释：# 多行注释： &quot;&quot;&quot; &quot;&quot;&quot; 空行的重要性，代码段之间有空行，Python之禅 基础数据类型 数值类型 整数 各种进制 0 八 0x 十六 0b 二 浮点数 1.2e2 13.34e-2 复数 3+4j 0.1-0.5j 布尔型 0或0.0 :看成false &quot;&quot; &#39;&#39; :false () [] {} :false 字符串 单引号 双引号: 单行字符串 三引号 多行字符串 空值 None 内置模块python -m module_name http 快速启动一个 HTTP Web 服务器 http.server [port] virtualenv 廖雪峰 virtualenv 虽然也可以用apt安装 python-venv, 但是最好不要这样,避免后续模块升级后不必要的冲突 创建环境 python3 -m venv web 或者 virtualenv --no-site-packages web 不将系统中安装的包带入该环境 启动环境 source web/bin/activate 在环境中使用的pip python 都是环境中的, 其实就是修改了系统的环境变量指向 停用环境 deactivate pip pip | doc | guide 作为Python的包管理器, 包的可执行文件默认在 /usr/local/bin 目录下(全局) 如果安装时加了该参数 –user 就是安装在 ~/.local/bin 目录下 升级pip python -m pip install --upgrade pip 也可以这样使用 python -m pip install xxx 安装指定版本的包 install name==version Requirements files pip官方文档 Requirements files 导出 pip freeze &gt; requirements.txt 这个命令会将当前环境安装的包全部列出来, 适合env环境下使用 如果没有使用虚拟环境, 然后只想导出某项目的依赖 Github pipreqs 安装 : pip install pipreqs 然后 pipreqs /path/to/project 使用 pip install -r requirements.txt 发布包到 pypi Official : about package edit $HOME/.pypirc to save authorization info 123[pypi]username = &lt;username&gt;password = &lt;password&gt; pip3 install wheel twine rm -rf dist build *.egg-info python3 setup.py bdist_wheel twine upload dist/* 可以参考该项目: 终端内使用百度翻译 变量 局部变量： 全局变量：定义在函数外的变量，也称公用变量，函数中 global x 声明引用全局变量x基本运行结构 输入输出： input(“”) 默认当成字符串输入 数值：int() 强转一下 print(“”) 输出不带换行 print(‘’, ‘’, end=’’) 选择： if elif else for循环： for in while 例如：for i in range(1,10,2): 范围 [1,10) 增量为2 pass 语句，当某个子句没有任何操作，，用pass保持程序结构完整性 不影响下一句 不像continue while 循环; while True:` while ‘2’ in nums: while num&lt;2:` while 列表: 直到列表为空退出循环 12345if (b==0) and (a==1) : pass print(\"pass\")else: print(\"Hi\") 序列序列通用操作（包含：字符串，列表，元组） ​索引，从左至右：0,1,2...n 从右至左：-1,-2...-n 切片（截取序列的部分） temp[:] 返回一个副本 temp[2:4]就是[2,4) temp[1:]1到最后 temp[-3:] [-3,-1] temp[:4] [0,4) temp[:-3] [0,-3] 加：lista+listb 直接连接 乘：lista*4 判断是否存在：in not int len() min() max() sum() 要求元素全是数值 列表 元素可包含 字符串，浮点，整型，列表，布尔 操作： 增加 + ，append()/extend()尾部加入元素/列表 insert(index, &quot;&quot;) 元素插入到任意位置,其后元素后移 检索 count() in 删除 ：del list[2]/ remove(&quot;apple&quot;) /pop(index) index为空指最后一个 永久性排序：sort() a-z sort(reverse=True) z-a 列表全是字符串才可 临时性排序：sorted() 也可以使用上面的参数 列表全是字符串才可 永久性的逆序列表:reverse() 类似数组的操作，例如声明数组：参考博客 原始的定义就是 lists = [1, 2, 4] 若要定义连续列表 lists = range(0, 100) 得到的是range对象不是列表对象 若要定义大小1000全为0列表 lists = [0 for x in range(0, 1000)] 二维数组的定义： 原始： lists = [[1, 2], [3, 4]] 仿造一维的定义： lists = [[0 for x in range(10)] for y in range(10)] 10*10 初始为0的列表 简便但是不可行的方法： lists = [[0]10]10 这是个坑， 只是声明了一维数组，然后多次引用， 虽然看起来是二维， 引用数据就会发现是一维 元组 元组和列表类似但是元组是创建不可更改的 和列表相比，相同点：按定义的顺序排序，负索引一致，可以使用分片 不同点：元组使用的是()，不能增加删除元素，没有index方法但是有in，可以在字典中作为键,列表不可以 由于具有写保护，代码安全，操作速度略快列表 操作： 访问： 和列表一样的索引和分片， 连接：+ 连接得到新的元组 删除：del 删除整个元组 字符串 str() 将对象转化成字符串 （注：Python中不能像Java一样字符串和数值直接+） repr() 注意和str()的区别 r&quot;d:\\python27\\&quot; r前缀表示转义字符看成普通字符 因为Python字符串实现是类似字符数组，temp = &quot;python&quot; temp[0] 结果：p temp.index(&quot;p&quot;) 结果是：0 操作： index(&#39;s&#39;) 找到s字符的下标 find(&#39;s&#39;,[start,end]) 找s的下标，只有一个整数参数则是start replace(&#39;s&#39;,&#39;v&#39;) 替换 count(&#39;sd&#39;) 计数 split(&#39;&#39;) 正则切分 空参数默认是空格 join(&#39;&#39;) 列表转化成字符串的方法 cmp(str1,str2) 比较两个字符串是否相等 + 进行拼接 可以拼接字符串 列表 a in b 判断a是否在b里存在 * 重复序列 例如 print &quot;-&quot;*20 就会输出20个 - b = &quot;www.github.com&quot; c = b.split(&quot;.&quot;) &quot;#&quot;.join(c) 实现了将字符串的 . 换成了# &quot;i am %s %d&quot; % (&quot;python&quot;,67)%s %d %f 和C语言一样占位符 新的方式 &quot;i am {0} {1} ..&quot;.format(23,&quot;ret&quot;) 或者&quot;i am {name} {age} ..&quot;.format(age=23,name=&quot;ret&quot;) 字典方式 title() 首字母大写 字符串，列表，元组相互转换： 字符串-列表 ： list(“python”) 字符串-元组 ： tuple(“python”) 列表或元组-字符串 join(obj) 参数是列表或元组类型，其元素只能是字符串类型 字符串编码问题(python2问题) Python 3的bytes/str之别 str和bytes的关系 解码 encode(&quot;utf-8&quot;)： str -&gt; bytes 编码 decode()： bytes -&gt; str 123# coding:utf-8unicode_str = unicode('使用',encoding='utf-8')print unicode_str.encode('utf-8') 12import codecscodecs.open('filename',encoding='utf-8') 因为文件不是UTF8：UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0xb9 in position 2: invalid start byte 字典（键值对） 通过用空间来换取时间，与列表相比，键的增加不影响查找插入速度，需要占用大量内存 特性： 值是可以是任意的，甚至是字典嵌套 键必须不可变，只能由 数值，字符串，元组，不能用列表 操作： 定义字典 dict={} 添加 ： dict[&#39;a&#39;] = 2323 返回所有key：keys() 查询是否有这个键 ：has_key() get() keys() values() 转化元组并返回 ：items() 删除指定键：del() del dict[&#39;name&#39;] 删除所有：clear() 删除指定键并返回值 ：pop() 合并另一个字典：update() in 嵌套： 字典套列表 {&#39;d&#39;:[&#39;we&#39;,&#39;e&#39;]} 列表套字典，当成普通类型包含即可 字典套字典 [ ] 字典的排序问题 运算符 算术运算符 加减一样，* 乘,不仅可以用于数字，还可以用于字符串 ，/ 除，和Java不一样，整数相除也会得到浮点数 // 取整除，得到商的整数部分 ，% 取余数 ，** 幂运算 可以用来开根 关系运算符 都是和Java一致 逻辑运算符 and or not 身份运算符 is : a is b 就是比较 id(a) id(b) 相同则是返回1 is not 比较id 不相同返回1 位运算符 &lt;&lt; &gt;&gt; 左右移 &amp; |按位与或 ^ ~ 按位异或 按位翻转 算术运算符优先级 ** / // % + // 取整数部分除法 ** 幂运算 转义字符： \\a 响铃 \\b 退格 backspace \\000 空 \\f 换页 \\ 续行符（行尾） 模块 参考博客 关于同级，子级目录是比较方便的，涉及到上级目录的就麻烦点了 输入输出输入输出 python3 print(&#39;Hi&#39;) 格式化输出 print(&quot;%10s - %-10s&quot;%(name, addr)) print会默认追加换行符, 取消需要参数 end=&#39;&#39;1234def show_help(): start='\\033[0;32m' end='\\033[0m' print(\"%-26s %-20s\"%(start+\"-h\"+end, \"帮助\")) python2 print &#39;Hi&#39; 读取命令行参数 参考博客 只有输入参数，没有选项1234import sysprint(\"脚本名：\", sys.argv[0])for i in range(1, len(sys.argv)): print(\"参数\", i, sys.argv[i]) python tree.py hi op 顺序是python，第一个参数是文件，之后才是别的参数 结果&gt;&gt; 脚本名 tree.py 参数1 hi 参数2 op 有选项getopt.getopt(args, options[, long_options])123import sys, getoptopts, args = getopt.getopt(sys.argv[1:], \"hi:o:\")for op, value in opts: sys.argv[1:]为要处理的参数列表，sys.argv[0]为脚本名，所以用sys.argv[1:]过滤掉脚本名。 &quot;hi:o:&quot;: 当一个选项只是表示开关状态时，即后面不带附加参数时，在分析串中写入选项字符。当选项后面是带一个附加参数时，在分析串中写入选项字符同时后面加一个”:”号。 所以”hi:o:”就表示”h”是一个开关选项(单单的-h)；”i:”和”o:”则表示后面应该带一个参数。 调用getopt函数。函数返回两个列表：opts和args。opts为分析出的格式信息。args为不属于格式信息的剩余的命令行参数。 opts是一个两元组的列表。每个元素为：(选项串,附加参数)。如果没有附加参数则为空串’’。 getopt函数的第三个参数[, long_options]为可选的长选项参数，上面例子中的都为短选项(如-i -o) 长选项格式举例: --version --file=error.txt 让一个脚本同时支持短选项和长选项 getopt.getopt(sys.argv[1:], &quot;hi:o:&quot;, [&quot;version&quot;, &quot;file=&quot;]) docopt Github地址 | 在脚本头部添加文档来实现读取参数的便捷会读取输入返回字典对象,可以很方便的读取输入的参数,但是需要书写大量文档, 适合参数比较多的时候,一眼过去简洁明了 Python Fire Github地址快速的简洁的生成CLI不过要自己书写帮助文档输出,小量参数的话,开发十分的便利 可以和类一起,也可以和方法一起 12345678import firedef main(action=None): print(action) if action == '-h': show_help() fire.Fire(main)# 使用时 py filename.py -h 函数 形参赋值传递方式 按位置 就是直接用看起来和Java一样，但不是按类型和位置，只是位置 按指定名称 调用的时候 create(name=&#39;df&#39;) 缺省默认值（参数缺省之后，调用可以不传这个参数，否则必须要传） def create(name=&#39;df&#39;) 列表类型，不想形参改变实参 传递副本过去即可 list[:] 以下两种情况（* 和 **），都必须放在形参列表的最后 (两者同时使用时：* 只能在 ** 前 ) 多个实参 create(age, *name) create(12, &#39;s&#39;,&#39;d&#39;) 所以这是名为name的元组 不能指定没有的名称 错误：create(12，d=2, 2,3,4) 多个指定名称实参 create(age, **name) create(12, name=&#39;d&#39;, lo=23) 必须要指定名称 这是名为name的键值对字典 错误：create(12,d=23,3,3,3) 注意： def hi(name, age=0, *names, **s) hi(&#39;d&#39;, 23,34, d=6) age会被赋值23 def hi(name, *names, age=0, **s) hi(&#39;d&#39;, 23,34, d=6) 这样写age就不会赋值，除非指定名称 age=23 返回值 返不返回 看需求 没有像Java一样的强制性约束类型 将函数写在一个py文件里，然后导入 import 文件名，名曰导入模块 还可以加别名 import creat as fun 给模块加别名 导入指定的函数 from create import create_aliens, type_button 多个就，分隔 同理 as给函数加别名 * 通配所有 注意：递归深度，Python中递归默认深度是 989， 要么更改实现，要么就 sys.setrecursionlimit(10000000) 参考博客: Magic Method __xxx__ 方法 类Python 不存在多态，存在鸭子类型 博客介绍 | python中的多态与鸭子类型 写在一个py文件里，默认构造器，可以加参数 def __init__(self): 属性： 实例属性 形如self.name，在任何方法中声明过即可 类属性 不加self前缀，__name私有的类属性， 类不能访问对象属性 类属性可以修改，但是实际上只能修改实例属性（这个修改只是声明了同名的实例属性，引用的时候就会覆盖类属性，看起来就是修改了 可以删除实例属性，然后就能看到原有的类属性了 12345class People: name = 'md'p = People()p.name = 'gh' # 声明了实例属性覆盖了类属性del p.name # 删除实例属性，恢复类属性引用 方法： 对象方法，类方法，静态方法 对象方法，同样的 __开头是私有的，只能在对象的公有方法中self.__引用 静态方法，之中只能引用类成员，不能访问对象成员 构造函数和析构函数： def __init__(self) def __del__(self) 123456789101112class Person: # 对象方法， 将对象作为参数self传进去 def say(self): print('hi') # 静态方法 @staticmethod def drink(): print('static method') # 类方法，将类作为参数cls传进去 @classmethod def eat(cls): print('class method') self 代表了自身引用 类似Java的this 特别不舒服 init 这种命名 不像Java的构造函数重载，这个就是后面覆盖前面定义的init 不管形参列表 因为不存在重载，就是说不能多个构造函数的书写了。。。 导入和函数一样 注意继承中类的依赖 继承 Python是支持多重继承的 同文件 父类定义要在子类之前 父类的构造器不会自动调用，需要显式使用父类构造器： 2.×版本： super(子类名, self).__init__(参数) 3.×版本： super().__init__(参数) 或者 父类名.__init__() 重写父类方法：只需要定义一个和父类方法同名的方法即可，因为没有多态，覆盖时形参不作考虑 多态： 方法重载： 子类覆盖父类的方法 运算符重载： 加__add__(self, x) 减__sub__(self, x) 异常12345678try: print(5/0)except ZeroDivisionError as err: print(\"0 不能做除数\", err)else: print(\"成功\")finally: print('finally') 基本语法 try except else finally else是无异常执行 有异常就执行 except， except 超类Exception，也可以多个except （和Java一致） 最终执行finally 和 Java的结构是一致的 | except 分句使用形式 | 说明 || :— | :—||except | 捕获所有类型||except name| 只捕获指定类型||except name, value|捕获指定类型，并获得抛出的异常对象||except (name1, name2)|捕获列出的异常||except (name1, name2), value |捕获列出的异常，获得抛出的异常对象| raise 语句 和Java的throw关键字 一致 ， 不过raise只是抛出一个通用异常类型 Exception dir(exceptions) 查看所有异常类型 raise name 手动引发异常 raise name,data 传递一个附加的数据 同样的也是可以自定义异常类型的，class MyExcetion(Exception): with 语句 在异常处理中，将 try except finally 关键字以及与资源分配释放相关的代码省略掉。 文件打开 with open(&#39;a.py&#39;) as files: 常见异常类 描述 NameError/UnboundLocalError 引用不存在的变量/或者引用在声明之前 ZeroDivisionError 除数为0 SyntaxError 语法错误 IndexError 索引错误 KeyError 使用不存在的字典关键字 IOError 输入输出错误 ValueError 搜索列表中不存在的值 AtrributeError 调用不存在的方法 TypeError 未强制转换就混用数据类型 EOPError 文件结束标识错误 文件操作 注意路径，Windows系统中要使用反斜杠 \\ 最简单：file = open(&#39;&#39;) 只读打开 使用with来操作 好处是Python自动关闭文件 12with open('filename') as name: name.read() 为写打开新文本文件只读 file = open(&#39;a.txt&#39;,&#39;w+&#39;[,coding=&#39;utf-8&#39;]) 打开删空 file.write(&#39;&#39;) os模块 os.rename(&#39;filename1&#39;,&#39;filename2&#39;) mv os.remove(&#39;filename.py&#39;) rm os.listdir(path) ls os.getcwd() pwd os.makedirs(r&#39;path&#39;) mkdir os.chdir(&#39;&#39;) 改变一个目录 os.rmdir(&#39;&#39;) 删除该目录，前提是空目录 os.path模块 abspath(‘’) 获取绝对路径 exists(‘’) 是否存在 isdir(‘’) 是否是一个目录 isfile(‘’) 是否是文件 islink(‘’) 是否是软链接硬链接文件 getsize() 获取文件尺寸 shutil模块 dir() 复制单个文件 shultil.copytree(r’’,r’’) 复制目录树 b 表示字节流（二进制文件） 不加表示字符流（文本文件） 字符流方式 意义 当存在 当不存在 r 只读打开 打开 返回空指针 w 只写打开新 打开删空 新建打开 a 追加打开 打开 新建打开 r+ 读打开可写 打开 返回空指针 w+ 写打开新可读 打开删空 新建打开 a+ 追加打开可读 打开 新建打开 字节流方式 意义 当存在 当不存在 rb 只读打开 打开 返回空指针 wb 只写打开新 打开删空 新建打开 ab 追加打开 打开 新建打开 rb+ 读打开可写 打开 返回空指针 wb+ 写打开新可读 打开删空 新建打开 ab+ 追加打开可读 打开 新建打开 JSON12345678910111213141516import jsonfile_name='result.json'def write_json(): global file_name person = &#123;'color': 'green', 'age': '23'&#125; with open(file_name, 'w') as o: json.dump(person, o)def read_json(): global file_name with open(file_name) as file: datas = json.load(file) for data in datas : # 引用的时候就当做是字典 print(data, datas[data]) conf或者ini 参考博客: python操作ini文件 123456789101112import osfrom configparser import ConfigParserpath = os.path.split(os.path.realpath(__file__))[0]mainConf = path + '/main.conf'cf = ConfigParser()cf.read(mainConf)host = cf.get('redis', 'host')# 写 但是要有write节点cf.set('write', 'add', '12')cf.write(open(mainConf, 'r+')) 对应的conf12[redis]host=127.0.0.1 测试 文件名test开头就当做是测试类，不会直接运行 类继承 unittest.TestCase, 所有test_开头的方法都将自动运行 断言 self.assertEqual assertNotEquals assertIn(item, list) 直接运行 unittest.main() 输出结果，. 测试通过 E 测试运行错误 F 测试断言不通过 数据库MySQL python3环境下： sudo apt install python3-mysqldb sudo apt install libmysqlclient-dev sudo pip install mysql-python Redis安装模块 python2 sudo pip install redis python3 sudo pip3 install redis _使用_ 使用的接口方法是和redis一样的 Redis笔记传送门 部署Docker部署 参考官方文档Create a Dockerfile in your Python app project123456FROM python:3WORKDIR /usr/src/appCOPY requirements.txt ./RUN pip install --no-cache-dir -r requirements.txtCOPY . .CMD [ \"python\", \"./your-daemon-or-script.py\" ] or (if you need to use Python 2)123456FROM python:2WORKDIR /usr/src/appCOPY requirements.txt ./RUN pip install --no-cache-dir -r requirements.txtCOPY . .CMD [ \"python\", \"./your-daemon-or-script.py\" ] You can then build and run the Docker image: $ docker build -t my-python-app . $ docker run -it –rm –name my-running-app my-python-app 绘图matplotlibpython 3.5 安装123sudo apt install python3-matplotlib sudo apt install python3.5-dev python3.5-tk tk-devsudo apt install libfreetype6-dev g++ 常见函数 id() 查看内存地址 help(方法名) 展示方法的说明文档 dir(对象) 展示对象的方法API 常见库内置库 codecs 编码 os 操作系统相关API 获取脚本绝对路径 os.path.split(os.path.realpath(__file__))[0] 获取用户目录 os.environ[&#39;HOME&#39;] | os.path.expandvars(&#39;$HOME&#39;) | os.path.expanduser(&#39;~&#39;) platform 操作系统信息 获取当前操作系统名称 platform.system() subprocess 代码 时间处理time 参考博客: Python 日期和时间 三方库 redis 和Redis命令完美融合 httpie HTTP方便的交互 doc POST时 特别注意:参数==值 python-excel python-docx 文档 chef 文档 Use the python resource to execute scripts using the Python interpreter QT 在Terminal中输入:sudo apt-get install qt4-dev-tools qt4-doc qt4-qtconfig qt4-demos qt4-designer12345qt4-dev-tools 中包括了Qt Assistant,Qt Linguist,Qt Creatorqt4-doc 这个是帮助文档qt4-qtconfig Qt的配置工具,这个装好默认好qt4-demos 官方的一些Demoqt4-designer 可视化窗体设置工具","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.kuangcp.top/categories/Python/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.kuangcp.top/tags/基础/"}]},{"title":"PythonConcurrent.md","slug":"Memo-Python-PythonConcurrent","date":"2018-12-13T08:00:40.000Z","updated":"2018-12-17T13:25:18.707Z","comments":true,"path":"2018/12/13/Memo-Python-PythonConcurrent/","link":"","permalink":"http://blog.kuangcp.top/2018/12/13/Memo-Python-PythonConcurrent/","excerpt":"","text":"目录 start Concurrent GIL 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs ConcurrentGIL Python的GIL是什么鬼，多线程性能究竟如何讲解了GIL以及使用其他并发库","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.kuangcp.top/categories/Python/"}],"tags":[{"name":"Concurrent","slug":"Concurrent","permalink":"http://blog.kuangcp.top/tags/Concurrent/"}]},{"title":"2018-3-15-install-deepin.md","slug":"Memo-MyBlog-2018-3-15-install-deepin","date":"2018-03-15T08:11:42.000Z","updated":"2018-12-17T13:25:18.711Z","comments":true,"path":"2018/03/15/Memo-MyBlog-2018-3-15-install-deepin/","link":"","permalink":"http://blog.kuangcp.top/2018/03/15/Memo-MyBlog-2018-3-15-install-deepin/","excerpt":"","text":"目录 start 在公司电脑上安装deepin 目录 end|2018-12-13 12:06| 码云 | CSDN | OSChina | cnblogs 在公司电脑上安装deepin 由于是全新的电脑, 默认开机在配置Windows10, 然后也配置用了下windows10, 被他的卡顿吓到了 前奏: 先进Windows10 关闭快速启动(电源设置, 电源按钮设置这里), 进入BIOS 关闭安全启动, 选择引导为完全关闭UEFI 只设置为Legacy 由于习惯Deepin, 所以一直备有一个Deepin15.4的安装盘, 然后试了一下, 发现U盘能进去, 点击安装Deepin就黑屏了 没有然后了 然后搜了一波一闪而过的报错信息, 朋友也和我提到了可能是内核版本太高 问题相关 然后就刻录了Deepin15.1的启动盘, 最终完美安装 分区: 因为该电脑是Intel的128固态加上1T的机械, 所以尝试了只在机械上放 / 和 /home失败后 尝试在固态上压缩了500M出来, 挂载 /boot 然后在机械上挂载 / 和 /home 选择引导时选择的固态 进入系统后, apt update apt upgrade 进行升级 其中提到的所有询问, 都是默认, 然后说grub引导需要升级, 需要选引导设备, 选之前分的500M的那个区即可 然后就发现升级完进不去桌面了, 能进tty, 密码是正确的, 但是图形化窗口进不去了 解决方案 sudo apt-get update &amp;&amp; sudo apt-get -f install &amp;&amp; sudo apt-get dist-upgrade &amp;&amp; sudo apt-get install dde 社区帖子 进去之后分辨率很低, 搜了一波怎么改, 然后说要自己用 xrandr 等命令来设置 1080P 在社区的官方帖子上找到了解决方案, 装个驱动就完了 官方社区 最后完美运行了, 和Windows10也完美兼容, 启动的话就需要进BIOS进行设置, 和我笔记本一样的方式, 开启UEFI 关闭 Legacy 就是默认进 Windows10 关闭UEFI 就是默认进Deepin","categories":[{"name":"Blog","slug":"Blog","permalink":"http://blog.kuangcp.top/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://blog.kuangcp.top/tags/Blog/"},{"name":"工具使用经验","slug":"工具使用经验","permalink":"http://blog.kuangcp.top/tags/工具使用经验/"}]}]}