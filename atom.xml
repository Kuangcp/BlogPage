<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kuangcp Blog</title>
  
  <subtitle>Javaer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.kuangcp.top/"/>
  <updated>2018-12-17T13:25:18.711Z</updated>
  <id>http://blog.kuangcp.top/</id>
  
  <author>
    <name>Kuangcp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ProgramThinking</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-ProgramThinking/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-ProgramThinking/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#开发思想">开发思想</a><ol><li><a href="#抽象">抽象</a></li><li><a href="#命令式编程和响应式编程">命令式编程和响应式编程</a><ol><li><a href="#命令式编程">命令式编程</a></li><li><a href="#响应式编程">响应式编程</a></li></ol></li><li><a href="#面向过程">面向过程</a></li><li><a href="#面向对象">面向对象</a><ol><li><a href="#oop">OOP</a></li><li><a href="#面向过程和面向对象的对比">面向过程和面向对象的对比</a></li></ol></li><li><a href="#ddd-领域驱动设计">DDD 领域驱动设计</a><ol><li><a href="#聚合">聚合</a></li><li><a href="#参考实践项目">参考实践项目</a></li></ol></li><li><a href="#数据的操作">数据的操作</a><ol><li><a href="#curd">CURD</a></li><li><a href="#cqrs">CQRS</a></li></ol></li><li><a href="#组件模型">组件模型</a><ol><li><a href="#soa">SOA</a></li><li><a href="#msa">MSA</a></li></ol></li><li><a href="#other">Other</a><ol><li><a href="#国际化的配置">国际化的配置</a></li></ol></li></ol></li><li><a href="#设计软件的方法">设计软件的方法</a><ol><li><a href="#契约式设计">契约式设计</a></li><li><a href="#精益思想">精益思想</a></li></ol></li><li><a href="#编程习惯">编程习惯</a><ol><li><a href="#晓风轻的经验">晓风轻的经验</a><ol><li><a href="#接口定义">接口定义</a></li><li><a href="#日志建议">日志建议</a></li><li><a href="#异常处理">异常处理</a></li><li><a href="#工具类规范">工具类规范</a></li></ol></li><li><a href="#代码质量分析">代码质量分析</a><ol><li><a href="#checkstyle">Checkstyle</a></li><li><a href="#findbugs">FindBugs</a></li><li><a href="#阿里巴巴的代码检查">阿里巴巴的代码检查</a></li></ol></li><li><a href="#配置文件">配置文件</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="开发思想"><a href="#开发思想" class="headerlink" title="开发思想"></a>开发思想</h1><blockquote><p>有关开发的理论性思想,编写,测试,部署等</p></blockquote><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513062&amp;idx=1&amp;sn=a3b4a2962d8e82471192d9606b0a2722&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:抽象：程序员必备的能力 </a></li></ul><blockquote><p>稍微注意一下就会发现: 抽象层次越高，接口的语意就越模糊，适用的范围就越广，到最后就会变成数学模型或者概念。<br>但是抽象成数学模型和算法通常是可遇而不可求的， 这种情况下，我们需要退而求其次，试图抽象成若干个正交的概念，来降低复杂度。<br>你在处理x轴相关的事情时，不用考虑其他的y和z 相关的东西，因为你知道他们不会受到影响， 这样问题的复杂度就从3维一下子下降到1维！更容易把握了。<br>如果你说了，我的整个系统还没法抽象成正交的概念， 那只好再退一步，在局部使用接口。<br>其实 一组定义良好的接口一定是正交的，不然的话接口之间的依赖就会让实现非常麻烦。 </p><blockquote><p>在著名的《设计模式》一书中，其实在反复强调一点: 发现变化并且封装变化，针对接口编程而不是实现编程。 很多人看书是只关注具体的模式，而忽略了模式的本质目的。  </p></blockquote></blockquote><p>抽象能力的高低，很大程度上反映了一个程序员的能力的高低</p><ul><li><a href="http://ifeve.com/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6%e4%b8%ad%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%a5%bd%e5%a4%84%e4%b8%8e%e9%97%ae%e9%a2%98-%e4%bc%aa%e5%85%b1%e4%ba%ab%e5%ae%9e%e4%be%8b%e5%88%86%e6%9e%90/" target="_blank" rel="noopener">计算机科学中抽象的好处与问题—伪共享实例分析</a><code>计算机科学中的任何问题都可以通过加上一层间接层来解决，这是很正确的，但是也正是因为一层一层的抽象和包装，导致出了问题后很难定位，你都不知道问题究竟是出现在哪一层。所以要想提高技术水平不仅要知其然（看得见最顶层的包装）也要知其所以然（看得见底层的包装），每一层如果都懂或者说了解一些，那么出了问题很大程度上都可以凭直觉定位，即使不能凭直觉也可以通过各种手段debug，只会最顶层的抽象很多时候就只能望bug兴叹了。</code></li></ul><h2 id="命令式编程和响应式编程"><a href="#命令式编程和响应式编程" class="headerlink" title="命令式编程和响应式编程"></a>命令式编程和响应式编程</h2><h3 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h3><blockquote><p>编写改变状态的一条条命令</p></blockquote><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><blockquote><p><a href="http://reactivex.io/intro.html" target="_blank" rel="noopener">ReactiveX</a></p></blockquote><p>组合异步的序列<br>设计模式是 观察者模式的扩展, 数据结构是序列串流, 避免了并发, 是非阻塞的</p><p>数据流驱动</p><p>异步</p><ul><li>非阻塞<ul><li>不是 (同步非阻塞 : 当时不阻塞后续回调) 而是异步</li></ul></li></ul><p>多路复用</p><hr><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><blockquote><p>只有数据和函数, 使用函数改变数据状态</p></blockquote><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote><p>OO  Object Oriented</p></blockquote><blockquote><p><a href="http://www.jdon.com/48231" target="_blank" rel="noopener">参考博客: 再见面向对象编程？</a></p></blockquote><blockquote><p>思考:</p><ul><li>遇到需求时, 先分析需要哪些独立的实体, 然后分析用户的行为, 行为就是API</li><li>实体的基本属性和行为确定好, 并且确定好各自的生命周期(一般是属性, 状态的变化)</li><li>并且要注意设计时要尽量解耦, 即使需求上是和时间, 天气, 等一些外部状态影响的, 但是也应该在此之上抽象, 解耦, 方便测试和开发<blockquote><ul><li>例如 <code>活动</code> 具有 开始时间和结束时间 的需求, 如果只用时间去设计行为的话, 测试的时候就需要去模拟那些时间, 如果引入<code>状态</code>这个属性(开启,关闭)</li><li>就可以方便的调试了, 只需更改这个状态即可控制 活动 这个对象的行为, 当然, 变化的时间也是通过控制 <code>状态</code> 来控制 活动 的</li></ul></blockquote></li></ul></blockquote><p><code>编写出完成需求的代码不难, 难的是写出, 优雅, 简洁, 设计良好, 可读性, 扩展性高的代码</code></p><h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener">维基 OOP</a> | <a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">中文版</a></p></blockquote><h3 id="面向过程和面向对象的对比"><a href="#面向过程和面向对象的对比" class="headerlink" title="面向过程和面向对象的对比"></a>面向过程和面向对象的对比</h3><blockquote><p>示例 把大象塞进冰箱:</p><blockquote><p>面向过程, 冰箱开门() 冰箱装进( 大象) 冰箱关门()<br>面向对象 冰箱.开门().装入(大象).关门()</p></blockquote></blockquote><ul><li>面向过程<ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展</li></ul></li><li>面向对象    <ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul></li></ul><hr><h2 id="DDD-领域驱动设计"><a href="#DDD-领域驱动设计" class="headerlink" title="DDD 领域驱动设计"></a>DDD 领域驱动设计</h2><blockquote><p><a href="http://www.jdon.com/ddd.html" target="_blank" rel="noopener">领域驱动设计(DDD:Domain-Driven Design)</a><code>入门贴</code></p></blockquote><blockquote><p><a href="http://ishare.iask.sina.com.cn/f/69200951.html" target="_blank" rel="noopener">领域驱动设计 软件核心复杂性应对之道 Eric J. Evans 在线阅读</a><br><a href="http://www.infoq.com/cn/minibooks/domain-driven-design-quickly" target="_blank" rel="noopener">领域驱动设计精简版 </a></p></blockquote><blockquote><p><a href="http://kb.cnblogs.com/page/117717/" target="_blank" rel="noopener">参考博客</a> | <a href="http://www.cnblogs.com/netfocus/p/3307971.html" target="_blank" rel="noopener">讨论</a> | <a href="http://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html" target="_blank" rel="noopener">基础</a></p></blockquote><blockquote><p><a href="http://www.cnblogs.com/netfocus/archive/2012/09/08/2676985.html" target="_blank" rel="noopener">参考博客: 危险的DDD聚合根</a> 初步感受是DDD禁不起变化, 必须要在起初就设计好一个完备的体系<br><a href="http://www.jdon.com/47313" target="_blank" rel="noopener">参考博客: DDD应用的思考</a><code>提出了关于领域设计的困惑</code></p></blockquote><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合根的修改行为应该属于聚合根实体对象自己，用聚合根行为守护其内部状态的一致性是DDD设计核心，如果聚合根内部的状态直接暴露给外界（通过领域服务）任意修改，那么会导致状态变化混乱，难以调试和跟踪。</p><ul><li>现在书写的这个项目就和这个理念相一致, 但是总说是OOP 没有提及DDD <em>TODO</em><ul><li>整个系统中涉及到的实体对象, 需要持久化的属就独立出来作为一个PO对象, 然后Spring Data JPA 接管DAO操作</li><li>然后在对象中建立 修改PO对象行为 的方法, 而不是以往 MVC 那样的设计, 业务全在Service里面, 对实体自身属性的基本操作也在Service里面</li></ul></li></ul><h3 id="参考实践项目"><a href="#参考实践项目" class="headerlink" title="参考实践项目"></a>参考实践项目</h3><blockquote><p><a href="https://github.com/tangxuehua/enode" target="_blank" rel="noopener">enode</a><code>C#实现</code><br><a href="https://github.com/liangzeng/cqrs" target="_blank" rel="noopener">CQRS</a></p></blockquote><hr><h2 id="数据的操作"><a href="#数据的操作" class="headerlink" title="数据的操作"></a>数据的操作</h2><h3 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h3><h3 id="CQRS"><a href="#CQRS" class="headerlink" title="CQRS"></a>CQRS</h3><blockquote><p><a href="http://www.cqrs.nu/" target="_blank" rel="noopener">www.cqrs.nu</a><code>CQRS Guides</code><br><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing" target="_blank" rel="noopener">event-sourcing</a>| <a href="https://docs.microsoft.com/zh-cn/azure/architecture/patterns/event-sourcing" target="_blank" rel="noopener">中文版</a>   <code>微软关于azure的技术性文档</code>  </p></blockquote><blockquote><p><a href="https://ookami86.github.io/event-sourcing-in-practice/" target="_blank" rel="noopener">event-sourcing-in-practice</a><br><a href="https://www.cnblogs.com/netfocus/category/361988.html" target="_blank" rel="noopener">参考博客:  CQRS &amp; Event Sourcing </a><br><a href="https://www.jianshu.com/p/9a3f8d514fcd" target="_blank" rel="noopener">参考博客: 领域驱动设计的实践 – CQRS &amp; Event Sourcing</a> <code>图文并茂的讲解CQRS思想</code></p></blockquote><blockquote><p><a href="https://github.com/kloiasoft/eventapis" target="_blank" rel="noopener">eventapis</a><code>Java实现的CQRS</code><br><a href="http://cqrsjourney.github.io/" target="_blank" rel="noopener">CQRS journey</a> <code>微软团队的项目</code></p></blockquote><hr><h2 id="组件模型"><a href="#组件模型" class="headerlink" title="组件模型"></a>组件模型</h2><h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><blockquote><p><a href="http://www.jdon.com/soa.html" target="_blank" rel="noopener">参考博客: SOA面向服务架构</a></p></blockquote><p><em><a href="http://www.jdon.com/45857" target="_blank" rel="noopener">Spring Web 应用的最大败笔</a></em></p><ul><li>传统意义上的SOA 内部封装的是数据表的DTO 也被称为 失血模型,贫血模型,  从而导致SOA服务内部腐烂堵塞，违背SOA自治和可用性等原则约束<ul><li>我现在使用Java的SpringMVC进行开发的东西, MVC架构, 然后JavaBean, Dao层或者JPA的Repository, Service层, Controller层, 而且还使用了好几年了</li></ul><ol><li>Web层负责处理用户输入，并返回正确的响应返回给用户。 web层与服务层通信。</li><li>服务层作为一个事务边界。它也负责授权和包含我们的应用程序的业务逻辑。服务层管理的域模型对象，并与其他服务和存储库层进行通信。</li><li>存储库/数据访问层负责与所使用的数据的存储进行通信。</li></ol><ul><li>正如这个毕业设计的项目  <a href="https://github.com/Kuangcp/Graduate" target="_blank" rel="noopener">Graduate</a>, 显然的都具有如上提到的各种缺陷, </li><li>每一个 DTO 只具有属性, 而没有方法, 一个DTO就要对应一个服务, 服务之间再相互注入, 就会有很有依赖, 甚至循环依赖</li></ul></li></ul><h3 id="MSA"><a href="#MSA" class="headerlink" title="MSA"></a>MSA</h3><blockquote><p>微服务</p></blockquote><blockquote><p>　<a href="https://blog.csdn.net/ztguang/article/details/52894794" target="_blank" rel="noopener">参考博客: SOA 与 MSA（微服务架构）</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513674&amp;idx=1&amp;sn=fbc727b7c8ff6d03f5d53478b6d4e585&amp;chksm=80d67a89b7a1f39ff0c3589a4a4076e323fab18379fc8d085c133b88e4db104f87988b29d246&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:从SOA到微服务</a></p></blockquote><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513873&amp;idx=1&amp;sn=2383f099fb353e59649167e723575158&amp;chksm=80d67bd2b7a1f2c4ae61704b8a2bd330764d20f0e2fafa6fdff55c99ea68272b3cff851684cc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:我是一个函数</a> <code>详解了RPC, 也就是RMI(远程过程调用)规范的实现</code></li></ul><blockquote><p><a href="http://www.spring4all.com/article/609" target="_blank" rel="noopener">微服务 MSA</a></p></blockquote><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="国际化的配置"><a href="#国际化的配置" class="headerlink" title="国际化的配置"></a>国际化的配置</h3><ul><li>将配置文件按语言分别配置</li><li>然后在加载时设定语言的配置, 然后加载对应文件夹下的配置文件</li></ul><hr><h1 id="设计软件的方法"><a href="#设计软件的方法" class="headerlink" title="设计软件的方法"></a>设计软件的方法</h1><h2 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h2><blockquote><p>Design by Contract  (Dbc)</p></blockquote><blockquote><p><a href="https://baike.baidu.com/item/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">百度百科解释 </a></p></blockquote><h2 id="精益思想"><a href="#精益思想" class="headerlink" title="精益思想"></a>精益思想</h2><blockquote><p>持续集成、持续交付、持续部署</p></blockquote><hr><h1 id="编程习惯"><a href="#编程习惯" class="headerlink" title="编程习惯"></a>编程习惯</h1><h2 id="晓风轻的经验"><a href="#晓风轻的经验" class="headerlink" title="晓风轻的经验"></a>晓风轻的经验</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/28705206" target="_blank" rel="noopener">知乎专栏-程序员你为什么这么累？</a> | <a href="https://github.com/xwjie/PLMCodeTemplate" target="_blank" rel="noopener">该专栏对应的源码</a> | <a href="https://xwjie.github.io/rule/" target="_blank" rel="noopener">个人站点版, 更为方便</a></p><ol><li><a href="https://zhuanlan.zhihu.com/p/28708259" target="_blank" rel="noopener">接口定义</a></li><li><a href="https://zhuanlan.zhihu.com/p/28717374" target="_blank" rel="noopener">Controller规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/28629319" target="_blank" rel="noopener">日志建议</a></li><li><a href="https://zhuanlan.zhihu.com/p/29005176" target="_blank" rel="noopener">异常处理规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/29129469" target="_blank" rel="noopener">参数校验和国际化规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/29199049" target="_blank" rel="noopener">工具类规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/29390147" target="_blank" rel="noopener">函数编写建议</a></li><li><a href="https://zhuanlan.zhihu.com/p/29191233" target="_blank" rel="noopener">配置文件的定义</a></li></ol></li><li><p>[ ] 详细的阅读</p></li></ul><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><ul><li>先有统一的接口定义规范，然后有AOP实现。先有思想再有技术。</li><li>现在知道为什么要返回统一的一个ResultBean了：<ul><li>为了统一格式</li><li>为了应用AOP</li><li>为了包装异常信息</li></ul></li></ul><h3 id="日志建议"><a href="#日志建议" class="headerlink" title="日志建议"></a>日志建议</h3><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li>所以，我对开发人员的要求就是，绝大部分场景，不允许捕获异常，不要乱加空判断。只有明显不需要关心的异常，如关闭资源的时候的io异常，可以捕获然后什么都不干，其他时候，不允许捕获异常，都抛出去，到controller处理。空判断大部分时候不需要，你如果写了空判断，你就必须测试为空和不为空二种场景，要么就不要写空判断。</li><li>强调，有些空判断是要的，如：参数是用户输入的情况下。但是，大部分场景是不需要的（我们的IT系统里面，一半以上不需要），如参数是其它系统传过来，或者其他地方获取的传过来的，99.99%都不会为空，你判断来干嘛？就抛一个空指针到前台怎么啦？何况基本上不会出现。</li><li>总结：<ul><li>开发组长定义好异常，异常继承RuntimeException。</li><li>不允许开发人员捕获异常。（异常上对开发人员就这点要求！异常都抛出到controller上用AOP处理）</li><li>后台（如队列等）异常一定要有通知机制，要第一时间知道异常。</li><li>少加空判断，加了空判断就要测试为空的场景！</li></ul></li></ul><h3 id="工具类规范"><a href="#工具类规范" class="headerlink" title="工具类规范"></a>工具类规范</h3><ol><li>方法参数要抽象(尽量往上找到父类和接口), 返回值要具体</li><li>隐藏实现: 不要在业务代码中直接调用三方工具, 应该自己写一个类, 然后调用三方库的方法, 方便以后修改</li><li>多使用重载编写功能齐全的对外接口和方法</li><li>单独存放, 单独维护, </li></ol><hr><blockquote><p>优先使用组合而不是继承, 继承破坏了封装性, 因为父类的很多细节对子类是可见的, 父类的变化可能极大的影响子类<br>面向接口编程, 而不是实现编程 </p></blockquote><h2 id="代码质量分析"><a href="#代码质量分析" class="headerlink" title="代码质量分析"></a>代码质量分析</h2><ul><li>测试对代码的覆盖率</li><li>代码的格式是否清晰，有助于差异比较和可读性</li><li>是否很可能会出现NPE</li><li>是否忘记了域对象中的equals和hashCode方法</li></ul><h3 id="Checkstyle"><a href="#Checkstyle" class="headerlink" title="Checkstyle"></a>Checkstyle</h3><h3 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h3><h3 id="阿里巴巴的代码检查"><a href="#阿里巴巴的代码检查" class="headerlink" title="阿里巴巴的代码检查"></a>阿里巴巴的代码检查</h3><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>千万业务代码里面不要和读取配置的代码耦合在一起。切记！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#开发思想&quot;&gt;开发思想&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#抽象&quot;&gt;抽象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#命令式编程和响应式编程&quot;&gt;命令式编程和响应式编程&lt;
      
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.kuangcp.top/categories/Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>AlibabaJavaStandard.md</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-AlibabaJavaStandard/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-AlibabaJavaStandard/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#阿里巴巴java开发手册">阿里巴巴Java开发手册</a></li><li><a href="#编程规约">编程规约</a><ol><li><a href="#命名规约">命名规约</a></li><li><a href="#常量定义">常量定义</a></li><li><a href="#代码格式">代码格式</a></li><li><a href="#oop规约">OOP规约</a></li><li><a href="#集合处理">集合处理</a></li><li><a href="#并发处理">并发处理</a></li><li><a href="#控制语句">控制语句</a></li><li><a href="#注释规约">注释规约</a></li><li><a href="#其他">其他</a></li></ol></li><li><a href="#异常日志">异常日志</a><ol><li><a href="#异常处理">异常处理</a></li><li><a href="#日志规约">日志规约</a></li></ol></li><li><a href="#单元测试">单元测试</a></li><li><a href="#安全规约">安全规约</a></li><li><a href="#mysql规约">MySQL规约</a><ol><li><a href="#建表规约">建表规约</a></li><li><a href="#索引规约">索引规约</a></li><li><a href="#sql规约">SQL规约</a></li><li><a href="#orm映射">ORM映射</a></li></ol></li><li><a href="#工程规约">工程规约</a><ol><li><a href="#应用分层">应用分层</a></li><li><a href="#二方库依赖">二方库依赖</a></li><li><a href="#服务器规约">服务器规约</a></li></ol></li><li><a href="#专有名词">专有名词</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="阿里巴巴Java开发手册"><a href="#阿里巴巴Java开发手册" class="headerlink" title="阿里巴巴Java开发手册"></a>阿里巴巴Java开发手册</h1><blockquote><p><a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">Github: p3c</a><code>含该手册PDF GitBook等版本</code> | <a href="https://yq.aliyun.com/articles/656256?spm=a2c4e.11155472.0.0.7ba85338l1Ef0N" target="_blank" rel="noopener">《阿里巴巴Java开发手册》详尽</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/ml5271169588/article/details/6975701" target="_blank" rel="noopener">FindBugs、PMD和CheckStyle对比</a></p></blockquote><h1 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h1><h2 id="命名规约"><a href="#命名规约" class="headerlink" title="命名规约"></a>命名规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>所有命名不能以<code>美元符和下划线</code>开始和结束</p></li><li><p>禁止拼音混合英文, 更不允许直接使用中文的方式。</p><ul><li>正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。</li></ul></li><li><p>类名用<code>UpperCamelCase风格</code> 但以下情形例外:  DO / BO / DTO / VO / AO / PO / UID 例如: <code>UserDO</code></p></li><li><p>方法名、参数名、成员变量、局部变量 都统一使用 <code>lowerCamelCase风格</code></p></li><li><p>常量名全部大写, 下划线隔开, 力求语义表达完整清楚, 不要嫌名字长(枚举类中的也是)。</p></li><li><p>抽象类使用<code>Abstract或者Base</code>开头, 异常类使用Exception结尾 测试类命名以它要测试的类的名称开始，以Test结尾</p></li><li><p>数组定义 <code>String[] name</code> 而不是 <code>String name[]</code></p></li><li><p>POJO 类中布尔类型的变量不能is开头, 否则部分框架解析会引起序列化错误。 </p></li><li><p>包名统一使用小写, 点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式, 但是类名如果有复数含义, 类名可以使用复数形式。</p><ul><li>正例:  应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（ 此规则参考spring 的框架结构）</li></ul></li><li><p>杜绝完全不规范的缩写,  避免望文不知义。</p><ul><li>反例:  AbstractClass“ 缩写” 命名成 AbsClass;  condition“ 缩写” 命名成 condi, 此类随意缩写严重降低了代码的可阅读性。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>为了达到代码自解释的目标, 任何自定义编程元素在命名时, 使用尽量完整的单词组合来表达其意。</p><ul><li>正例:  从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。</li></ul></li><li><p>如果使用到了设计模式, 建议在类名中体现出具体模式。将设计模式体现在名字中, 有利于阅读者快速理解架构设计理念<code>LoginProxy</code></p></li><li><p>接口类中的方法和属性不要加任何修饰符号（ public 也不要加） , 保持代码的简洁性, 并加上有效的 Javadoc 注释。</p><ul><li>尽量不要在接口里定义变量, 如果一定要定义变量, 肯定是与接口方法相关, 并且是整个应用的基础常量。</li></ul></li></ol><p><strong><code>接口和实现类的命名有两套规则</code></strong></p><ol><li><p><code>强制</code> 对于 Service 和 DAO 类, 基于 SOA 的理念, 暴露出来的服务一定是接口, 内部的实现类用 Impl 的后缀与接口区别。</p><ul><li>正例:  CacheServiceImpl 实现 CacheService 接口。</li></ul></li><li><p><code>推荐</code> 如果是形容能力的接口名称, 取对应的形容词做接口名 （ 通常是–able 的形式）。</p><ul><li>正例:  AbstractTranslator 实现 Translatable。</li></ul></li></ol><p><strong><code>参考</code></strong></p><ol><li><p>枚举类名建议带上 Enum 后缀, 枚举成员名称需要全大写, 单词间用下划线隔开。</p><ul><li>说明:  枚举其实就是特殊的常量类, 域成员均为常量, 且构造方法被默认强制是私有。</li><li>正例:  枚举名字为 <code>ProcessStatusEnum</code> 的成员名称:  <code>SUCCESS</code>或者<code>UNKOWN_REASON</code></li></ul></li><li><p>MVC各层命名规约</p><ul><li>Service/Dao层<ul><li>获取单个对象 get 做前缀</li><li>获取多个对象 list, 复数形式结尾</li><li>获取统计值的方法 count </li><li>插入 save</li><li>删除 remove</li><li>修改 update<ul><li>领域模型</li><li>数据对象 <strong><em>xxxDO</em></strong> xxx是数据表名</li><li>数据传输对象 <strong><em>xxxDTO</em></strong> xxx是业务领域相关的名称</li><li>展示对象 <strong><em>xxxVO</em></strong> xxx是网页名称 使用了模板框架</li><li>POJO是 <strong><em>DO DTO BO VO</em></strong> 统称, 禁止命名为 xxxPOJO</li><li>有关这些缩写的详细说明  <a href="/Java/AdvancedLearning/GrammarAndType.md#object">详细定义和解释</a></li></ul></li></ul></li></ul></li></ol><ol><li><strong><code>Tomcat组织推荐的代码风格</code></strong><ol><li>使用空格进行缩进, 而不是制表符</li><li>用于 Java 源的100个字符行宽度, 用于文档源（.txt, .xml）的80个字符行宽度</li><li>Java 源代码: {在行末, 4个空格缩进</li><li>XML 源文件: 2个空格缩进</li></ol></li></ol><hr><h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><p><strong><code>强制</code></strong></p><ol><li><p>不允许出现魔法值(未经定义的常量)直接出现</p></li><li><p>long 或者 Long 初始赋值时,  使用大写的 L , 不能是小写的 l, 小写容易跟数字 1 混淆, 造成误解</p></li></ol><ol><li>不要使用一个常量类维护所有的常量, 应该按常量的功能, 进行归类, 分开维护.<ul><li>大而全的常量类, 只能用搜索 才能快速定位, 不利于理解和维护</li><li>例如 缓存相关常量放在类 <code>CacheConsts</code> 下;  系统配置相关常量放在类 <code>ConfigConsts</code> 下</li></ul></li></ol><ol><li>常量的复用层次的安排<ul><li><em>跨应用共享常量</em> : 二方库中 通常是client.jar中的<code>constant</code>目录下</li><li><em>应用内共享常量</em> : 一方库的modules中的<code>constant</code>目录下<ul><li>易懂变量也要统一定义成 应用内共享变量, 比如两个开发者在两个模块定义了相同含义的常量, 但是值却不一样, 这样就很容易埋下隐患</li></ul></li><li><em>子工程内共享常量</em> : 当前子工程的<code>constant</code>目录下</li><li><em>包内共享常量</em>: 当前包下单独的<code>constant</code>目录下</li><li><em>类内共享常量</em>: 直接在类内部 <code>private static final</code> 定义</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>如果变量值仅在一个范围内变化, 且带有名称之外的延伸属性,  定义为枚举类。下面正例中的数字就是延伸信息, 表示星期几。</p><ul><li><code>public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6),SUNDAY(7);}</code></li></ul></li><li><p>枚举类的定义 不能直接使用枚举的 ordinal() 作为枚举常量的值在程序中使用, 而应该自己定义一个变量, ordinal 方法的Javadoc上也有说明</p><ul><li>Most programmers will have no use for this method. It is designed for use by sophisticated enum-based data structures, such as EnumSet and EnumMap</li></ul></li></ol><hr><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><p><strong><code>强制</code></strong></p><ol><li><p>大括号约定: </p><ul><li>如果是大括号内为空, 则简洁地写成{}即可, 不需要换行;  </li><li>如果是非空代码块则: <ul><li>左大括号前不换行, 左大括号后换行。</li><li>右大括号前换行, 右大括号后还有 else 等代码则不换行;  表示终止的右大括号后必须换行。</li></ul></li></ul></li><li><p>小括号和字符之间不出现空格; </p><ul><li>反例:  <code>if (空格 a == b 空格)</code></li></ul></li><li><p><code>if/for/while/switch/do</code>等保留字与括号之间必须加空格.</p></li><li><p>任何二目、 三目运算符的左右两边都需要加一个空格。</p></li><li><p>缩进采用4个空格(Google的风格是两个空格), 而不是tab字符, 对应的IDE要调整一下</p></li><li><p>注释的双斜线与注释内容之间有且仅有一个空格。 <code>// 注释</code></p></li><li><p>单行字符不超过120个, 超出需换行: </p><ul><li>第二行比第一行缩进4个空格, 第三行以后就和第二行平齐就可以了</li><li>运算符与下文一起换行</li><li>方法调用的点符号与下文一起换行</li><li>调用方法 多个参数, 需在逗号后进行换行</li><li>括号之前不要换行</li></ul></li><li><p>方法参数在定义和传入时, 多个参数逗号后边必须加空格 :  <code>method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></p></li><li><p>文件编码统一采用<code>UTF-8</code> IDE中换行符采用Unix格式(LF) <code>使用别的编码的话会开心死的</code></p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>方法体内执行语句组, 变量的定义语句组, 不同的业务逻辑之间或者不同的语义之间插入一个空行, 相同业务逻辑和语义之间不需要插入空行</p><ul><li>也没必要插入多个空行进行分隔</li></ul></li><li><p>没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。(很傻的做法)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>    a = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">public</span> String b = <span class="number">2</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">float</span>  c = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>避免使用一个类的对象来引用该类的静态变量或静态方法。无谓增加编译器解析成本, 直接用<code>类名</code>来访问即可。</p></li><li><p>所有的覆写方法, 必须加 @Override 注解</p><ul><li>例如 getObject() 与 get0bject() 的问题, 前者是字母o,后者是数字0 通过使用覆盖的注解, 可以准确判断是否覆盖成功</li><li>另外, 如果在抽象类中对方法签名进行修改, 其实现类 会立即编译报错</li></ul></li><li><p>相同参数类型, 相同业务含义, 才可以使用Java的可变参数, 避免使用Object.</p><ul><li>说明:  可变参数必须放置在参数列表的最后。 <code>提倡尽量不用可变参数编程</code></li><li>正例:  <code>public User getUsers(String type, Integer... ids) {...}</code></li></ul></li><li><p>外部正在调用或者二方库依赖的接口, 不允许修改方法签名, 避免对接口调用方产生影响。</p><ul><li>接口过时必须加 <code>@Deprecated</code> 注解, 并清晰地说明采用的新接口或者新服务是什么。</li></ul></li><li><p>不能使用过时的类或方法</p><ul><li>说明:  <code>java.net.URLDecoder</code> 中的方法 <code>decode(String encodeStr)</code> 这个方法已经过时, </li><li>应该使用双参数 <code>decode(String source, String encode)</code>。接口提供方既然明确是过时接口, </li><li>那么有义务同时提供新的接口;  作为调用方来说, 有义务去考证过时方法的新实现是什么。</li></ul></li><li><p>Object 的 equals 方法容易抛空指针异常, 应使用常量或确定有值的对象来调用equals。</p><ul><li>使用<code>&quot;t&quot;.equals(test)</code>方式</li><li>推荐使用<code>java.util.Object.equals</code> (jdk7引入的工具类)</li></ul></li><li><p>所有的相同类型的包装类对象之间的 <em>值的比较</em> , 全部使用equals方法比较, </p><ul><li>注意: 对于 <code>Integer var = ?</code> 在 -128 至 127 范围内的赋值,  Integer 对象是在<code>IntegerCache.cache 产生</code>, 会复用已有对象, </li><li>这个区间内的 Integer 值可以直接使用 == 进行判断, 但是这个区间之外的所有数据, 都会在堆上产生, 并不会复用已有对象, 所以 <code>==</code> 就会失效</li><li>这是一个大坑！, <strong>推荐统一使用 equals 方法进行判断</strong></li></ul></li><li><p>关于基本数据类型与包装数据类型的使用标准如下: </p><ul><li>所有的 POJO 类属性必须使用包装数据类型。</li><li>RPC 方法的 返回值 和 参数 必须使用包装数据类型</li><li>所有的局部变量 推荐使用基本数据类型</li><li><code>说明</code>:  POJO 类属性没有初值是提醒使用者在需要使用时, 必须自己显式地进行赋值, 任何NPE 问题, 或者入库检查, 都由使用者来保证。<ul><li>数据库的查询结果可能是 null, 因为自动拆箱, 用基本数据类型接收有 NPE 风险。</li></ul></li><li><code>反例</code>:  比如显示成交总额涨跌情况, 即正负 x%,  x 为基本数据类型, 调用的 RPC 服务, 调用不成功时, 返回的是默认值, <ul><li>页面显示为 0%, 这是不合理的, 应该显示成中划线。所以包装数据类型的 null 值, 能够表示额外的信息</li><li>如: 远程调用失败, 异常退出。</li></ul></li></ul></li><li><p>定义 <code>DO/DTO/VO</code>等POJO类时, 不要给任何成员属性设定 <strong>默认值</strong></p><ul><li><code>反例</code>:  POJO 类的 createTime属性 默认值为 new Date();<ul><li>但是这个属性在数据提取时并没有置入具体值, 在更新其它字段时又附带更新了此字段, 导致创建时间被修改成当前时间。</li></ul></li></ul></li><li><p>序列化类新增属性时, 不要修改<code>serialVersionUID</code>字段, 避免反序列化失败</p><ul><li>如果完全不兼容升级, 为了避免反序列化混乱, 就需要修改<code>serialVersionUID</code>的值 <code>(idea可以配置使用快捷键自动生成)</code></li><li><code>说明</code>:  当 serialVersionUID 不一致会抛出序列化运行时异常。</li></ul></li><li><p>构造方法里面禁止加入任何业务逻辑, 如果有初始化逻辑, 请放在 init 方法中。</p></li><li><p>POJO 类必须写 toString 方法。 如果继承了另一个 POJO 类, 注意在前面加一下 super.toString() <code>lombok解救众生</code></p><ul><li>说明:  在方法执行抛出异常时, 可以直接调用 POJO 的 toString()方法打印其属性值, 便于排查问题</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>使用索引访问用 String 的 split 方法得到的数组时, 需做最后一个分隔符后有无内容的检查, 否则会有 <code>IndexOutOfBoundsException</code> 的风险。</p><ul><li><code>System.out.println(&quot;a,b,c,,&quot;.split(&quot;,&quot;).length);</code> 预期是大于3,结果却是3</li></ul></li><li><p>当一个类有多个构造方法, 或者多个同名方法, 这些方法应该按顺序放置在一起, 优于下条规则</p></li><li><p>类内方法的定义顺序依次是 共有方法或保护方法 -&gt; 私有方法 -&gt; setter/getter方法(lombok可省)</p><ul><li>公有方法是类的调用者和维护者最关心的方法, 首屏展示最好;  </li><li>保护方法虽然只是子类关心, 也可能是 <strong>模板设计模式</strong> 下的核心方法;  </li><li>而私有方法外部一般不需要特别关心, 是一个黑盒实现;  </li><li>因为承载的信息价值较低, 所有 Service 和 DAO 的 <code>getter/setter</code> 方法放在类的最后, 用了lombok就省去了。</li></ul></li><li><p>setter 方法中, 参数名称与类成员变量名称一致,  this.成员名 = 参数名。</p><ul><li>在<code>getter/setter</code> 方法中,  不要增加业务逻辑, 增加排查问题的难度。</li></ul></li><li><p>循环体中的字符串的连接方式, 使用<code>StringBuffer</code>的<code>append</code>方法进行扩展</p><ul><li>说明:  反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象, 然后进行 append 操作, </li><li><p>最后通过 toString 方法返回 String 对象, 造成内存资源浪费。</p><blockquote><p>验证循环中String的拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String target = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>; a&lt;<span class="number">10</span>; a++)&#123;</span><br><span class="line">            target += a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. javac test.java 编译</span></span><br><span class="line"><span class="comment">// 2. javap -c -l test 反编译, 就能大致看到new StringBuilder了</span></span><br></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>final 可以声明类、成员变量、方法、以及本地变量, 下列情况使用 final 关键字: </p><ol><li>不允许被继承的类, 如:  String 类。</li><li>不允许修改引用的域对象, 如:  POJO 类的域变量。</li><li>不允许被重写的方法, 如:  POJO 类的 setter 方法。</li><li>不允许运行过程中重新赋值的局部变量。</li><li>避免上下文重复使用一个变量, 使用 final 描述可以强制重新定义一个变量, 方便更好地进行重构。<ul><li>这里就隐含了一个习惯, 不应该把一个变量到处传, 到处用,赋值, 很难追踪调试</li></ul></li></ol></li><li><p>慎用Object的clone方法来拷贝对象 <code>详见API</code></p><ul><li>说明:  对象的 clone 方法默认是浅拷贝, 最好重写该方法, 实现属性对象的拷贝。</li></ul></li><li><p>类成员与方法访问控制从严: </p><ol><li>如果不允许外部直接通过 new 来创建对象, 那么构造方法显式声明并 private</li><li><strong>工具类</strong> 不允许有 public 或 default 的构造方法</li><li>类非static成员变量 或者 成员方法 若 <strong>只与</strong> 子类共享, 必须是 protected</li><li>成员属性或方法 若 <strong>仅</strong> 本类中使用, 必须是 private</li><li>若是static成员变量, 必须考虑是否final</li><li>类static 成员变量如果仅在本类使用, 必须是 private。</li></ol><ul><li><strong>注意</strong> 说明:  任何类、方法、参数、变量, 都需要严控访问范围。过于宽泛的访问范围, 不利于模块解耦。<ul><li>思考: 如果是一个 private 的方法, 想删除就删除, 可是一个 public 的 service 方法, 或者一个 public 的成员变量, 删除一下, 不得手心冒点汗吗？</li><li>变量像自己的小孩, 尽量在自己的视线内, 变量作用域太大,  无限制的到处跑, 那么你会担心的。</li></ul></li></ul></li></ol><hr><h2 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h2><p><strong><code>强制</code></strong></p><ol><li><p>关于 hashCode 和 equals 的处理, 遵循如下规则:</p><ul><li>只要重写 equals, 就必须重写 hashCode</li><li>因为 Set 存储的是不重复的对象, 依据 hashCode 和 equals 进行判断, 所以 Set 存储的方法必须重写这两个方法</li><li>如果自定义对象作为 Map 的键, 那么必须重写 hashCode 和 equals</li><li><code>说明</code>:  String 重写了 hashCode 和 equals 方法, 所以我们可以非常愉快地使用 String 对象作为 key 来使用。</li></ul></li><li><p>ArrayList 的 subList 结果不可强转成 ArrayList 否则会抛出 ClassCastException异常,  </p><ul><li>即 <code>java.util.RandomAccessSubList cannot be cast to java.util.ArrayList.</code></li><li><code>说明</code>: subList返回的是 ArrayList 的内部类 SubList, 并不是ArrayList, 而是ArrayList的一个视图, 对于SubList的所有操作最终都会反映到原列表上</li></ul></li><li><p>在 <code>subList</code> 场景中, 高度注意对原集合元素 <strong>个数的修改</strong>, 会导致子列表的 <strong>遍历、增加、删除</strong> 均会产生 <code>ConcurrentModificationException</code> </p></li><li><p>使用集合转数组的方法, 必须使用集合的 <code>toArray(T[] array)</code> , 传入的是类型完全一样的数组, 数组大小就是 <code>list.size()</code></p><ul><li>使用 toArray 带参方法, 入参分配的数组空间不够大时,  toArray 方法内部将重新分配内存空间, 并返回新数组地址, 原数组不做更改; </li><li>如果数组元素大于实际所需, 下标超出的数组元素将被置为 null, 其它数组元素保持原值, 因此最好将方法入参数组大小定义与集合元素个数一致。</li><li><em>注意</em> 直接使用 toArray 无参方法存在问题, 此方法返回值只能是 Object[]类, 若强转其它类型数组将出现 ClassCastException 错误。</li></ul></li><li><p>把数组转换成集合: 使用工具类<code>Arrays.asList()</code>时, 不能使用其修改集合相关的方法, 其<code>add/remove/clear</code>方法会抛出<code>UnsupportedOperationException</code>异常。</p><ul><li>因为 asList 的返回对象是一个继承于 AbstractList 的内部类 Arrays, 实现集合的那些修改方法时 都是直接抛出异常</li><li><code>Arrays.asList</code>体现的是适配器模式, 只是转换接口, 后台的数据仍是固定长度的数组。</li><li>案例: <code>String[] str = new String[] { &quot;a&quot;, &quot;b&quot; }; List list = Arrays.asList(str);</code><ul><li><em>第一种情况</em>:  <code>list.add(&quot;c&quot;);</code>  运行时异常。</li><li><em>第二种情况</em>:  <code>str[0]= &quot;gujin&quot;;</code> 那么 <code>list.get(0)</code> 也会随之修改。</li></ul></li></ul></li><li><p>泛型通配符<code>&lt;? extends T&gt;</code>来接收返回的数据, 此写法的泛型集合不能使用 add 方法。</p><ul><li>而<code>&lt;? super T&gt;</code>不能使用 get 方法, 做为接口调用赋值时易出错。</li><li><em>说明</em>:  扩展说一下 <code>PECS(Producer Extends Consumer Super)</code>原则:  <ul><li>第一、 频繁往外读取内容的, 适合用<code>&lt;? extends T&gt;</code>。 </li><li>第二、 经常往里插入的, 适合用<code>&lt;? super T&gt;</code>。<ul><li>说明: 苹果装箱后返回一个<code>&lt;? extends Fruits&gt;</code>对象, 此对象就不能往里加任何水果, 包括苹果。</li></ul></li></ul></li></ul></li><li><p>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。 remove 元素请使用 Iterator方式, 如果并发操作, 需要对 Iterator 对象加锁。</p><p> <em>正例: </em></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String item = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (删除元素的条件) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <em>反例: </em></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; a = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"1"</span>);</span><br><span class="line">list.add(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"1"</span>.equals(item)) &#123;</span><br><span class="line">        list.remove(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <em>说明</em>:  以上代码的执行结果肯定会出乎大家的意料, 那么试一下把“1”换成“2”, 会是同样的结果吗？</p></li><li><p>在 JDK7 版本以上,  Comparator 要满足自反性, 传递性, 对称性, 不然 <code>Arrays.sort</code> , <code>Collections.sort</code> 会报 <code>IllegalArgumentException</code> </p><ul><li>1 ） 自反性:  x ,  y 的比较结果和 y ,  x 的比较结果相反。</li><li>2 ） 传递性:  x &gt; y , y &gt; z ,则 x &gt; z 。</li><li><p>3 ） 对称性:  x = y ,则 x , z 比较结果和 y ,  z 比较结果相同。</p><p><em>反例:  下例中没有处理相等的情况, 实际使用中可能会出现异常: </em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() &gt; o2.getId() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>集合初始化时, 尽量指定集合初始容量值。</p><ul><li>HashMap 使用 HashMap(int initialCapacity) 初始化</li><li>正例: <code>initialCapacity=(需要存储的元素个数/负载因子)+1</code>。注意负载因子（即 loaderfactor）默认为<code>0.75</code><ul><li>如果暂时无法确定初始值大小, 请设置为 16（即默认值） 。</li></ul></li><li>反例:  HashMap 需要放置 1024 个元素,  由于没有设置容量初始大小, 随着元素不断增加, 容量<code>7</code>次被迫扩大,  resize 需要重建 hash 表, 严重影响性能。</li></ul></li><li><p>使用 <code>entrySet</code> 遍历 Map 类集合 KV , 而不是 <code>keySet</code> 方式进行遍历</p><ul><li><code>keySet</code> 其实是遍历了 2 次, 一次是转为 <code>Iterator</code> 对象, 另一次是从 hashMap 中取出key 所对应的 value 。</li><li>而 <code>entrySet</code> 只是遍历了一次就把 key 和 value 都放到了 entry 中, 效率更高。 如果是 JDK8, 使用 lambda 的 foreach 方法。</li><li>说明: values() 返回的是V值集合, 是一个 list 集合对象; keySet()返回的是K值集合, 是一个 Set集合对象;entrySet()返回的是 K - V 值组合集合。</li></ul></li><li><p>高度注意 Map 类集合 <code>K/V</code> 能不能存储 null 值的情况, 如下表格:</p><ul><li><p>反例:  由于 HashMap 的干扰, 很多人认为 ConcurrentHashMap 是可以置入 null 值, 而事实上, 存储 null 值时会抛出 NPE 异常。</p><p>|  集合类   |    Key  |   Value  |  Super   |  说明  |<br>| — | — | — | — | — |<br>|Hashtable|! NULL|! NULL|Dictionary|线程安全|<br>|ConcurrentHashMap|! NULL|! NULL|AbstractMap|锁分段技术（ JDK8:CAS）|<br>|TreeMap|! NULL|NULL|AbstractMap|线程不安全|<br>|HashMap|NULL|NULL|AbstractMap|线程不安全|</p></li></ul></li><li><p>合理利用好集合的有序性 (sort) 和稳定性 (order) , 避免集合的无序性 (unsort) 和不稳定性 (unorder) 带来的负面影响。</p><ul><li>稳定性指集合每次遍历的元素次序是一定的。</li><li>有序性是指遍历的结果是按某种比较规则依次排列的。</li><li>如:  ArrayList 是 order / unsort; <ul><li>HashMap 是 unorder/unsort; </li><li>TreeSet 是 order / sort 。</li></ul></li></ul></li><li><p>利用 Set元素唯一的特性, 可以快速对一个集合进行去重操作, 避免使用 List的contains 方法进行遍历、对比、去重操作。</p><ul><li>OrderSet也是一个很重要的类</li></ul></li></ol><h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><p><strong><code>强制</code></strong></p><ol><li><p>获取单例对象需要保证线程安全, 其中的方法也要保证线程安全。</p><ul><li>资源驱动类、工具类、单例工厂类都需要注意。</li></ul></li><li><p>创建线程或线程池时请指定有意义的线程名称, 方便出错时回溯。</p></li><li><p>线程资源必须通过线程池提供, 不允许在应用中自行显式创建线程。</p><ul><li>使用线程池的好处是减少在创建和销毁线程上所花的时间, 以及系统资源的开销,解决资源不足的问题, 如果不使用线程池, 有可能造成系统创建大量同类线程而导致消耗完内存或者 过度切换 的问题</li></ul></li><li><p>线程池不允许使用 <strong>Executors</strong> 去创建, 而是通过 <strong>ThreadPoolExecutor</strong> 的方式, 这样的处理方式让写的同学更加明确线程池的运行规则, 规避资源耗尽的风险。</p><ul><li>Executors 返回的线程池对象的弊端如下:<ol><li>FixedThreadPool 和 SingleThreadPool :<ul><li>允许的请求队列长度为 Integer.MAX_VALUE , 可能会堆积大量的请求, 从而导致 OOM 。</li></ul></li><li>CachedThreadPool 和 ScheduledThreadPool :<ul><li>允许的创建线程数量为 Integer.MAX_VALUE , 可能会创建大量的线程, 从而导致 OOM 。</li></ul></li></ol></li></ul></li><li><p>SimpleDateFormat 是线程不安全的类, 一般不要定义为 static 变量, 如果定义为static , 必须加锁, 或者使用 DateUtils 工具类。</p><ul><li>如果是 JDK 8 的应用, 可以使用 Instant 代替 Date ,  LocalDateTime 代替 Calendar , DateTimeFormatter 代替 Simpledateformatter , </li><li>官方给出的解释:  simple beautiful strongimmutable thread - safe 。<blockquote><p>或者如下处理实例化  </p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;      </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;           </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>高并发时, 同步调用应该去考量锁的性能损耗。</p><ul><li>能用无锁数据结构, 就不要用锁 ;  </li><li>能锁区块, 就不要锁整个方法体 ;  </li><li>能用对象锁, 就不要用类锁。</li><li>尽可能使得加锁的代码块工作量尽可能的小, 避免在锁代码块中调用 RPC 方法;</li></ul></li><li><p>对多个资源、数据库表、对象同时加锁时, 需要保持一致的加锁顺序, 否则可能会造成死锁。</p><ul><li>线程一需要对表 A 、 B 、 C 依次全部加锁后才可以进行更新操作, 那么线程二的加锁顺序也必须是 A 、 B 、 C , 否则可能出现死锁。</li></ul></li><li><p>并发修改同一记录时, 避免更新丢失, 要么在应用层加锁, 要么在缓存加锁, 要么在数据库层使用乐观锁, 使用 version 作为更新依据。</p><ul><li>如果每次访问冲突概率小于 20%, 推荐使用乐观锁, 否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</li></ul></li><li><p>多线程并行处理定时任务时,  Timer 运行多个 TimeTask 时, 只要其中之一没有捕获抛出的异常, 其它任务便会自动终止运行</p><ul><li>使用 ScheduledExecutorService 则没有这个问题。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>使用 CountDownLatch 进行异步转同步操作, 每个线程退出前必须调用 countDown方法, 线程执行代码注意 catch 异常, 确保 countDown 方法被执行到, 避免主线程无法执行至 await 方法, 直到超时才返回结果。</p><ul><li>注意, 子线程抛出异常堆栈, 不能在主线程 try - catch 到。</li></ul></li><li><p>避免 Random 实例被多线程使用, 虽然共享该实例是线程安全的, 但会因竞争同一 seed 导致的性能下降。</p><ul><li>Random 实例包括 java.util.Random 的实例或者  Math.random() 实例。</li><li>在JDK7之后, 可以直接使用 TreadLocalRandom, 而在JDK7以前, 需要编码保证每个线程持有一个实例</li></ul></li><li><p>在并发场景下, 通过双重检查锁 （double - checked locking） 实现延迟初始化的优化问题隐患 </p><ul><li>可参考 The “Double - Checked Locking is Broken” Declaration ,</li><li>推荐问题解决方案中较为简单一种 （ 适用于 JDK 5 及以上版本 ） , 将目标属性声明为  volatile 型 。</li></ul></li><li><p>volatile 解决多线程内存不可见问题。对于一写多读, 是可以解决变量同步问题</p><ul><li>但是如果多写, 同样无法解决线程安全问题。如果是 count++ 操作, 使用如下类实现: <ul><li>AtomicInteger count =  new AtomicInteger(); count . addAndGet( 1 );  </li></ul></li><li>如果是 JDK 8, 推荐使用 LongAdder 对象, 比 AtomicLong 性能更好 （ 减少乐观锁的重试次数 ） 。</li></ul></li><li><p>HashMap 在容量不够进行 resize 时由于高并发可能出现死链, 导致 CPU 飙升, 在开发过程中可以使用其他数据结构或加锁来规避此风险。</p></li><li><p>ThreadLocal 无法解决共享对象的更新问题,  ThreadLocal 对象建议使用 static 修饰。</p><ul><li>这个变量是针对一个线程内所有操作共有的, 所以设置为静态变量, 所有此类实例共享此静态变量,  </li><li>也就是说在类第一次被使用时装载, 只分配一块存储空间, 所有此类的对象 ( 只要是这个线程内定义的 ) 都可以操控这个变量。</li></ul></li></ol><hr><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p><strong><code>强制</code></strong></p><ol><li><p>在一个 switch 块内, 每个 case 要么通过 break/return 等来终止, 要么注释说明程序将继续执行到哪一个 case 为止 ;  </p><ul><li>在一个 switch 块内, 都必须包含一个 default 语句并且放在最后, 即使它什么代码也没有。</li></ul></li><li><p>在 if/else/for/while/do 语句结构中必须使用大括号, 即使只有一行代码</p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>表达异常的分支时, 少用 if-else 的方式, 这种方式可以改写:</p><ul><li>逻辑上超过 3 层的 if-else 代码可以使用卫语句, 状态模式, 策略模式来实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 卫语句就是将错误情况提前返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">today</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isBusy())&#123;</span><br><span class="line">        System.out.println(<span class="string">"change time."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isFree())&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>除常用方法（如 getXxx/isXxx）等外, 不要在条件判断中执行其它复杂的语句</p><ul><li>并且将复杂逻辑判断的结果赋值给一个有意义的布尔变量名, 以提高可读性。</li><li>很多 if 语句内的逻辑判断都是相当复杂, 不能一眼看出在判断什么, 需要停顿,分析一下表达式才能理解 if 语句存在的意义</li><li>如果有个boolean变量接收, 变量名就起到了注释的作用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> existed = (file.open(fileName, <span class="string">"w"</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...);</span><br><span class="line"><span class="keyword">if</span>(existed)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">if</span> ((file.open(fileName, <span class="string">"w"</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...);)&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>循环体中的语句要考量性能, 以下操作尽量移至循环体外处理, 如定义对象、变量、获取数据库连接</p><ul><li>进行不必要的 try-catch 操作 (需要考虑这个 try-catch 是否可以移至循环体外而不影响逻辑)。</li></ul></li><li><p>接口入参保护, 这种场景常见的是用于做批量操作的接口。</p></li><li><p>方法中 <strong>必须</strong> 进行参数校验的场景: </p><ol><li>调用频次低的方法。</li><li>执行时间开销很大的方法. 此情形中,参数校验时间几乎可以忽略不计, <ul><li>但如果因为参数错误导致中间执行回退, 或者错误, 那得不偿失。</li></ul></li><li>需要极高稳定性和可用性的方法。</li><li>对外提供的开放接口, 不管是 RPC/API/HTTP 接口。</li><li>敏感权限入口。</li></ol></li><li><p>方法中 <strong>不需要</strong> 参数校验的场景: </p><ol><li>极有可能被循环调用的方法, 不建议对参数进行校验。但在方法说明里必须注明外部参数检查要求。</li><li>底层的方法调用频度都比较高。毕竟是像纯净水过滤的最后一道, 参数错误不太可能到底层才会暴露问题。<ul><li>一般 DAO 层与 Service层都在同一个应用中, 部署在同一台服务器中, 所以 DAO 的参数校验, 可以省略。</li></ul></li><li>被声明成 private 只会被自己代码所调用的方法, 如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题, 此时可以不校验参数。</li></ol></li></ol><h2 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>类、类属性、类方法的注释必须使用 Javadoc 规范, 使用 /*<em> 内容 </em>/ 格式, 不得使用 // xxx 方式。</p><ul><li>为了能在IDE中快速查看注释</li></ul></li><li><p>所有的抽象方法 （包括接口中的方法） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外, 还必须指出该方法做什么事情, 实现什么功能。</p><ul><li>并且声明 对子类的实现要求, 或者调用注意事项</li></ul></li><li><p>所有的类都必须添加创建者和创建日期。</p></li><li><p>方法内部单行注释, 在被注释语句上方另起一行, 使用//注释(而不是行尾注释)。方法内部多行注释使用 /<em> </em>/ 注释, 注意与代码对齐。</p></li><li><p>所有的枚举类型字段必须要有注释, 说明每个数据项的用途。</p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>与其“半吊子”英文来注释, 不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</p><ul><li>反例: TCP连接超时 解释成 传输控制协议连接超时, 反而更难以理解</li></ul></li><li><p>代码修改的同时, 注释也要进行相应的修改, 尤其是参数、返回值、异常、核心逻辑等的修改。</p><ul><li>代码与注释更新不同步, 就像路网与导航软件更新不同步一样, 如果导航软件严重滞后, 就失去了导航的意义。</li></ul></li><li><p>谨慎注释掉代码, 尽量要配合说明, 而不是简单的注释掉, 如果无用, 则删除即可</p><ul><li>代码被注释掉有两种可能性: <ol><li>后续会恢复此段代码逻辑, 若无注释,难以知晓注释动机</li><li>永久不用: 建议直接删除, 仓库有历史记录的</li></ol></li></ul></li><li><p>对于注释的要求: </p><ol><li>第一、能够准确反应设计思想和代码逻辑</li><li>第二、能够描述业务含义, 使别的程序员能够迅速了解到代码背后的信息。</li><li>完全没有注释的大段代码对于阅读者形同天书, 注释是给自己看的, 即使隔很长时间, 也能清晰理解当时的思路 ;  </li><li>注释也是给继任者看的, 使其能够快速接替自己的工作。</li></ol></li><li><p>好的命名、代码结构是自解释的, 注释力求精简准确、表达到位。避免出现注释的一个极端:过多过滥的注释, 代码的逻辑一旦修改, 修改注释是相当大的负担。</p></li><li><p>特殊注释标记, 请注明标记人与标记时间。注意及时处理这些标记, 通过标记扫描, 经常清理此类标记。 线上故障有时候就是来源于这些标记处的代码。</p><ol><li>待办事项 (TODO) : 标记人, 标记时间,  [ 预计处理时间 ]<ul><li>表示需要实现, 但目前还未实现的功能。这实际上是一个 Javadoc 的标签, 目前的 Javadoc还没有实现, 但已经被广泛使用。只能应用于类, 接口和方法 （ 因为它是一个 Javadoc 标签 ） 。</li></ul></li><li>错误, 不能工作 （FIXME） : 标记人, 标记时间,  [ 预计处理时间 ]<ul><li>在注释中用 FIXME 标记错误的代码, 不能工作, 需要及时纠正的情况。</li></ul></li></ol></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong><code>强制</code></strong></p><ol><li><p>在使用正则表达式时, 利用好其预编译功能, 可以有效加快正则匹配速度。</p><ul><li>不要在方法体内定义:  Pattern pattern =  Pattern.compile( 规则 );</li></ul></li><li><p>velocity 调用 POJO 类的属性时, 建议直接使用属性名取值即可, 模板引擎会自动按规范调用 POJO 的 getXxx() , </p><ul><li>如果是 boolean 基本数据类型变量 （boolean 命名不需要加 is前缀 ） , 会自动调用 isXxx() 方法。</li><li><strong>注意</strong> 如果是 Boolean 包装类对象, 优先调用 getXxx() 的方法。</li></ul></li><li><p>后台输送给页面的变量必须加 $!{var} ——中间的感叹号。</p><ul><li>如果 var 为 null 或者不存在, 那么 ${var} 会直接显示在页面上。</li></ul></li><li><p>注意 Math.random() 这个方法返回是 double 类型, 注意取值的范围 0 &lt;= x &lt;1 （ 能够取到零值, 注意除零异常 ） , </p><ul><li>如果想获取整数类型的随机数, 不要将 x 放大 10 的若干倍然后取整, 直接使用 Random 对象的 nextInt 或者 nextLong 方法。</li></ul></li><li><p>获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</p><ul><li>如果想获取更加精确的纳秒级时间值, 用 System.nanoTime(), 在 JDK8 中, 针对统计时间等场景, 推荐使用 Instant 类。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>尽量不要在视图模板中加入变量声明、逻辑运算符, 更不要加入任何复杂的逻辑。</p><ul><li>根据MVC理论, 视图的原则是展示, 不要抢模板和控制器的活</li></ul></li><li><p>任何数据结构的构造或初始化, 都应指定大小, 避免数据结构无限增长吃光内存。</p></li><li><p>及时清理不再使用的代码段或配置信息, 避免程序过度臃肿, 代码冗余</p><ul><li>对于暂时被注释掉, 后续可能恢复使用的代码片段, 在注释代码上方, 统一规定使用三个斜杠来说明注释掉代码的理由</li></ul></li></ol><h1 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong><code>强制</code></strong></p><ol><li><p>Java类库中定义的一类 RuntimeException 可以通过预先检查进行规避, 而不应该通过 catch 来处理</p><ul><li>比如 IndexOutOfBoundsException NullPointerException 等等.</li><li>无法通过预检查的异常除外, 如在解析一个外部传来的字符串形式的数字时, 通过 catch NumberFormatException 来实现</li><li>正例: if (obj != null){…}</li><li>反例: try{obj.method()} catch(NullPointerException e){…}</li></ul></li><li><p>异常不要用来做流程控制, 条件控制, 因为异常的处理效率比条件分支低.</p></li><li><p>对大段代码进行 try-catch,  这是不负责任的表现。 </p><ul><li>catch 时请分清稳定代码和非稳定代码, 稳定代码指的是无论如何不会出错的代码。</li><li>对于非稳定代码的 catch 尽可能进行区分异常类型, 再做对应的异常处理。</li><li>但是! 新手来说,分不清稳不稳定, 最好用大 try 块, 避免有异常遗漏没有处理</li></ul></li><li><p>捕获异常是为了处理它, 不要捕获了却什么都不处理而抛弃之, 如果不想处理它, 请将该异常抛给它的调用者。</p><ul><li>最外层的业务使用者, 必须处理异常, 将其转化为用户可以理解的内容。</li></ul></li><li><p>有 try 块放到了事务代码中,  catch 异常后, 如果需要回滚事务, 一定要注意手动回滚事务。</p></li><li><p>finally 块必须对资源对象、流对象进行关闭, 有异常也要做 try-catch 。</p><ul><li>对于 JDK7及以上, 可以使用 try-with-resources 方式。</li></ul></li><li><p>不能在 finally 块中使用 return ,  finally 块中的 return 返回后方法结束执行, 不会再执行 try 块中的 return 语句。</p><ul><li>? try 还没走完就进了 finally ? </li></ul></li><li><p>捕获与抛出的异常, 必须是完全匹配, 或者捕获的异常是抛出的异常的父类。</p><ul><li>说明: 如果预期对方抛的是绣球, 实际接到的是铅球, 就会产生意外情况。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>方法的返回值可以为 null, 不强制返回空集合, 或者空对象等, 必须添加注释充分说明什么情况下会返回 null 值。<strong>调用方</strong>需要进行 null 判断防止 NPE 问题。</p><ul><li>本规约明确 <strong>防止 NPE 是调用者的责任</strong>。即使被调用方法返回空集合或者空对象, 对调用者来说, 也并非高枕无忧, 必须考虑到远程调用失败, 运行时异常等场景返回 null 的情况。</li></ul></li><li><p>防止 NPE, 是程序员的基本修养, 注意 NPE 产生的场景: </p><ol><li>返回类型为基本数据类型, return包装类型的对象时, 自动拆箱有可能产生 NPE.<ul><li>反例:  <code>public int f() {  return Integer对象};</code> 如果为 null , 自动拆箱将抛出 NPE</li></ul></li><li>数据库的查询结果可能为 null</li><li>集合里的元素即使 isNotEmpty , 取出的数据元素也可能为 null </li><li>远程调用返回对象时, 一律要求进行 NPE 检查</li><li>对于 Session 中获取的数据, 建议 NPE 检查</li><li>级联调用 <code>obj.getA().getB().getC();</code> 一连串调用, 易产生 NPE </li></ol></li><li><p>在代码中使用“抛异常”还是“返回错误码”</p><ul><li>对于公司外的 http/api 开放接口必须使用“错误码”; </li><li>而应用内部推荐异常抛出; </li><li>跨应用间 RPC 调用优先考虑 <strong>使用 Result 方式</strong>, 封装 isSuccess()方法, “错误码”, “错误简短信息”。</li><li>关于 RPC 方法返回方式使用 Result 方式的理由: <ol><li>使用抛异常返回方式, 调用方如果没有捕获到就会产生运行时错误。</li><li>如果不加栈信息, 只是 new 自定义异常, 加入自己的理解的 error message, 对于调用端解决问题的帮助不会太多<ul><li>如果加了栈信息, 在频繁调用出错的情况下, 数据序列化和传输的性能损耗也是问题。</li></ul></li></ol></li></ul></li><li><p>定义时区分 unchecked/checked 异常, 避免直接抛出 RuntimeException, 更不允许抛出 Exception 或者 Throwable, 应使用有业务含义的自定义异常</p><ul><li>推荐业界已定义过的自定义异常, 如:  DAOException /  ServiceException 等。</li></ul></li><li><p>避免出现重复的代码 （Don ’ t Repeat Yourself） , 即 DRY 原则。</p><ul><li>随意复制和粘贴代码, 必然会导致代码的重复, 在以后需要修改时, 需要修改所有的副本, 容易遗漏。必要时抽取共性方法, 或者抽象公共类, 甚至是组件化.</li><li>正例: 一个类中有多个public方法, 都需要进行数行相同的参数校验操作, 这个时候请抽取:</li><li><code>private boolean checkParam(DTO dto){...}</code></li></ul></li></ol><h2 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>应用中不可直接使用日志系统 （Log4j, Logback） 中的 API , 而应依赖使用日志框架 SLF4J 中的API, 使用门面模式的日志框架, 有利于维护和各个类的日志处理方式统一。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(A.class);</span><br></pre></td></tr></table></figure></li><li><p>日志文件推荐至少保存 15 天, 因为有些异常具备以“周”为频次发生的特点。</p></li><li><p>应用中的扩展日志 （ 如打点、临时监控、访问日志等 ） 命名方式: appName_logType_logName.log 。 </p><ul><li>logType: 日志类型<ul><li>推荐分类有stats / desc / monitor / visit 等</li></ul></li><li>logName: 日志描述<ul><li>这种命名的好处: 通过文件名就可知道日志文件属于什么应用, 什么类型, 什么目的, 也有利于归类查找。</li></ul></li><li>推荐对日志进行分类, 错误日志和业务日志尽量分开存放, 便于开发人员查看, 也便于通过日志对系统进行及时监控。</li></ul></li><li><p>对 trace / debug / info 级别的日志输出, 必须使用条件输出形式或者使用占位符的方式。</p><ul><li><code>logger.debug(&quot;Processing trade with id : &quot; + id + &quot; symbol : &quot; + symbol);</code></li><li>如果日志级别是 warn , 上述日志不会打印, 但是会执行字符串拼接操作</li><li>并且若 symbol 是对象, 会执行 toString() 方法, 浪费了系统资源, 执行了上述操作, 最终日志却没有打印。</li></ul></li><li><p>避免重复打印日志, 浪费磁盘空间, 务必在 log4j.xml 中设置 <code>additivity = false</code></p><ul><li><code>&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code></li></ul></li><li><p>异常信息应该包括两类信息: 案发现场信息和异常堆栈信息。如果不处理,就要通过关键字 throws 上抛</p><ul><li><code>logger.error(各类参数或者对象toString + &quot;_&quot; + e.getMessage(), e)</code></li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>可以使用 warn 日志级别来记录<code>用户输入参数错误</code>的情况, 避免用户投诉时, 无所适从。</p><ul><li>注意日志输出的级别,  error 级别只记录系统逻辑出错、异常等重要的错误信息。</li><li>如非必要, 请不要在此场景打出 error 级别。</li></ul></li><li><p>谨慎地记录日志。生产环境禁止输出 debug 日志 ;  有选择地输出 info 日志 ;  如果使用 warn 来记录刚上线时的业务行为信息, 一定要注意日志输出量的问题, 避免把服务器磁盘撑爆, 并记得及时删除这些观察日志。</p><ul><li>大量地输出无效日志, 不利于系统性能提升, 也不利于快速定位错误点。</li><li>记录日志时请思考: <ul><li>这些日志真的有人看吗？</li><li>看到这条日志你能做什么？</li><li>能不能给问题排查带来好处？</li></ul></li></ul></li></ol><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p><strong><code>强制</code></strong></p><ol><li><p>好的单元测试必须遵守 AIR 原则 </p><ul><li>单元测试在线上运行时, 就像空气 AIR 一样不存在, 但是测试质量的保障上, 却是非常关键的</li><li>好的单元测试宏观上来说, 具有自动化, 独立性, 可重复执行的特点<ul><li>A: Automatic  </li><li>I: Independent</li><li>R: Repeatable</li></ul></li></ul></li><li><p>单元测试应该是全自动执行的, 而且是非交互式的. 测试框架通常是定期执行的, 执行过程中必须完全自动化才有意义.</p><ul><li>输出结果需要人工检查的测试不是一个好的单元测试, 单元测试中不准使用 System.out 来进行人工验证, 必须使用 assert.</li></ul></li><li><p>保持单元测试的独立性. 为了保证单元测试稳定可靠且便于维护, 单元测试用例之间决不能互相调用, 也不能依赖执行的先后次序.</p><ul><li>method2 需要依赖 method1 的执行, 将执行结果作为method2 的输入.</li></ul></li><li><p>单元测试是可以重复执行的, 不能受到外界环境的影响.</p><ul><li>说明: <ul><li>单元测试通常会放到持续集成中, 每次有代码 check in 时单元测试都会被执行.</li><li>如果测试对外部环境(网络, 服务, 中间件等)有依赖, 容易导致持续集成机制的不可用.</li></ul></li><li>正例: <ul><li>为了不受外界环境影响, 要求设计代码时就把SUT的依赖改成注入, 在测试时用Spring这样的DI框架注入一个本地(内存)实现或者Mock实现.</li></ul></li></ul></li><li><p>对于单元测试, 要保证测试粒度足够小, 有助于精确定位问题. 单测粒度至多是类级别, 一般是方法级别.</p><ul><li>只有测试粒度小才能在出错时尽快定位到出错位置. 单测不负责检查跨类或者夸系统的交互逻辑, 那是集成测试的领域.</li></ul></li><li><p>核心业务, 核心应用, 核心模块的增量代码确保单元测试通过.</p><ul><li>新增代码及时补充单元测试, 如果新增代码影响了原有单元测试, 请及时修正.</li></ul></li><li><p>单元测试代码必须写在如下工程目录: src/test/java 不允许写在业务代码目录下.</p><ul><li>源码构建时会跳过此目录, 而单元测试框架默认是扫描此目录.</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>单元测试的基本目标: 语句覆盖率达到70%; 核心模块的语句覆盖率和分支覆盖率都要达到100%.</p><ul><li>在工程规约的应用分层中提高的DAO层, Manager层, 可重用度高的Service, 都应该进行单元测试.</li></ul></li><li><p>编写单元测试代码遵守BCDE原则, 以保证被测试模块的交付质量.</p><ul><li>B: Border, 边界值测试, 包括循环边界 特殊取值 特殊时间点 数据顺序等.</li><li>C: Correct, 正确的输入, 并得到预期的结果.</li><li>D: Design, 与设计文档相结合, 来编写单元测试.</li><li>E: Error, 强制错误信息输入 (如: 非法数据 异常流程 非业务允许输入等), 并得到预期的结果.</li></ul></li><li><p>对于数据库相关的查询, 更新, 删除等操作, 不能假设数据库里的数据是存在的, 或者直接操作数据库把数据插入进行, 请使用程序插入或者导入数据的方式来准备数据.(使用内存数据库就容易些)</p></li><li><p>和数据库相关的单元测试, 可以设定自动回滚机制, 不给数据库造成脏数据. 或者对单元测试产生的数据有明确的前后缀标识.</p><ul><li>在RDC内部单元测试中, 使用 RDC_UNIT_TEST_ 的前缀标识数据</li></ul></li><li><p>对于不可测的代码建议做必要的重构, 使代码变得可测, 避免为了达到测试要求而书写不规范测试代码.</p></li><li><p>在设计评审阶段, 开发人员需要和测试人员一起确定单元测试范围, 单元测试最好覆盖所有测试用例(UC).</p></li><li><p>单元测试作为一种质量保障手段, 不建议在项目发布后补充单元测试用例, 建议在项目提测前完成单元测试.</p></li><li><p>为了更方便地进行单元测试, 业务代码应避免以下情况:</p><ul><li>构造方法中做的事情过多.</li><li>存在过多的全局变量和静态方法.</li><li>存在过多的外部依赖.</li><li>存在过多的条件语句 (多层条件语句建议使用卫语句,策略模式,状态模式等方式重构)</li></ul></li><li><p>不要对单元测试存在如下误解:</p><ul><li>那是测试要干的事情. 本文是开发手册, 凡是本文内容都是与开发强相关的.</li><li>单元测试代码是多余的</li><li>单元测试不需要维护</li><li>单元测试和线上故障没有辩证关系</li></ul></li></ol><h1 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h1><p><strong><code>强制</code></strong></p><ol><li><p>隶属于用户个人的页面或者功能必须进行权限控制校验。</p><ul><li>防止没有做水平权限校验就可随意访问、修改 删除 别人的数据, 比如查看他人的私信内容, 修改他人的订单</li></ul></li><li><p>用户敏感数据禁止直接展示, 必须对展示数据脱敏。</p><ul><li>查看个人手机号码会显示成:158<em>**</em>9119, 隐藏中间 4 位, 防止隐私泄露。</li></ul></li><li><p>用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定, 防止 SQL 注入, 禁止字符串拼接 SQL 访问数据库。</p></li><li><p>用户请求传入的任何参数必须做有效性验证。</p><ul><li>忽略参数校验可能导致: <ul><li>page size 过大导致内存溢出</li><li>恶意 order by 导致数据库慢查询</li><li>任意重定向</li><li>SQL 注入</li><li>反序列化注入</li><li>正则输入源串拒绝服务 ReDoS</li></ul></li><li>Java 代码用正则来验证客户端的输入, 有些正则写法验证普通用户输入没有问题, 但是如果攻击人员使用的是特殊构造的字符串来验证, 有可能导致死循环的效果。</li></ul></li><li><p>禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</p></li><li><p>表单, AJAX 提交必须执行 CSRF 安全过滤</p><ul><li>CSRF(Cross-site request forgery) 跨站请求伪造是一类常见编程漏洞。</li><li>对于存在CSRF 漏洞的应用/网站, 攻击者可以事先构造好 URL, 只要受害者用户一访问, 后台便在用户不知情情况下对数据库中用户参数进行相应修改。<blockquote><p><strong>个人理解</strong> 万一ajax接口的API暴露了, 被别有用心的人利用就能构造好页面, 用于钓鱼什么的</p></blockquote></li></ul></li><li><p>在使用平台资源, 譬如短信、邮件、电话、下单、支付, 必须实现正确的防重放限制, 如数量限制、疲劳度控制、验证码校验, 避免被滥刷、资损。</p><ul><li>如注册时发送验证码到手机, 如果没有限制次数和频率, 那么可以利用此功能骚扰到其它用户, 并造成短信平台资源浪费。</li></ul></li><li><p>发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。</p></li></ol><h1 id="MySQL规约"><a href="#MySQL规约" class="headerlink" title="MySQL规约"></a>MySQL规约</h1><h2 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>表达是与否概念的字段, 必须使用 is_xxx 的方式命名, 数据类型是 unsigned tinyint (1 表示是, 0 表示否)</p><ul><li>任何字段如果为非负数, 必须是 unsigned 。</li><li>正例: 表达逻辑删除的字段名 is_deleted, 1表示删除, 0表示未删除.<blockquote><p>个人理解: 是不是简单的整型枚举也可以这么用呢</p></blockquote></li></ul></li><li><p>表名、字段名必须使用小写字母或数字; 禁止出现数字开头, 禁止两个下划线中间只出现数字。数据库字段名的修改代价很大, 因为无法进行预发布, 所以字段名称需要慎重考虑。</p><ul><li>MySQL 在 Windows 下不区分大小写, 但在 Linux 下默认是区分大小写, 因此 数据库名, 表名 字段名 都不允许出现任何大写字母.</li></ul></li><li><p>表名不使用复数名词。</p><ul><li>表名应该仅仅表示表里面的实体内容, 不应该表示实体数量, 对应于 DO 类名也是单数形式, 符合表达习惯。</li></ul></li><li><p>禁用保留字, 如 desc 、 range 、 match 、 delayed 等, 请参考 MySQL 官方保留字。</p></li><li><p>主键索引名为 pk_字段名, 唯一索引名为 uk_字段名, 普通索引名则为 idx_字段名。</p><ul><li>pk_ 即 primary key, uk_ 即  unique key, idx_ 即 index 的简称。</li></ul></li><li><p>小数类型为 decimal , 禁止使用 float 和 double 。</p><ul><li>float 和 double 在存储的时候, 存在精度损失的问题, 很可能在值的比较时, 得到不正确的结果。</li><li>如果存储的数据范围超过 decimal 的范围, 建议将数据拆成整数和小数分开存储。</li></ul></li><li><p>如果某字段存储的字符串长度几乎是固定的, 使用 char 定长字符串类型。</p></li><li><p>varchar 是可变长字符串, 不预先分配存储空间, 长度不要超过 500, </p><ul><li>如果存储长度大于此值, 定义字段类型为 text , 独立出来一张表, 用主键来对应, 避免影响其它字段索引效率。</li></ul></li><li><p>表必备三字段:  id,  gmt_create,  gmt_modified 。</p><ul><li>其中 id 必为主键, 类型为 unsigned bigint 、单表时自增、步长为 1。 </li><li>gmt_create ,gmt_modified 的类型均为 date_time 类型, 前者现在时表示主动创建, 后者过去分词表示被动更新.</li><li>GMT 是指格林尼治时间, 这样的话, 就是会让表的数据和时间关联上, 具有一定数据分析价值</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>表的命名最好是加上“业务名称_表的作用”。</p><ul><li>正例: alipay_task force_project trade_config</li></ul></li><li><p>库名与应用名称尽量一致。</p></li><li><p>如果修改字段含义或对字段表示的状态追加时, 需要及时更新字段注释。</p></li><li><p>字段允许适当冗余, 以提高查询性能, 但必须考虑数据一致, 冗余字段应遵循: </p><ol><li>不是频繁修改的字段。</li><li>不是 varchar 超长字段, 更不能是 text 字段。</li></ol><ul><li>正例: 商品类目名称使用频率高, 字段长度短, 名称基本一成不变, 可在相关联的表中冗余存储类目名称, 避免关联查询。</li></ul></li><li><p>单表行数超过 500 万行或者单表容量超过 2 GB, 才推荐进行分库分表。</p><ul><li>如果预计三年后的数据量根本达不到这个级别, 请不要在创建表时就分库分表。</li></ul></li><li><p>合适的字符存储长度, 不但节约数据库表空间、节约索引存储, 更重要的是提升检索速度。</p><ul><li><p>如下表, 其中无符号值可以避免误存负数, 且扩大了表示范围.</p><p>| 对象 | 年龄区间 | 类型 | 字节 | 表示范围 |<br>|:—-:|:—-:|:—-|:—-:|:—-|<br>| 人 | 150岁之内 | unsigned tinyint | 1 | 0 - 255 |<br>| 龟 | 数百年 | unsigned smallint | 2 | 0 - 65535 |<br>| 恐龙化石 | 数千万年 | unsigned int | 4 | 0 - 约42.9亿 |<br>| 太阳 | 约50亿年 | unsigned bigint | 8 | 0 - 约10的19次幂 |</p></li></ul></li></ol><h2 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>业务上具有唯一特性的字段, 即使是多个字段的组合, 也必须建成唯一索引。</p><ul><li>不要以为唯一索引影响了 insert 速度, 这个速度损耗可以忽略, 但提高查找速度是明显的 ;  </li><li>另外, 即使在应用层做了非常完善的校验控制, 只要没有唯一索引, 根据墨菲定律, 必然有脏数据产生。</li></ul></li><li><p>超过三个表禁止 join。需要 join 的字段, 数据类型必须保持绝对一致; 多表关联查询时, 保证被关联的字段需要有索引。</p><ul><li>即使双表 join 也要注意表索引、SQL 性能。</li></ul></li><li><p>在 varchar 字段上建立索引时, 必须指定索引长度, 没必要对全字段建立索引, 根据实际文本区分度决定索引长度即可。</p><ul><li>索引的长度与区分度是一对矛盾体, 一般对字符串类型数据, 长度为 20 的索引, 区分度会高达 90% 以上, </li><li>可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。</li></ul></li><li><p>页面搜索严禁左模糊或者全模糊, 如果需要请使用搜索引擎来解决。</p><ul><li>索引文件具有 B-Tree 的最左前缀匹配特性, 如果左边的值未确定, 那么无法使用此索引。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>如果有 order by 的场景, 请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分,</p><ul><li>并且放在索引组合顺序的最后, 避免出现 file_sort 的情况, 影响查询性能。</li><li>正例: <code>where a = ? and b = ? order by c;</code> 索引:  a_b_c</li><li>反例: 索引中有范围查找, 那么索引有序无法利用, 如: WHERE a &gt; 10 order by b; 索引 a_b 无法排序.</li></ul></li><li><p>利用覆盖索引来进行查询操作, 来避免回表操作。</p><ul><li>如果一本书需要知道第 11 章是什么标题, 会翻开第 11 章对应的那一页吗? 目录浏览一下就好, 这个目录就是起到覆盖索引的作用.</li><li>能够建立索引的种类: 主键索引、唯一索引、普通索引, 而覆盖索引是一种查询的一种效果, 用 explain 的结果, extra 列会出现:  using index 。</li><li>覆盖索引是select的数据列只用从索引中就能够取得, 不必读取数据行, 换句话说查询列要被所建的索引覆盖。<ul><li><strong>理解方式一</strong>: 索引是高效找到行的一个方法, 但是一般数据库也能使用索引找到一个列的数据, 因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据; 当能通过读取索引就可以得到想要的数据, 那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引</li><li><strong>理解方式二</strong>: 是非聚集复合索引的一种形式, 它包括在查询里的Select、Join和Where子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段, 也即, 索引包含了查询正在查找的数据）。</li></ul></li></ul></li><li><p>利用延迟关联或者子查询优化超多分页场景。</p><ul><li>MySQL 并不是跳过 offset 行, 而是取 offset + N 行, 然后返回放弃前 offset 行, 返回 N 行, 那当 offset 特别大的时候, 效率就非常的低下, 要么控制返回的总页数, 要么对超过特定阈值的页数进行 SQL 改写.</li><li>正例: 先快速定位需要获取的id段, 然后再关联:<ul><li>select a.* from table_a a, (select id from table_a where 条件 limit 100000, 20) b where a.id = b.id</li></ul></li></ul></li><li><p>SQL 性能优化的目标: 至少要达到  range 级别, 要求是 ref 级别, 如果可以是 consts最好。</p><ol><li>consts 单表中最多只有一个匹配行 （ 主键或者唯一索引 ） , 在优化阶段即可读取到数据。</li><li>ref 指的是使用普通的索引 （normal index） 。</li><li>range 对索引进行范围检索。</li></ol><ul><li>反例: explain 表的结果,  type = index , 索引物理文件全扫描, 速度非常慢, 这个 index 级别比较 range 还低, 与全表扫描是小巫见大巫。</li></ul></li><li><p>建组合索引的时候, 区分度最高的在最左边。</p><ul><li>正例: 如果 <code>where a = ? and b = ?</code>,  a 列的几乎接近于唯一值, 那么只需要单建 idx_a 索引即可。</li><li>存在非等号和等号混合判断条件时, 在建索引时, 请把等号条件的列前置。</li><li>如:  <code>where a &gt; ? and b = ?</code> 那么即使 a 的区分度更高, 也必须把 b 放在索引的最前列。</li></ul></li><li><p>防止因字段类型不同造成的隐式转换, 导致索引失效.</p></li><li><p>创建索引时避免有如下极端误解: </p><ol><li>宁缺毋滥. 认为一个查询就需要建一个索引。</li><li>宁缺毋滥. 认为索引会消耗空间、严重拖慢更新和新增速度。</li><li>抵制惟一索引. 认为业务的惟一性一律需要在应用层通过 “先查后插” 方式解决。</li></ol></li></ol><h2 id="SQL规约"><a href="#SQL规约" class="headerlink" title="SQL规约"></a>SQL规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>不要使用 count(列名) 或 count(常量) 来替代 count(<em>),  count( </em> ) 就是 SQL 92 定义的标准统计行数的语法, 跟数据库无关, 跟 NULL 和非 NULL 无关。</p><ul><li>count( * ) 会统计值为 NULL 的行, 而 count(列名) 不会统计此列为 NULL 值的行。</li></ul></li><li><p>count(distinct col) 计算该列除 NULL 之外的不重复行数。注意 count(distinct col1,  col2) 如果其中一列全为 NULL, 那么即使另一列有不同的值, 也返回为 0。</p></li><li><p>当某一列的值全是 NULL 时,  count(col) 的返回结果为 0, 但 sum(col) 的返回结果为NULL , 因此使用 sum() 时需注意 NPE 问题。</p><ul><li>正例: 可以使用如下方式来避免 sum 的 NPE 问题:  <code>SELECT IF(ISNULL(SUM(g)) ,0, SUM(g))FROM table;</code></li></ul></li><li><p>使用 ISNULL() 来判断是否为 NULL 值。注意:  NULL 与任何值的直接比较都为 NULL。</p><p> | 表达式 | 返回值 |<br> |:—-|:—-:|<br> | NULL&lt;&gt;NULL | NULL 而不是 false |<br> | NULL=NULL | NULL 而不是 true |<br> | NULL&lt;&gt;1 | NULL 而不是 true |</p></li><li><p>在代码中写分页查询逻辑时, 若 count 为 0 应直接返回, 避免执行后面的分页语句。</p></li><li><p>不得使用外键与级联, 一切外键概念必须在应用层解决。</p><ul><li>说明: 以学生和成绩的关系为例, 学生表中的 student_id 是主键, 那么成绩表中的 student_id 则为外键。<ul><li>如果更新学生表中的 student_id , 同时触发成绩表中的 student_id 更新, 则为级联更新。</li></ul></li><li>外键与级联更新适用于单机低并发, 不适合分布式、高并发集群; 级联更新是强阻塞, 存在数据库更新风暴的风险; </li><li>并且外键影响数据库的插入速度。</li></ul></li><li><p>禁止使用存储过程, 存储过程难以调试和扩展, 更没有移植性。</p></li><li><p>数据订正时, 删除和修改记录时, 要先 select, 避免出现误删除, 确认无误才能执行更新语句。</p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>in 操作能避免则避免, 若实在避免不了, 需要仔细评估 in 后边的集合元素数量, 控制在 1000 个之内。</p></li><li><p>如果有全球化需要, 所有的字符存储与表示, 均以 utf-8 编码, 注意字符统计函数的区别</p><ul><li><strong>注意</strong>: <ul><li>SELECT LENGTH( “轻松工作” );  返回为 12</li><li>SELECT CHARACTER _ LENGTH( “轻松工作” );  返回为 4</li></ul></li><li>如果需要存储表情, 那么使用 utfmb4(这才是真正的UTF-8) 来进行存储, MySQL 的 utf-8 编码只能存放3字节的字符</li></ul></li><li><p>TRUNCATE TABLE 比 DELETE 速度快, 且使用的系统和事务日志资源少, 但 TRUNCATE 无事务且不触发 trigger, 有可能造成事故, 故不建议在开发代码中使用此语句。</p><ul><li>TRUNCATE TABLE 在功能上与不带  WHERE 子句的  DELETE 语句相同。</li></ul></li></ol><h2 id="ORM映射"><a href="#ORM映射" class="headerlink" title="ORM映射"></a>ORM映射</h2><p><strong><code>强制</code></strong></p><ol><li><p>在表查询中, 一律不要使用 * 作为查询的字段列表, 需要哪些字段必须明确写明。</p><ol><li>增加查询分析器解析成本。</li><li>增减字段容易与 resultMap 配置不一致。</li></ol></li><li><p>POJO 类的 boolean 属性不能 is 开头, 而数据库字段必须加 is_, 要求在 resultMap 中进行字段与属性之间的映射。</p><ul><li>参见定义POJO类以及数据库字段定义的规定, 在 <code>&lt;resultMap&gt;</code> 中增加映射是必须的, 在 Mybatis Generator 生成的代码中, 需要进行对应的修改.</li></ul></li><li><p>不要用 resultClass 当返回参数, 即使所有类属性名与数据库字段一一对应, 也需要定义;  反过来, 每一个表也必然有一个与之对应。</p><ul><li>说明: 配置映射关系, 使字段与DO类解耦, 方便维护.</li></ul></li><li><p><code>sql.xml</code> 配置中参数注意使用: #{}, #param# 不要使用 ${} 此种方式容易出现 SQL 注入。</p></li><li><p>iBATIS 自带的 queryForList(String statementName , int start , int size) 不推荐使用。</p><ul><li>其实现方式是在数据库取到 statementName 对应的SQL语句的所有记录, 再通过 subList 取 start, size 的子集合 线上因为这个原因曾经出现过 OOM </li><li>正例: <ul><li>Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</li><li>map.put(“start”, start);</li><li>map.put(“size”, size);</li></ul></li></ul></li><li><p>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</p><ul><li>resultClass=”Hashtable”, 会置入字段名和属性值, 但是值的类型不可控 </li></ul></li><li><p>更新数据表记录时, 必须同时更新记录对应的 gmt_modified 字段值为当前时间。</p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>不要写一个大而全的数据更新接口, 传入为 POJO 类, 不管是不是自己的目标更新字段, </p><ul><li>都进行 <code>update table set c1=value1,c2=value2,c3=value3;</code> </li><li>这是不对的。执行 SQL时, 尽量不要更新无改动的字段, 一是易出错; 二是效率低 ; 三是 binlog 增加存储。</li></ul></li><li><p>@Transactional 事务不要滥用。事务会影响数据库的 QPS, 另外使用事务的地方需要考虑各方面的回滚方案, </p><ul><li>包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</li></ul></li><li><p><code>&lt;isEqual&gt;</code> 中的 compareValue 是与属性值对比的常量, 一般是数字, 表示相等时带上此条件;  </p><ul><li><code>&lt;isNotEmpty&gt;</code> 表示不为空且不为 null 时执行 ; </li><li><code>&lt;isNotNull&gt;</code> 表示不为 null 值时执行。</li></ul></li></ol><h1 id="工程规约"><a href="#工程规约" class="headerlink" title="工程规约"></a>工程规约</h1><h2 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h2><p><strong><code>推荐</code></strong></p><ol><li>图中默认上层依赖于下层, 箭头关系表示可直接依赖, 如: 开放接口层可以依赖于Web 层, 也可以直接依赖于 Service 层, 依此类推: <blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Alibaba/ApplicationLevels.png" alt="Application Level" title="">                </div>                <div class="image-caption">Application Level</div>            </figure>  <ul><li><strong>开放接口层</strong>: 可直接封装 Service 接口暴露成 RPC(Remote Procedure Calls) 接口;  通过 Web 封装成 http 接口; 进行网关安全控制, 流量控制等.</li><li><strong>终端显示层</strong>: 各个端的模板渲染并执行显示的层。当前主要是 Velocity 渲染, JS 渲染, JSP 渲染, 移动端展示层等。</li><li><strong>Web 层</strong>: 主要是对访问控制进行转发, 各类基本参数校验, 或者不复用的业务简单处理等。</li><li><strong>Service 层</strong>: 相对具体的业务逻辑服务层。</li><li><strong>Manager 层</strong>: 通用业务处理层, 它有如下特征: <ol><li>对第三方平台封装的层, 预处理返回结果及转化异常信息 ; </li><li>对 Service 层通用能力的下沉, 如缓存方案、中间件通用处理 ; </li><li>与 DAO 层交互, 对 DAO 的业务通用能力的封装, 对多个 DAO 的组合复用</li></ol></li><li><strong>DAO 层</strong>: 数据访问层, 与底层 MySQL、Oracle、 Hbase 等进行数据交互。</li><li><strong>外部接口或第三方平台</strong>: 包括其它部门 RPC 开放接口, 基础平台, 其它公司的 HTTP 接口。</li></ul></blockquote></li></ol><p><strong><code>参考</code></strong></p><ol><li><p><strong>分层异常处理规约</strong> 在 DAO 层, 产生的异常类型有很多, 无法用细粒度异常进行catch, 使用 catch(Exception e) 方式, 并 throw new DAOException(e), 不需要打印日志, </p><ul><li>因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去, 如果同台服务器再打日志, 浪费性能和存储。</li><li>在 Service 层出现异常时, 必须记录出错日志信息到磁盘, 尽可能带上必要的参数信息(能够描述出场景的大致状态), 相当于保护案发现场。</li><li>如果 Manager 层与 Service 同机部署, 日志方式与 DAO 层处理一致; 如果是单独部署, 则采用与 Service 一致的处理方式。</li><li>Web 层绝不应该继续往上抛异常, 因为已经处于顶层, 无继续处理异常的方式, 如果意识到这个异常将导致页面无法正常渲染, 那么就应该直接跳转到友好错误页面, 尽量加上友好的错误提示信息。</li><li>开放接口层要将异常处理成错误码和错误信息方式返回。</li></ul></li><li><p>分层领域模型规约: </p><p>| 缩写 | 名称 | 作用 |<br>|:—-|:—-|:—-|<br>| DO | Data Object | 与数据库表结构一一对应, 通过DAO层向上传输数据源对象 |<br>| DTO | Data Transfer Object | 数据传输对象, Service或Manager向外传输的对象 |<br>| BO | Business Object | 由Service层输出的封装业务逻辑的对象 |<br>| AO | Application Object | 应用对象, 在Web层与Service层之间抽象的复用对象模型, 极为贴近展示层, 复用度不高 |<br>| VO | View Object | 显示层对象, 通常是Web向模板引擎传输的对象 |<br>| Qurey | | 数据查询对象, 各层接收上层的查询请求, 注意超过2个参数的查询封装, 禁止使用Map类来传输 |</p></li></ol><h2 id="二方库依赖"><a href="#二方库依赖" class="headerlink" title="二方库依赖"></a>二方库依赖</h2><p><strong><code>强制</code></strong></p><ol><li><p>定义 GAV 遵从以下规则: </p><ul><li><strong>GroupID</strong> 格式:  <code>com.{公司/BU}.业务线.[子业务线]</code>, 最多 4 级。<ul><li>{公司/BU} 例如:  alibaba/taobao/tmall/aliexpress 等 BU; 子业务线可选。</li><li>正例: com.taobao.jstorm 或  com.alibaba.dubbo.register </li></ul></li><li><strong>ArtifactID</strong> 格式: 产品线名-模块名。语义不重复不遗漏, 先到仓库中心去查证一下。<ul><li>正例: dubbo-client /  fastjson-api /  jstorm-tool</li></ul></li><li><strong>Version</strong> : 详细规定参考下方。</li></ul></li><li><p>二方库版本号命名方式: 主版本号.次版本号.修订号</p><ol><li>主版本号: 产品方向改变, 或者大规模API不兼容, 或者架构不兼容升级. </li><li>次版本号: 保持相对兼容性, 增加主要功能特性, 影响范围极小的API不兼容修改.</li><li>修订号: 保持完全兼容性, 修复 bug, 新增次要功能特性等</li></ol><ul><li>说明: 注意起始版本号必须为:  1.0.0 , 而不是 0.0.1, 正式发布的类库必须先去中央仓库进行查证, 使版本号有延续性, 正式版本号不允许覆盖升级</li><li>如当前版本 1.3.3 那么下一个合理的版本号 1.3.4 或者 1.4.0 或 2.0.0</li></ul></li><li><p>线上应用不要依赖 SNAPSHOT 版本（安全包除外）; </p><ul><li>不依赖 SNAPSHOT 版本是保证应用发布的幂等性. 另外, 也可以加快编译时的打包构建.</li></ul></li><li><p>二方库的新增或升级, 保持除功能点之外的其它 jar 包仲裁结果不变。</p><ul><li>如果有改变, 必须明确评估和验证, 建议进行 dependency:resolve 前后信息比对, </li><li>如果仲裁结果完全不一致, 那么通过 dependency:tree 命令, 找出差异点, 进行<code>&lt;excludes&gt;</code>排除 jar 包。</li></ul></li><li><p>二方库里可以定义枚举类型, 参数可以使用枚举类型, 但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。</p></li><li><p>依赖于一个二方库群时, 必须定义一个统一版本变量, 避免版本号不一致。</p><ul><li>说明: 依赖 springframework-core, -context, -beans, 它们都是同一个版本</li><li>可以定义一个变量来保存版本: ${spring.version}, 定义依赖的时候, 引用该版本。</li></ul></li><li><p>禁止在子项目的 pom 依赖中出现相同的 GroupId , 相同的 ArtifactId , 但是不同的Version 。</p><ul><li>在本地调试时会使用各子项目指定的版本号, 但是合并成一个war, 只能有一个版本号出现在最后的lib目录中, 可能出现线下调试是正确的, 发布到线上却出故障的问题.</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>所有 pom 文件中的依赖声明放在 <code>&lt;dependencies&gt;</code> 语句块中, 所有版本仲裁放在<code>&lt;dependencyManagement&gt;</code> 语句块中。</p><ul><li><code>&lt;dependencyManagement&gt;</code> 里只是声明版本, 并不实现引入, 因此子项目需要显式的声明依赖,  version 和 scope 都读取自父 pom 。</li><li>而 <code>&lt;dependencies&gt;</code> 所有声明在主 pom 的 <code>&lt;dependencies&gt;</code> 里的依赖都会自动引入, 并默认被所有的子项目继承。</li></ul></li><li><p>二方库不要有配置项, 最低限度不要再增加配置项。</p></li></ol><p><strong><code>参考</code></strong></p><ol><li>为避免应用二方库的依赖冲突问题, 二方库发布者应当遵循以下原则: <ol><li><strong>精简可控原则</strong> 移除一切不必要的 API 和依赖, 只包含 Service API、必要的领域模型对象、 Utils类、常量、枚举等。<ul><li>如果依赖其它二方库, 尽量是 provided 引入, 让二方库使用者去依赖具体版本号; 无 log 具体实现的依赖, 只依赖日志框架(例如不依赖Logback而是依赖SLF4J)。</li></ul></li><li><strong>稳定可追溯原则</strong> 每个版本的变化应该被记录, 二方库由谁维护, 源码在哪里, 都需要能方便查到。除非用户主动升级版本, 否则公共二方库的行为不应该发生变化。</li></ol></li></ol><h2 id="服务器规约"><a href="#服务器规约" class="headerlink" title="服务器规约"></a>服务器规约</h2><p><strong><code>推荐</code></strong></p><ol><li><p>高并发服务器建议调小 TCP 协议的 time_wait 超时时间。</p><ul><li>说明: 操作系统默认 240 秒后, 才会关闭处于 time_wait 状态的连接, 在高并发访问下, 服务器端会因为处于 time_wait 的连接数太多,可能无法建立新的连接, 所以需要在服务器上调小此等待值。</li><li>正例: 在 linux 服务器上请通过变更 <code>/etc/sysctl.conf</code> 文件去修改该缺省值 （ 秒 ）<ul><li><code>net.ipv4.tcp_fin_timeout = 30</code></li></ul></li></ul></li><li><p>调大服务器所支持的最大文件句柄数 （File Descriptor, 简写为 fd） 。</p><ul><li>说明: 主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理, 即一个连接对应于一个 fd 。<ul><li>主流的 linux 服务器默认所支持最大 fd 数量为 1024, 当并发连接数很大时很容易因为 fd 不足而出现“ open too many files ”错误, 导致新的连接无法建立。 </li><li>建议将 linux服务器所支持的最大句柄数调高数倍 （与服务器的内存数值相关）</li></ul></li></ul></li><li><p>给 JVM 设置 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 参数, 让 JVM 碰到 OOM 场景时输出dump 信息。</p><ul><li>OOM 的发生是有概率的, 甚至有规律地相隔数月才出现一例, 出现时的现场信息对查错非常有价值。</li></ul></li><li><p>在线上生产环境, JVM 的 Xms 和 Xmx 设置一样的内存容量, 避免在GC后调整堆大小带来的压力</p></li><li><p>服务器内部重定向使用 forward;  外部重定向地址使用 URL 拼装工具类来生成, 否则会带来 URL 维护不一致的问题和潜在的安全风险。</p></li></ol><h1 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h1><ol><li><p>POJO (Plain Ordinary Java Object): 在手册中, POJO专指只有 setter/getter/toString 的简单类, 包括 DO/DTO/BO/VO等.</p></li><li><p>GAV (GroupId, AritifactId, Version): Maven 坐标, 是用来唯一标识 jar 包.</p></li><li><p>OOP(Object Oriented Programming): 泛指类,对象的编程处理方式</p></li><li><p>ORM(Object Relation Mapping): 对象关系映射, 对象领域模型与底层数据之间的转换, 本文泛指 iBATIS Mybatis 等框架</p></li><li><p>NPE(java.lang.NullPointerException): 空指针异常</p></li><li><p>SOA(Service-Oriented Architecture): 面向服务架构, 它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署, 组合和使用, 有利于提升组件可重用性, 可维护性.</p></li><li><p>一方库: 本工程内部子项目模块依赖的库 jar包</p></li><li>二方库: 公司内部发布到中央仓库, 可供公司内部其他应用依赖的库 jar包</li><li>三方库: 公司之外的开源库 jar包</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#阿里巴巴java开发手册&quot;&gt;阿里巴巴Java开发手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#编程规约&quot;&gt;编程规约&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#命名规约&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Solution.md</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Blog-Solution/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Blog-Solution/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#解决方案">解决方案</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><blockquote><p>关于问题的解决方案</p></blockquote><p><a href="http://www.cnblogs.com/x-xk/archive/2012/11/17/2770935.html" target="_blank" rel="noopener">站内信设计思路之己见（基于上百万用户）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#解决方案&quot;&gt;解决方案&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-13 12:06&lt;/em&gt;| &lt;a href=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>View.md</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Blog-View/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Blog-View/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#前端">前端</a><ol><li><a href="#基础">基础</a><ol><li><a href="#规范">规范</a></li></ol></li><li><a href="#css">CSS</a></li><li><a href="#相关库">相关库</a><ol><li><a href="#jquery">Jquery</a></li><li><a href="#bootstrap">Bootstrap</a></li><li><a href="#layui">LayUI</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><blockquote><p>半学半就 <a href="https://kuangcp.github.io/main.html" target="_blank" rel="noopener">个人导航页</a></p></blockquote><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><blockquote><p><a href="https://www.cnblogs.com/Smiled/p/8377188.html" target="_blank" rel="noopener">我所理解的前端</a><br><a href="http://blog.csdn.net/limlimlim/article/details/9088161" target="_blank" rel="noopener">Javascript字典操作</a><br><a href="https://segmentfault.com/a/1190000002447815" target="_blank" rel="noopener">js数据结构和算法（五）字典和散列（hash） </a></p></blockquote><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul><li><a href="https://juejin.im/post/592d4a5b0ce463006b43b6da" target="_blank" rel="noopener">前端开发命名规范</a></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><a href="http://www.html5tricks.com/9-nick-css3-menu-button.html" target="_blank" rel="noopener">酷炫按钮</a></li></ul><h2 id="相关库"><a href="#相关库" class="headerlink" title="相关库"></a>相关库</h2><h3 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h3><ul><li><a href="http://www.codeceo.com/article/10-jquery-image-player.html#0-tsina-1-78156-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="noopener">10个超赞的jQuery图片滑块动画</a></li></ul><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><h3 id="LayUI"><a href="#LayUI" class="headerlink" title="LayUI"></a>LayUI</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#前端&quot;&gt;前端&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#基础&quot;&gt;基础&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#规范&quot;&gt;规范&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ZenOfPattern.md</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-ZenOfPattern/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-ZenOfPattern/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#设计模式之禅">设计模式之禅</a><ol><li><a href="#软件设计的一些原则">软件设计的一些原则</a><ol><li><a href="#思维原则">思维原则</a><ol><li><a href="#奥卡姆剃刀原理">奥卡姆剃刀原理</a></li></ol></li><li><a href="#首要原则">首要原则</a><ol><li><a href="#勿重复造轮子">勿重复造轮子</a></li><li><a href="#减法优于加法">减法优于加法</a></li><li><a href="#抽象优于实现">抽象优于实现</a></li><li><a href="#组合优于继承">组合优于继承</a></li><li><a href="#查询与命令分离">查询与命令分离</a></li><li><a href="#够用原则">够用原则</a></li><li><a href="#最少知识原则">最少知识原则</a></li></ol></li><li><a href="#面向对象的solid-原则">面向对象的S.O.L.I.D 原则</a><ol><li><a href="#单一职责原则">单一职责原则</a></li><li><a href="#开闭原则">开闭原则</a></li><li><a href="#里氏代换原则">里氏代换原则</a></li><li><a href="#接口隔离原则">接口隔离原则</a></li><li><a href="#依赖倒置原则">依赖倒置原则</a></li></ol></li><li><a href="#其他原则">其他原则</a><ol><li><a href="#共同封闭原则">共同封闭原则</a></li><li><a href="#共同重用原则">共同重用原则</a></li><li><a href="#好莱坞原则">好莱坞原则</a></li><li><a href="#高内聚低耦合">高内聚低耦合</a></li><li><a href="#惯例优于配置原则">惯例优于配置原则</a></li><li><a href="#关注点分离">关注点分离</a></li><li><a href="#契约式设计">契约式设计</a></li><li><a href="#无环依赖原则">无环依赖原则</a></li></ol></li></ol></li><li><a href="#设计模式">设计模式</a><ol><li><a href="#基础">基础</a></li><li><a href="#策略者模式">策略者模式</a></li><li><a href="#1创建型设计模式">1.创建型设计模式</a></li><li><a href="#2结构型设计模式">2.结构型设计模式</a></li><li><a href="#3行为设计模式">3.行为设计模式</a></li><li><a href="#常见设计模式">【常见设计模式】</a><ol><li><a href="#适配器模式">适配器模式</a></li><li><a href="#中介者模式">中介者模式</a></li><li><a href="#观察者模式">观察者模式</a><ol><li><a href="#单例模式">单例模式</a></li><li><a href="#装饰器模式">装饰器模式</a></li></ol></li><li><a href="#原型模式">原型模式</a></li><li><a href="#生成器模式">生成器模式</a></li></ol></li></ol></li><li><a href="#实践">实践</a><ol><li><a href="#经验之谈">经验之谈</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h1><h2 id="软件设计的一些原则"><a href="#软件设计的一些原则" class="headerlink" title="软件设计的一些原则"></a>软件设计的一些原则</h2><h3 id="思维原则"><a href="#思维原则" class="headerlink" title="思维原则"></a>思维原则</h3><h4 id="奥卡姆剃刀原理"><a href="#奥卡姆剃刀原理" class="headerlink" title="奥卡姆剃刀原理"></a>奥卡姆剃刀原理</h4><h3 id="首要原则"><a href="#首要原则" class="headerlink" title="首要原则"></a>首要原则</h3><h4 id="勿重复造轮子"><a href="#勿重复造轮子" class="headerlink" title="勿重复造轮子"></a>勿重复造轮子</h4><p>-<code>DRY Don’t Repeat Yourself</code><br>是一个最简单的法则，也是最容易被理解的。但它也可能是最难被应用的（因为要做到这样，我们需要在泛型设计上做相当的努力，这并不是一件容易的事）。它意味着，当我们在两个或多个地方的时候发现一些相似的代码的时候，我们需要把他们的共性抽象出来形一个唯一的新方法，并且改变现有的地方的代码让他们以一些合适的参数调用这个新的方法。</p><h4 id="减法优于加法"><a href="#减法优于加法" class="headerlink" title="减法优于加法"></a>减法优于加法</h4><ul><li><code>KISS Keep It Simple, Stupid</code><br>KISS原则在设计上可能最被推崇的，在家装设计，界面设计 ，操作设计上，复杂的东西越来越被众人所BS了，而简单的东西越来越被人所认可，比如这些UI的设计和我们中国网页（尤其是新浪的网页）者是负面的例子。<br>“宜家”（IKEA）简约、效率的家居设计、生产思路；“微软”（Microsoft）“所见即所得”的理念；“谷歌”（Google)简约、直接的商业风格，无一例外的遵循了“kiss”原则，<br>也正是“kiss”原则，成就了这些看似神奇的商业经典。而苹果公司的iPhone/iPad将这个原则实践到了极至。</li></ul><p>把一个事情搞复杂是一件简单的事，但要把一个复杂的事变简单，这是一件复杂的事。</p><h4 id="抽象优于实现"><a href="#抽象优于实现" class="headerlink" title="抽象优于实现"></a>抽象优于实现</h4><p>-<code>Program to an interface, not an implementation</code></p><ul><li>这是设计模式中最根本的哲学，注重接口，而不是实现，依赖接口，而不是实现。接口是抽象是稳定的，实现则是多种多样的。</li><li>以后面我们会面向对象的SOLID原则中会提到我们的依赖倒置原则，就是这个原则的的另一种样子。</li></ul><h4 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h4><p><code>【Composition over inheritance】</code></p><ul><li>多使用组合而不是继承, 但是这个观点是存在一定的争议的, 还是要有度的,合理搭配最为重要<ul><li>组合就是将原来继承方式中的父类放到子类作为属性?</li></ul></li></ul><p>组合<br>1.（对象）组合是一种通过创建一个组合了其它对象的对象，从而获得新功能的复用方法。<br>2.将功能委托给所组合的一个对象，从而获得新功能。<br>3.有些时候也称之为”聚合”（aggregation）或”包容”（containment），尽管有些作者对这些术语赋予了专门的含义</p><ul><li style="list-style: none"><input type="checkbox"> 再度思考</li></ul><blockquote><p><a href="http://www.cnblogs.com/narutow/p/8117352.html" target="_blank" rel="noopener">参考博客: 组合、委托与继承，面向对象中类之间的基本关系漫游</a><br><a href="https://www.xuebuyuan.com/1639556.html" target="_blank" rel="noopener">参考博客: 优先使用（对象）组合，而非（类）继承</a></p></blockquote><h4 id="查询与命令分离"><a href="#查询与命令分离" class="headerlink" title="查询与命令分离"></a>查询与命令分离</h4><p><code>【CQS Command-Query Separation】</code></p><ul><li>查询命令分离原则<ul><li>查询：当一个方法返回一个值来回应一个问题的时候，它就具有查询的性质；</li><li>命令：当一个方法要改变对象的状态的时候，它就具有命令的性质；</li></ul></li></ul><h4 id="够用原则"><a href="#够用原则" class="headerlink" title="够用原则"></a>够用原则</h4><p><code>【YAGNI  You Ain’t Gonna Need It 】</code></p><ul><li>这个原则简而言之为——只考虑和设计必须的功能，避免过度设计。只实现目前需要的功能，在以后您需要更多功能时，可以再进行添加。<ul><li>如无必要，勿增复杂性。</li><li>软件开发先是一场沟通博弈。 </li></ul></li></ul><h4 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h4><blockquote><p>【Law of Demeter – 迪米特法则】</p><ul><li>迪米特法则(Law of Demeter)，又称“最少知识原则” <code>（Principle of Least Knowledge）</code>，其来源于1987年荷兰大学的一个叫做Demeter的项目。</li><li>Craig Larman把Law of Demeter又称作“不要和陌生人说话”。在《程序员修炼之道》中讲LoD的那一章叫作“解耦合与迪米特法则”。</li><li>关于迪米特法则有一些很形象的比喻：<ul><li>如果你想让你的狗跑的话，你会对狗狗说还是对四条狗腿说？</li><li>如果你去店里买东西，你会把钱交给店员，还是会把钱包交给店员让他自己拿？ </li></ul></li><li>正式表述如下:</li><li>对于对象 ‘O’ 中一个方法’M’，M应该只能够访问以下对象中的方法:<ul><li>对象O；</li><li>与O直接相关的Component Object；</li><li>由方法M创建或者实例化的对象；</li><li>作为方法M的参数的对象。</li></ul></li></ul></blockquote><blockquote><p><a href="http://zhangyi.xyz/demeter-law-and-refactoring/" target="_blank" rel="noopener">参考博客: 迪米特法则与重构</a></p></blockquote><hr><h3 id="面向对象的S-O-L-I-D-原则"><a href="#面向对象的S-O-L-I-D-原则" class="headerlink" title="面向对象的S.O.L.I.D 原则"></a>面向对象的S.O.L.I.D 原则</h3><ul><li>一般来说这是面向对象的五大设计原则，但是，我觉得这些原则可适用于所有的软件开发。</li></ul><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p><code>Single Responsibility Principle (SRP)</code></p><ul><li>关于单一职责原则，其核心的思想是：<code>一个类，只做一件事，并把这件事做好，且只有一个引起它变化的原因。</code><ul><li>Unix/Linux是这一原则的完美体现者。各个程序都独立负责一个单一的事。</li><li>Windows是这一原则的反面示例。几乎所有的程序都交织耦合在一起。 </li></ul></li></ul><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p><code>Open/Closed Principle (OCP)</code></p><ul><li>关于开发封闭原则，其核心的思想是：模块是可扩展的，而不可修改的。也就是说，<code>对扩展是开放的，而对修改是封闭的。</code><ul><li>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li><li>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。</li></ul></li></ul><h4 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h4><p><code>Liskov substitution principle (LSP)</code></p><ul><li>软件工程大师Robert C. Martin把里氏代换原则最终简化为一句话：<code>“Subtypes must be substitutable for their base types”。</code></li><li><p>也就是，子类必须能够替换成它们的基类。</p><blockquote><p>即：子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现if/else之类对子类类型进行判断的条件。<br>里氏替换原则LSP是使代码符合开闭原则的一个重要保证。正是由于子类型的可替换性才使得父类型的模块在无需修改的情况下就可以扩展。</p></blockquote></li><li><p>这么说来，似乎有点教条化，我非常建议大家看看这个原则个两个最经典的案例——<code>“正方形不是长方形”</code>和<code>“鸵鸟不是鸟”</code>。</p></li><li>通过这两个案例，你会明白《墨子小取》中说的——<code>“娣，美人也，爱娣，非爱美人也….盗，人也；恶盗，非恶人也。”</code>——妹妹虽然是美人，但喜欢妹妹并不代表喜欢美人。</li><li>盗贼是人，但讨厌盗贼也并不代表就讨厌人类。这个原则让你考虑的不是语义上对象的间的关系，而是实际需求的环境。</li><li>在很多情况下，在设计初期我们类之间的关系不是很明确，LSP则给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系。</li><li><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><code>Interface Segregation Principle (ISP)</code></li><li>接口隔离原则意思是把功能实现在接口中，而不是类中，使用多个专门的接口比使用单一的总接口要好。</li><li>举个例子，我们对电脑有不同的使用方式，比如：写作，通讯，看电影，打游戏，上网，编程，计算，数据等，如果我们把这些功能都声明在电脑的抽类里面，那么，我们的上网本，PC机，服务器，</li><li>笔记本的实现类都要实现所有的这些接口，这就显得太复杂了。所以，我们可以把其这些功能接口隔离开来，比如：工作学习接口，编程开发接口，上网娱乐接口，计算和数据服务接口，这样，我们的不同功能的电脑就可以有所选择地继承这些接口。</li><li>这个原则可以提升我们“搭积木式”的软件开发。对于设计来说，Java中的各种Event Listener和Adapter，对于软件开发来说，不同的用户权限有不同的功能，不同的版本有不同的功能，都是这个原则的应用。</li></ul><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p><code>Dependency Inversion Principle (DIP)</code><br>高层模块不应该依赖于低层模块的实现，而是依赖于高层抽象。<br>举个例子，墙面的开关不应该依赖于电灯的开关实现，而是应该依赖于一个抽象的开关的标准接口，这样，当我们扩展程序的时候，我们的开关同样可以控制其它不同的灯，甚至不同的电器。<br>也就是说，电灯和其它电器继承并实现我们的标准开关接口，而我们的开关产商就可不需要关于其要控制什么样的设备，只需要关心那个标准的开关标准。这就是依赖倒置原则。<br>这就好像浏览器并不依赖于后面的web服务器，其只依赖于HTTP协议。这个原则实在是太重要了，社会的分工化，标准化都是这个设计原则的体现。</p><blockquote><p>下面有几点指导意见，帮助你避免在面向对象设计中违反依赖倒置原则：  </p><blockquote><p>变量不能持有具体类的引用，就像订单方法代码中，你看不到new一样。<br>不要让派生自具体类，要派生就派生抽象类abstract<br>不要覆盖基类中已实现的方法，除非你要覆盖的是比较特殊的一部分代码。  </p></blockquote></blockquote><h3 id="其他原则"><a href="#其他原则" class="headerlink" title="其他原则"></a>其他原则</h3><h4 id="共同封闭原则"><a href="#共同封闭原则" class="headerlink" title="共同封闭原则"></a>共同封闭原则</h4><p><code>Common Closure Principle（CCP）</code><br>一个包中所有的类应该对同一种类型的变化关闭。一个变化影响一个包，便影响了包中所有的类。一个更简短的说法是：一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。CCP原则就是把因为某个同样的原因而需要修改的所有类组合进一个包里。如果2个类从物理上或者从概念上联系得非常紧密，它们通常一起发生改变，那么它们应该属于同一个包。</p><p>CCP延伸了开闭原则（OCP）的“关闭”概念，当因为某个原因需要修改时，把需要修改的范围限制在一个最小范围内的包里。</p><h4 id="共同重用原则"><a href="#共同重用原则" class="headerlink" title="共同重用原则"></a>共同重用原则</h4><p><code>Common Reuse Principle (CRP)</code><br>包的所有类被一起重用。如果你重用了其中的一个类，就重用全部。换个说法是，没有被一起重用的类不应该被组合在一起。CRP原则帮助我们决定哪些类应该被放到同一个包里。依赖一个包就是依赖这个包所包含的一切。当一个包发生了改变，并发布新的版本，使用这个包的所有用户都必须在新的包环境下验证他们的工作，即使被他们使用的部分没有发生任何改变。因为如果包中包含有未被使用的类，即使用户不关心该类是否改变，但用户还是不得不升级该包并对原来的功能加以重新测试。</p><p>CCP则让系统的维护者受益。CCP让包尽可能大（CCP原则加入功能相关的类），CRP则让包尽可能小（CRP原则剔除不使用的类）。它们的出发点不一样，但不相互冲突。</p><h4 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h4><p><code>Hollywood Principle</code><br>好莱坞原则就是一句话——“don’t call us, we’ll call<br>you.”。意思是，好莱坞的经纪人们不希望你去联系他们，而是他们会在需要的时候来联系你。也就是说，所有的组件都是被动的，所有的组件初始化和调用都由容器负责。组件处在一个容器当中，由容器负责管理。</p><p>简单的来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在：</p><pre><code>不创建对象，而是描述创建对象的方式。在代码中，对象与服务没有直接联系，而是容器负责将这些联系在一起。</code></pre><p>控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。</p><p>好莱坞原则就是IoC（Inversion of Control）或DI（Dependency Injection）的基础原则。这个原则很像依赖倒置原则，依赖接口，而不是实例，但是这个原则要解决的是怎么把这个实例传入调用类中？你可能把其声明成成员，你可以通过构造函数，你可以通过函数参数。但是<br>IoC可以让你通过配置文件，一个由Service Container<br>读取的配置文件来产生实际配置的类。但是程序也有可能变得不易读了，程序的性能也有可能还会下降。</p><h4 id="高内聚低耦合"><a href="#高内聚低耦合" class="headerlink" title="高内聚低耦合"></a>高内聚低耦合</h4><p><code>【 High Cohesion &amp; Low/Loose coupling &amp; – 高内聚， 低耦合 】</code></p><ul><li>这个原则是UNIX操作系统设计的经典原则，把模块间的耦合降到最低，而努力让一个模块做到精益求精。<ul><li>内聚：一个模块内各个元素彼此结合的紧密程度</li><li>耦合：一个软件结构内不同模块之间互连程度的度量</li></ul></li><li>内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身</li></ul><blockquote><p>凝聚&gt;松耦合&gt;重用  <a href="http://www.jdon.com/forum/messageList.shtml?thread=45977#23144139" target="_blank" rel="noopener">参考博客: 为什么我停止使用Spring?</a></p></blockquote><h4 id="惯例优于配置原则"><a href="#惯例优于配置原则" class="headerlink" title="惯例优于配置原则"></a>惯例优于配置原则</h4><p><code>Convention over Configuration（CoC）</code><br>简单点说，就是将一些公认的配置方式和信息作为内部缺省的规则来使用。例如，Hibernate的映射文件，如果约定字段名和类属性一致的话，基本上就可以不要这个配置文件了。你的应用只需要指定不convention的信息即可，从而减少了大量convention而又不得不花时间和精力啰里啰嗦的东东。配置文件很多时候相当的影响开发效率。</p><p>Rails 中很少有配置文件（但不是没有，数据库连接就是一个配置文件），Rails 的fans号称期开发效率是 java 开发的 10<br>倍，估计就是这个原因。Maven也使用了CoC原则，当你执行mvn<br>-compile命令的时候，不需要指源文件放在什么地方，而编译以后的class文件放置在什么地方也没有指定，这就是CoC原则。</p><h4 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a>关注点分离</h4><p><code>Separation of Concerns (SoC)</code></p><blockquote><p>　是计算机科学中最重要的努力目标之一。这个原则，就是在软件开发中，通过各种手段，将问题的各个关注点分开。如果一个问题能分解为独立且较小的问题，就是相对较易解决的。<br>问题太过于复杂，要解决问题需要关注的点太多，而程序员的能力是有限的，不能同时关注于问题的各个方面。正如程序员的记忆力相对于计算机知识来说那么有限一样，<br>程序员解决问题的能力相对于要解决的问题的复杂性也是一样的非常有限。在我们分析问题的时候，如果我们把所有的东西混在一起讨论，那么就只会有一个结果——乱。</p></blockquote><p>我记得在上一家公司有一个项目，讨论就讨论了1年多，项目本来不复杂，但是没有使用SoC，全部的东西混为一谈，再加上一堆程序员注入了各种不同的观点和想法，整个项目一下子就失控了。<br>最后，本来一个1年的项目做了3年。</p><p>实现关注点分离的方法主要有两种，一种是标准化，另一种是抽象与包装。标准化就是制定一套标准，让使用者都遵守它，将人们的行为统一起来，这样使用标准的人就不用担心别人会有很多种不同的实现，使自己的程序不能和别人的配合。<br>JavaEE就是一个标准的大集合。每个开发者只需要关注于标准本身和他所在做的事情就行了。就像是开发镙丝钉的人只专注于开发镙丝钉就行了，而不用关注镙帽是怎么生产的，反正镙帽和镙丝钉按标来就一定能合得上。不断地把程序的某些部分抽像差包装起来，也是实现关注点分离的好方法。<br>一旦一个函数被抽像出来并实现了，那么使用函数的人就不用关心这个函数是如何实现的，同样的，一旦一个类被抽像并实现了，类的使用者也不用再关注于这个类的内部是如何实现的。<br>诸如组件，分层，面向服务，等等这些概念都是在不同的层次上做抽像和包装，以使得使用者不用关心它的内部实现细节。<br>说白了还是“高内聚，低耦合”。</p><blockquote><p><a href="http://www.cnblogs.com/wenhongyu/p/7992028.html" target="_blank" rel="noopener">参考博客: 理论篇：关注点分离(Separation of concerns, SoC)</a></p></blockquote><h4 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h4><p><code>Design by Contract (DbC)</code><br>DbC的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。例如：</p><pre><code>供应商必须提供某种产品（责任），并且他有权期望客户已经付款（权利）。客户必须付款（责任），并且有权得到产品（权利）。契约双方必须履行那些对所有契约都有效的责任，如法律和规定等。</code></pre><p>同样的，如果在程序设计中一个模块提供了某种功能，那么它要：</p><pre><code>期望所有调用它的客户模块都保证一定的进入条件：这就是模块的先验条件（客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况）。保证退出时给出特定的属性：这就是模块的后验条件——（供应商的义务，显然也是客户的权利）。在进入时假定，并在退出时保持一些特定的属性：不变式。</code></pre><p>契约就是这些权利和义务的正式形式。我们可以用“三个问题”来总结DbC，并且作为设计者要经常问：</p><pre><code>它期望的是什么？它要保证的是什么？它要保持的是什么？</code></pre><p>根据Bertrand<br>Meyer氏提出的DBC概念的描述，对于类的一个方法，都有一个前提条件以及一个后续条件，前提条件说明方法接受什么样的参数数据等，只有前提条件得到满足时，这个方法才能被调用；同时后续条件用来说明这个方法完成时的状态，如果一个方法的执行会导致这个方法的后续条件不成立，那么这个方法也不应该正常返回。</p><p>现在把前提条件以及后续条件应用到继承子类中，子类方法应该满足：</p><pre><code>前提条件不强于基类．后续条件不弱于基类．</code></pre><p>换句话说，通过基类的接口调用一个对象时，用户只知道基类前提条件以及后续条件。因此继承类不得要求用户提供比基类方法要求的更强的前提条件，亦即，继承类方法必须接受任何基类方法能接受的任何条件（参数）。同样，继承类必须顺从基类的所有后续条件，亦即，继承类方法的行为和输出不得违反由基类建立起来的任何约束，不能让用户对继承类方法的输出感到困惑。</p><p>这样，我们就有了基于契约的LSP，基于契约的LSP是LSP的一种强化。</p><h4 id="无环依赖原则"><a href="#无环依赖原则" class="headerlink" title="无环依赖原则"></a>无环依赖原则</h4><p><code>Acyclic Dependencies Principle (ADP)</code><br>包之间的依赖结构必须是一个直接的无环图形，也就是说，在依赖结构中不允许出现环（循环依赖）。如果包的依赖形成了环状结构，怎么样打破这种循环依赖呢？有2种方法可以打破这种循环依赖关系：第一种方法是创建新的包，如果A、B、C形成环路依赖，那么把这些共同类抽出来放在一个新的包D里。这样就把C依赖A变成了C依赖D以及A依赖D，从而打破了循环依赖关系。第二种方法是使用DIP（依赖倒置原则）和ISP（接口分隔原则）设计原则。</p><p>无环依赖原则（ADP）为我们解决包之间的关系耦合问题。在设计模块时，不能有循环依赖。</p><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><p><a href="https://java-design-patterns.com/" target="_blank" rel="noopener">java design patterns</a></p></blockquote><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><blockquote><p><a href="http://www.cnblogs.com/x-xk/archive/2013/01/21/2864916.html" target="_blank" rel="noopener">设计模式基础</a><br><a href="http://www.baike.com/wiki/GoF" target="_blank" rel="noopener">参考博客: GoF解释</a><br><a href="http://blog.csdn.net/column/details/zsxdesignpattern.html" target="_blank" rel="noopener">参考博客: 设计模式专栏</a></p></blockquote><blockquote><p><a href="http://blog.csdn.net/u011240877/article/details/45381071" target="_blank" rel="noopener">23种经典设计模式UML类图汇总 </a><br><a href="http://blog.csdn.net/chen4013874/article/details/51347535" target="_blank" rel="noopener">参考博客: 23种设计模式UML表示形式</a><br><a href="http://blog.csdn.net/tingting256/article/details/52534663" target="_blank" rel="noopener">参考博客: 23中设计模式类图和原理详解</a><br><a href="http://blog.csdn.net/qq_25827845/article/details/52510803" target="_blank" rel="noopener">参考博客: 23种设计模式类图总结 </a> </p></blockquote><h3 id="策略者模式"><a href="#策略者模式" class="headerlink" title="策略者模式"></a>策略者模式</h3><blockquote><p>定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。<br><a href="http://blog.csdn.net/hguisu/article/details/7558249" target="_blank" rel="noopener">参考博客: 设计模式 ( 十八 ) 策略模式Strategy（对象行为型） </a><br><a href="http://www.cnblogs.com/zdd-java/p/6143935.html" target="_blank" rel="noopener">参考博客: Java消除ifelse</a></p></blockquote><p>也就是说将一种需求的多种实现算法分别封装起来, 然后利用多态, 让调用方选择任一实现</p><h3 id="1-创建型设计模式"><a href="#1-创建型设计模式" class="headerlink" title="1.创建型设计模式"></a>1.创建型设计模式</h3><blockquote><p>单例模式(Singleton)<br>原型模式(Prototype)<br>建造者(Builder)<br>抽象工厂(Abstract Factory)<br>工厂方法(Factory Method)   </p></blockquote><ul><li>抽象了实例化过程，它们帮助一个系统独立于如何创建，组合和表示它的那些对象。</li><li>一个类创建型模型使用继承改变被实例化的类，而一个对象创建型模型将实例化委托给另一个对象</li><li>将一组固定行为的硬编码转移为定义一个较小的基本行为集，这些行为可以被组合成任意数目的更复杂性的行为。这样创建有特定行为的对象要求的不仅仅是实例化一个类</li></ul><p><em>Builder</em></p><ul><li>生成器 Builder，是一种对象构建模式，模式通常包含Builder，ConcreteBuilder。Director 和 Product四部分</li></ul><p><em>Abstract Factory</em></p><ul><li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</li></ul><p><em>Factory Method</em></p><ul><li>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类</li></ul><p><em>Prototype</em></p><ul><li>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 </li></ul><p><em>Singleton</em></p><ul><li>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li></ul><h3 id="2-结构型设计模式"><a href="#2-结构型设计模式" class="headerlink" title="2.结构型设计模式"></a>2.结构型设计模式</h3><blockquote><p>适配器模式(<strong>Adapter</strong>)<br>桥接模式(<strong>Bridge</strong>)<br>组合模式(<strong>Compontent</strong>)<br>代理模式(<strong>Proxy</strong>)<br>享元模式(<strong>Flyweight</strong>)<br>外观模式(<strong>Facade</strong>)<br>装饰模式(<strong>Decorator</strong>)  </p></blockquote><ul><li>结构型设计模式涉及如何组合类和对象以获得更大的结构</li><li>结构型模式采用继承机制来组合接口或实现。</li><li>结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能</li></ul><hr><ul><li><strong>Composite模式</strong><br>它将对象组合成树形结构以表示“部分-整体”</li><li><strong>Flyweight模式</strong><br>该模式为共享对象定义了一个结构，强调对象的空间效率，自由共享</li><li><p><strong>Facade模式</strong>（外观模式）<br>描述了如何用单个对象表示整个子系统（外部与其内部通信必须通过一个统一的对象进行交互），模式中的facade用来表示一组对象，<br>外观设计模式提供一个高层次的接口是的子系统易于使用。<br><strong>适用情况:</strong></p><blockquote><p> 1.为复杂的子系统提供一个简单的接口<br> 2.客户程序与抽象类的实现部分有很大依赖性<br> 3.构建一个层次结构的子系统时，适用外观模式定义子系统每层的入口</p></blockquote></li><li><p><strong>Bridge模式</strong> 将对象的抽象和实现分离，从而可以独立的改变他们。</p></li><li><strong>Decorator模式</strong><br>描述如何动态地为对象添加职责，模式采用递归方式组合对象，从而允许添加任意多的对象职责。</li></ul><h3 id="3-行为设计模式"><a href="#3-行为设计模式" class="headerlink" title="3.行为设计模式"></a>3.行为设计模式</h3><blockquote><p>策略模式(<strong>Strategy</strong>)<br>命令模式(<strong>Command</strong>)<br>状态模式(<strong>State</strong>)<br>解释器模式(<strong>Interpreter</strong>)<br>模板方法(<strong>Template Method</strong>)<br>责任链模式(<strong>Chain of Responsibility</strong>)<br>迭代器模式(<strong>Iterator</strong>)<br>中介者模式(<strong>Mediator</strong>)<br>备忘录模式(<strong>Memento</strong>)<br>观察者模式(<strong>Observe</strong>)<br>访问者模式(<strong>Visitor</strong>)  </p></blockquote><ul><li>行为设计模式涉及算法和对象间职责的分配，行为模式描述对象和类的模式以及其通信模式</li><li>行为模式使用继承机制在类间派发行为</li></ul><hr><h3 id="【常见设计模式】"><a href="#【常见设计模式】" class="headerlink" title="【常见设计模式】"></a>【常见设计模式】</h3><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><ul><li><strong>适配器 模式</strong>（Adapter）：适配器是的一个接口与其他接口兼容，从而给出了多个不同接口的同一抽象。一般分类结构和对象结构两种：</li><li><em>类适配器</em>：适配器类继承被适配类，实现某个接口，在客户端类中可以根据需求来建立子类</li><li><em>对象适配器</em>：适配器不是继承，是使用直接关联，或称委托方式<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/UML/Adapter.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><ul><li><strong>中介者 模式</strong>：包装了一系列对象相互作用的方式，使得对象间的相互作用是独立变化，但是与中介者紧密联系</li></ul><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ul><li><strong>观察者 模式 Observer</strong>：一个目标物件管理相依于它的管理物件，并且在它本身的状态发生改变时发出通知，这种模式常用来实现事件处理系统。（也称发布-订阅，模型-视图，源-收听者模式）<ul><li>观察者（接口）：更新信息，展示信息，给 <strong>被观察者（形参）</strong> 注册上观察者</li><li>被观察者（接口）：发出更新通知（遍历观察者集合并注册），当自身发生改动时发出通知消息</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Observer.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><blockquote><p>Singleton 一个类只有一个实例易于外界访问 Spring将该模式运用的出神入化</p></blockquote><ul><li><a href="http://www.cnblogs.com/atwanli/articles/5104898.html" target="_blank" rel="noopener">单例模式与高并发</a>当某个单例对象中含有不具有并发性的对象 就会发生并发问题, 由于只有一个对象, 为了确保数据一致, 就需要加锁, 这样就带来了严重的性能下降, 而Spring是怎么做的呢<ul><li><a href="https://blog.csdn.net/java_fancy/article/details/7439657" target="_blank" rel="noopener">参考博客 Spring如何处理线程并发</a></li><li><a href="https://bbs.csdn.net/topics/390873889" target="_blank" rel="noopener">参考博客: springmvc是单例的，开发的时候会不会影响性能呢？</a></li><li><a href="http://www.xuebuyuan.com/1628190.html" target="_blank" rel="noopener">参考博客: Spring并发访问的线程安全性问题</a> <code>Controller或者Service层中定义共享对象, 但是使用线程安全对象</code></li></ul></li></ul><blockquote><p><a href="https://bbs.csdn.net/topics/310136305" target="_blank" rel="noopener">参考博客: 单例模式和Static的区别! </a> </p><ul><li style="list-style: none"><input type="checkbox"> <code>static 有可能被实例化多个出来么</code></li></ul></blockquote><h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h5><ul><li><strong>装饰器模式</strong> 创建一个新类为某一个类动态添加新功能或增强原有的功能，避免代码重复或具体子类的数量增加</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Decorator.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>策略模式</strong> 优点：灵活添加同一问题的不同解决方案</li><li><strong>状态模式</strong> 允许对象在内部状态时变更其行为，并且修改其类：<ul><li>环境类（Context）：定义客户感兴趣的接口，维护一个子类的实例，这个实例就是当前状态</li><li>抽象状态类（State）：定义一个接口以封装与Context的一个特定状态相关的行为</li><li>具体状态类（concreteState）：每一子类实现与Context的一个状态相关的行为</li><li><strong>例题</strong>：纸巾售卖机:有四个状态!<ul><li>【状态图】</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/State_zhijin.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>【类图】</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/State_zhijin2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul></li><li><strong>例题</strong>：TCP连接状态:<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/State_TCP.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul></li><li><strong>命令模式 command</strong>：<ul><li>行为请求者 与 请求实现者 之间 紧耦合 的关系</li><li><strong>将一个请求封装成一个对象</strong>，从而可用不同的请求对客户进行参数化，支持可撤销的操作</li><li>下例：使用了接口来实现多态，子类是多个的，方法同名并功能多样的<ul><li>代码复用好，代码结构清晰【参数类表最好不要出现标志变量，最好分离出另一个方法】</li></ul></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Command.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>桥接模式</strong> ： 便于扩展，实现与抽象分离（解耦）对一个模块修改不影响别的模块</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Bridge.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>抽象工厂模式</strong> ： 提供一个创建一系列相关实例相互依赖的对象。<ul><li>当一个系统要独立于它的产品的创建，组合和表示时</li><li>当一个系统要由多个产品系列中的一个来配置时</li><li>当需强调一系列相关的产品对象的设计以便进行联合使用时</li><li>想提供一组对象而不显示他们的实现过程，只显示他们的接口</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/AbstractFactory.png" alt=""></p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><blockquote><p>struts2 就是采用该模式</p><ul><li><strong>原型模式</strong> ： 对象创建模型： 允许一个对象创建另一个可定制的对象，封装实例化细节。<ul><li>实现Cloneable接口（Java自带接口），重写clone方法（在这里实例化对象，new或反射，按需求来修改）</li><li>该例，组合关系，在对方使用clone来代替构造器来实例化对象，并做好了绑定操作，大量减少代码量</li></ul></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Clone.png" alt=""> </p><h4 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h4><ul><li><strong>生成器模式</strong>：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Builder.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><ul><li><a href="https://www.ibm.com/developerworks/cn/java/design/" target="_blank" rel="noopener">IBM 社区 Java 设计模式专题</a></li><li><a href="http://www.cnblogs.com/x-xk/archive/2012/12/21/2823401.html" target="_blank" rel="noopener">一个鸭子游戏引发的设计（多态，继承，抽象，接口，策略者模式）</a></li><li><p><a href="www.cnblogs.com/x-xk/archive/2013/01/06/2830742.html">不要再盲目的new了！你要学着针对接口编程！（具体方法，Factory，Abstract Factory</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/aGMz1u0Oh4ZHTDBFvgq0lg" target="_blank" rel="noopener">参考博客: 为什么我墙裂建议大家使用枚举来实现单例。</a></p></li><li style="list-style: none"><input type="checkbox"> 自己用Java重写一下这个例子, 并做出自己的总结</li></ul><p>反模式<br>末日金字塔: 多层嵌套</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#设计模式之禅&quot;&gt;设计模式之禅&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#软件设计的一些原则&quot;&gt;软件设计的一些原则&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#思维原则&quot;&gt;思维
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GraphQL</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Database-GraphQL/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Database-GraphQL/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#graphql">GraphQL</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h1><blockquote><p><a href="https://graphql.org" target="_blank" rel="noopener">Official Site</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#graphql&quot;&gt;GraphQL&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-13 12:06&lt;/em&gt;| &lt;a
      
    
    </summary>
    
      <category term="数据库" scheme="http://blog.kuangcp.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="GraphQL" scheme="http://blog.kuangcp.top/tags/GraphQL/"/>
    
      <category term="基础" scheme="http://blog.kuangcp.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Oracle</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Database-Oracle/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Database-Oracle/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#oracle">Oracle</a><ol><li><a href="#安装">安装</a><ol><li><a href="#linux">Linux</a><ol><li><a href="#docker安装">Docker安装</a></li></ol></li><li><a href="#windows">Windows</a></li></ol></li><li><a href="#使用">使用</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><blockquote><p>强大的数据库, 稍微理解一下他的设计都觉得精妙</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h4><blockquote><p><a href="/Linux/Container/DockerSoft.md#安装oracle">详情&gt;&gt;</a></p></blockquote><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#oracle&quot;&gt;Oracle&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#安装&quot;&gt;安装&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#linux&quot;&gt;Linux&lt;/a&gt;&lt;ol&gt;
&lt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://blog.kuangcp.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle" scheme="http://blog.kuangcp.top/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Server.md</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Blog-Server/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Blog-Server/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#server">Server</a><ol><li><a href="#终端">终端</a></li><li><a href="#内存优化">内存优化</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><blockquote><p>服务器运维相关</p></blockquote><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwNjEwNTQ4Mw==&amp;mid=2651580395&amp;idx=1&amp;sn=d311abab344aed97fe8b5244aa51e08d&amp;chksm=8cd9f90fbbae7019fc5ee8fbe423c8027527f068bcb71ad3d7a18b85a503bc4ffd377dfb9b6d&amp;mpshare=1&amp;scene=1&amp;srcid=0110cegY48pxj9fMGcObeEMT&amp;pass_ticket=9AXPGsZExYCvgc64Pq%2Fge7rdAI7U%2F%2BG%2F5NrA4rv24OXW2BDRnIZzo5eMh%2F%2FanrNZ#rd" target="_blank" rel="noopener">效率为王：终端管理工具 Tmux </a></li></ul><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><blockquote><p><a href="http://www.cnblogs.com/dongzhiquan/p/5043912.html" target="_blank" rel="noopener">参考博客 大内存页配置实战</a> <code>内存占用大, 访问随机就需要使用大内存页了</code><br><a href="http://www.oracle.com/technetwork/cn/articles/servers-storage-dev/hugepages-2099009-zhs.html" target="_blank" rel="noopener">Oracle官网的使用案例</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#server&quot;&gt;Server&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#终端&quot;&gt;终端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#内存优化&quot;&gt;内存优化&lt;/a&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MultipleLanguage</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-MultipleLanguage/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-MultipleLanguage/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#jvm上的多语言使用">JVM上的多语言使用</a><ol><li><a href="#语言生态学">语言生态学</a><ol><li><a href="#重新实现的语言和原生语言">重新实现的语言和原生语言</a></li></ol></li><li><a href="#jvm上的多语言编程">JVM上的多语言编程</a><ol><li><a href="#groovy">Groovy</a></li><li><a href="#scala">Scala</a></li><li><a href="#clojure">Clojure</a></li><li><a href="#为什么非要用java语言">为什么非要用Java语言</a></li><li><a href="#jvm对备选语言的支持">JVM对备选语言的支持</a></li><li><a href="#编译器小说">编译器小说</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="JVM上的多语言使用"><a href="#JVM上的多语言使用" class="headerlink" title="JVM上的多语言使用"></a>JVM上的多语言使用</h1><h2 id="语言生态学"><a href="#语言生态学" class="headerlink" title="语言生态学"></a>语言生态学</h2><ul><li>大致讨论 解释型和编译型， 动态和静态， 命令式和函数式</li><li>Java是运行时编译，静态类型的命令式语言。强调安全性，代码清晰，性能，并表现出一定程度的繁琐和死板（例如部署）</li></ul><p><strong><code>解释型和编译型</code></strong></p><ul><li>在80 90 年代，边界较为清晰，类C语言是编译型，Perl和Python是解释型。但Java是两者都有</li><li>基于JVM来划分的边界是：该语言是否将源码编译为类文件并且执行，不产生类文件的语言会由解释器逐行执行。有些语言既有编译器又有解释器，有些是既有解释器又有产生字节码的即时编译器JIT</li></ul><p><strong><code>动态和静态类型</code></strong></p><ul><li>动态类型语言，变量在不同的时间可能会有不同的类型 动态类型语言是跟踪变量的值的类型信息，静态类型语言是跟踪变量的类型信息</li><li>静态类型适合做编译型语言</li></ul><p><strong><code>命令式和函数式</code></strong></p><ul><li>Java是典型的命令式语言，命令式语言把程序的运行状态建模为可修改的数据，用一系列的指令来改变状态。因此在命令式语言中，程序状态是核心概念</li><li>命令式语言主要分为两类，一种是面向过程语言，一种是面向对象语言<ul><li>面向过程：Basic Fortran 这种语言将代码和数据完全分离开，有简单的代码操作数据范式</li><li>面向对象：数据和代码（方法形式）封装在对象中，面向对象语言中或多或少会存在元数据（比如：类信息）引入的额外结构</li></ul></li><li>函数式语言他把计算本身当成最重要的概念。函数式语言和过程式语言一样对值进行操作，但他不会修改输入，而是像数学函数一样返回新值<ul><li>函数被看成是一个小处理机，输入值并输出值，他们没有自己的状态，并且将他们和任何外部状态绑定在一起也没有意义<blockquote><p>Groovy带一点函数式风格，Scala对FP的利用更为充分，Clojure是纯粹的函数式语言，没有丁点儿面向对象特性</p></blockquote></li></ul></li></ul><h3 id="重新实现的语言和原生语言"><a href="#重新实现的语言和原生语言" class="headerlink" title="重新实现的语言和原生语言"></a>重新实现的语言和原生语言</h3><blockquote><p>一般来说，以JVM为目标的语言较重新实现的语言能将自己的类型系统和JVM的类型系统结合的更紧密</p></blockquote><ul><li>重新实现已有语言的JVM语言：<ul><li>JRuby：Ruby是一个动态类型的面向对象语言，有些函数式特性，在JVM上基本算解释型的</li><li>Jython：动态的面向对象语言。运行方式是先生成Python字节码再转化成JVM字节码。这使得他能以看起来像是Python的典型解释型模式下运行</li><li>Rhino：他在JVM上提供了一个JavaScript实现，既支持编译模式，也支持解释模式</li></ul></li></ul><h2 id="JVM上的多语言编程"><a href="#JVM上的多语言编程" class="headerlink" title="JVM上的多语言编程"></a>JVM上的多语言编程</h2><ul><li><p>非Java技术的作用可以分为三个层次 特定领域层，动态层，稳定层，多语言编程金字塔：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p178.jpg" alt="p178金字塔" title="">                </div>                <div class="image-caption">p178金字塔</div>            </figure></li><li><p>静态类型语言更倾向于稳定层的任务，能力不是那么强，通用性较低的技术在金字塔的顶部更好用</p></li></ul><blockquote><p><a href="https://www.zhihu.com/question/21740715" target="_blank" rel="noopener">Java 、Groovy、 Scala 的未来会怎样？</a><br><a href="https://www.jianshu.com/p/3d01a98da9f9" target="_blank" rel="noopener">Java &amp; Groovy &amp; Scala &amp; Kotlin - 16.方法，Lambda 与闭包</a></p></blockquote><ol><li>喜欢Ruby =&gt; 用Groovy</li><li>喜欢LISP，喜欢STM功能 =&gt; 用Clojure</li><li>喜欢C++ =&gt; 用Kotlin</li></ol><p>Scala有两个流派：FP和Better Java。FP派喜欢scalaz，喜欢shapeless，喜欢type level programming。这一派特点是程序高度抽象但可读性奇差。<br>适合PL研究者验证概念，适合业余项目自嗨，也适合学习PL概念。不适合多人协作的工程项目。Better Java派以前之所以存在，单纯是因为Java语法设计太烂，烂到无法忍受。<br>而JVM上当时也没有其它更好的选择。<br>那些告诉你“写了n年Java以后，我切换到Scala，现在每天都活在幸福中”的人，基本都是这一派。但Scala as a better Java的工程性也不好，因为特性太多太复杂，除非有高手带队，否则很难只用到它“better java”的那个子集。<br>解决一个问题的同时，往往引入更多的问题。所以会有Java8发布以后Linkedin所有新项目全部回归Java这种事情。</p><p>Groovy是动态语言，工程性比Scala还差。但是因为有Gradle这种被广泛采用的项目，所以会存活下去。但是请记住爱因斯坦曾经说过：“任何超过两百行的新项目，都不应该采用动态语言开发，无论是Ruby，Python，Perl，Groovy还是Clojure”。<br>哦，对了，也不要用Clojure。因为它是动态语言，而且是Lisp系的动态语言。“Lisp系”意味着，读书的时候可以靠它开眼界。毕业工作以后，对于这一类语言，能躲多远就躲多远。</p><p>刚刚发布的Kotlin看上去靠谱。它不讲究FP有多纯，目标就一个：“a better java”。Kotlin在“到底引入多少FP特性”上面做得恰到好处。 看到Kotlin，我马上就想起了这个演讲：“Please stop polluting our imperative languages with pure concepts”。<br>Kotlin有以下好处：</p><ol><li>强大的IDE。而且是JetBrains第一方支持，不是3年更新一次的第三方插件；</li><li>库多生态强。Kotlin的设计者非常重视和Java的互操作，所以Kotlin号称可以无缝衔接所有Java库。</li><li>宇宙第一运行时：JVM。</li><li>Android上不能用Java8的新语法，Kotlin恰逢其时的出现，抓了一波完美的timing。如果Kotlin依靠Android开发爆发，那服务器端，大数据界，也会收益，最后多面开花，势不可挡。<br>但是Kotlin刚出来，到底有没有它自称的那么好用还待观察。另外，Kotlin社区现在集中力量攻坚Android，在服务器和大数据方向没什么靠谱项目。所以还是得用Java8。<br>总之，“魔镜啊魔镜，谁是JVM上最好的语言”之最后决战，将是Java10 vs Kotlin（Java9在语法特性上已经输了）。而在这场最终决战之前，C#已经靠着CoreCLR统一世界了。</li></ol><blockquote><p>最后送上人生经验两则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match comment with</span><br><span class="line">| &quot;X怎么不能Y？人家Z就是这样做的。&quot; -&gt;  reply &quot;卡马克能用haskell移植Wolf 3D，你能？&quot;</span><br><span class="line">| _ -&gt; reply &quot;Thank you&quot;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match location with</span><br><span class="line">| Office -&gt; use whatever your boss chose</span><br><span class="line">| Home   -&gt; use F#</span><br></pre></td></tr></table></figure><h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3><blockquote><p>James Strachan 于2003年发明，可以看作动态层语言，擅长DSL构建</p></blockquote><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><blockquote><p>Martin Odersky 于2003年意外产生，一门支持函数式编程的面向对象语言<br>有一个非常好的ScalaTest测试框架，比Junit更简洁，</p></blockquote><h3 id="Clojure"><a href="#Clojure" class="headerlink" title="Clojure"></a>Clojure</h3><blockquote><p>Rich Hickey设计的属于Lisp家族的语言，动态类型的函数式语言，编译型语言但是通常以源码发布</p></blockquote><h3 id="为什么非要用Java语言"><a href="#为什么非要用Java语言" class="headerlink" title="为什么非要用Java语言"></a>为什么非要用Java语言</h3><ul><li>Java 作为一种通用，静态类型的编译型语言，实现稳定层方便，但是放到金字塔上层就成为负担<ul><li>编译耗时</li><li>静态类型不够灵活，重构时间长</li><li>部署麻烦</li><li>语法不适合生产DSL（领域专用语言 domain specific language）</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p180.jpg" alt="p180 分类" title="">                </div>                <div class="image-caption">p180 分类</div>            </figure><hr><h3 id="JVM对备选语言的支持"><a href="#JVM对备选语言的支持" class="headerlink" title="JVM对备选语言的支持"></a>JVM对备选语言的支持</h3><ul><li>一种语言要在JVM上运行的两种方式：<ul><li>一个产生类文件的编译器</li><li>一个用JVM字节码实现的解释器<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p183.jpg" alt="p183.jpg" title="">                </div>                <div class="image-caption">p183.jpg</div>            </figure></li></ul></li><li>有一种评估语言运行时环境复杂度的简单方法，看运行实现中Jar的大小，Clojure相对较轻量，JRuby就显得重</li></ul><hr><h3 id="编译器小说"><a href="#编译器小说" class="headerlink" title="编译器小说"></a>编译器小说</h3><blockquote><p>语言的某些特性是由编程环境和高层语言合成的，在底层JVM中不存在，这种特性就称为编译器小说</p></blockquote><ul><li>Java中的编译器小说还包括检查型异常和内部类（通常内部类都会转换成带有特殊合成访问方法的顶层类），如果jar -cvf看jar包，能看到很多含<code>$</code>的类，这些就是被取出转换成<code>常规类</code>的内部类<br><code>备选语言的编译器小说</code><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p184.jpg" alt="p184.jpg" title="">                </div>                <div class="image-caption">p184.jpg</div>            </figure></li><li>函数一等值：<ul><li>这个就是说可以将函数当成其他普通值一样操作，Java只能把类当做最小的代码和功能单元。解决这种差异的方法是，因为对象只是把数据和操作数据的方法绑定在一起，只要有一个没有状态只有一个方法的对象。</li><li>这似乎就是Java8的lambda表达式的存在条件，单方法的实现用操作符 <code>-&gt;</code></li></ul></li><li>多继承：<ul><li>在Java和JVM中无法实现多继承，只能使用接口，但是接口又没有任何具体的方法</li><li>在Scala中特性机制 trait 允许将方法的实现混合到类中，所以提供了不同的继承视图，这种行为必须由Scala编译器和运行时合成，在VM层面不提供这种特性</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#jvm上的多语言使用&quot;&gt;JVM上的多语言使用&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#语言生态学&quot;&gt;语言生态学&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#重新实现的语言和
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaWeb</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Web/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Web/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#java-web">Java Web</a><ol><li><a href="#jspservlet">【JSP/Servlet】</a><ol><li><a href="#servlet">Servlet</a></li><li><a href="#jsp">JSP</a><ol><li><a href="#九大内置对象">九大内置对象</a></li><li><a href="#四个作用域">四个作用域</a></li></ol></li></ol></li><li><a href="#spring系">Spring系</a><ol><li><a href="#缓存">缓存</a></li></ol></li><li><a href="#tips">Tips</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><h2 id="【JSP-Servlet】"><a href="#【JSP-Servlet】" class="headerlink" title="【JSP/Servlet】"></a>【JSP/Servlet】</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><blockquote><p><a href="http://www.cnblogs.com/iOS-mt/p/5717631.html" target="_blank" rel="noopener">参考博客: JSP面试题及答案</a></p></blockquote><h4 id="九大内置对象"><a href="#九大内置对象" class="headerlink" title="九大内置对象"></a>九大内置对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request            请求对象　                类型 javax.servlet.ServletRequest        作用域 Request</span><br><span class="line">response          响应对象                   类型 javax.servlet.SrvletResponse       作用域  Page</span><br><span class="line">pageContext    页面上下文对象       类型 javax.servlet.jsp.PageContext      作用域    Page</span><br><span class="line">　　session            会话对象                   类型 javax.servlet.http.HttpSession       作用域    Session</span><br><span class="line">　　application       应用程序对象          类型 javax.servlet.ServletContext          作用域    Application</span><br><span class="line">　　out                   输出对象                   类型 javax.servlet.jsp.JspWriter             作用域    Page</span><br><span class="line">　　config              配置对象                  类型 javax.servlet.ServletConfig            作用域    Page</span><br><span class="line">　　page               页面对象                  类型 javax.lang.Object                            作用域    Page</span><br><span class="line">　　exception        例外对象                 类型 javax.lang.Throwable                     作用域    page 来源:</span><br></pre></td></tr></table></figure><h4 id="四个作用域"><a href="#四个作用域" class="headerlink" title="四个作用域"></a>四个作用域</h4><blockquote><p><a href="http://www.cnblogs.com/featherfly/p/3513656.html" target="_blank" rel="noopener">参考博客: JSP的四大作用域</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">application 在所有应用程序中有效</span><br><span class="line">session 在当前会话中有效</span><br><span class="line">request 在当前请求中有效</span><br><span class="line">page 在当前页面有效</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="Spring系"><a href="#Spring系" class="headerlink" title="Spring系"></a>Spring系</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><em>如何做Etag缓存</em></p><ol><li>自定义了EtagCache注解</li><li>通过拦截器判断带EtagCache注解的Controller</li><li>通过Spring Data Jpa自带的乐观锁 version, 针对每个资源就可以做到EtagCache</li><li>将其值放在http的header中</li><li>还有另一种做法就是 自己针对内容进行hash code编码</li></ol><hr><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>1、JSP页面上的SQL标签以及EL标签是优先于文件头的那些JavaServlet语句运行的，所以要保证非法进入页面时重定向的问题</li><li>2、如果想要获取异常来据此返回参数到页面弹窗提示，那么就要对一层层的方法调用，进行查找，所有的try catch 块 都要检查<ul><li>因为一般我的习惯就是把异常当场就处理了，而要实现这个要求就必须将异常层层上抛！！！！</li></ul></li></ul><ul><li><p>3、中文乱码问题：</p><ul><li><strong>接收</strong><ul><li>使用get方法，需要转换成gbk :<code>newString(s.getBytes(&quot;ISO-88511-1&quot;,&quot;gbk&quot;);</code></li><li>post方法需要转换成UTF-8</li></ul></li><li><strong>回应</strong> 均使用UTF-8</li></ul></li><li><p>4、查询数据： 使用set集合，查询对象是否存在，使用contians</p></li><li>5、Servlet 是单例多线程的</li><li>6、<strong>eclipse中将java项目转成web项目</strong><ul><li>经常在eclipse中导入web项目时，出现转不了项目类型的问题，导入后就是一个java项目，有过很多次经历，今天也有同事遇到类似问题，就把这个解决方法记下来吧，免得以后再到处去搜索。<br><strong>解决步骤</strong>： </li></ul></li></ul><ul><li>1、进入项目目录，可看到.project文件，打开。 </li><li>2、找到<code>&lt;natures&gt;...&lt;/natures&gt;</code>代码段。 </li><li>3、在第2步的代码段中加入如下标签内容并保存： </li></ul><pre><code class="xml"><span class="tag">&lt;<span class="name">nature</span>&gt;</span>org.eclipse.wst.common.project.facet.core.nature<span class="tag">&lt;/<span class="name">nature</span>&gt;</span><span class="tag">&lt;<span class="name">nature</span>&gt;</span>org.eclipse.wst.common.modulecore.ModuleCoreNature<span class="tag">&lt;/<span class="name">nature</span>&gt;</span> <span class="tag">&lt;<span class="name">nature</span>&gt;</span>org.eclipse.jem.workbench.JavaEMFNature<span class="tag">&lt;/<span class="name">nature</span>&gt;</span> </code></pre><ul><li>4、在eclipse的项目上点右键，刷新项目。 </li><li>5、在项目上点右键，进入属性（properties） </li><li>6、在左侧列表项目中点击选择“Project Facets”，在右侧选择“Dynamic Web Module”和”Java”，点击OK保存即可。</li></ul><ol><li>RPC RMI<ul><li>RPC Remote Process Calls </li><li>RMI Remote Methos Invocation </li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#java-web&quot;&gt;Java Web&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#jspservlet&quot;&gt;【JSP/Servlet】&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Web" scheme="http://blog.kuangcp.top/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Java线程</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Thread/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Thread/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#线程的基础学习">线程的基础学习</a><ol><li><a href="#todo">TODO</a></li><li><a href="#基础">基础</a></li><li><a href="#线程的意义">线程的意义</a></li><li><a href="#线程的生命周期">线程的生命周期</a><ol><li><a href="#创建">创建</a></li><li><a href="#控制">控制</a></li><li><a href="#销毁">销毁</a></li></ol></li><li><a href="#线程的优先级">线程的优先级</a></li><li><a href="#线程池">线程池</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="线程的基础学习"><a href="#线程的基础学习" class="headerlink" title="线程的基础学习"></a>线程的基础学习</h1><blockquote><p><a href="https://github.com/Kuangcp/JavaBase/tree/master/src/main/java/com/threads" target="_blank" rel="noopener">个人相关代码</a></p></blockquote><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li style="list-style: none"><input type="checkbox"> 线程的多种创建方式</li><li style="list-style: none"><input type="checkbox"> 线程池的创建方式</li><li style="list-style: none"><input type="checkbox"> 线程的状态转化</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=416915373&amp;idx=1&amp;sn=f80a13b099237534a3ef777d511d831a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:我是一个线程</a> | <a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513653&amp;idx=1&amp;sn=e30c18c0c1780fb3ef0cdb858ee5201e&amp;chksm=80d67af6b7a1f3e059466302c2c04c14d097c1a5de01cf986df84d4677299542f12b974dfde3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:编程世界的那把锁</a> | <a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513692&amp;idx=1&amp;sn=ef2416a4bb96d64db77e32d5b4c7967e&amp;chksm=80d67a9fb7a1f3898e513cc1d9e96841610bb84aed2dc24cab2d403e74e317e3c447e45e7611&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:加锁还是不加锁，这是一个问题 </a></li></ul><h2 id="线程的意义"><a href="#线程的意义" class="headerlink" title="线程的意义"></a>线程的意义</h2><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><blockquote><p><a href="https://segmentfault.com/a/1190000005006079" target="_blank" rel="noopener">参考博客</a> | <a href="http://www.cnblogs.com/riskyer/p/3263032.html" target="_blank" rel="noopener">Blog: 线程详解</a> | <a href="https://github.com/brianway/java-learning" target="_blank" rel="noopener">参考Java-learning仓库</a></p></blockquote><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>创建线程有三种创建方式： 继承，实现接口，实例化匿名内部方法。-&gt; <a href="https://github.com/Kuangcp/JavaBase/blob/master/src/main/java/com/threads/HowToCreateThread.java" target="_blank" rel="noopener">示例代码</a></li></ul><blockquote><p>查看Thread类源码 看看Thread类源码，捋清Runnable，target,run,start关系</p><ul><li>Runnable是一个接口</li><li>target是Thread类中类型为Runnable，名为target的属性</li><li>run是Thread类实现了Runnable的接口，重写的方法。</li><li>start是启动线程的方法</li><li>在Thread类中，调用关系为：<em>start-&gt;start0-&gt;run-&gt;target.run</em></li></ul></blockquote><p><em>Thread类的run方法源码</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>Thread类的target属性</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* What will be run. */</span></span><br><span class="line"><span class="keyword">private</span> Runnable target;</span><br></pre></td></tr></table></figure></p><ul><li>target属性由 <code>private void init(ThreadGroup g, Runnable target, String name,long stackSize, AccessControlContext acc)</code>方法初始化。<ul><li>init方法在Thread类的构造方法里被调用</li></ul></li></ul><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><ul><li>当调用 <code>Thread.join()</code> 时，<em>调用线程</em>将阻塞，直到<em>目标线程</em>完成为止。 </li></ul><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><hr><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><blockquote><p>多个线程同时运行时,由线程调度器来决定哪些线程运行,哪些等待以及线程切换的时间点. 由于各个操作系统的线程调度器的实现各不相同, 所以依赖JDK来设置线程优先级策略是错误和非平台可移植性的.</p></blockquote><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote><p><a href="https://segmentfault.com/a/1190000012916473" target="_blank" rel="noopener">线程池 BlockingQueue synchronized volatile</a><br><a href="http://www.trinea.cn/android/java-android-thread-pool/" target="_blank" rel="noopener">参考博客: Java(Android)线程池</a><br><a href="http://codefine.site/2941.html" target="_blank" rel="noopener">参考博客: Java ThreadPoolExecutor线程池使用的一个误区</a><br><a href="http://ifeve.com/java-threadpool/" target="_blank" rel="noopener">参考博客: 聊聊并发（三）Java线程池的分析和使用</a><br><a href="http://ifeve.com/thread-pools/" target="_blank" rel="noopener">参考博客: 线程池</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#线程的基础学习&quot;&gt;线程的基础学习&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#todo&quot;&gt;TODO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#基础&quot;&gt;基础&lt;/a&gt;&lt;/li&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Thread" scheme="http://blog.kuangcp.top/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Socket/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Socket/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#socket">Socket</a><ol><li><a href="#基础">基础</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><blockquote><p>其实就是Socket <a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513387&amp;idx=1&amp;sn=99665948d0b968cf15c5e7a01ffe166c&amp;chksm=80d679e8b7a1f0febad077b57e8ad73bfb4b08de74814c45e1b1bd61ab4017b5041942403afb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:张大胖的socket </a></p></blockquote><ul><li><p>得到URL文件的输入流</p><ul><li><code>new URL(url).openStream()</code></li></ul></li><li><p>使用Linux编程开启web容器时<code>java.net.SocketException: 权限不够</code></p><ul><li><a href="http://www.xuebuyuan.com/1432737.html" target="_blank" rel="noopener">参考博客</a></li><li>快速解决，不使用小于1024的端口即可，或者提权</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#socket&quot;&gt;Socket&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#基础&quot;&gt;基础&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Socket" scheme="http://blog.kuangcp.top/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Reflect/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-Reflect/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#反射">反射</a><ol><li><a href="#获取属性">获取属性</a></li><li><a href="#获得方法">获得方法</a><ol><li><a href="#性能问题">性能问题</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><blockquote><p><a href="https://blog.csdn.net/zhangzeyuaaa/article/details/39611467" target="_blank" rel="noopener"> Java反射异常处理之InvocationTargetException </a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/lakeslove/p/5978382.html" target="_blank" rel="noopener">参考博客: java8–类加载机制与反射(java疯狂讲义3复习笔记)</a><br><a href="https://segmentfault.com/a/1190000007492958" target="_blank" rel="noopener">参考博客: Java8替代传统反射动态获取成员变量值的一个示例</a></p></blockquote><blockquote><p><a href="http://www.cnblogs.com/zhishan/p/3195771.html" target="_blank" rel="noopener">参考博客: java反射的性能问题</a></p></blockquote><h2 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h2><p><em>通过属性名得到对象属性的值</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PropertyDescriptor propertyDescriptor = <span class="keyword">new</span> PropertyDescriptor(meta.getField().getName(), target);</span><br><span class="line">Method method = propertyDescriptor.getReadMethod();</span><br><span class="line">Object result = method.invoke(model);</span><br></pre></td></tr></table></figure></p><p>或者如下方式更为简洁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set</span></span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">Field field = a.getClass().getDeclaredField(<span class="string">"x"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(a, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// get</span></span><br><span class="line">Field f = a.getClass().getDeclaredField(<span class="string">"x"</span>);</span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(f.get(a));</span><br></pre></td></tr></table></figure></p><h2 id="获得方法"><a href="#获得方法" class="headerlink" title="获得方法"></a>获得方法</h2><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><blockquote><p><a href="http://www.cnblogs.com/zhishan/p/3195771.html" target="_blank" rel="noopener">参考博客: java反射的性能问题 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#反射&quot;&gt;反射&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#获取属性&quot;&gt;获取属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#获得方法&quot;&gt;获得方法&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Reflect" scheme="http://blog.kuangcp.top/tags/Reflect/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-JVM/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-AdvancedLearning-JVM/</id>
    <published>2018-12-17T13:25:18.711Z</published>
    <updated>2018-12-17T13:25:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#jvm">JVM</a><ol><li><a href="#hotspot-jvm">Hotspot JVM</a></li><li><a href="#openj9">OpenJ9</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><blockquote><p>Oracle 默认采用的是 Hotspot JVM</p></blockquote><h2 id="Hotspot-JVM"><a href="#Hotspot-JVM" class="headerlink" title="Hotspot JVM"></a>Hotspot JVM</h2><h2 id="OpenJ9"><a href="#OpenJ9" class="headerlink" title="OpenJ9"></a>OpenJ9</h2><p>IBM主导开发, 捐赠给Eclipse基金会</p><blockquote><p><a href="http://www.eclipse.org/openj9/" target="_blank" rel="noopener">Officail Site</a> | <a href="https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.vm.80.doc/docs/j9_intro.html" target="_blank" rel="noopener">IBM原文</a></p></blockquote><ul><li><a href="https://github.com/eclipse/openj9" target="_blank" rel="noopener">Github:</a></li></ul><blockquote><p><a href="http://www.infoq.com/cn/news/2017/09/IBM-JVM-OpenJ9-Eclipse" target="_blank" rel="noopener">参考博客: IBM开源JVM实现OpenJ9，并提交Eclipse基金会托管)</a><br><a href="http://www.infoq.com/cn/news/2018/03/OMR-OpenJ9" target="_blank" rel="noopener">参考博客: Eclipse Open J9：Eclipse OMR项目提供的开源JVM</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#jvm&quot;&gt;JVM&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#hotspot-jvm&quot;&gt;Hotspot JVM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#openj9&quot;&gt;O
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://blog.kuangcp.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GradleAdvance.md</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-GradleAdvance/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-GradleAdvance/</id>
    <published>2018-12-17T13:25:18.707Z</published>
    <updated>2018-12-17T13:25:18.707Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#gradle进阶知识">Gradle进阶知识</a><ol><li><a href="#gradle-使用和配置">Gradle 使用和配置</a><ol><li><a href="#主配置目录">主配置目录</a></li></ol></li><li><a href="#gradle-构建块">Gradle 构建块</a></li><li><a href="#task">task</a><ol><li><a href="#task的依赖关系">task的依赖关系</a></li><li><a href="#终结器-task">终结器 task</a></li><li><a href="#groovy的pogo类管理配置文件上的版本号">Groovy的POGO类管理配置文件上的版本号</a></li><li><a href="#task-的inputs-和-outputs">task 的inputs 和 outputs</a></li><li><a href="#编写和使用自定义task">编写和使用自定义task</a><ol><li><a href="#声明task规则">声明task规则</a></li></ol></li></ol></li><li><a href="#增量式构建特性">增量式构建特性</a></li></ol></li><li><a href="#测试模块">测试模块</a><ol><li><a href="#单元测试">单元测试</a><ol><li><a href="#使用junit">使用JUnit</a></li><li><a href="#使用其他框架-testng-spock">使用其他框架 TestNG Spock</a></li></ol></li><li><a href="#配置测试执行">配置测试执行</a></li></ol></li><li><a href="#多语言编程">多语言编程</a><ol><li><a href="#处理javascript">处理javascript</a><ol><li><a href="#压缩javascript">压缩javascript</a></li><li><a href="#java-和-groovy的联合编译">Java 和 Groovy的联合编译</a></li><li><a href="#java-和-scala">Java 和 Scala</a></li></ol></li><li><a href="#jenkin-使用">Jenkin 使用</a><ol><li><a href="#下载安装和配置">下载安装和配置</a></li></ol></li></ol></li><li><a href="#发布自己的构件">发布自己的构件</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Gradle进阶知识"><a href="#Gradle进阶知识" class="headerlink" title="Gradle进阶知识"></a>Gradle进阶知识</h1><blockquote><p><a href="https://docs.gradle.org/4.9/dsl/org.gradle.api.Project.html" target="_blank" rel="noopener">gradle api </a> <code>所有{}结构 以及配置</code></p></blockquote><blockquote><p><a href="https://github.com/davenkin/gradle-learning" target="_blank" rel="noopener">davenkin的学习仓库</a><br><a href="https://github.com/Kuangcp/LearnGradle" target="_blank" rel="noopener">个人学习Gradle的记录仓库</a></p></blockquote><h2 id="Gradle-使用和配置"><a href="#Gradle-使用和配置" class="headerlink" title="Gradle 使用和配置"></a>Gradle 使用和配置</h2><h3 id="主配置目录"><a href="#主配置目录" class="headerlink" title="主配置目录"></a>主配置目录</h3><blockquote><p>~/.gradle</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── caches</span><br><span class="line">│   ├── 4.8</span><br><span class="line">│   ├── 4.9</span><br><span class="line">│   ├── jars-3</span><br><span class="line">│   ├── modules-2</span><br><span class="line">│   │   ├── files-2.1 依赖的Jar 缓存目录</span><br><span class="line">│   │   ├── metadata-2.58</span><br><span class="line">│   │   └── modules-2.lock</span><br><span class="line">│   └── transforms-1</span><br><span class="line">├── daemon</span><br><span class="line">│   ├── 4.8</span><br><span class="line">│   └── 4.9</span><br><span class="line">├── native</span><br><span class="line">│   ├── 25</span><br><span class="line">│   └── jansi</span><br><span class="line">├── notifications</span><br><span class="line">│   ├── 4.8</span><br><span class="line">│   └── 4.9</span><br><span class="line">└── workers</span><br></pre></td></tr></table></figure><blockquote><p>~/.gradle/caches/modules-2/files-2.1 等价于Maven的 ~/.m2/repository 目录<br>不得不说, 这个目录很丑, 字母加字符短杠..强迫症很难受</p></blockquote><ul><li>那么问题来了, 以前一直以为是和Maven共用一个仓库<ul><li>他和Maven本地仓库没有半毛钱关系, 他只是去复制了一下而已! <a href="https://blog.csdn.net/kcp606/article/details/81636426" target="_blank" rel="noopener">详情</a></li></ul></li></ul><h2 id="Gradle-构建块"><a href="#Gradle-构建块" class="headerlink" title="Gradle 构建块"></a>Gradle 构建块</h2><ul><li>三个基本块 project task property， 使用DDD（领域驱动设计）</li><li>一个真实的项目包含多个project 而 Project又包含多个task ，task之间通过依赖来确保执行顺序</li><li>build.gradle 和 pom.xml 作用是一致的，但是gradle可以使用一份源码 构建出多种想要的目标程序</li></ul><h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><ul><li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="_blank" rel="noopener">doc:task</a></li></ul><h3 id="task的依赖关系"><a href="#task的依赖关系" class="headerlink" title="task的依赖关系"></a>task的依赖关系</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  version = <span class="string">'0.1-SNAPSHOT'</span></span><br><span class="line">  task first &#123;</span><br><span class="line">  println <span class="string">'First Run !'</span></span><br><span class="line">  &#125;</span><br><span class="line">  task second &#123;</span><br><span class="line">  println <span class="string">'Second Run !'</span></span><br><span class="line">  &#125;</span><br><span class="line">  task printVersion (<span class="string">dependsOn:</span>[second,first])&#123;</span><br><span class="line">  doLast &#123;</span><br><span class="line">  println <span class="string">"Version : $version"</span></span><br><span class="line">  logger.quiet <span class="string">"Version : $version"</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  task third &lt;&lt;&#123;</span><br><span class="line">println <span class="string">'Third Run!'</span></span><br><span class="line">  &#125;</span><br><span class="line">  third.dependsOn(<span class="string">'printVersion'</span>)</span><br></pre></td></tr></table></figure><ul><li>如果把second的定义放在First前面，就会先运行second</li><li>这个例子就说明了，被依赖方的运行，不是按照声明的顺序，而是定义的顺序<ul><li>（因为依赖是只要被依赖方执行即可，和顺序关系不是很大）</li></ul></li><li>还可以使用SLF4J的logger实现<ul><li>日志级别 DEBUG,ERROR,INFO,TRACE,WARN ,还有QUIET…</li></ul></li><li>如果 是 <code>gradle -b tasksL.gradle -q third</code> 就会运行所有的task，因为这是最后一层依赖<ul><li>如果 是<code>gradle -b tasksL.gradle -q printVersion</code> 就会只运行 printVersion 如果整个文件有编译错误也是不运行的</li></ul></li></ul><h3 id="终结器-task"><a href="#终结器-task" class="headerlink" title="终结器 task"></a>终结器 task</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task f&lt;&lt;&#123;println <span class="string">'first'</span>&#125;</span><br><span class="line">task s&lt;&lt;&#123;println <span class="string">'second'</span>&#125;</span><br><span class="line">f.finalizedBy s</span><br><span class="line"><span class="comment">//当运行 gradle f 就会自动触发 s</span></span><br><span class="line"><span class="comment">//如果gradle s 就和f没有任何关系了</span></span><br></pre></td></tr></table></figure><hr><h3 id="Groovy的POGO类管理配置文件上的版本号"><a href="#Groovy的POGO类管理配置文件上的版本号" class="headerlink" title="Groovy的POGO类管理配置文件上的版本号"></a>Groovy的POGO类管理配置文件上的版本号</h3><ul><li><a href="https://github.com/Kuangcp/LearnGradle/blob/master/demo/tasksL.gradle" target="_blank" rel="noopener">taskL.gradle</a></li><li>gradle -b tasksL.gradle -q printVersion</li><li>虽然只是 运行了这个task 但是读取文件的task也被自动调用了</li><li>因为Gradle的构建生命周期阶段如下: 初始化、配置和执行 读取文件就属于配置阶段<ul><li><strong>注意</strong> : 项目的每一次构建都会运行属于配置阶段的代码，即使你只是运行了 gradle tasks</li></ul></li></ul><h3 id="task-的inputs-和-outputs"><a href="#task-的inputs-和-outputs" class="headerlink" title="task 的inputs 和 outputs"></a>task 的inputs 和 outputs</h3><ul><li>流程 : inputs -&gt; |task| -&gt; outputs</li><li>gradle通过比较两个task的inputs和outputs来决定task是否最新<ul><li>如果inputs和outputs没有改变 就不会执行该task</li><li>输入和输出可以是，一个文件，多个文件，一个目录，一个property属性</li></ul></li><li><a href="https://github.com/Kuangcp/LearnGradle/blob/master/demo/turnVersion.gradle" target="_blank" rel="noopener">示例代码:turnVersion.gradle</a><ul><li>makeRealeseVersion : 将一个项目的版本切换为发布版本 </li><li>IOReleaseVersion : 通过inputs/outputs来添加增量式构建支持 <ul><li>发现并不能得到书上的预期效果，书上是说改动了properties文件才会让这个task运行，没有改就会说 up-to-date</li><li>但是实际得到的是，改动了properties或者是构建文件都会引起task运行，两者都不改动就不会运行task，而且不会有输出提示up-to-date，要自己手动logger</li></ul></li></ul></li></ul><hr><h3 id="编写和使用自定义task"><a href="#编写和使用自定义task" class="headerlink" title="编写和使用自定义task"></a>编写和使用自定义task</h3><ul><li><p>自定义task包含两个组件：</p><ul><li>自定义的task类，封装了逻辑行为，也被称为任务类型</li><li>真实的task 提供了用于配置行为的task类所暴露的属性值</li></ul></li><li><p>这个task就是做到了改配置文件，确保是RELEASE版本</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先要实例化version属性对象的存在</span></span><br><span class="line">   version = <span class="keyword">new</span> ProjectVersion(<span class="number">0</span>,<span class="number">1</span>,<span class="literal">true</span>)</span><br><span class="line">   <span class="comment">//继承DefaultTask类型的自定义task类</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">ReleaseVersionTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span>&#123;</span></span><br><span class="line">    <span class="meta">@Input</span> Boolean release</span><br><span class="line">    <span class="meta">@OutputFile</span> File destFile</span><br><span class="line">    ReleaseVersionTask()&#123;</span><br><span class="line">        group = <span class="string">'versioning'</span></span><br><span class="line">        description = <span class="string">'Make Project a release version'</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//task的行为逻辑</span></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="keyword">void</span> start ()&#123;</span><br><span class="line">        project.version.release = <span class="literal">true</span>;</span><br><span class="line">        ant.propertyfile(<span class="string">file:</span>destFile)&#123;</span><br><span class="line">            entry(<span class="string">key:</span><span class="string">'release'</span>,<span class="string">type:</span><span class="string">'string'</span>,<span class="string">operation:</span><span class="string">'='</span>,<span class="string">value:</span><span class="string">'true'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println <span class="string">"$project.version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//version的POGO类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectVersion</span>&#123;</span></span><br><span class="line">    Integer major</span><br><span class="line">Integer minor</span><br><span class="line">    Boolean release</span><br><span class="line">    ProjectVersion (Integer major ,Integer minor)&#123;</span><br><span class="line"><span class="keyword">this</span>.major = major</span><br><span class="line"><span class="keyword">this</span>.minor = minor</span><br><span class="line">&#125;</span><br><span class="line">    ProjectVersion (Integer major ,Integer minor,Boolean release)&#123;</span><br><span class="line"><span class="keyword">this</span>(major,minor)</span><br><span class="line"><span class="keyword">this</span>.release = release</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String toString()&#123;</span><br><span class="line">        <span class="string">"$major.$minor$&#123;release?'-RELEASE':'-SNAPSHOT'&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实的task，用来操作自定义类暴露的几个属性</span></span><br><span class="line"><span class="comment">//使用命令来运行，本质是运行真实的task但是行为逻辑在自定义类中编写</span></span><br><span class="line"><span class="comment">//gradle -b UserDefineTask.gradle -q makeReleaseVersion</span></span><br><span class="line"><span class="comment">//如果要改动一些数据可以直接更改暴露的task而不用去改自定义的task类</span></span><br><span class="line">task makeReleaseVersion(<span class="string">type:</span>ReleaseVersionTask)&#123;</span><br><span class="line">    release = <span class="string">'true'</span></span><br><span class="line">    destFile = file(<span class="string">'version.properties'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="声明task规则"><a href="#声明task规则" class="headerlink" title="声明task规则"></a>声明task规则</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//All used property must define and initial first</span></span><br><span class="line">   version = <span class="keyword">new</span> ProjectVersion(<span class="number">0</span>,<span class="number">1</span>,<span class="literal">true</span>)</span><br><span class="line">   ext.versionFile = file(<span class="string">'version.properties'</span>)</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">ProjectVersion</span>&#123;</span></span><br><span class="line">       Integer major</span><br><span class="line">   Integer minor</span><br><span class="line">       Boolean release</span><br><span class="line">       ProjectVersion (Integer major ,Integer minor)&#123;</span><br><span class="line">   <span class="keyword">this</span>.major = major</span><br><span class="line">   <span class="keyword">this</span>.minor = minor</span><br><span class="line">   &#125;</span><br><span class="line">       ProjectVersion (Integer major ,Integer minor,Boolean release)&#123;</span><br><span class="line">   <span class="keyword">this</span>(major,minor)</span><br><span class="line">   <span class="keyword">this</span>.release = release</span><br><span class="line">   &#125;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       String toString()&#123;</span><br><span class="line">           <span class="string">"$major.$minor$&#123;release?'-RELEASE':'-SNAPSHOT'&#125;"</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// task规则的定义</span></span><br><span class="line">   tasks.addRule(<span class="string">"Pattern: increment&lt;Classifier&gt;Version - Increment the project version classifier."</span> )&#123;</span><br><span class="line">   <span class="comment">//根据预定义模式来检查task的名称</span></span><br><span class="line">    String taskName -&gt; <span class="keyword">if</span>(taskName.startsWith(<span class="string">'increment'</span>) &amp;&amp; taskName.endsWith(<span class="string">'Version'</span>))&#123;</span><br><span class="line">        <span class="comment">//根据符合命名模式的task动态添加一个doLast的方法</span></span><br><span class="line">        task(taskName)&lt;&lt;&#123;</span><br><span class="line">         <span class="comment">//从完整的task名称中提取类型字符串，</span></span><br><span class="line">         <span class="comment">//字面意思是将字符串中increment和Version两个串去除掉然后转小写再赋值</span></span><br><span class="line">            String classifier = (taskName - <span class="string">'increment'</span> - <span class="string">'Version'</span>).toLowerCase()</span><br><span class="line">            String currentVersion = version.toString()</span><br><span class="line">            <span class="keyword">switch</span> (classifier)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'major'</span>:++version.major</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">'minor'</span>:++version.minor</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="string">default :</span> <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">"Invalid version type '$classifier' . Allow types :['Major','Minor']"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            String newVersion = version.toString()</span><br><span class="line">            logger.info <span class="string">"Increment $classifier project version: $currentVersion -&gt; $newVersion"</span></span><br><span class="line">            ant.propertyfile(<span class="string">file:</span>versionFile)&#123;</span><br><span class="line">                entry(<span class="string">key:</span>classifier,<span class="string">type:</span><span class="string">'int'</span>,<span class="string">operation:</span><span class="string">'+'</span>,<span class="string">value:</span><span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行 <code>gradle -b RulesTask.gradle -q incrementMinorVersion</code>就可以增加版本号了，就是一个动态的执行命令的机制<ul><li>使用 incrementMajorVersion就可以增加主版本号</li></ul></li><li>如果运行 <code>gradle -b RulesTask.gradle -q tasks</code> 就会得到一个具体的tasks的组Rules</li></ul><h2 id="增量式构建特性"><a href="#增量式构建特性" class="headerlink" title="增量式构建特性"></a>增量式构建特性</h2><ul><li>如果Java源文件与最后一次运行的构建不同的话，运行 <code>compileJava task</code> 将充分提高构建的性能</li></ul><hr><h1 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h1><blockquote><p>凡是依赖于本地环境的测试，使用完就注释Test注解，还有那些会CRUD，影响到数据的测试方法也是<br>以防以后线上测试通不过 打包失败, </p></blockquote><ul><li>跳过测试 <code>gradle build -x test</code> 或者是 <code>--exclude-task test</code> 参数 </li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="使用JUnit"><a href="#使用JUnit" class="headerlink" title="使用JUnit"></a>使用JUnit</h3><blockquote><p><a href="/MyBlog/how-to-use-junit.md">使用Junit4</a></p></blockquote><h3 id="使用其他框架-TestNG-Spock"><a href="#使用其他框架-TestNG-Spock" class="headerlink" title="使用其他框架 TestNG Spock"></a>使用其他框架 TestNG Spock</h3><h2 id="配置测试执行"><a href="#配置测试执行" class="headerlink" title="配置测试执行"></a>配置测试执行</h2><hr><hr><h1 id="多语言编程"><a href="#多语言编程" class="headerlink" title="多语言编程"></a>多语言编程</h1><h2 id="处理javascript"><a href="#处理javascript" class="headerlink" title="处理javascript"></a>处理javascript</h2><h3 id="压缩javascript"><a href="#压缩javascript" class="headerlink" title="压缩javascript"></a>压缩javascript</h3><ul><li>调用Google Closure Compiler 的task 来压缩javascript文件 将所有的javascript压缩成一个javascript文件</li><li>执行该task  gradle :web :taskname</li><li>执行之后就能得到一个优化的js文件，现在就要在页面中修改原来的js引用</li></ul><h3 id="Java-和-Groovy的联合编译"><a href="#Java-和-Groovy的联合编译" class="headerlink" title="Java 和 Groovy的联合编译"></a>Java 和 Groovy的联合编译</h3><ul><li>src 下 main 下 java 和groovy 的一个目录结构，直接编译就会发生Java无法依赖groovy的类</li><li>错误：需要配置 <code>sourceSets.main.java.srcDirs=[]</code> <code>sourceSets.main.groovy.srcDirs=[&#39;src/main/java&#39;,&#39;src/main/groovy&#39;]</code><ul><li>正确： <code>sourceSets.main.java.srcDirs=[&#39;src/main/java&#39;,&#39;src/main/groovy&#39;]</code> 上面的会报错</li></ul></li><li>配置好后就能把groovy当普通Java类直接使用了</li></ul><hr><h3 id="Java-和-Scala"><a href="#Java-和-Scala" class="headerlink" title="Java 和 Scala"></a>Java 和 Scala</h3><ul><li>联合双向编译 Java和scala</li><li><code>sourceSets.main.scala.srcDirs</code> <code>sourceSets.main.groovy.srcDirs=[&#39;src/main/java&#39;,&#39;src/main/scala&#39;]</code></li><li>那么问题来了，如果是有了java groovy scala 呢怎么配置编译，直接就加上就好了嘛？</li></ul><h2 id="Jenkin-使用"><a href="#Jenkin-使用" class="headerlink" title="Jenkin 使用"></a>Jenkin 使用</h2><h3 id="下载安装和配置"><a href="#下载安装和配置" class="headerlink" title="下载安装和配置"></a>下载安装和配置</h3><ul><li>官网下载war包后，直接使用Java命令运行 或者放在web容器中运行</li><li>配置下载插件（位置在C盘用户目录下， 其实第一次运行后也是会解压在.jenkin 目录下 插件就在plugin目录下）</li><li></li></ul><h1 id="发布自己的构件"><a href="#发布自己的构件" class="headerlink" title="发布自己的构件"></a>发布自己的构件</h1><p><a href="https://lambeta.com/2017/09/15/release-jar-to-maven-central-repository/" target="_blank" rel="noopener">如何发布Jar包到Maven Central Repository </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#gradle进阶知识&quot;&gt;Gradle进阶知识&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#gradle-使用和配置&quot;&gt;Gradle 使用和配置&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringbootDatabase.md</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringbootDatabase/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringbootDatabase/</id>
    <published>2018-12-17T13:25:18.707Z</published>
    <updated>2018-12-17T13:25:18.707Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#数据库模块">数据库模块</a><ol><li><a href="#relational-database">Relational Database</a><ol><li><a href="#多数据源配置">多数据源配置</a></li><li><a href="#连接池">连接池</a><ol><li><a href="#c3p0">c3p0</a></li><li><a href="#druid">druid</a></li><li><a href="#hikaripool">HikariPool</a></li></ol></li><li><a href="#jpa">JPA</a><ol><li><a href="#configuration">Configuration</a></li></ol></li><li><a href="#mybatis">Mybatis</a><ol><li><a href="#自定义查询">自定义查询</a><ol><li><a href="#hql">HQL</a></li><li><a href="#原生sql">原生SQL</a></li></ol></li><li><a href="#mysql">Mysql</a></li><li><a href="#映射关系">映射关系</a><ol><li><a href="#一对一">一对一</a></li><li><a href="#一对多">一对多</a></li><li><a href="#多对多">多对多</a></li></ol></li></ol></li><li><a href="#restful设计">Restful设计</a><ol><li><a href="#特别注意">【特别注意】</a></li></ol></li><li><a href="#jpa数据分页">Jpa数据分页</a></li><li><a href="#数据库上的事务支持">数据库上的事务支持</a></li></ol></li><li><a href="#non-relational-database">Non Relational database</a><ol><li><a href="#jpa">JPA</a><ol><li><a href="#redis的简单使用">Redis的简单使用</a></li><li><a href="#关于stringredistemplate的方法使用">关于StringRedisTemplate的方法使用</a></li><li><a href="#消息订阅和发布">消息订阅和发布</a></li></ol></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="数据库模块"><a href="#数据库模块" class="headerlink" title="数据库模块"></a>数据库模块</h1><blockquote><p>主要是采用的JPA，极大的缩减了代码量，但是要注意不要过度依赖框架，丧失了基本的能力</p></blockquote><h2 id="Relational-Database"><a href="#Relational-Database" class="headerlink" title="Relational Database"></a>Relational Database</h2><h3 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h3><blockquote><p>为什么要有多数据源? 思考</p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/34730e595a8c" target="_blank" rel="noopener">Spring Boot多数据源配置与使用</a></p></blockquote><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h4 id="c3p0"><a href="#c3p0" class="headerlink" title="c3p0"></a>c3p0</h4><ul><li><a href="http://www.cnblogs.com/520playboy/p/7526252.html" target="_blank" rel="noopener">参考博客</a></li></ul><h4 id="druid"><a href="#druid" class="headerlink" title="druid"></a>druid</h4><ul><li><a href="http://makaidong.com/L_Sail/1/40930_11573921.html" target="_blank" rel="noopener">druid连接池的配置</a></li></ul><h4 id="HikariPool"><a href="#HikariPool" class="headerlink" title="HikariPool"></a>HikariPool</h4><blockquote><p>性能最好的数据库连接池</p></blockquote><ul><li style="list-style: none"><input type="checkbox"> 听说代码很精简, 阅读源码学习</li></ul><hr><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><blockquote><p>连接池:1.x 默认是tomcat-jdbc连接池 2.x 是 HikariPool</p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/3b31270a44b1" target="_blank" rel="noopener">参考博客: spring boot2 整合（二）JPA</a></p></blockquote><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/htmlsingle/#howto-configure-jpa-properties" target="_blank" rel="noopener">Official Doc</a><br><strong><code>ddl-auto</code></strong></p><ul><li>JPA 默认是该配置 <code>spring.jpa.hibernate.ddl-auto</code></li><li>但是如上配置没有生效的话就要用 这个 <code>spring.jpa.properties.hibernate.hbm2ddl.auto</code> <ol><li>none 什么都不做</li><li>create-only </li><li>create 先删除, 然后建立新的表</li><li>create-drop 先删除, 然后建立新的表, 然后在SessionFactory实例关闭后再删除</li><li>update 创建和修改</li><li>validate 校验是否一致, 不一致就报错,启动失败</li></ol></li></ul></blockquote><ul><li><p><a href="http://blog.csdn.net/Amy_Queen/article/details/72454099" target="_blank" rel="noopener">Blog: 原生SQL的写法</a></p></li><li><p>[ ] 怎么映射视图到实体上?</p></li></ul><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><blockquote><p><a href="https://blog.csdn.net/juewang_love/article/details/53769906" target="_blank" rel="noopener">IDEA下创建Springboot，thymeleaf，Mybatis，Postgresql，Gradle项目</a></p></blockquote><h4 id="自定义查询"><a href="#自定义查询" class="headerlink" title="自定义查询"></a>自定义查询</h4><h5 id="HQL"><a href="#HQL" class="headerlink" title="HQL"></a>HQL</h5><ul><li>使用Hibernate语法模式,将对象和数据库的表看成一个实体,方便书写SQL,但是在Controller层和Service层<ul><li>进行写代码的时候,参数的传递全是实体对象,要不停的new,这样真的没问题么(当有各种复杂的关联关系的时候,单个对象的CURD基本没有什么问题)</li><li><code>TODO</code> 所以还不如直接写原生SQL! 那么JPA就真的没有使用的必要性了,直接用Mybatis结合插件生成自动的CRUD的代码,这样更为轻量</li><li>待后续使用后再回来填坑</li></ul></li></ul><h5 id="原生SQL"><a href="#原生SQL" class="headerlink" title="原生SQL"></a>原生SQL</h5><ul><li>涉及到数据的修改,就要加上前两个前缀,查询就直接写Query注解即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Query</span>(value = <span class="string">"update a set b=?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><ul><li><p>1.引入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-data-jpa'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-jdbc'</span>)</span><br><span class="line">runtime(<span class="string">'mysql:mysql-connector-java'</span>)</span><br></pre></td></tr></table></figure></li><li><p>2.继承接口，打好实体类的注解 @Entity </p></li><li><p>3.<em>切记 属性名不能使用下划线（数据库风格）不然写声明方法就会报错，jpa只是看下划线前半部分，会说找不到属性</em></p><ul><li>jpa在创建表时会把驼峰命名改成数据库风格的形式</li></ul></li><li><p>4.jpa是声明特定方法的接口，让jpa来实现并自动注入，如果是没有的方法，就可以使用@Query注解</p><ul><li>默认使用的是HQL（HQL是基于类的所以使用的是类的名字不是表的名字），可以设置下使用原生SQL</li></ul></li></ul><h4 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h4><h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><blockquote><p>据说这是性能最好的方式, 但是有一点让人不舒服, A的id是名存实亡的, 数据库都没有这个字段, 实际上就是B的id, 但是对象又一定要保留这个id, 不然约束通不过<br>也就是说, 创建的时候要设置A的id的值, 但是后面却用不到这个值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@OneToOne</span>(fetch = FetchType.LAZY)</span><br><span class="line">  <span class="meta">@MapsId</span></span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h5><ul><li><p>一方的配置是当前类的id，多方则按基本ER的规则来，注解中配置的是外键的名字, 所以当前类中的属性,外键名是不能重复的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 一方</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOne</span></span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String testOneId;</span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"testOneId"</span>)<span class="comment">//这个名字可以重复，最终会有一个随机码生成</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;TestMany&gt; testManySet;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 多方</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMany</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String testManyId;</span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"testOneId"</span>)</span><br><span class="line">    <span class="keyword">private</span> TestOne testOneId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>[ ] 问题: 当两个表互相引用了, 需要修改表结构 ,怎么删除重建两张表结构, 简单的命令会陷入死锁</p></li></ul><hr><h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><hr><h3 id="Restful设计"><a href="#Restful设计" class="headerlink" title="Restful设计"></a>Restful设计</h3><ul><li>1.添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-rest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2.引入自动配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestConfiguration</span> <span class="keyword">extends</span> <span class="title">RepositoryRestMvcConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RepositoryRestConfiguration <span class="title">config</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.config();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProfileResourceProcessor <span class="title">profileResourceProcessor</span><span class="params">(RepositoryRestConfiguration config)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置rest根目录是应用路径下的路径 : localhost:8080/rest</span></span><br><span class="line">        config.setBasePath(<span class="string">"/rest"</span>);</span><br><span class="line">        <span class="comment">// 允许输出id</span></span><br><span class="line">        config.exposeIdsFor(Goods.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.profileResourceProcessor(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3.配置repository的名字例如：（只要配置repository就能用REST了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RepositoryRestResource</span>(path = <span class="string">"book"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Book</span>,<span class="title">Long</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>4.启动应用，控制台有如下输出</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Java/Spring/output.png" alt="输出" title="">                </div>                <div class="image-caption">输出</div>            </figure></li><li><p>所有路径的使用方法：</p><ul><li><code>GET</code> 查询单个 <code>/repo/id</code> 成功：200 失败404</li><li><code>GET</code> 查询所有 <code>/repo</code> 成功200 失败404</li><li><code>POST</code> 新增 <code>/repo</code> json数据发送 成功 201 失败404</li><li><code>DELETE</code> 删除 <code>/repo/id</code> json数据 成功204 失败404</li><li><code>PUT</code> 更新 <code>/repo/id</code> json 更新成功200 没有该id就插入201 失败404（使用主键自动增长就不会遇到404）</li></ul></li></ul><h4 id="【特别注意】"><a href="#【特别注意】" class="headerlink" title="【特别注意】"></a>【特别注意】</h4><ul><li>rest得到的数据没有id<ul><li>添加配置 <code>config.exposeIdsFor(Goods.class);</code> 即可查看到id <a href="http://tommyziegler.com/how-to-expose-the-resourceid-with-spring-data-rest/" target="_blank" rel="noopener">参考博客</a></li></ul></li></ul><h3 id="Jpa数据分页"><a href="#Jpa数据分页" class="headerlink" title="Jpa数据分页"></a>Jpa数据分页</h3><blockquote><p><a href="https://www.tianmaying.com/tutorial/spring-jpa-page-sort" target="_blank" rel="noopener">参考博客</a></p></blockquote><ul><li>分页 page 从0开始 size是个数 sort可以不需要（如果本来就是id排序就没必要了） <ul><li>原理就是 预编译SQL然后查询总数，然后再执行 必须有两条SQL执行</li></ul></li><li>查询的结果不包含实体的id属性</li></ul><h3 id="数据库上的事务支持"><a href="#数据库上的事务支持" class="headerlink" title="数据库上的事务支持"></a>数据库上的事务支持</h3><ul><li>JPA对所有默认方法都开启了事务支持，查询类事务默认启用readOnly=true</li></ul><hr><h2 id="Non-Relational-database"><a href="#Non-Relational-database" class="headerlink" title="Non Relational database"></a>Non Relational database</h2><h3 id="JPA-1"><a href="#JPA-1" class="headerlink" title="JPA"></a>JPA</h3><h4 id="Redis的简单使用"><a href="#Redis的简单使用" class="headerlink" title="Redis的简单使用"></a>Redis的简单使用</h4><p><em>配置连接信息</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=127.0.0.1</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）0不超时</span><br><span class="line">spring.redis.timeout=0</span><br></pre></td></tr></table></figure></p><p><code>在一个配置类中复制如下代码即可使用 StringRedisTemplate RedisTemplate 的实例</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object,Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 值序列化采用 jackson2JsonRedisSerializer</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 键序列化采用 StringRedisSerializer</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">StringRedisTemplate <span class="title">template</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringRedisTemplate(connectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">`两个对象的简单使用`</span><br><span class="line">```java</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"aaa"</span>, <span class="string">"hello"</span>);</span><br><span class="line">    String result = stringRedisTemplate.opsForValue().get(<span class="string">"aaa"</span>);</span><br><span class="line">    <span class="comment">//获取所有</span></span><br><span class="line">    Set&lt;String&gt; keysList =  stringRedisTemplate.keys(<span class="string">"*"</span>);</span><br><span class="line">    <span class="keyword">for</span>(String temp :keysList)&#123;</span><br><span class="line">        log.info(temp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>以上配置的template都是只是建立在最简单的键值对上，String-String，所以对象使用的是json来存储</li><li>但是使用的时候如同使用MySQL一样，是ORM框架自动处理数据的转换</li></ul><h4 id="关于StringRedisTemplate的方法使用"><a href="#关于StringRedisTemplate的方法使用" class="headerlink" title="关于StringRedisTemplate的方法使用"></a>关于StringRedisTemplate的方法使用</h4><ul><li><p>常见数据类型的中间对象</p><ul><li>opsForValue() 操作简单键值对数据<ul><li>hasKey()</li></ul></li><li>opsForHash() 操作含有hash的数据</li><li>opsForList() 操作含有list的数据</li><li>opsForZSet() 操作含有zset（有序）的数据<ul><li>range()方法返回指定范围的数据 Java中Set类型的（诡异的是顺序保持了一致）</li></ul></li><li>opsForSet() 操作含有set的数据</li></ul></li><li><p>设置超时时间</p><ul><li><code>redisTemplate.expire(&quot;max&quot;,tempTime,TimeUnit.SECONDS);</code></li></ul></li></ul><h4 id="消息订阅和发布"><a href="#消息订阅和发布" class="headerlink" title="消息订阅和发布"></a>消息订阅和发布</h4><p><a href="https://www.tianmaying.com/tutorial/springboot-redis-message" target="_blank" rel="noopener">参考博客: Spring Boot使用Redis进行消息的发布订阅</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#数据库模块&quot;&gt;数据库模块&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#relational-database&quot;&gt;Relational Database&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Maven.md</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-Maven/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-Tool-Maven/</id>
    <published>2018-12-17T13:25:18.707Z</published>
    <updated>2018-12-17T13:25:18.707Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#maven">Maven</a><ol><li><a href="#1安装">1.安装</a><ol><li><a href="#11maven常用命令">1.1.Maven常用命令</a><ol><li><a href="#从jar安装到本地库">从jar安装到本地库</a></li></ol></li><li><a href="#12settingsxml配置">1.2.settings.xml配置</a><ol><li><a href="#配置镜像源">配置镜像源</a><ol><li><a href="#阿里云">阿里云</a></li></ol></li><li><a href="#配置本地仓库">配置本地仓库</a></li></ol></li></ol></li><li><a href="#2maven配置">2.maven配置</a><ol><li><a href="#21eclipse中配置">2.1.eclipse中配置</a></li><li><a href="#22配置插件">2.2.配置插件</a></li><li><a href="#23pom配置文件详解">2.3.POM配置文件详解</a></li><li><a href="#24配置代码编译版本">2.4.配置代码编译版本</a></li></ol></li><li><a href="#3构建">3.构建</a><ol><li><a href="#31使用maven构建多模块的项目">3.1.使用maven构建多模块的项目</a></li><li><a href="#32maven多配置环境">3.2.Maven多配置环境</a></li><li><a href="#33部署">3.3.部署</a></li></ol></li><li><a href="#4maven的依赖">4.maven的依赖</a><ol><li><a href="#41-依赖的范围">4.1 依赖的范围</a><ol><li><a href="#依赖的传递">依赖的传递</a></li></ol></li><li><a href="#42处理项目间依赖方法">4.2.处理项目间依赖方法</a></li><li><a href="#43依赖冲突">4.3.依赖冲突</a><ol><li><a href="#排除依赖">排除依赖</a></li></ol></li><li><a href="#44继承">4.4.继承</a></li></ol></li><li><a href="#5使用maven新建web30项目">5.使用maven新建Web3.0项目</a><ol><li><a href="#51添加web容器">5.1.添加web容器</a><ol><li><a href="#512jetty">5.1.2.Jetty</a></li><li><a href="#513tomcat">5.1.3.Tomcat</a></li></ol></li><li><a href="#52加入servlet的api包">5.2.加入Servlet的API包</a></li></ol></li><li><a href="#6常用插件">6.常用插件</a><ol><li><a href="#61lombok">6.1.lombok</a></li><li><a href="#62-protobuf">6.2 protobuf</a></li></ol></li><li><a href="#7构建工具对比">7.构建工具对比</a><ol><li><a href="#71maven和ant的区别一">7.1.Maven和Ant的区别一</a></li><li><a href="#72maven的优势">7.2.Maven的优势</a></li></ol></li><li><a href="#8发布构件到公共仓库">8.发布构件到公共仓库</a></li><li><a href="#9配置私服">9.配置私服</a><ol><li><a href="#nexus">nexus</a></li><li><a href="#码云">码云</a><ol><li><a href="#创建仓库">创建仓库</a></li><li><a href="#引用仓库中的构件">引用仓库中的构件</a><ol><li><a href="#gradle">Gradle</a></li><li><a href="#maven">Maven</a></li></ol></li></ol></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><blockquote><p><a href="https://maven.apache.org/" target="_blank" rel="noopener">官网</a> | <a href="https://maven.apache.org/guides/" target="_blank" rel="noopener">官网手册</a> | <a href="http://takari.io/" target="_blank" rel="noopener">http://takari.io/ 在线练习网</a><br><a href="http://tengj.top/2018/01/01/maven/" target="_blank" rel="noopener">关于Maven的完整博客</a></p></blockquote><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><ul><li>下载zip包解压，将bin目录配置至PATH（最好是配置MAVEN_HOME然后引用）</li></ul><h3 id="1-1-Maven常用命令"><a href="#1-1-Maven常用命令" class="headerlink" title="1.1.Maven常用命令"></a>1.1.Maven常用命令</h3><blockquote><p>mvn [插件]:[目标] [参数]<br>mvn [阶段]</p></blockquote><ul><li>mvn archetype:generate ：创建 Maven 项目<ul><li>-DgroupId=组织名/公司网址的反写+项目名</li><li>-DartifactId=项目名-模块名</li><li>-Dversion=版本号</li><li>-Dpackage=代码所在的包</li></ul></li></ul><ul><li><code>compile</code> ：编译源代码</li><li><code>test-compile</code> ：编译测试代码</li><li><code>test</code> ： 运行应用程序中的单元测试</li><li><code>site</code> ： 生成项目相关信息的网站</li><li><code>clean</code> ：清除目标目录中的生成结果</li><li><code>package</code> ： 依据项目生成 jar 文件</li><li><code>install</code> ：在本地 Repository 中安装 jar</li><li><code>deploy</code>：将jar包发布到远程仓库</li><li><p>使用id为ChatServer的Profile <code>-PChatServer</code> </p></li><li><p>跳过测试</p><ul><li><code>-Dmaven.test.skip=true</code> 不执行测试用例，也不编译测试用例类。</li><li><code>-DskipTests=true</code> 不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下</li><li><code>-Dmaven.javadoc.skip=true</code> 跳过文档生成</li></ul></li></ul><p><em>配置文件中配置</em><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="从jar安装到本地库"><a href="#从jar安装到本地库" class="headerlink" title="从jar安装到本地库"></a>从jar安装到本地库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file </span><br><span class="line">    -Dfile=D:\mvn\spring-context-support-3.1.0.RELEASE.jar \</span><br><span class="line">    -DgroupId=org.springframework  \</span><br><span class="line">    -DartifactId=spring-context-support \</span><br><span class="line">    -Dversion=3.1.0.RELEASE \</span><br><span class="line">    -Dpackaging=jar</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-settings-xml配置"><a href="#1-2-settings-xml配置" class="headerlink" title="1.2.settings.xml配置"></a>1.2.settings.xml配置</h3><blockquote><p>要特别注意 <code>settings.xml</code> 后者覆盖前者 加载顺序是: </p><blockquote><p><code>maven目录/conf/setting.xml</code><br><code>用户目录下/.m2/setting.xml</code> </p></blockquote></blockquote><h4 id="配置镜像源"><a href="#配置镜像源" class="headerlink" title="配置镜像源"></a>配置镜像源</h4><blockquote><p>在 用户目录下 .m2/setttings.xml 中 找到 mirrors 标签 进行添加<code>mirror节点</code>即可</p></blockquote><h5 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置本地仓库"><a href="#配置本地仓库" class="headerlink" title="配置本地仓库"></a>配置本地仓库</h4><p><code>localRepository节点</code></p><hr><h2 id="2-maven配置"><a href="#2-maven配置" class="headerlink" title="2.maven配置"></a>2.maven配置</h2><h3 id="2-1-eclipse中配置"><a href="#2-1-eclipse中配置" class="headerlink" title="2.1.eclipse中配置"></a>2.1.eclipse中配置</h3><blockquote><p>高版本自带maven，需要注意的是eclipse的JRE运行环境目录要选择jdk下的JRE目录</p></blockquote><h3 id="2-2-配置插件"><a href="#2-2-配置插件" class="headerlink" title="2.2.配置插件"></a>2.2.配置插件</h3><blockquote><p><a href="http://maven.apache.org/plugins/index.html" target="_blank" rel="noopener">插件地址</a></p></blockquote><h3 id="2-3-POM配置文件详解"><a href="#2-3-POM配置文件详解" class="headerlink" title="2.3.POM配置文件详解"></a>2.3.POM配置文件详解</h3><blockquote><p><a href="http://www.blogjava.net/RomulusW/archive/2008/05/04/197985.html" target="_blank" rel="noopener">版本说明</a></p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>反写的公司域名+项目名<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>项目名+模块名<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        第一个 0 是大版本号</span></span><br><span class="line"><span class="comment">        第二个 0 是分支版本号</span></span><br><span class="line"><span class="comment">        第三个 0 是小版本号</span></span><br><span class="line"><span class="comment">        snapshot 快照</span></span><br><span class="line"><span class="comment">        alpha 内部测试</span></span><br><span class="line"><span class="comment">        beta 公测</span></span><br><span class="line"><span class="comment">        RC 发行候选版本</span></span><br><span class="line"><span class="comment">        Release/GA 正式发布</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jar war zip pom--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目描述名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目描述--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span><span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span><span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">orgnazation</span>&gt;</span><span class="tag">&lt;/<span class="name">orgnazation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 配置属性 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 统一定义版本 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">springframework.version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">springframework.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">           test 表明这个构件只在test目录下可以被引用</span></span><br><span class="line"><span class="comment">           compile 默认的</span></span><br><span class="line"><span class="comment">           provided 只在编译中引用</span></span><br><span class="line"><span class="comment">           runtime 编译和运行都有效</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置依赖是否可选，默认是false--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span><span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--排除依赖传递列表--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 构件三要素 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--继承--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-配置代码编译版本"><a href="#2-4-配置代码编译版本" class="headerlink" title="2.4.配置代码编译版本"></a>2.4.配置代码编译版本</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-构建"><a href="#3-构建" class="headerlink" title="3.构建"></a>3.构建</h2><h3 id="3-1-使用maven构建多模块的项目"><a href="#3-1-使用maven构建多模块的项目" class="headerlink" title="3.1.使用maven构建多模块的项目"></a>3.1.使用maven构建多模块的项目</h3><p><code>.gitignore文件</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.idea/</span><br><span class="line">*.iml</span><br><span class="line">target/</span><br><span class="line">*.log</span><br></pre></td></tr></table></figure></p><p><code>父项目pom文件</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.kuangcp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Modules<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>repository<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>website<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>子项目pom文件</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>website<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.kuangcp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Modules<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="3-2-Maven多配置环境"><a href="#3-2-Maven多配置环境" class="headerlink" title="3.2.Maven多配置环境"></a>3.2.Maven多配置环境</h3><blockquote><p><a href="https://www.zybuluo.com/haokuixi/note/25985" target="_blank" rel="noopener">Maven 如何为不同的环境打包</a> <code>开发、测试和产品环境</code></p></blockquote><ul><li style="list-style: none"><input type="checkbox"> 子项目编译打包各自独立，怎么整合成一个</li></ul><h3 id="3-3-部署"><a href="#3-3-部署" class="headerlink" title="3.3.部署"></a>3.3.部署</h3><blockquote><p><a href="/Java/AdvancedLearning/Deploy.md">Java项目部署方式整理</a></p></blockquote><hr><h2 id="4-maven的依赖"><a href="#4-maven的依赖" class="headerlink" title="4.maven的依赖"></a>4.maven的依赖</h2><h3 id="4-1-依赖的范围"><a href="#4-1-依赖的范围" class="headerlink" title="4.1 依赖的范围"></a>4.1 依赖的范围</h3><blockquote><p>依赖范围就是用来控制依赖和三种classpath(编译classpath，测试classpath、运行classpath)的关系</p></blockquote><ul><li><code>compile</code>:编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。<ul><li>典型的例子是spring-core,在编译、测试和运行的时候都需要使用该依赖。</li></ul></li><li><code>test</code>: 测试依赖范围。使用次依赖范围的Maven依赖，只对于测试classpath有效<ul><li>在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。</li></ul></li><li><code>provided</code>:已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。<ul><li>典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要Maven重复地引入一遍。</li></ul></li><li><code>runtime</code>:运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。<ul><li>典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</li></ul></li></ul><table><thead><tr><th style="text-align:center">依赖范围 Scope</th><th style="text-align:center">对于编译classpath</th><th style="text-align:center">对于测试classpath</th><th style="text-align:center">对于运行classpath</th><th style="text-align:center">Demo</th></tr></thead><tbody><tr><td style="text-align:center">compile</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">spring-boot-starter-web</td></tr><tr><td style="text-align:center">test</td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center">Junit</td></tr><tr><td style="text-align:center">provided</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center">servlet-api</td></tr><tr><td style="text-align:center">runtime</td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">JDBC的实现Jar</td></tr><tr><td style="text-align:center">system</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center">Maven仓库之外的类库文件</td></tr></tbody></table><h4 id="依赖的传递"><a href="#依赖的传递" class="headerlink" title="依赖的传递"></a>依赖的传递</h4><ul><li>比如一个account-email项目为例<ul><li>account-email有一个compile范围的spring-code依赖，</li><li>spring-core有一个compile范围的commons-logging依赖，</li></ul></li><li>那么commons-logging就会成为account-email的compile的范围依赖，commons-logging是account-email的一个传递性依赖</li></ul><h3 id="4-2-处理项目间依赖方法"><a href="#4-2-处理项目间依赖方法" class="headerlink" title="4.2.处理项目间依赖方法"></a>4.2.处理项目间依赖方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">项目A依赖B</span><br><span class="line">A项目 pom.xml中配置依赖 （构件三要素）</span><br><span class="line">B项目 先clean package</span><br><span class="line">      然后build 的 install</span><br><span class="line">A 项目 compile</span><br></pre></td></tr></table></figure><h3 id="4-3-依赖冲突"><a href="#4-3-依赖冲突" class="headerlink" title="4.3.依赖冲突"></a>4.3.依赖冲突</h3><ul><li>依赖路径短优先<ul><li>1 A-&gt;B-&gt;C-&gt;X(jar文件)</li><li>2 A-&gt;C-&gt;X(jar文件)</li><li>会选择 2 中的X的jar版本</li></ul></li><li>先声明的优先</li></ul><h4 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h4><p><code>对应的&lt;dependency&gt;标签中添加</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="4-4-继承"><a href="#4-4-继承" class="headerlink" title="4.4.继承"></a>4.4.继承</h3><blockquote><p>新建一个项目作为父项目<br>然后在需要引用父项目的子项目pom文件中, 加上parent 标签里面写上 父项目的三要素</p></blockquote><hr><h2 id="5-使用maven新建Web3-0项目"><a href="#5-使用maven新建Web3-0项目" class="headerlink" title="5.使用maven新建Web3.0项目"></a>5.使用maven新建Web3.0项目</h2><blockquote><p><a href="http://mvnrepository.com/" target="_blank" rel="noopener">网络maven仓库</a></p></blockquote><ul><li>新建maven 选择webapp 然后输入三要素</li><li>但是因为模板默认的是web2.3，所以要手动修改成3.0</li><li><ol><li>pom文件中添加插件 编译部分<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>2.navigator目录模式下 修改相关文件，把2.3改成3.0</p></li><li>3.eclipse中右击改动Facets 然后maven-update一下就可以了</li></ul><h3 id="5-1-添加web容器"><a href="#5-1-添加web容器" class="headerlink" title="5.1.添加web容器"></a>5.1.添加web容器</h3><h4 id="5-1-2-Jetty"><a href="#5-1-2-Jetty" class="headerlink" title="5.1.2.Jetty"></a>5.1.2.Jetty</h4><ul><li><a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a> 里找到想要的版本，加入即可<br>特别注意 NIO的原因，静态文件在服务器启动的时候不能更改，需要找到maven仓库下的org/eclipse/jettyjetty-webapp/<br>下的jar包中的default配置文件，把useFileBuffer标签的 true 改成false</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.1.16.v20140903<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在打包成功后使用jetty:run来运行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">stopKey</span>&gt;</span>stop<span class="tag">&lt;/<span class="name">stopKey</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">stopPort</span>&gt;</span>9999<span class="tag">&lt;/<span class="name">stopPort</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scanIntervalSeconds</span>&gt;</span>1<span class="tag">&lt;/<span class="name">scanIntervalSeconds</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">contextXml</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources/jetty-context.xml<span class="tag">&lt;/<span class="name">contextXml</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">webApp</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里配置主机后的目录，现在表示根目录，最好加上项目名例如： /Project --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">webApp</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connectors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">connector</span> <span class="attr">implementation</span>=<span class="string">"org.eclipse.jetty.server.nio.SelectChannelConnector"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxIdleTime</span>&gt;</span>60000<span class="tag">&lt;/<span class="name">maxIdleTime</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">connector</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">connectors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>部署成功后，使用jetty:run 即可运行起服务器</li></ul><h4 id="5-1-3-Tomcat"><a href="#5-1-3-Tomcat" class="headerlink" title="5.1.3.Tomcat"></a>5.1.3.Tomcat</h4><ul><li>去Tomcat官网 找到maven plugins进入找到想要的版本即可</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat6-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在打包成功后使用tomcat6:deploy来运行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注意此处的url --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8080/manager/text<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span>tomcat6<span class="tag">&lt;/<span class="name">server</span>&gt;</span> <span class="comment">&lt;!-- 此处的名字必须和setting.xml中配置的ID一致 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span>&gt;</span>/mavenProject<span class="tag">&lt;/<span class="name">path</span>&gt;</span> <span class="comment">&lt;!-- 此处的名字是项目发布的工程名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>部署完成后 tomcat7:deploy 运行服务器</li></ul><h3 id="5-2-加入Servlet的API包"><a href="#5-2-加入Servlet的API包" class="headerlink" title="5.2.加入Servlet的API包"></a>5.2.加入Servlet的API包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-常用插件"><a href="#6-常用插件" class="headerlink" title="6.常用插件"></a>6.常用插件</h2><h3 id="6-1-lombok"><a href="#6-1-lombok" class="headerlink" title="6.1.lombok"></a>6.1.lombok</h3><blockquote><p>极大的简化了bean的代码量</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-protobuf"><a href="#6-2-protobuf" class="headerlink" title="6.2 protobuf"></a>6.2 protobuf</h3><blockquote><p><a href="https://www.xolstice.org/protobuf-maven-plugin/" target="_blank" rel="noopener">maven 插件 </a> <code>本质还是要使用系统安装的protoc, 然后插件实现了自动编译文件</code></p></blockquote><hr><h2 id="7-构建工具对比"><a href="#7-构建工具对比" class="headerlink" title="7.构建工具对比"></a>7.构建工具对比</h2><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513207&amp;idx=1&amp;sn=cbfad70e656fc50c4fff18678a282b95&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:小李的Build之路(上)</a> | <a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513212&amp;idx=1&amp;sn=280647b0c6cd265f85590f64d3216bee&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:小李的Build之路(下)</a> <code>这个小故事讲述了ant到maven的演化</code></p></blockquote><h3 id="7-1-Maven和Ant的区别一"><a href="#7-1-Maven和Ant的区别一" class="headerlink" title="7.1.Maven和Ant的区别一"></a>7.1.Maven和Ant的区别一</h3><ol><li><p>ant脚本是可以直接运行在maven中的。maven和ant最大的差别就是在于maven的编译以及所有的脚本都有一个基础，就是POM（project object model）。这个模型定义了项目的方方面面，然后各式各样的脚本在这个模型上工作，而ant完全是自己定义，显然maven更胜一筹。</p></li><li><p>maven对所依赖的包有明确的定义，如使用那个包，版本是多少，一目了然。而ant则通常是简单的inclde 所有的jar。导致的最终结果就是，你根本无法确定JBoss中的lib下的common－logging 是哪个版本的，唯一的方法就是打开 META－INF 目录下MANIFEST.MF。</p></li><li><p>maven是基于中央仓库的编译，即把编译所需要的资源放在一个中央仓库里，如jar，tld，pom，等。当编译的时候，maven会自动在仓库中找到相应的包，如果本地仓库没有，则从设定好的远程仓库中下载到本地。这一切都是自动的，而ant需要自己定义了。这个好处导致的结果就是，用maven编译的项目在发布的时候只需要发布源码，小得很，而反之，ant的发布则要把所有的包一起发布，显然maven又胜了一筹。</p></li><li><p>maven有大量的重用脚本可以利用，如生成网站，生成javadoc，sourcecode reference，等。而ant都需要自己去写。</p></li><li><p>maven目前不足的地方就是没有象ant那样成熟的GUI界面，不过mavengui正在努力中。目前使用maven最好的方法还是命令行，又快又方便</p></li></ol><h3 id="7-2-Maven的优势"><a href="#7-2-Maven的优势" class="headerlink" title="7.2.Maven的优势"></a>7.2.Maven的优势</h3><ul><li>协同开发的基本规范，为大家提供方便的协作的模式，能增加代码的复用，提高生产率。</li><li>提供方便，规范化的打包方法，是公司完成自动构建系统的核心部分，能帮助提高敏捷开发的效率(敏捷开发提倡尽早集成)。</li><li>减少冗余，减少出错的可能。</li><li>中心资源库管理，能减低源码库的大小，中心资源库可以统一定期备份。</li><li>目录结构规范，让开发者从一个maven项目过度到另一maven项目很容易。</li><li>大量的开源项目使用了maven。</li></ul><hr><h2 id="8-发布构件到公共仓库"><a href="#8-发布构件到公共仓库" class="headerlink" title="8.发布构件到公共仓库"></a>8.发布构件到公共仓库</h2><ul><li style="list-style: none"><input type="checkbox"> Jforg mvnrepository </li></ul><blockquote><p><a href="http://blog.csdn.net/h3243212/article/details/72374363" target="_blank" rel="noopener">将项目发布到 maven 中央仓库踩过的坑</a></p></blockquote><blockquote><p><a href="https://www.xncoding.com/2018/01/27/tool/maven-central.html" target="_blank" rel="noopener">发布Maven构件到中央仓库</a></p></blockquote><hr><h2 id="9-配置私服"><a href="#9-配置私服" class="headerlink" title="9.配置私服"></a>9.配置私服</h2><blockquote><p>不用去跑审核流程, 私有, 快速, 便捷</p></blockquote><h3 id="nexus"><a href="#nexus" class="headerlink" title="nexus"></a>nexus</h3><blockquote><p>需要运行软件, 一般公司内部局域网使用, 如果自己有服务器也能开放给公众使用 <a href="https://www.jianshu.com/p/b1fe26d5b8c8" target="_blank" rel="noopener">参考博客: maven私服搭建及gradle上传</a></p></blockquote><h3 id="码云"><a href="#码云" class="headerlink" title="码云"></a>码云</h3><blockquote><p>利用公开仓库来搭建私服 | <a href="https://my.oschina.net/polly/blog/1649362" target="_blank" rel="noopener">参考博客:  使用git仓库搭建maven私服 </a></p></blockquote><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><blockquote><p>当然了在各个托管平台都可以的, 只不过码云是国内的, 毕竟要快 github gitlab bitbucket 就….</p></blockquote><ol><li>创建好一个空的公开仓库</li><li>使用统一的groupId, 这样就会放到默认目录 <code>~/.m2/repository/</code> 下 只要在groupId对应的目录下 git init</li><li>只需在项目中执行install, 然后在此目录进行提交即可</li></ol><h4 id="引用仓库中的构件"><a href="#引用仓库中的构件" class="headerlink" title="引用仓库中的构件"></a>引用仓库中的构件</h4><h5 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h5><p>build.gradle 中添加<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven&#123;</span><br><span class="line">        url <span class="string">"https://gitee.com/你的用户名/创建的仓库/raw/master"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Maven-1"><a href="#Maven-1" class="headerlink" title="Maven"></a>Maven</h5><p>pom.xml中添加<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>mvnrepo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mvn repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://gitee.com/用户名/仓库/raw/master<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#maven&quot;&gt;Maven&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#1安装&quot;&gt;1.安装&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#11maven常用命令&quot;&gt;1.1.Mave
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringSecurity.md</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringSecurity/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringSecurity/</id>
    <published>2018-12-17T13:25:18.707Z</published>
    <updated>2018-12-17T13:25:18.707Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#springsecurity">SpringSecurity</a><ol><li><a href="#配置">配置</a><ol><li><a href="#配置静态口令使用">配置静态口令使用</a></li></ol></li></ol></li><li><a href="#使用该配置即可自定义用户名密码">使用该配置即可自定义用户名密码</a><ol><li><a href="#springboot的集成demo">SpringBoot的集成Demo</a><ol><li><a href="#创建单用户单角色的安全控制">创建单用户单角色的安全控制</a></li><li><a href="#多用户多角色的实现思路">多用户多角色的实现思路</a><ol><li><a href="#每个身份都使用一个登录实体类">每个身份都使用一个登录实体类</a></li><li><a href="#另一种思路">另一种思路：</a></li></ol></li></ol></li><li><a href="#jwt">JWT</a><ol><li><a href="#跨域问题">跨域问题</a></li></ol></li><li><a href="#oauth">Oauth</a></li><li><a href="#实现细节">实现细节</a><ol><li><a href="#关于注解的几种使用方式">关于注解的几种使用方式</a><ol><li><a href="#@secured">@Secured</a></li><li><a href="#@rolesallowed">@RolesAllowed</a></li><li><a href="#springsecurity30-开始提供了-spel表达式">SpringSecurity3.0 开始提供了 SpEL表达式</a></li></ol></li><li><a href="#保护方法应用">保护方法应用</a></li></ol></li><li><a href="#社交登录">社交登录</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><blockquote><p><a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle" target="_blank" rel="noopener">Spring Security 5.0.6 doc</a></p></blockquote><p><a href="http://www.spring4all.com/article/428" target="_blank" rel="noopener">参考博客: Spring Security 入门系列</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置静态口令使用"><a href="#配置静态口令使用" class="headerlink" title="配置静态口令使用"></a>配置静态口令使用</h3><p>当添加了Security依赖之后, 只会生成一个默认的随机密码, 如下简单配置:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用该配置即可自定义用户名密码</span></span><br><span class="line">spring.security.user.name=admin</span><br><span class="line">spring.security.user.password=secret</span><br></pre></td></tr></table></figure></p><p>如果要用 curl 访问则是 <code>curl -i  -u admin:secret  http://tomcat.kcp/hi</code>  </p><blockquote><p>注意 : 前提是要关闭 crsf 校验<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.csrf().disable();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="SpringBoot的集成Demo"><a href="#SpringBoot的集成Demo" class="headerlink" title="SpringBoot的集成Demo"></a>SpringBoot的集成Demo</h2><h3 id="创建单用户单角色的安全控制"><a href="#创建单用户单角色的安全控制" class="headerlink" title="创建单用户单角色的安全控制"></a>创建单用户单角色的安全控制</h3><ol><li>Gradle : <code>compile(&#39;org.springframework.boot:spring-boot-starter-security&#39;)</code></li><li><a href="https://gitee.com/kcp1104/codes/n2berl0tfg8wq9s4ko7xa78#SecurityConfig.java" target="_blank" rel="noopener">Security主要配置类</a></li><li><a href="https://gitee.com/kcp1104/codes/n2berl0tfg8wq9s4ko7xa78#Reader.java" target="_blank" rel="noopener">登录实体类</a></li><li>Jpa实现的Dao层 <code>public interface ReaderRepository extends JpaRepository&lt;Reader, String&gt; {}</code></li></ol><hr><h3 id="多用户多角色的实现思路"><a href="#多用户多角色的实现思路" class="headerlink" title="多用户多角色的实现思路"></a>多用户多角色的实现思路</h3><ul><li><p>使用多个实体类（实现了UserDetails接口），一个权限类，再一个多对多连接，就得到了多用户，多权限的控制</p><ul><li>在页面上加上角色的判断来控制数据显示，业务操作等功能</li></ul></li><li><p>根据书上案例代码，可以得出结论，用户表，角色表，用户角色关联表，用户表是可以多张的，角色公用一张即可，然后关联表也对应的多张，就能实现具体的业务需求</p><ul><li>例如：一个网上在线阅读书城，作家和读者以及编辑，网站后台管理员等角色的不同权限对应的页面甚至页面上细分的各个模块</li><li><code>Author</code> <code>Admin</code> <code>Reader</code> 三个类</li></ul></li><li><code>继承了UserDetails接口的实体类的配置</code> <a href="https://gitee.com/kcp1104/codes/n2berl0tfg8wq9s4ko7xa78#Readers.java" target="_blank" rel="noopener">代码片段</a></li></ul><h4 id="每个身份都使用一个登录实体类"><a href="#每个身份都使用一个登录实体类" class="headerlink" title="每个身份都使用一个登录实体类"></a>每个身份都使用一个登录实体类</h4><ul><li>然后使用不同的dao层查询，显然的实体类登录查询的效率及其低且不易扩展</li><li>设置好<code>spirng.jpa.hibernate.ddl-auto=update</code></li><li>第一次运行还会有没有实体对应的表这样的提示,说明了他正在根据多对多映射创建实体表，也体现了这个多种用户模式下需要实体等量的连接表</li><li>所以这个是要查询多张表了<ul><li>（除非UserDetailService接口的loadUserByUsername能收到表类别的参数）</li><li>也可以考虑使用一个字符串，然后用<code>特殊字符</code>把类型放进去，然后正则取出来</li><li>登录页面就需要自定义一个函数进行拼接（或者使用校验来拼接？）</li></ul></li></ul><h4 id="另一种思路："><a href="#另一种思路：" class="headerlink" title="另一种思路："></a>另一种思路：</h4><ul><li>使用一个登录用户表（序列id，用户名，密码，用户编码（对应多张表））<ul><li>角色表（序列id，用户编码，角色） </li><li>这样的话扩展就只要加表，使用同一个主键生成策略就可以了</li></ul></li></ul><blockquote><ul><li>思考：</li><li>其实这个安全框架使用的是角色控制，而不是权限控制，目前的了解，达不到Oracle那样的权限加角色的精细化控制</li></ul></blockquote><hr><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><blockquote><p><a href="/Skills/Base/WebSecurity.md#jwt">JWT相关原理</a> | <a href="https://github.com/Kuangcp/SpringBoot2-Security-Jwt" target="_blank" rel="noopener">Github SpringBoot2使用Security整合Jwt案例项目</a>  </p></blockquote><ul><li><a href="https://gitee.com/kcp1104/codes/kw31qf40iz9p8mt2x7bcd49" target="_blank" rel="noopener">个人代码片段</a>  |</li></ul><blockquote><p><a href="http://www.saily.top/2016/12/08/spring-boot-jwt/" target="_blank" rel="noopener">集成JWT到Spring Boot项目</a> | <a href="https://segmentfault.com/a/1190000009231329" target="_blank" rel="noopener">使用JWT保护你的Spring Boot应用</a><br><a href="https://juejin.im/post/58c29e0b1b69e6006bce02f4" target="_blank" rel="noopener">重拾后端之Spring Boot（四）：使用JWT和Spring Security保护REST API</a><br><a href="http://www.cnblogs.com/grissom007/p/6294746.html" target="_blank" rel="noopener">开箱即用 - jwt 无状态分布式授权</a></p></blockquote><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><blockquote><p><a href="https://segmentfault.com/q/1010000005067552" target="_blank" rel="noopener">跨域(CORS) 解决方案中，为什么 Access-Control-Allow-Methods 不起作用？</a><br><a href="https://bbs.csdn.net/topics/392006333" target="_blank" rel="noopener">WEB应用前后端分离实践 关键词：rest架构+跨域访问+JWT校验</a></p></blockquote><p><a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#csrf" target="_blank" rel="noopener">csrf</a></p><hr><h2 id="Oauth"><a href="#Oauth" class="headerlink" title="Oauth"></a>Oauth</h2><blockquote><p><a href="https://github.com/spring-projects/spring-security-oauth" target="_blank" rel="noopener">oauth</a></p></blockquote><hr><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="关于注解的几种使用方式"><a href="#关于注解的几种使用方式" class="headerlink" title="关于注解的几种使用方式"></a>关于注解的几种使用方式</h3><h4 id="Secured"><a href="#Secured" class="headerlink" title="@Secured"></a>@Secured</h4><ul><li>这是基于Spring特定的注解<h4 id="RolesAllowed"><a href="#RolesAllowed" class="headerlink" title="@RolesAllowed"></a>@RolesAllowed</h4></li><li>JSR-250的@RolesAllowed Java标准定义的注解，与上面的注解是差不多的</li><li><p>但是都是有局限性，只能判断请求是否有权限，不能进行更多的自定义判断</p><h4 id="SpringSecurity3-0-开始提供了-SpEL表达式"><a href="#SpringSecurity3-0-开始提供了-SpEL表达式" class="headerlink" title="SpringSecurity3.0 开始提供了 SpEL表达式"></a>SpringSecurity3.0 开始提供了 SpEL表达式</h4><p><code>需要先配置这个配置类，后面的注解才会生效</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSecurityConfig</span> <span class="keyword">extends</span> <span class="title">GlobalMethodSecurityConfiguration</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@PreAuthorize</code> 方法调用前，基于表达式的计算结果来限制方法的访问</p></li><li><code>@PostAuthorize</code> 允许方法调用，如果表达式是false 抛出安全异常</li><li><code>@PostFilter</code> 允许方法调用，按照表达式来过滤方法的结果</li><li><p><code>@PreFilter</code> 允许方法调用，必须进入方法前过滤输入值</p></li><li><p>方法调用前验证权限，示例:</p><ul><li><code>@PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)</code> 只允许该权限的用户访问</li><li>方法入参user，限定读者用户的text长度小于140，或者是作家用户无限制</li><li><code>@PreAuthorize(&quot;(hasRole(&#39;ROLE_READER&#39;) and #user.text.length()&lt;=140 ) or hasRole(&#39;ROLE_AUTHOR&#39;)&quot;)</code></li></ul></li><li>方法调用之后验证权限，示例;<ul><li><code>@PostAuthorize(&quot;returnObject.spitter.username == principal.username&quot;)</code></li><li>public Spittle getSpittleById(long id){} </li><li>保护方法，只有当返回的对象就是当前登录的用户时，才返回，不然抛出安全异常<br><code>以上是保护方法的调用，但是有时候保护的是数据的输入输出：</code></li></ul></li><li>过滤方法的输入输出<ul><li>事后对方法的返回值进行过滤<ul><li><code>@PreAuthorize(&quot;hasAnyRole({&#39;ROLE_ADMIN&#39;,&#39;ROLE_USER&#39;})&quot;)</code></li><li><code>@PostFilter(&quot;hasRole(&#39;ROLE_ADMIN&#39;) || filterObject.user.username == principal.name&quot;)</code></li><li><code>public List&lt;User&gt; getUsers(){}</code></li><li>该示例就是限制了如果是管理员可以获取到所有数据，普通用户只能看到自己</li><li>但是这种实现是不好的，只是一个例子，只获取自己，重载方法加个id参数就好了，上面的实现，把数据全拿出来再判断，性能上。。。</li></ul></li><li>事先对方法的参数进行过滤<ul><li><code>@PreAuthorize(&quot;hasAnyRole({&#39;ROLE_ADMIN&#39;,&#39;ROLE_USER&#39;})&quot;)</code></li><li><code>@PreFilter(&quot;hasRole(&#39;ROLE_ADMIN&#39;) || targetObject.user.username == principal.name&quot;)</code></li><li><code>public void deleteUsers(){List&lt;User&gt; users}</code></li><li>示例实现了传入一个集合，要删除的用户，但是当前用户只能删除自己，管理员才能删除集合里所有的用户</li></ul></li><li>定义许可计算器<ul><li><code>@PreFilter(&quot;hasPermission(targetObject,&#39;delete&#39;)&quot;)</code> 用户是否有权限删除目标对象？</li><li>使用了自定义的计算器类来实现这个判断，表达式简洁，但是自定义类不好写</li><li>实现PermissionEvaluator接口，新建hasPermission方法，功能就是判断是否有权限，其实就是对比目标对象是不是当前用户</li><li>创建好类后，重载GlobalMethodSecurityConfiguration配置类的createExpressionHalder方法，注册进去</li><li><code>DefaultMethodSecurityExperssionHandler ex = new De...();</code></li><li><code>ex.setPermissionEvaluator(new 自定义类);</code></li><li><code>return ex;</code></li></ul></li></ul></li></ul><h3 id="保护方法应用"><a href="#保护方法应用" class="headerlink" title="保护方法应用"></a>保护方法应用</h3><ul><li>@Secured 注解限制方法调用</li></ul><hr><h2 id="社交登录"><a href="#社交登录" class="headerlink" title="社交登录"></a>社交登录</h2><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDEwMjgwNA==&amp;mid=2247484230&amp;idx=1&amp;sn=358f684bd122888270730f2b102ee1b2&amp;chksm=fb3f1abdcc4893ab9dc400a44edfe7a9d483c070b78db1d81f70c4a3d7870d113d9287d81b0f&amp;mpshare=1&amp;scene=1&amp;srcid=0121kLxdu4ezkmeJAoJcdMZ1&amp;pass_ticket=LGmo8DCbLhUXTV%2FDVv1W9SyGxNSXxxYLrKODVeXD8f3lkWt2HnMB5b7racYt5W6V#rd" target="_blank" rel="noopener">SpringForAll社区:Spring Security源码分析（三）：Spring Social实现QQ社交登录 </a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDEwMjgwNA==&amp;mid=2247484233&amp;idx=1&amp;sn=1e84ffd8c9169db56a0d48ccb31bc842&amp;chksm=fb3f1ab2cc4893a4263799c466d73ee67971ce9deb22a91b8ae8e968621679de3bce83a2c558&amp;mpshare=1&amp;scene=1&amp;srcid=0121cjpvaOeB0nktdOSQNitj&amp;pass_ticket=LGmo8DCbLhUXTV%2FDVv1W9SyGxNSXxxYLrKODVeXD8f3lkWt2HnMB5b7racYt5W6V#rd" target="_blank" rel="noopener">SpringForAll社区:Spring Security 源码分析（四）：Spring Social实现微信社交登录 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#springsecurity&quot;&gt;SpringSecurity&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#配置&quot;&gt;配置&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#配置静态口令
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC.md</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringMVC/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringMVC/</id>
    <published>2018-12-17T13:25:18.707Z</published>
    <updated>2018-12-17T13:25:18.707Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#springmvc">SpringMVC</a><ol><li><a href="#mvc思想">MVC思想</a><ol><li><a href="#原理">原理</a></li></ol></li><li><a href="#api">API</a></li><li><a href="#传统项目配置完整流程">传统项目配置完整流程</a><ol><li><a href="#配置依赖">配置依赖</a><ol><li><a href="#maven">Maven</a></li><li><a href="#gradle">Gradle</a></li></ol></li><li><a href="#webxml">web.xml</a></li><li><a href="#applicationcontextxml">ApplicationContext.xml</a><ol><li><a href="#全局异常处理">全局异常处理</a></li><li><a href="#自定义错误页面">自定义错误页面</a></li><li><a href="#中文编码问题">中文编码问题</a></li></ol></li><li><a href="#创建controller">创建Controller</a></li></ol></li><li><a href="#使用">使用</a><ol><li><a href="#自定义拦截器">自定义拦截器</a></li><li><a href="#q&amp;a">Q&amp;A</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><blockquote><p><a href="https://legacy.gitbook.com/book/linesh/spring-mvc-documentation-linesh-translation/details" target="_blank" rel="noopener">Spring MVC 4.2.4.RELEASE 中文文档</a></p></blockquote><h2 id="MVC思想"><a href="#MVC思想" class="headerlink" title="MVC思想"></a>MVC思想</h2><blockquote><p><a href="http://blog.csdn.net/besley/article/details/8479943" target="_blank" rel="noopener">参考博客</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/mvc.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure></p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>统一使用一个Servlet 进行请求的收发, 通过配置的URL对应的方法, 进行调用, 然后返回视图解析器进行渲染</p></blockquote><hr><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><blockquote><p><a href="http://www.csdn.net/article/2013-05-02/2815115-stop-designing-fragile-web-api" target="_blank" rel="noopener">简洁的API设计</a></p></blockquote><hr><h2 id="传统项目配置完整流程"><a href="#传统项目配置完整流程" class="headerlink" title="传统项目配置完整流程"></a>传统项目配置完整流程</h2><blockquote><p>也就是Maven的Web结构，甚至是Eclipse那样的DynamicWeb项目结构， <a href="https://www.cnblogs.com/Sinte-Beuve/p/5730553.html" target="_blank" rel="noopener">参考 博客</a></p></blockquote><h3 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h3><h4 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.3.9.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果使用JSP作为视图层,还需 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework:spring-web:4.3.9.RELEASE'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework:spring-webmvc:4.3.9.RELEASE'</span>)</span><br></pre></td></tr></table></figure><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ApplicationContext-xml"><a href="#ApplicationContext-xml" class="headerlink" title="ApplicationContext.xml"></a>ApplicationContext.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.sprinControllergframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context/spring-context-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--启用spring的一些annotation --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.test.controller"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--HandlerMapping 无需配置，springmvc可以默认启动--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--静态资源映射--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--本项目把静态资源放在了WEB-INF的statics目录下，资源映射如下--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/css/**" location="/WEB-INF/statics/css/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/js/**" location="/WEB-INF/statics/js/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/image/**" location="/WEB-INF/statics/image/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--但是项目部署到linux下发现WEB-INF的静态资源会出现无法解析的情况，但是本地tomcat访问正常，因此建议还是直接把静态资源放在webapp的statics下，映射配置如下--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/css/**" location="/statics/css/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/js/**" location="/statics/js/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/image/**" location="/statics/images/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置注解驱动 可以将request参数与绑定到controller参数上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀(如果最后一个还是表示文件夹,则最后的斜杠不要漏了) 使用JSP--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;bean id="defaultViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="prefix" value="/WEB-INF/views/"/&gt;&amp;lt;!&amp;ndash;设置JSP文件的目录位置&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="suffix" value=".jsp"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springmvc文件上传需要配置的节点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"20971500"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resolveLazily"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        model.put(<span class="string">"ex"</span>, ex);</span><br><span class="line">        ex.printStackTrace();<span class="comment">//打印异常信息</span></span><br><span class="line">        <span class="comment">// 根据不同错误转向不同页面</span></span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> CSRFException) &#123;<span class="comment">//受到csrf攻击</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"/errorPage/error"</span>, model);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BusinessException) &#123;<span class="comment">//业务逻辑处理出错</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"errorPage/businessError"</span>, model);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> ParameterException) &#123;<span class="comment">//参数处理出错。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"errorPage/parameterError"</span>, model);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//其他数据类型错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"errorPage/error"</span>, model);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但如果是前后端分离的话， 就只能统一处理异常然后然后对应的错误码和提示信息了<br><a href="http://www.cnblogs.com/exmyth/p/5601288.html" target="_blank" rel="noopener">参考博客</a><br><a href="https://blog.csdn.net/xin917480852/article/details/78023911" target="_blank" rel="noopener">ResponseBody方案</a></p></blockquote><h4 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义错误页面 需要放在静态资源下面</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">containerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (container -&gt; &#123;</span><br><span class="line">        ErrorPage error401Page = <span class="keyword">new</span> ErrorPage(HttpStatus.FORBIDDEN, <span class="string">"/500.html"</span>);</span><br><span class="line">        ErrorPage error404Page = <span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">"/404.html"</span>);</span><br><span class="line">        ErrorPage error500Page = <span class="keyword">new</span> ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, <span class="string">"/500.html"</span>);</span><br><span class="line">        container.addErrorPages(error401Page, error404Page, error500Page);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中文编码问题"><a href="#中文编码问题" class="headerlink" title="中文编码问题"></a>中文编码问题</h4><blockquote><p><a href="http://www.cnblogs.com/dyllove98/p/3180158.html" target="_blank" rel="noopener">参考博客</a> <code>但是奇怪的是某些方法用第二种正常，有些还是要用第一种</code></p><ol><li>单个方法：<code>@GetMapping(value = &quot;/target/all&quot;,  produces = &quot;application/json; charset=utf-8&quot;)</code></li><li>或者整个应用 注意：<code>&lt;/mvc:annotation-driven&gt;</code> 只能有一个，要将上面的覆盖掉<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                   <span class="comment">&lt;!-- 如果是前后端使用JSON作为主要数据交换格式就把JSON列为第一个， 否则就会被认为是Text --&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json; charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/plain; charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html; charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="创建Controller"><a href="#创建Controller" class="headerlink" title="创建Controller"></a>创建Controller</h3><p>包 com.test.controller 下创建一个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hi"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hi"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hi"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>使用上 ResponseEntity 让响应结果规范<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/handle"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  URI location = ...;</span><br><span class="line">  HttpHeaders responseHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">  responseHeaders.setLocation(location);</span><br><span class="line">  responseHeaders.set(<span class="string">"MyResponseHeader"</span>, <span class="string">"MyValue"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;String&gt;(<span class="string">"Hello World"</span>, responseHeaders, HttpStatus.CREATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>在Springboot框架中，static templates 文件夹下分别代表了tomcat管理的静态文件和MVC负责跳转的HTML文件或JSP文件<br>在static中对于路径的使用一定要带上应用路径，而在templates中就只要写相对路径即可</p></blockquote><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><ul><li><a href="http://www.jianshu.com/p/f14ed6ca4e56" target="_blank" rel="noopener">相关博客</a>|<a href="http://blog.csdn.net/catoop/article/details/50501696" target="_blank" rel="noopener">相关博客</a></li></ul><p><code>定义拦截器类</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MythInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        request.setAttribute(<span class="string">"startTime"</span>,startTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// true就继续跳转，false就停止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = (Long)request.getAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        request.removeAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        log.info(request.getRequestURL()+<span class="string">"发起请求耗时:[ "</span>+ (endTime - startTime) +<span class="string">"  ms]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>配置MVC的配置类</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line">    <span class="comment">//自定义拦截器bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MythInterceptor <span class="title">mythInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MythInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拦截器的URL正则</span></span><br><span class="line">        registry.addInterceptor(mythInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><blockquote><p>URL 中带了 jsessionid 参数，导致页面各种问题</p><ul><li>一种原因：禁用cookie导致的</li><li>最终解决： chrome中在设置里清除localhost的所有cookie和缓存</li></ul></blockquote><ul><li><a href="https://yq.aliyun.com/articles/101169" target="_blank" rel="noopener">解决问题参考博客</a></li><li><p><a href="http://sxsoft.blog.163.com/blog/static/190412229200911103116773" target="_blank" rel="noopener">jsessionid的作用</a></p></li><li><p>[ ] ModelAndView中的addObject 的值能用js获取到么</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#springmvc&quot;&gt;SpringMVC&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#mvc思想&quot;&gt;MVC思想&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#原理&quot;&gt;原理&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot.md</title>
    <link href="http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringBoot/"/>
    <id>http://blog.kuangcp.top/2018/12/17/Memo-Java-Spring-SpringBoot/</id>
    <published>2018-12-17T13:25:18.707Z</published>
    <updated>2018-12-17T13:25:18.707Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#springboot">SpringBoot</a><ol><li><a href="#思考">思考</a></li><li><a href="#参考教程">参考教程</a><ol><li><a href="#系列">系列</a></li></ol></li><li><a href="#开始使用">开始使用</a></li><li><a href="#安装springbootcli">安装SpringBootCLI</a></li><li><a href="#测试模块">测试模块</a></li><li><a href="#配置文件">配置文件</a><ol><li><a href="#多种配置文件并切换">多种配置文件并切换</a><ol><li><a href="#yml方式">yml方式</a></li><li><a href="#yml和properties结合">yml和Properties结合</a></li></ol></li><li><a href="#应用配置文件">应用配置文件</a></li></ol></li><li><a href="#日志模块">日志模块</a></li><li><a href="#web模块">Web模块</a><ol><li><a href="#lisener">Lisener</a><ol><li><a href="#servletcontextlistener">ServletContextListener</a></li></ol></li><li><a href="#上传下载文件">上传下载文件</a></li><li><a href="#错误页面跳转配置">错误页面跳转配置</a></li><li><a href="#跨域">跨域</a></li></ol></li><li><a href="#全局异常处理">全局异常处理</a></li><li><a href="#https的配置">HTTPS的配置</a></li><li><a href="#线程池">线程池</a></li><li><a href="#项目部署">项目部署</a><ol><li><a href="#生成指定文件">生成指定文件</a><ol><li><a href="#war">war</a></li><li><a href="#jar">jar</a></li></ol></li><li><a href="#构建docker镜像">构建docker镜像</a><ol><li><a href="#手动方式">手动方式</a></li><li><a href="#gradle结合docker">gradle结合docker</a></li></ol></li><li><a href="#热部署">热部署</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><blockquote><p><a href="https://spring.io/projects/spring-boot#learn" target="_blank" rel="noopener">首页</a></p></blockquote><blockquote><p>一个简化Spring开发的框架,微服务SpringCloud的基础<br><a href="https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/htmlsingle/" target="_blank" rel="noopener">1.5.14 官方文档</a></p></blockquote><ul><li><a href="https://github.com/spring-projects/spring-boot/releases" target="_blank" rel="noopener">Github:Springboot</a></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p><a href="https://www.zhihu.com/question/39483566" target="_blank" rel="noopener">SpringBoot优缺点</a> </p><ul><li><code>大大降低编程门槛, 但是, 将大量细节隐藏在默认配置中, 需要详细阅读文档和源码才能更好的玩转SpringBoot, 不然到处是坑</code></li></ul></li><li><p><a href="https://www.cnblogs.com/trgl/p/7353782.html" target="_blank" rel="noopener">SpringBoot启动流程解析</a><code>原理才是王道</code></p></li><li><p><a href="https://yq.aliyun.com/articles/6056" target="_blank" rel="noopener">spring boot应用启动原理分析 </a></p></li><li><p>Spring 是单例模式, 全部使用IOC容器进行管理, 那么怎么处理并发呢, </p><ul><li>答案是 ? 多线程 然后 ThreadLocal 分别存储了各自的数据, 所以才说, 不能在Controller层 放置属性, 使其具有状态, 从而导致并发问题</li><li>那么WebSocket服务器, 处理并发会不会有并发问题?</li></ul></li><li><p><a href="http://www.ityouknow.com/springboot/2018/06/12/spring-boo-java-simple.html" target="_blank" rel="noopener">为什么说 Java 程序员到了必须掌握 Spring Boot 的时候？</a></p></li></ul><blockquote><p><a href="https://spring.io/guides/gs/actuator-service/" target="_blank" rel="noopener">Guide</a></p></blockquote><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><ul><li><a href="http://springboot.fun/" target="_blank" rel="noopener">SpringBoot中文索引</a></li><li><a href="http://www.spring4all.com/article/246" target="_blank" rel="noopener">参考博客: Spring Boot 入门系列</a></li><li><a href="https://juejin.im/post/598dd709f265da3e213f0c57" target="_blank" rel="noopener">Springboot探索</a></li><li><a href="http://blog.csdn.net/jsyxcjw/article/details/46763639" target="_blank" rel="noopener">SpringBoot入门</a></li></ul><h3 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h3><ul><li><a href="https://github.com/guoxiaoxu/guo-projects/tree/master/guns-admin/note" target="_blank" rel="noopener">一系列专栏</a></li><li><a href="http://tengj.top/tags/Spring-Boot/" target="_blank" rel="noopener">个人博客专栏: SpringBoot干货系列</a></li><li><a href="http://www.ityouknow.com/spring-boot" target="_blank" rel="noopener">SpringBoot系列文章</a></li><li><a href="https://www.jianshu.com/u/092df3f77bca" target="_blank" rel="noopener">恒宇少年</a><code>大量Boot博客</code></li></ul><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><blockquote><p>使用Idea的话就可以直接创建项目 使用别的可以下载zip进行导入 | <a href="http://start.spring.io/" target="_blank" rel="noopener">官方初始项目构建 下载地址</a></p></blockquote><p><em>目录结构最好如下</em> <code>*Application类要处于所有用了Springboot注解的类的顶级目录, 这样默认才能扫描到</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── config/</span><br><span class="line">├── controller/</span><br><span class="line">├── dao/</span><br><span class="line">├── domain/</span><br><span class="line">├── GraduateApplication.java</span><br><span class="line">├── service/</span><br><span class="line">├── ServletInitializer.java</span><br><span class="line">└── util/</span><br></pre></td></tr></table></figure></p><h2 id="安装SpringBootCLI"><a href="#安装SpringBootCLI" class="headerlink" title="安装SpringBootCLI"></a>安装SpringBootCLI</h2><ul><li>使用 SDKMAN 进行安装<ul><li>使用git bash运行  <code>curl -s get.sdkman.io | bash</code></li><li><code>source &quot;/Users/{yourname}/.sdkman/bin/sdkman-init.sh&quot;</code>根据实际目录去运行</li><li>spring –version</li></ul></li><li>官方下载地址 <a href="https://repo.spring.io/release/org/springframework/boot/spring-boot-cli/" target="_blank" rel="noopener">所有版本</a></li></ul><h2 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h2><ul><li style="list-style: none"><input type="checkbox"> 了解这些测试注解 的作用和使用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖于Springboot环境的测试类的必备注解</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内存数据库测试</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.github.kuagncp"</span>) <span class="comment">// 如果有类没注入需要手动设置扫面</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br></pre></td></tr></table></figure><ul><li>可以使用MockMvc来测试Controller层的代码</li><li>可以使用MockMvc的SpringSecurity支持来测试安全模块</li><li>使用 WebIntegraionTest 测试运行中的Web容器<ul><li>启动嵌入式的Servlet容器来进行测试，下断言</li></ul></li><li>使用随机端口启动服务器 配置local.server.port=0</li><li>使用Selenium来测试HTML页面，模拟浏览器的动作，查看系统运行状态</li></ul><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote><p>配置文件(<code>application.properties或者yml</code>)加载顺序 <a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config-application-property-files" target="_blank" rel="noopener">官方文档说明</a></p><blockquote><p>1.当前Jar/War目录下的/config目录 <code>file:./config/</code><br>2.当前目录 <code>file:./</code><br>3.classpath 里的/config目录 <code>classpath:/config/</code><br>4.classpath 根目录 <code>classpath:/</code>  </p></blockquote></blockquote><blockquote><p>自定义配置文件名就要运行时加参数  </p><blockquote><p><code>java -jar myproject.jar --spring.config.name=myproject</code><br><code>java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties</code> <br></p></blockquote></blockquote><ul><li><a href="http://www.itwendao.com/article/detail/391009.html" target="_blank" rel="noopener">配置文件的使用</a></li><li><a href="https://www.tuicool.com/articles/veUjQba" target="_blank" rel="noopener">Spring boot配置文件 application.properties</a></li><li><a href="https://my.oschina.net/wangnian/blog/666641" target="_blank" rel="noopener">SpringBoot常用配置</a></li><li><a href="https://segmentfault.com/a/1190000008968295" target="_blank" rel="noopener">使用Gradle整合SpringBoot+Vue.js-开发调试与打包</a></li><li><p><a href="https://yq.aliyun.com/articles/182720" target="_blank" rel="noopener">配置文件加密</a></p></li><li><p><a href="http://www.cnblogs.com/java-zhao/p/5542154.html" target="_blank" rel="noopener">自定义配置文件</a><code>将应用配置外置并注入成bean</code></p></li><li><a href="http://www.cnblogs.com/xiaoqi/p/6955288.html" target="_blank" rel="noopener">配置文件外置</a></li></ul><h3 id="多种配置文件并切换"><a href="#多种配置文件并切换" class="headerlink" title="多种配置文件并切换"></a>多种配置文件并切换</h3><h4 id="yml方式"><a href="#yml方式" class="headerlink" title="yml方式"></a>yml方式</h4><ul><li><p>单文件<code>配置文件 application.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">     profiles:</span></span><br><span class="line"><span class="attr">       active:</span> <span class="string">development</span> <span class="comment"># 选用开发模式</span></span><br><span class="line"><span class="bullet">   -</span><span class="bullet">--</span></span><br><span class="line"><span class="attr">   spring:</span></span><br><span class="line"><span class="attr">     profiles:</span> <span class="string">development</span></span><br><span class="line">     <span class="string">//一系列配置</span></span><br><span class="line"><span class="bullet">   -</span><span class="bullet">--</span></span><br><span class="line"><span class="attr">   spring:</span></span><br><span class="line"><span class="attr">     profiles:</span> <span class="string">production</span></span><br><span class="line">     <span class="string">//一系列配置</span></span><br></pre></td></tr></table></figure></li><li><p>或者 多文件放 <code>application-{profile}.yml</code></p></li></ul><h4 id="yml和Properties结合"><a href="#yml和Properties结合" class="headerlink" title="yml和Properties结合"></a>yml和Properties结合</h4><ul><li>格式：<code>application-{profile}.properties</code></li><li>将上面的开发部分，发行部分的配置创建两个配置文件 <code>application-dev.properties</code> 和 <code>application-prod.properties</code></li><li>在主配置文件<code>application.yml</code>中指明<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev或者是prod</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="应用配置文件"><a href="#应用配置文件" class="headerlink" title="应用配置文件"></a>应用配置文件</h3><blockquote><p>依赖于 <code>org.springframework.boot:spring-boot-configuration-processor</code><br>配置对应的实体类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"graduate.main"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String delimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>应用配置类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MainConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoCustomConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>application.yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">graduate:</span></span><br><span class="line"><span class="attr">  main:</span></span><br><span class="line"><span class="attr">    delimiter:</span> <span class="string">,</span></span><br></pre></td></tr></table></figure></p><hr><h2 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h2><p>默认可以通过 application.properties 配置框架的日志,以及应用具体到包和类的日志等级,日志文件等等</p><blockquote><p><a href="https://www.cnblogs.com/lixuwu/p/5804793.html" target="_blank" rel="noopener">参考博客: Spring boot——logback 基础使用篇（一）</a></p></blockquote><blockquote><p><a href="https://springframework.guru/using-logback-spring-boot/" target="_blank" rel="noopener">参考博客: springboot use logback</a><code>能根据Profile配置,还能写if</code></p></blockquote><p>使用 logback 则需要配置 logback.xml 或者 logback-spring.xml 建议使用后者</p><hr><h2 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h2><h3 id="Lisener"><a href="#Lisener" class="headerlink" title="Lisener"></a>Lisener</h3><h4 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Servlet容器初始化"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Servlet容器销毁"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上传下载文件"><a href="#上传下载文件" class="headerlink" title="上传下载文件"></a>上传下载文件</h3><blockquote><p>第一种直接上传到应用的webroot或者resources目录下，第二种上传到数据库中，第三种使用ftp。</p></blockquote><ul><li><a href="http://www.cnblogs.com/studyCenter/p/6665171.html" target="_blank" rel="noopener">Springboot上传文件</a></li><li>上传文件有大小限制，使用如下方法进行配置 <a href="http://makaidong.com/studyDetail/11882_45833.html" target="_blank" rel="noopener">参考博客</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipartConfigElement <span class="title">multipartConfigElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MultipartConfigFactory factory = <span class="keyword">new</span> MultipartConfigFactory();</span><br><span class="line">    <span class="comment">//单个文件最大</span></span><br><span class="line">    factory.setMaxFileSize(<span class="string">"80MB"</span>); <span class="comment">//KB,MB</span></span><br><span class="line">    <span class="comment">// 设置总上传数据总大小</span></span><br><span class="line">    factory.setMaxRequestSize(<span class="string">"102400KB"</span>);</span><br><span class="line">    <span class="keyword">return</span> factory.createMultipartConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="错误页面跳转配置"><a href="#错误页面跳转配置" class="headerlink" title="错误页面跳转配置"></a>错误页面跳转配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">containerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (container -&gt; &#123;</span><br><span class="line">            ErrorPage error401Page = <span class="keyword">new</span> ErrorPage(HttpStatus.FORBIDDEN, <span class="string">"/403.html"</span>);</span><br><span class="line">            ErrorPage error404Page = <span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">"/404.html"</span>);</span><br><span class="line">            ErrorPage error500Page = <span class="keyword">new</span> ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, <span class="string">"/500.html"</span>);</span><br><span class="line">            container.addErrorPages(error401Page, error404Page, error500Page);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><blockquote><p>不同的域名（主机）端口都会导致跨域问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> CorsConfiguration <span class="title">buildConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>); <span class="comment">// 允许任何域名使用</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>); <span class="comment">// 允许任何头</span></span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">"*"</span>); <span class="comment">// 允许任何方法（post、get等）</span></span><br><span class="line">        <span class="keyword">return</span> corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, buildConfig()); <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><ol><li>新建类, 加上注解 ControllerAdvice</li><li>方法上使用注解 <code>ExceptionHandler(Exception.class)</code> 处理所有异常</li><li>然后返回值的写法和普通Controller一样, 返回JSON就<code>ResponseBody</code></li></ol><hr><h2 id="HTTPS的配置"><a href="#HTTPS的配置" class="headerlink" title="HTTPS的配置"></a>HTTPS的配置</h2><blockquote><p><a href="https://www.drissamri.be/blog/java/enable-https-in-spring-boot/" target="_blank" rel="noopener">参考博客</a></p></blockquote><ul><li>签发证书：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -<span class="built_in">alias</span> tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  context-path:</span> <span class="string">/myth</span></span><br><span class="line"><span class="attr">  ssl:</span></span><br><span class="line"><span class="attr">    key-store:</span> <span class="attr">classpath:keystore.p12</span></span><br><span class="line"><span class="attr">    key-store-password:</span> <span class="string">demo1429336</span></span><br><span class="line"><span class="attr">    key-store-type:</span> <span class="string">PKCS12</span></span><br><span class="line"><span class="attr">    key-alias:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">  session:</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p><code>任意的一个@Configuration注解类里添加</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="title">servletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TomcatEmbeddedServletContainerFactory factory =</span><br><span class="line">        <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//SecurityConstraint必须存在，可以通过其为不同的URL设置不同的重定向策略。</span></span><br><span class="line">                SecurityConstraint securityConstraint = <span class="keyword">new</span> SecurityConstraint();</span><br><span class="line">                securityConstraint.setUserConstraint(<span class="string">"CONFIDENTIAL"</span>);</span><br><span class="line">                SecurityCollection collection = <span class="keyword">new</span> SecurityCollection();</span><br><span class="line">                collection.addPattern(<span class="string">"/*"</span>);</span><br><span class="line">                securityConstraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(securityConstraint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    factory.addAdditionalTomcatConnectors(createHttpConnector());</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connector <span class="title">createHttpConnector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connector connector = <span class="keyword">new</span> Connector(<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>);</span><br><span class="line">    connector.setScheme(<span class="string">"http"</span>);</span><br><span class="line">    connector.setSecure(<span class="keyword">false</span>);</span><br><span class="line">    connector.setPort(<span class="number">8887</span>);<span class="comment">//http端口（这是要新增加的一个端口）</span></span><br><span class="line">    connector.setRedirectPort(<span class="number">8888</span>);<span class="comment">// https 端口配置文件中tomcat启动的默认端口</span></span><br><span class="line">    <span class="keyword">return</span> connector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>另一种方式 <a href="http://www.cnblogs.com/xinzhao/p/4950689.html" target="_blank" rel="noopener">参考博客</a><br><code>方式不一样，没有成功</code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############ 证书颁发机构</span></span><br><span class="line"><span class="comment"># CA机构私钥</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"><span class="comment"># CA证书</span></span><br><span class="line">openssl req -x509 -new -key ca.key -out ca.crt</span><br><span class="line"><span class="comment">############ 服务端</span></span><br><span class="line"><span class="comment"># 生成服务端私钥</span></span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"><span class="comment"># 生成服务端证书请求文件</span></span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line"><span class="comment"># 使用CA证书生成服务端证书  关于sha256，默认使用的是sha1，在新版本的chrome中会被认为是不安全的，因为使用了过时的加密算法。</span></span><br><span class="line">openssl x509 -req -sha256 -<span class="keyword">in</span> server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650 -out server.crt    </span><br><span class="line"><span class="comment"># 打包服务端的资料为pkcs12格式(非必要，只是换一种格式存储上一步生成的证书) 生成过程中，需要创建访问密码，请记录下来。</span></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -<span class="keyword">in</span> server.crt -inkey server.key -out server.pkcs12</span><br><span class="line"><span class="comment"># 生成服务端的keystore（.jks文件, 非必要，Java程序通常使用该格式的证书） 生成过程中，需要创建访问密码，请记录下来。</span></span><br><span class="line">keytool -importkeystore -srckeystore server.pkcs12 -destkeystore server.jks -srcstoretype pkcs12</span><br><span class="line"><span class="comment"># 把ca证书放到keystore中（非必要）</span></span><br><span class="line">keytool -importcert -keystore server.jks -file ca.crt</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li><a href="https://hacpai.com/article/1501152977477?p=1&amp;m=0" target="_blank" rel="noopener">参考博客</a></li><li>多线程以及异常处理 <a href="http://www.liuhaihua.cn/archives/496733.html" target="_blank" rel="noopener">参考博客</a><ul><li>因为多线程的特性，所以异常只能在子线程中处理不能抛出到主线程里，但是 Spring实现的线程池可以返回一个异常信息对象</li></ul></li></ul><hr><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><h3 id="生成指定文件"><a href="#生成指定文件" class="headerlink" title="生成指定文件"></a>生成指定文件</h3><h4 id="war"><a href="#war" class="headerlink" title="war"></a>war</h4><ul><li><p>部署为war必须的类，一般在创建项目时选war就会自动生成，选jar就要手动添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(DemoApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>maven： <code>mvn war</code> 即可 mvn package -DskipTests</p></li><li>gradle: <code>gradle war</code> 然后 <code>gradle bootRepackage</code> 即可</li></ul><h4 id="jar"><a href="#jar" class="headerlink" title="jar"></a>jar</h4><ul><li>没有特殊的配置，打包即用<ul><li>maven: <code>mvn package</code> 即可生成可执行的jar</li><li>gradle:<code>gradle jar</code> 然后 <code>gradle bootRepackage</code> 也生成可执行jar</li></ul></li></ul><h3 id="构建docker镜像"><a href="#构建docker镜像" class="headerlink" title="构建docker镜像"></a>构建docker镜像</h3><blockquote><p>方便监控应用状态，cpu 内存 流量, <a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">官方文档</a></p></blockquote><h4 id="手动方式"><a href="#手动方式" class="headerlink" title="手动方式"></a>手动方式</h4><ul><li>先构建得到war或jar，然后根据dockerfile构建一个镜像<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> frolvlad/alpine-oraclejdk8:slim</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> weixin-1.0.0.war app.war</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.war"</span>]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="gradle结合docker"><a href="#gradle结合docker" class="headerlink" title="gradle结合docker"></a>gradle结合docker</h4><h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><blockquote><p><a href="https://nilzzzz.github.io/2017/11/SpringBoot1/" target="_blank" rel="noopener">参考博客: SpringBoot热部署</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#springboot&quot;&gt;SpringBoot&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#思考&quot;&gt;思考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#参考教程&quot;&gt;参考教程&lt;/a
      
    
    </summary>
    
    
  </entry>
  
</feed>
