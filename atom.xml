<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kuangcp Blog</title>
  
  <subtitle>Javaer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.kuangcp.top/"/>
  <updated>2018-12-14T12:42:49.254Z</updated>
  <id>http://blog.kuangcp.top/</id>
  
  <author>
    <name>Kuangcp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Querydsl.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Java-Ecosystem-Querydsl/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Java-Ecosystem-Querydsl/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#querydsl">Querydsl</a><ol><li><a href="#个人感想">个人感想</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Querydsl"><a href="#Querydsl" class="headerlink" title="Querydsl"></a>Querydsl</h1><blockquote><p><a href="https://github.com/querydsl/querydsl" target="_blank" rel="noopener">Github 地址</a> | <a href="http://www.querydsl.com/static/querydsl/latest/reference/html/" target="_blank" rel="noopener">最新文档地址</a></p></blockquote><blockquote><p>Querydsl 是一个通用的查询框架, 专注于通过Java API构建类型安全的SQL查询。<br>Querydsl可以通过一组通用的查询API为用户构建出适合不同类型ORM框架或者是SQL的查询语句，也就是说QueryDSL是基于各种ORM框架以及SQL之上的一个通用的查询框架。<br>借助QueryDSL可以在任何支持的ORM框架或者SQL平台上以一种通用的API方式来构建查询。目前QueryDSL支持的平台包括JPA,JDO,SQL,Java Collections,RDF,Lucene,Hibernate Search。</p></blockquote><h2 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h2><blockquote><p>初接触, 看起来很是漂亮, 一如Java8的优美, 不用折腾SQL,  2018-06-13 20:48:18</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#querydsl&quot;&gt;Querydsl&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#个人感想&quot;&gt;个人感想&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AlibabaJavaStandard.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Java-AlibabaJavaStandard/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Java-AlibabaJavaStandard/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#阿里巴巴java开发手册">阿里巴巴Java开发手册</a></li><li><a href="#编程规约">编程规约</a><ol><li><a href="#命名规约">命名规约</a></li><li><a href="#常量定义">常量定义</a></li><li><a href="#代码格式">代码格式</a></li><li><a href="#oop规约">OOP规约</a></li><li><a href="#集合处理">集合处理</a></li><li><a href="#并发处理">并发处理</a></li><li><a href="#控制语句">控制语句</a></li><li><a href="#注释规约">注释规约</a></li><li><a href="#其他">其他</a></li></ol></li><li><a href="#异常日志">异常日志</a><ol><li><a href="#异常处理">异常处理</a></li><li><a href="#日志规约">日志规约</a></li></ol></li><li><a href="#单元测试">单元测试</a></li><li><a href="#安全规约">安全规约</a></li><li><a href="#mysql规约">MySQL规约</a><ol><li><a href="#建表规约">建表规约</a></li><li><a href="#索引规约">索引规约</a></li><li><a href="#sql规约">SQL规约</a></li><li><a href="#orm映射">ORM映射</a></li></ol></li><li><a href="#工程规约">工程规约</a><ol><li><a href="#应用分层">应用分层</a></li><li><a href="#二方库依赖">二方库依赖</a></li><li><a href="#服务器规约">服务器规约</a></li></ol></li><li><a href="#专有名词">专有名词</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="阿里巴巴Java开发手册"><a href="#阿里巴巴Java开发手册" class="headerlink" title="阿里巴巴Java开发手册"></a>阿里巴巴Java开发手册</h1><blockquote><p><a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">Github: p3c</a><code>含该手册PDF GitBook等版本</code> | <a href="https://yq.aliyun.com/articles/656256?spm=a2c4e.11155472.0.0.7ba85338l1Ef0N" target="_blank" rel="noopener">《阿里巴巴Java开发手册》详尽</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/ml5271169588/article/details/6975701" target="_blank" rel="noopener">FindBugs、PMD和CheckStyle对比</a></p></blockquote><h1 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h1><h2 id="命名规约"><a href="#命名规约" class="headerlink" title="命名规约"></a>命名规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>所有命名不能以<code>美元符和下划线</code>开始和结束</p></li><li><p>禁止拼音混合英文, 更不允许直接使用中文的方式。</p><ul><li>正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。</li></ul></li><li><p>类名用<code>UpperCamelCase风格</code> 但以下情形例外:  DO / BO / DTO / VO / AO / PO / UID 例如: <code>UserDO</code></p></li><li><p>方法名、参数名、成员变量、局部变量 都统一使用 <code>lowerCamelCase风格</code></p></li><li><p>常量名全部大写, 下划线隔开, 力求语义表达完整清楚, 不要嫌名字长(枚举类中的也是)。</p></li><li><p>抽象类使用<code>Abstract或者Base</code>开头, 异常类使用Exception结尾 测试类命名以它要测试的类的名称开始，以Test结尾</p></li><li><p>数组定义 <code>String[] name</code> 而不是 <code>String name[]</code></p></li><li><p>POJO 类中布尔类型的变量不能is开头, 否则部分框架解析会引起序列化错误。 </p></li><li><p>包名统一使用小写, 点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式, 但是类名如果有复数含义, 类名可以使用复数形式。</p><ul><li>正例:  应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（ 此规则参考spring 的框架结构）</li></ul></li><li><p>杜绝完全不规范的缩写,  避免望文不知义。</p><ul><li>反例:  AbstractClass“ 缩写” 命名成 AbsClass;  condition“ 缩写” 命名成 condi, 此类随意缩写严重降低了代码的可阅读性。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>为了达到代码自解释的目标, 任何自定义编程元素在命名时, 使用尽量完整的单词组合来表达其意。</p><ul><li>正例:  从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。</li></ul></li><li><p>如果使用到了设计模式, 建议在类名中体现出具体模式。将设计模式体现在名字中, 有利于阅读者快速理解架构设计理念<code>LoginProxy</code></p></li><li><p>接口类中的方法和属性不要加任何修饰符号（ public 也不要加） , 保持代码的简洁性, 并加上有效的 Javadoc 注释。</p><ul><li>尽量不要在接口里定义变量, 如果一定要定义变量, 肯定是与接口方法相关, 并且是整个应用的基础常量。</li></ul></li></ol><p><strong><code>接口和实现类的命名有两套规则</code></strong></p><ol><li><p><code>强制</code> 对于 Service 和 DAO 类, 基于 SOA 的理念, 暴露出来的服务一定是接口, 内部的实现类用 Impl 的后缀与接口区别。</p><ul><li>正例:  CacheServiceImpl 实现 CacheService 接口。</li></ul></li><li><p><code>推荐</code> 如果是形容能力的接口名称, 取对应的形容词做接口名 （ 通常是–able 的形式）。</p><ul><li>正例:  AbstractTranslator 实现 Translatable。</li></ul></li></ol><p><strong><code>参考</code></strong></p><ol><li><p>枚举类名建议带上 Enum 后缀, 枚举成员名称需要全大写, 单词间用下划线隔开。</p><ul><li>说明:  枚举其实就是特殊的常量类, 域成员均为常量, 且构造方法被默认强制是私有。</li><li>正例:  枚举名字为 <code>ProcessStatusEnum</code> 的成员名称:  <code>SUCCESS</code>或者<code>UNKOWN_REASON</code></li></ul></li><li><p>MVC各层命名规约</p><ul><li>Service/Dao层<ul><li>获取单个对象 get 做前缀</li><li>获取多个对象 list, 复数形式结尾</li><li>获取统计值的方法 count </li><li>插入 save</li><li>删除 remove</li><li>修改 update<ul><li>领域模型</li><li>数据对象 <strong><em>xxxDO</em></strong> xxx是数据表名</li><li>数据传输对象 <strong><em>xxxDTO</em></strong> xxx是业务领域相关的名称</li><li>展示对象 <strong><em>xxxVO</em></strong> xxx是网页名称 使用了模板框架</li><li>POJO是 <strong><em>DO DTO BO VO</em></strong> 统称, 禁止命名为 xxxPOJO</li><li>有关这些缩写的详细说明  <a href="/Java/AdvancedLearning/GrammarAndType.md#object">详细定义和解释</a></li></ul></li></ul></li></ul></li></ol><ol><li><strong><code>Tomcat组织推荐的代码风格</code></strong><ol><li>使用空格进行缩进, 而不是制表符</li><li>用于 Java 源的100个字符行宽度, 用于文档源（.txt, .xml）的80个字符行宽度</li><li>Java 源代码: {在行末, 4个空格缩进</li><li>XML 源文件: 2个空格缩进</li></ol></li></ol><hr><h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><p><strong><code>强制</code></strong></p><ol><li><p>不允许出现魔法值(未经定义的常量)直接出现</p></li><li><p>long 或者 Long 初始赋值时,  使用大写的 L , 不能是小写的 l, 小写容易跟数字 1 混淆, 造成误解</p></li></ol><ol><li>不要使用一个常量类维护所有的常量, 应该按常量的功能, 进行归类, 分开维护.<ul><li>大而全的常量类, 只能用搜索 才能快速定位, 不利于理解和维护</li><li>例如 缓存相关常量放在类 <code>CacheConsts</code> 下;  系统配置相关常量放在类 <code>ConfigConsts</code> 下</li></ul></li></ol><ol><li>常量的复用层次的安排<ul><li><em>跨应用共享常量</em> : 二方库中 通常是client.jar中的<code>constant</code>目录下</li><li><em>应用内共享常量</em> : 一方库的modules中的<code>constant</code>目录下<ul><li>易懂变量也要统一定义成 应用内共享变量, 比如两个开发者在两个模块定义了相同含义的常量, 但是值却不一样, 这样就很容易埋下隐患</li></ul></li><li><em>子工程内共享常量</em> : 当前子工程的<code>constant</code>目录下</li><li><em>包内共享常量</em>: 当前包下单独的<code>constant</code>目录下</li><li><em>类内共享常量</em>: 直接在类内部 <code>private static final</code> 定义</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>如果变量值仅在一个范围内变化, 且带有名称之外的延伸属性,  定义为枚举类。下面正例中的数字就是延伸信息, 表示星期几。</p><ul><li><code>public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6),SUNDAY(7);}</code></li></ul></li><li><p>枚举类的定义 不能直接使用枚举的 ordinal() 作为枚举常量的值在程序中使用, 而应该自己定义一个变量, ordinal 方法的Javadoc上也有说明</p><ul><li>Most programmers will have no use for this method. It is designed for use by sophisticated enum-based data structures, such as EnumSet and EnumMap</li></ul></li></ol><hr><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><p><strong><code>强制</code></strong></p><ol><li><p>大括号约定: </p><ul><li>如果是大括号内为空, 则简洁地写成{}即可, 不需要换行;  </li><li>如果是非空代码块则: <ul><li>左大括号前不换行, 左大括号后换行。</li><li>右大括号前换行, 右大括号后还有 else 等代码则不换行;  表示终止的右大括号后必须换行。</li></ul></li></ul></li><li><p>小括号和字符之间不出现空格; </p><ul><li>反例:  <code>if (空格 a == b 空格)</code></li></ul></li><li><p><code>if/for/while/switch/do</code>等保留字与括号之间必须加空格.</p></li><li><p>任何二目、 三目运算符的左右两边都需要加一个空格。</p></li><li><p>缩进采用4个空格(Google的风格是两个空格), 而不是tab字符, 对应的IDE要调整一下</p></li><li><p>注释的双斜线与注释内容之间有且仅有一个空格。 <code>// 注释</code></p></li><li><p>单行字符不超过120个, 超出需换行: </p><ul><li>第二行比第一行缩进4个空格, 第三行以后就和第二行平齐就可以了</li><li>运算符与下文一起换行</li><li>方法调用的点符号与下文一起换行</li><li>调用方法 多个参数, 需在逗号后进行换行</li><li>括号之前不要换行</li></ul></li><li><p>方法参数在定义和传入时, 多个参数逗号后边必须加空格 :  <code>method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></p></li><li><p>文件编码统一采用<code>UTF-8</code> IDE中换行符采用Unix格式(LF) <code>使用别的编码的话会开心死的</code></p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>方法体内执行语句组, 变量的定义语句组, 不同的业务逻辑之间或者不同的语义之间插入一个空行, 相同业务逻辑和语义之间不需要插入空行</p><ul><li>也没必要插入多个空行进行分隔</li></ul></li><li><p>没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。(很傻的做法)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>    a = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">public</span> String b = <span class="number">2</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">float</span>  c = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>避免使用一个类的对象来引用该类的静态变量或静态方法。无谓增加编译器解析成本, 直接用<code>类名</code>来访问即可。</p></li><li><p>所有的覆写方法, 必须加 @Override 注解</p><ul><li>例如 getObject() 与 get0bject() 的问题, 前者是字母o,后者是数字0 通过使用覆盖的注解, 可以准确判断是否覆盖成功</li><li>另外, 如果在抽象类中对方法签名进行修改, 其实现类 会立即编译报错</li></ul></li><li><p>相同参数类型, 相同业务含义, 才可以使用Java的可变参数, 避免使用Object.</p><ul><li>说明:  可变参数必须放置在参数列表的最后。 <code>提倡尽量不用可变参数编程</code></li><li>正例:  <code>public User getUsers(String type, Integer... ids) {...}</code></li></ul></li><li><p>外部正在调用或者二方库依赖的接口, 不允许修改方法签名, 避免对接口调用方产生影响。</p><ul><li>接口过时必须加 <code>@Deprecated</code> 注解, 并清晰地说明采用的新接口或者新服务是什么。</li></ul></li><li><p>不能使用过时的类或方法</p><ul><li>说明:  <code>java.net.URLDecoder</code> 中的方法 <code>decode(String encodeStr)</code> 这个方法已经过时, </li><li>应该使用双参数 <code>decode(String source, String encode)</code>。接口提供方既然明确是过时接口, </li><li>那么有义务同时提供新的接口;  作为调用方来说, 有义务去考证过时方法的新实现是什么。</li></ul></li><li><p>Object 的 equals 方法容易抛空指针异常, 应使用常量或确定有值的对象来调用equals。</p><ul><li>使用<code>&quot;t&quot;.equals(test)</code>方式</li><li>推荐使用<code>java.util.Object.equals</code> (jdk7引入的工具类)</li></ul></li><li><p>所有的相同类型的包装类对象之间的 <em>值的比较</em> , 全部使用equals方法比较, </p><ul><li>注意: 对于 <code>Integer var = ?</code> 在 -128 至 127 范围内的赋值,  Integer 对象是在<code>IntegerCache.cache 产生</code>, 会复用已有对象, </li><li>这个区间内的 Integer 值可以直接使用 == 进行判断, 但是这个区间之外的所有数据, 都会在堆上产生, 并不会复用已有对象, 所以 <code>==</code> 就会失效</li><li>这是一个大坑！, <strong>推荐统一使用 equals 方法进行判断</strong></li></ul></li><li><p>关于基本数据类型与包装数据类型的使用标准如下: </p><ul><li>所有的 POJO 类属性必须使用包装数据类型。</li><li>RPC 方法的 返回值 和 参数 必须使用包装数据类型</li><li>所有的局部变量 推荐使用基本数据类型</li><li><code>说明</code>:  POJO 类属性没有初值是提醒使用者在需要使用时, 必须自己显式地进行赋值, 任何NPE 问题, 或者入库检查, 都由使用者来保证。<ul><li>数据库的查询结果可能是 null, 因为自动拆箱, 用基本数据类型接收有 NPE 风险。</li></ul></li><li><code>反例</code>:  比如显示成交总额涨跌情况, 即正负 x%,  x 为基本数据类型, 调用的 RPC 服务, 调用不成功时, 返回的是默认值, <ul><li>页面显示为 0%, 这是不合理的, 应该显示成中划线。所以包装数据类型的 null 值, 能够表示额外的信息</li><li>如: 远程调用失败, 异常退出。</li></ul></li></ul></li><li><p>定义 <code>DO/DTO/VO</code>等POJO类时, 不要给任何成员属性设定 <strong>默认值</strong></p><ul><li><code>反例</code>:  POJO 类的 createTime属性 默认值为 new Date();<ul><li>但是这个属性在数据提取时并没有置入具体值, 在更新其它字段时又附带更新了此字段, 导致创建时间被修改成当前时间。</li></ul></li></ul></li><li><p>序列化类新增属性时, 不要修改<code>serialVersionUID</code>字段, 避免反序列化失败</p><ul><li>如果完全不兼容升级, 为了避免反序列化混乱, 就需要修改<code>serialVersionUID</code>的值 <code>(idea可以配置使用快捷键自动生成)</code></li><li><code>说明</code>:  当 serialVersionUID 不一致会抛出序列化运行时异常。</li></ul></li><li><p>构造方法里面禁止加入任何业务逻辑, 如果有初始化逻辑, 请放在 init 方法中。</p></li><li><p>POJO 类必须写 toString 方法。 如果继承了另一个 POJO 类, 注意在前面加一下 super.toString() <code>lombok解救众生</code></p><ul><li>说明:  在方法执行抛出异常时, 可以直接调用 POJO 的 toString()方法打印其属性值, 便于排查问题</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>使用索引访问用 String 的 split 方法得到的数组时, 需做最后一个分隔符后有无内容的检查, 否则会有 <code>IndexOutOfBoundsException</code> 的风险。</p><ul><li><code>System.out.println(&quot;a,b,c,,&quot;.split(&quot;,&quot;).length);</code> 预期是大于3,结果却是3</li></ul></li><li><p>当一个类有多个构造方法, 或者多个同名方法, 这些方法应该按顺序放置在一起, 优于下条规则</p></li><li><p>类内方法的定义顺序依次是 共有方法或保护方法 -&gt; 私有方法 -&gt; setter/getter方法(lombok可省)</p><ul><li>公有方法是类的调用者和维护者最关心的方法, 首屏展示最好;  </li><li>保护方法虽然只是子类关心, 也可能是 <strong>模板设计模式</strong> 下的核心方法;  </li><li>而私有方法外部一般不需要特别关心, 是一个黑盒实现;  </li><li>因为承载的信息价值较低, 所有 Service 和 DAO 的 <code>getter/setter</code> 方法放在类的最后, 用了lombok就省去了。</li></ul></li><li><p>setter 方法中, 参数名称与类成员变量名称一致,  this.成员名 = 参数名。</p><ul><li>在<code>getter/setter</code> 方法中,  不要增加业务逻辑, 增加排查问题的难度。</li></ul></li><li><p>循环体中的字符串的连接方式, 使用<code>StringBuffer</code>的<code>append</code>方法进行扩展</p><ul><li>说明:  反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象, 然后进行 append 操作, </li><li><p>最后通过 toString 方法返回 String 对象, 造成内存资源浪费。</p><blockquote><p>验证循环中String的拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String target = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>; a&lt;<span class="number">10</span>; a++)&#123;</span><br><span class="line">            target += a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. javac test.java 编译</span></span><br><span class="line"><span class="comment">// 2. javap -c -l test 反编译, 就能大致看到new StringBuilder了</span></span><br></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>final 可以声明类、成员变量、方法、以及本地变量, 下列情况使用 final 关键字: </p><ol><li>不允许被继承的类, 如:  String 类。</li><li>不允许修改引用的域对象, 如:  POJO 类的域变量。</li><li>不允许被重写的方法, 如:  POJO 类的 setter 方法。</li><li>不允许运行过程中重新赋值的局部变量。</li><li>避免上下文重复使用一个变量, 使用 final 描述可以强制重新定义一个变量, 方便更好地进行重构。<ul><li>这里就隐含了一个习惯, 不应该把一个变量到处传, 到处用,赋值, 很难追踪调试</li></ul></li></ol></li><li><p>慎用Object的clone方法来拷贝对象 <code>详见API</code></p><ul><li>说明:  对象的 clone 方法默认是浅拷贝, 最好重写该方法, 实现属性对象的拷贝。</li></ul></li><li><p>类成员与方法访问控制从严: </p><ol><li>如果不允许外部直接通过 new 来创建对象, 那么构造方法显式声明并 private</li><li><strong>工具类</strong> 不允许有 public 或 default 的构造方法</li><li>类非static成员变量 或者 成员方法 若 <strong>只与</strong> 子类共享, 必须是 protected</li><li>成员属性或方法 若 <strong>仅</strong> 本类中使用, 必须是 private</li><li>若是static成员变量, 必须考虑是否final</li><li>类static 成员变量如果仅在本类使用, 必须是 private。</li></ol><ul><li><strong>注意</strong> 说明:  任何类、方法、参数、变量, 都需要严控访问范围。过于宽泛的访问范围, 不利于模块解耦。<ul><li>思考: 如果是一个 private 的方法, 想删除就删除, 可是一个 public 的 service 方法, 或者一个 public 的成员变量, 删除一下, 不得手心冒点汗吗？</li><li>变量像自己的小孩, 尽量在自己的视线内, 变量作用域太大,  无限制的到处跑, 那么你会担心的。</li></ul></li></ul></li></ol><hr><h2 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h2><p><strong><code>强制</code></strong></p><ol><li><p>关于 hashCode 和 equals 的处理, 遵循如下规则:</p><ul><li>只要重写 equals, 就必须重写 hashCode</li><li>因为 Set 存储的是不重复的对象, 依据 hashCode 和 equals 进行判断, 所以 Set 存储的方法必须重写这两个方法</li><li>如果自定义对象作为 Map 的键, 那么必须重写 hashCode 和 equals</li><li><code>说明</code>:  String 重写了 hashCode 和 equals 方法, 所以我们可以非常愉快地使用 String 对象作为 key 来使用。</li></ul></li><li><p>ArrayList 的 subList 结果不可强转成 ArrayList 否则会抛出 ClassCastException异常,  </p><ul><li>即 <code>java.util.RandomAccessSubList cannot be cast to java.util.ArrayList.</code></li><li><code>说明</code>: subList返回的是 ArrayList 的内部类 SubList, 并不是ArrayList, 而是ArrayList的一个视图, 对于SubList的所有操作最终都会反映到原列表上</li></ul></li><li><p>在 <code>subList</code> 场景中, 高度注意对原集合元素 <strong>个数的修改</strong>, 会导致子列表的 <strong>遍历、增加、删除</strong> 均会产生 <code>ConcurrentModificationException</code> </p></li><li><p>使用集合转数组的方法, 必须使用集合的 <code>toArray(T[] array)</code> , 传入的是类型完全一样的数组, 数组大小就是 <code>list.size()</code></p><ul><li>使用 toArray 带参方法, 入参分配的数组空间不够大时,  toArray 方法内部将重新分配内存空间, 并返回新数组地址, 原数组不做更改; </li><li>如果数组元素大于实际所需, 下标超出的数组元素将被置为 null, 其它数组元素保持原值, 因此最好将方法入参数组大小定义与集合元素个数一致。</li><li><em>注意</em> 直接使用 toArray 无参方法存在问题, 此方法返回值只能是 Object[]类, 若强转其它类型数组将出现 ClassCastException 错误。</li></ul></li><li><p>把数组转换成集合: 使用工具类<code>Arrays.asList()</code>时, 不能使用其修改集合相关的方法, 其<code>add/remove/clear</code>方法会抛出<code>UnsupportedOperationException</code>异常。</p><ul><li>因为 asList 的返回对象是一个继承于 AbstractList 的内部类 Arrays, 实现集合的那些修改方法时 都是直接抛出异常</li><li><code>Arrays.asList</code>体现的是适配器模式, 只是转换接口, 后台的数据仍是固定长度的数组。</li><li>案例: <code>String[] str = new String[] { &quot;a&quot;, &quot;b&quot; }; List list = Arrays.asList(str);</code><ul><li><em>第一种情况</em>:  <code>list.add(&quot;c&quot;);</code>  运行时异常。</li><li><em>第二种情况</em>:  <code>str[0]= &quot;gujin&quot;;</code> 那么 <code>list.get(0)</code> 也会随之修改。</li></ul></li></ul></li><li><p>泛型通配符<code>&lt;? extends T&gt;</code>来接收返回的数据, 此写法的泛型集合不能使用 add 方法。</p><ul><li>而<code>&lt;? super T&gt;</code>不能使用 get 方法, 做为接口调用赋值时易出错。</li><li><em>说明</em>:  扩展说一下 <code>PECS(Producer Extends Consumer Super)</code>原则:  <ul><li>第一、 频繁往外读取内容的, 适合用<code>&lt;? extends T&gt;</code>。 </li><li>第二、 经常往里插入的, 适合用<code>&lt;? super T&gt;</code>。<ul><li>说明: 苹果装箱后返回一个<code>&lt;? extends Fruits&gt;</code>对象, 此对象就不能往里加任何水果, 包括苹果。</li></ul></li></ul></li></ul></li><li><p>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。 remove 元素请使用 Iterator方式, 如果并发操作, 需要对 Iterator 对象加锁。</p><p> <em>正例: </em></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String item = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (删除元素的条件) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <em>反例: </em></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; a = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"1"</span>);</span><br><span class="line">list.add(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"1"</span>.equals(item)) &#123;</span><br><span class="line">        list.remove(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <em>说明</em>:  以上代码的执行结果肯定会出乎大家的意料, 那么试一下把“1”换成“2”, 会是同样的结果吗？</p></li><li><p>在 JDK7 版本以上,  Comparator 要满足自反性, 传递性, 对称性, 不然 <code>Arrays.sort</code> , <code>Collections.sort</code> 会报 <code>IllegalArgumentException</code> </p><ul><li>1 ） 自反性:  x ,  y 的比较结果和 y ,  x 的比较结果相反。</li><li>2 ） 传递性:  x &gt; y , y &gt; z ,则 x &gt; z 。</li><li><p>3 ） 对称性:  x = y ,则 x , z 比较结果和 y ,  z 比较结果相同。</p><p><em>反例:  下例中没有处理相等的情况, 实际使用中可能会出现异常: </em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() &gt; o2.getId() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>集合初始化时, 尽量指定集合初始容量值。</p><ul><li>HashMap 使用 HashMap(int initialCapacity) 初始化</li><li>正例: <code>initialCapacity=(需要存储的元素个数/负载因子)+1</code>。注意负载因子（即 loaderfactor）默认为<code>0.75</code><ul><li>如果暂时无法确定初始值大小, 请设置为 16（即默认值） 。</li></ul></li><li>反例:  HashMap 需要放置 1024 个元素,  由于没有设置容量初始大小, 随着元素不断增加, 容量<code>7</code>次被迫扩大,  resize 需要重建 hash 表, 严重影响性能。</li></ul></li><li><p>使用 <code>entrySet</code> 遍历 Map 类集合 KV , 而不是 <code>keySet</code> 方式进行遍历</p><ul><li><code>keySet</code> 其实是遍历了 2 次, 一次是转为 <code>Iterator</code> 对象, 另一次是从 hashMap 中取出key 所对应的 value 。</li><li>而 <code>entrySet</code> 只是遍历了一次就把 key 和 value 都放到了 entry 中, 效率更高。 如果是 JDK8, 使用 lambda 的 foreach 方法。</li><li>说明: values() 返回的是V值集合, 是一个 list 集合对象; keySet()返回的是K值集合, 是一个 Set集合对象;entrySet()返回的是 K - V 值组合集合。</li></ul></li><li><p>高度注意 Map 类集合 <code>K/V</code> 能不能存储 null 值的情况, 如下表格:</p><ul><li><p>反例:  由于 HashMap 的干扰, 很多人认为 ConcurrentHashMap 是可以置入 null 值, 而事实上, 存储 null 值时会抛出 NPE 异常。</p><p>|  集合类   |    Key  |   Value  |  Super   |  说明  |<br>| — | — | — | — | — |<br>|Hashtable|! NULL|! NULL|Dictionary|线程安全|<br>|ConcurrentHashMap|! NULL|! NULL|AbstractMap|锁分段技术（ JDK8:CAS）|<br>|TreeMap|! NULL|NULL|AbstractMap|线程不安全|<br>|HashMap|NULL|NULL|AbstractMap|线程不安全|</p></li></ul></li><li><p>合理利用好集合的有序性 (sort) 和稳定性 (order) , 避免集合的无序性 (unsort) 和不稳定性 (unorder) 带来的负面影响。</p><ul><li>稳定性指集合每次遍历的元素次序是一定的。</li><li>有序性是指遍历的结果是按某种比较规则依次排列的。</li><li>如:  ArrayList 是 order / unsort; <ul><li>HashMap 是 unorder/unsort; </li><li>TreeSet 是 order / sort 。</li></ul></li></ul></li><li><p>利用 Set元素唯一的特性, 可以快速对一个集合进行去重操作, 避免使用 List的contains 方法进行遍历、对比、去重操作。</p><ul><li>OrderSet也是一个很重要的类</li></ul></li></ol><h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><p><strong><code>强制</code></strong></p><ol><li><p>获取单例对象需要保证线程安全, 其中的方法也要保证线程安全。</p><ul><li>资源驱动类、工具类、单例工厂类都需要注意。</li></ul></li><li><p>创建线程或线程池时请指定有意义的线程名称, 方便出错时回溯。</p></li><li><p>线程资源必须通过线程池提供, 不允许在应用中自行显式创建线程。</p><ul><li>使用线程池的好处是减少在创建和销毁线程上所花的时间, 以及系统资源的开销,解决资源不足的问题, 如果不使用线程池, 有可能造成系统创建大量同类线程而导致消耗完内存或者 过度切换 的问题</li></ul></li><li><p>线程池不允许使用 <strong>Executors</strong> 去创建, 而是通过 <strong>ThreadPoolExecutor</strong> 的方式, 这样的处理方式让写的同学更加明确线程池的运行规则, 规避资源耗尽的风险。</p><ul><li>Executors 返回的线程池对象的弊端如下:<ol><li>FixedThreadPool 和 SingleThreadPool :<ul><li>允许的请求队列长度为 Integer.MAX_VALUE , 可能会堆积大量的请求, 从而导致 OOM 。</li></ul></li><li>CachedThreadPool 和 ScheduledThreadPool :<ul><li>允许的创建线程数量为 Integer.MAX_VALUE , 可能会创建大量的线程, 从而导致 OOM 。</li></ul></li></ol></li></ul></li><li><p>SimpleDateFormat 是线程不安全的类, 一般不要定义为 static 变量, 如果定义为static , 必须加锁, 或者使用 DateUtils 工具类。</p><ul><li>如果是 JDK 8 的应用, 可以使用 Instant 代替 Date ,  LocalDateTime 代替 Calendar , DateTimeFormatter 代替 Simpledateformatter , </li><li>官方给出的解释:  simple beautiful strongimmutable thread - safe 。<blockquote><p>或者如下处理实例化  </p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;      </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;           </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>高并发时, 同步调用应该去考量锁的性能损耗。</p><ul><li>能用无锁数据结构, 就不要用锁 ;  </li><li>能锁区块, 就不要锁整个方法体 ;  </li><li>能用对象锁, 就不要用类锁。</li><li>尽可能使得加锁的代码块工作量尽可能的小, 避免在锁代码块中调用 RPC 方法;</li></ul></li><li><p>对多个资源、数据库表、对象同时加锁时, 需要保持一致的加锁顺序, 否则可能会造成死锁。</p><ul><li>线程一需要对表 A 、 B 、 C 依次全部加锁后才可以进行更新操作, 那么线程二的加锁顺序也必须是 A 、 B 、 C , 否则可能出现死锁。</li></ul></li><li><p>并发修改同一记录时, 避免更新丢失, 要么在应用层加锁, 要么在缓存加锁, 要么在数据库层使用乐观锁, 使用 version 作为更新依据。</p><ul><li>如果每次访问冲突概率小于 20%, 推荐使用乐观锁, 否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</li></ul></li><li><p>多线程并行处理定时任务时,  Timer 运行多个 TimeTask 时, 只要其中之一没有捕获抛出的异常, 其它任务便会自动终止运行</p><ul><li>使用 ScheduledExecutorService 则没有这个问题。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>使用 CountDownLatch 进行异步转同步操作, 每个线程退出前必须调用 countDown方法, 线程执行代码注意 catch 异常, 确保 countDown 方法被执行到, 避免主线程无法执行至 await 方法, 直到超时才返回结果。</p><ul><li>注意, 子线程抛出异常堆栈, 不能在主线程 try - catch 到。</li></ul></li><li><p>避免 Random 实例被多线程使用, 虽然共享该实例是线程安全的, 但会因竞争同一 seed 导致的性能下降。</p><ul><li>Random 实例包括 java.util.Random 的实例或者  Math.random() 实例。</li><li>在JDK7之后, 可以直接使用 TreadLocalRandom, 而在JDK7以前, 需要编码保证每个线程持有一个实例</li></ul></li><li><p>在并发场景下, 通过双重检查锁 （double - checked locking） 实现延迟初始化的优化问题隐患 </p><ul><li>可参考 The “Double - Checked Locking is Broken” Declaration ,</li><li>推荐问题解决方案中较为简单一种 （ 适用于 JDK 5 及以上版本 ） , 将目标属性声明为  volatile 型 。</li></ul></li><li><p>volatile 解决多线程内存不可见问题。对于一写多读, 是可以解决变量同步问题</p><ul><li>但是如果多写, 同样无法解决线程安全问题。如果是 count++ 操作, 使用如下类实现: <ul><li>AtomicInteger count =  new AtomicInteger(); count . addAndGet( 1 );  </li></ul></li><li>如果是 JDK 8, 推荐使用 LongAdder 对象, 比 AtomicLong 性能更好 （ 减少乐观锁的重试次数 ） 。</li></ul></li><li><p>HashMap 在容量不够进行 resize 时由于高并发可能出现死链, 导致 CPU 飙升, 在开发过程中可以使用其他数据结构或加锁来规避此风险。</p></li><li><p>ThreadLocal 无法解决共享对象的更新问题,  ThreadLocal 对象建议使用 static 修饰。</p><ul><li>这个变量是针对一个线程内所有操作共有的, 所以设置为静态变量, 所有此类实例共享此静态变量,  </li><li>也就是说在类第一次被使用时装载, 只分配一块存储空间, 所有此类的对象 ( 只要是这个线程内定义的 ) 都可以操控这个变量。</li></ul></li></ol><hr><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p><strong><code>强制</code></strong></p><ol><li><p>在一个 switch 块内, 每个 case 要么通过 break/return 等来终止, 要么注释说明程序将继续执行到哪一个 case 为止 ;  </p><ul><li>在一个 switch 块内, 都必须包含一个 default 语句并且放在最后, 即使它什么代码也没有。</li></ul></li><li><p>在 if/else/for/while/do 语句结构中必须使用大括号, 即使只有一行代码</p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>表达异常的分支时, 少用 if-else 的方式, 这种方式可以改写:</p><ul><li>逻辑上超过 3 层的 if-else 代码可以使用卫语句, 状态模式, 策略模式来实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 卫语句就是将错误情况提前返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">today</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isBusy())&#123;</span><br><span class="line">        System.out.println(<span class="string">"change time."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isFree())&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>除常用方法（如 getXxx/isXxx）等外, 不要在条件判断中执行其它复杂的语句</p><ul><li>并且将复杂逻辑判断的结果赋值给一个有意义的布尔变量名, 以提高可读性。</li><li>很多 if 语句内的逻辑判断都是相当复杂, 不能一眼看出在判断什么, 需要停顿,分析一下表达式才能理解 if 语句存在的意义</li><li>如果有个boolean变量接收, 变量名就起到了注释的作用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> existed = (file.open(fileName, <span class="string">"w"</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...);</span><br><span class="line"><span class="keyword">if</span>(existed)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">if</span> ((file.open(fileName, <span class="string">"w"</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...);)&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>循环体中的语句要考量性能, 以下操作尽量移至循环体外处理, 如定义对象、变量、获取数据库连接</p><ul><li>进行不必要的 try-catch 操作 (需要考虑这个 try-catch 是否可以移至循环体外而不影响逻辑)。</li></ul></li><li><p>接口入参保护, 这种场景常见的是用于做批量操作的接口。</p></li><li><p>方法中 <strong>必须</strong> 进行参数校验的场景: </p><ol><li>调用频次低的方法。</li><li>执行时间开销很大的方法. 此情形中,参数校验时间几乎可以忽略不计, <ul><li>但如果因为参数错误导致中间执行回退, 或者错误, 那得不偿失。</li></ul></li><li>需要极高稳定性和可用性的方法。</li><li>对外提供的开放接口, 不管是 RPC/API/HTTP 接口。</li><li>敏感权限入口。</li></ol></li><li><p>方法中 <strong>不需要</strong> 参数校验的场景: </p><ol><li>极有可能被循环调用的方法, 不建议对参数进行校验。但在方法说明里必须注明外部参数检查要求。</li><li>底层的方法调用频度都比较高。毕竟是像纯净水过滤的最后一道, 参数错误不太可能到底层才会暴露问题。<ul><li>一般 DAO 层与 Service层都在同一个应用中, 部署在同一台服务器中, 所以 DAO 的参数校验, 可以省略。</li></ul></li><li>被声明成 private 只会被自己代码所调用的方法, 如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题, 此时可以不校验参数。</li></ol></li></ol><h2 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>类、类属性、类方法的注释必须使用 Javadoc 规范, 使用 /*<em> 内容 </em>/ 格式, 不得使用 // xxx 方式。</p><ul><li>为了能在IDE中快速查看注释</li></ul></li><li><p>所有的抽象方法 （包括接口中的方法） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外, 还必须指出该方法做什么事情, 实现什么功能。</p><ul><li>并且声明 对子类的实现要求, 或者调用注意事项</li></ul></li><li><p>所有的类都必须添加创建者和创建日期。</p></li><li><p>方法内部单行注释, 在被注释语句上方另起一行, 使用//注释(而不是行尾注释)。方法内部多行注释使用 /<em> </em>/ 注释, 注意与代码对齐。</p></li><li><p>所有的枚举类型字段必须要有注释, 说明每个数据项的用途。</p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>与其“半吊子”英文来注释, 不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</p><ul><li>反例: TCP连接超时 解释成 传输控制协议连接超时, 反而更难以理解</li></ul></li><li><p>代码修改的同时, 注释也要进行相应的修改, 尤其是参数、返回值、异常、核心逻辑等的修改。</p><ul><li>代码与注释更新不同步, 就像路网与导航软件更新不同步一样, 如果导航软件严重滞后, 就失去了导航的意义。</li></ul></li><li><p>谨慎注释掉代码, 尽量要配合说明, 而不是简单的注释掉, 如果无用, 则删除即可</p><ul><li>代码被注释掉有两种可能性: <ol><li>后续会恢复此段代码逻辑, 若无注释,难以知晓注释动机</li><li>永久不用: 建议直接删除, 仓库有历史记录的</li></ol></li></ul></li><li><p>对于注释的要求: </p><ol><li>第一、能够准确反应设计思想和代码逻辑</li><li>第二、能够描述业务含义, 使别的程序员能够迅速了解到代码背后的信息。</li><li>完全没有注释的大段代码对于阅读者形同天书, 注释是给自己看的, 即使隔很长时间, 也能清晰理解当时的思路 ;  </li><li>注释也是给继任者看的, 使其能够快速接替自己的工作。</li></ol></li><li><p>好的命名、代码结构是自解释的, 注释力求精简准确、表达到位。避免出现注释的一个极端:过多过滥的注释, 代码的逻辑一旦修改, 修改注释是相当大的负担。</p></li><li><p>特殊注释标记, 请注明标记人与标记时间。注意及时处理这些标记, 通过标记扫描, 经常清理此类标记。 线上故障有时候就是来源于这些标记处的代码。</p><ol><li>待办事项 (TODO) : 标记人, 标记时间,  [ 预计处理时间 ]<ul><li>表示需要实现, 但目前还未实现的功能。这实际上是一个 Javadoc 的标签, 目前的 Javadoc还没有实现, 但已经被广泛使用。只能应用于类, 接口和方法 （ 因为它是一个 Javadoc 标签 ） 。</li></ul></li><li>错误, 不能工作 （FIXME） : 标记人, 标记时间,  [ 预计处理时间 ]<ul><li>在注释中用 FIXME 标记错误的代码, 不能工作, 需要及时纠正的情况。</li></ul></li></ol></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong><code>强制</code></strong></p><ol><li><p>在使用正则表达式时, 利用好其预编译功能, 可以有效加快正则匹配速度。</p><ul><li>不要在方法体内定义:  Pattern pattern =  Pattern.compile( 规则 );</li></ul></li><li><p>velocity 调用 POJO 类的属性时, 建议直接使用属性名取值即可, 模板引擎会自动按规范调用 POJO 的 getXxx() , </p><ul><li>如果是 boolean 基本数据类型变量 （boolean 命名不需要加 is前缀 ） , 会自动调用 isXxx() 方法。</li><li><strong>注意</strong> 如果是 Boolean 包装类对象, 优先调用 getXxx() 的方法。</li></ul></li><li><p>后台输送给页面的变量必须加 $!{var} ——中间的感叹号。</p><ul><li>如果 var 为 null 或者不存在, 那么 ${var} 会直接显示在页面上。</li></ul></li><li><p>注意 Math.random() 这个方法返回是 double 类型, 注意取值的范围 0 &lt;= x &lt;1 （ 能够取到零值, 注意除零异常 ） , </p><ul><li>如果想获取整数类型的随机数, 不要将 x 放大 10 的若干倍然后取整, 直接使用 Random 对象的 nextInt 或者 nextLong 方法。</li></ul></li><li><p>获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</p><ul><li>如果想获取更加精确的纳秒级时间值, 用 System.nanoTime(), 在 JDK8 中, 针对统计时间等场景, 推荐使用 Instant 类。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>尽量不要在视图模板中加入变量声明、逻辑运算符, 更不要加入任何复杂的逻辑。</p><ul><li>根据MVC理论, 视图的原则是展示, 不要抢模板和控制器的活</li></ul></li><li><p>任何数据结构的构造或初始化, 都应指定大小, 避免数据结构无限增长吃光内存。</p></li><li><p>及时清理不再使用的代码段或配置信息, 避免程序过度臃肿, 代码冗余</p><ul><li>对于暂时被注释掉, 后续可能恢复使用的代码片段, 在注释代码上方, 统一规定使用三个斜杠来说明注释掉代码的理由</li></ul></li></ol><h1 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong><code>强制</code></strong></p><ol><li><p>Java类库中定义的一类 RuntimeException 可以通过预先检查进行规避, 而不应该通过 catch 来处理</p><ul><li>比如 IndexOutOfBoundsException NullPointerException 等等.</li><li>无法通过预检查的异常除外, 如在解析一个外部传来的字符串形式的数字时, 通过 catch NumberFormatException 来实现</li><li>正例: if (obj != null){…}</li><li>反例: try{obj.method()} catch(NullPointerException e){…}</li></ul></li><li><p>异常不要用来做流程控制, 条件控制, 因为异常的处理效率比条件分支低.</p></li><li><p>对大段代码进行 try-catch,  这是不负责任的表现。 </p><ul><li>catch 时请分清稳定代码和非稳定代码, 稳定代码指的是无论如何不会出错的代码。</li><li>对于非稳定代码的 catch 尽可能进行区分异常类型, 再做对应的异常处理。</li><li>但是! 新手来说,分不清稳不稳定, 最好用大 try 块, 避免有异常遗漏没有处理</li></ul></li><li><p>捕获异常是为了处理它, 不要捕获了却什么都不处理而抛弃之, 如果不想处理它, 请将该异常抛给它的调用者。</p><ul><li>最外层的业务使用者, 必须处理异常, 将其转化为用户可以理解的内容。</li></ul></li><li><p>有 try 块放到了事务代码中,  catch 异常后, 如果需要回滚事务, 一定要注意手动回滚事务。</p></li><li><p>finally 块必须对资源对象、流对象进行关闭, 有异常也要做 try-catch 。</p><ul><li>对于 JDK7及以上, 可以使用 try-with-resources 方式。</li></ul></li><li><p>不能在 finally 块中使用 return ,  finally 块中的 return 返回后方法结束执行, 不会再执行 try 块中的 return 语句。</p><ul><li>? try 还没走完就进了 finally ? </li></ul></li><li><p>捕获与抛出的异常, 必须是完全匹配, 或者捕获的异常是抛出的异常的父类。</p><ul><li>说明: 如果预期对方抛的是绣球, 实际接到的是铅球, 就会产生意外情况。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>方法的返回值可以为 null, 不强制返回空集合, 或者空对象等, 必须添加注释充分说明什么情况下会返回 null 值。<strong>调用方</strong>需要进行 null 判断防止 NPE 问题。</p><ul><li>本规约明确 <strong>防止 NPE 是调用者的责任</strong>。即使被调用方法返回空集合或者空对象, 对调用者来说, 也并非高枕无忧, 必须考虑到远程调用失败, 运行时异常等场景返回 null 的情况。</li></ul></li><li><p>防止 NPE, 是程序员的基本修养, 注意 NPE 产生的场景: </p><ol><li>返回类型为基本数据类型, return包装类型的对象时, 自动拆箱有可能产生 NPE.<ul><li>反例:  <code>public int f() {  return Integer对象};</code> 如果为 null , 自动拆箱将抛出 NPE</li></ul></li><li>数据库的查询结果可能为 null</li><li>集合里的元素即使 isNotEmpty , 取出的数据元素也可能为 null </li><li>远程调用返回对象时, 一律要求进行 NPE 检查</li><li>对于 Session 中获取的数据, 建议 NPE 检查</li><li>级联调用 <code>obj.getA().getB().getC();</code> 一连串调用, 易产生 NPE </li></ol></li><li><p>在代码中使用“抛异常”还是“返回错误码”</p><ul><li>对于公司外的 http/api 开放接口必须使用“错误码”; </li><li>而应用内部推荐异常抛出; </li><li>跨应用间 RPC 调用优先考虑 <strong>使用 Result 方式</strong>, 封装 isSuccess()方法, “错误码”, “错误简短信息”。</li><li>关于 RPC 方法返回方式使用 Result 方式的理由: <ol><li>使用抛异常返回方式, 调用方如果没有捕获到就会产生运行时错误。</li><li>如果不加栈信息, 只是 new 自定义异常, 加入自己的理解的 error message, 对于调用端解决问题的帮助不会太多<ul><li>如果加了栈信息, 在频繁调用出错的情况下, 数据序列化和传输的性能损耗也是问题。</li></ul></li></ol></li></ul></li><li><p>定义时区分 unchecked/checked 异常, 避免直接抛出 RuntimeException, 更不允许抛出 Exception 或者 Throwable, 应使用有业务含义的自定义异常</p><ul><li>推荐业界已定义过的自定义异常, 如:  DAOException /  ServiceException 等。</li></ul></li><li><p>避免出现重复的代码 （Don ’ t Repeat Yourself） , 即 DRY 原则。</p><ul><li>随意复制和粘贴代码, 必然会导致代码的重复, 在以后需要修改时, 需要修改所有的副本, 容易遗漏。必要时抽取共性方法, 或者抽象公共类, 甚至是组件化.</li><li>正例: 一个类中有多个public方法, 都需要进行数行相同的参数校验操作, 这个时候请抽取:</li><li><code>private boolean checkParam(DTO dto){...}</code></li></ul></li></ol><h2 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>应用中不可直接使用日志系统 （Log4j, Logback） 中的 API , 而应依赖使用日志框架 SLF4J 中的API, 使用门面模式的日志框架, 有利于维护和各个类的日志处理方式统一。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(A.class);</span><br></pre></td></tr></table></figure></li><li><p>日志文件推荐至少保存 15 天, 因为有些异常具备以“周”为频次发生的特点。</p></li><li><p>应用中的扩展日志 （ 如打点、临时监控、访问日志等 ） 命名方式: appName_logType_logName.log 。 </p><ul><li>logType: 日志类型<ul><li>推荐分类有stats / desc / monitor / visit 等</li></ul></li><li>logName: 日志描述<ul><li>这种命名的好处: 通过文件名就可知道日志文件属于什么应用, 什么类型, 什么目的, 也有利于归类查找。</li></ul></li><li>推荐对日志进行分类, 错误日志和业务日志尽量分开存放, 便于开发人员查看, 也便于通过日志对系统进行及时监控。</li></ul></li><li><p>对 trace / debug / info 级别的日志输出, 必须使用条件输出形式或者使用占位符的方式。</p><ul><li><code>logger.debug(&quot;Processing trade with id : &quot; + id + &quot; symbol : &quot; + symbol);</code></li><li>如果日志级别是 warn , 上述日志不会打印, 但是会执行字符串拼接操作</li><li>并且若 symbol 是对象, 会执行 toString() 方法, 浪费了系统资源, 执行了上述操作, 最终日志却没有打印。</li></ul></li><li><p>避免重复打印日志, 浪费磁盘空间, 务必在 log4j.xml 中设置 <code>additivity = false</code></p><ul><li><code>&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code></li></ul></li><li><p>异常信息应该包括两类信息: 案发现场信息和异常堆栈信息。如果不处理,就要通过关键字 throws 上抛</p><ul><li><code>logger.error(各类参数或者对象toString + &quot;_&quot; + e.getMessage(), e)</code></li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>可以使用 warn 日志级别来记录<code>用户输入参数错误</code>的情况, 避免用户投诉时, 无所适从。</p><ul><li>注意日志输出的级别,  error 级别只记录系统逻辑出错、异常等重要的错误信息。</li><li>如非必要, 请不要在此场景打出 error 级别。</li></ul></li><li><p>谨慎地记录日志。生产环境禁止输出 debug 日志 ;  有选择地输出 info 日志 ;  如果使用 warn 来记录刚上线时的业务行为信息, 一定要注意日志输出量的问题, 避免把服务器磁盘撑爆, 并记得及时删除这些观察日志。</p><ul><li>大量地输出无效日志, 不利于系统性能提升, 也不利于快速定位错误点。</li><li>记录日志时请思考: <ul><li>这些日志真的有人看吗？</li><li>看到这条日志你能做什么？</li><li>能不能给问题排查带来好处？</li></ul></li></ul></li></ol><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p><strong><code>强制</code></strong></p><ol><li><p>好的单元测试必须遵守 AIR 原则 </p><ul><li>单元测试在线上运行时, 就像空气 AIR 一样不存在, 但是测试质量的保障上, 却是非常关键的</li><li>好的单元测试宏观上来说, 具有自动化, 独立性, 可重复执行的特点<ul><li>A: Automatic  </li><li>I: Independent</li><li>R: Repeatable</li></ul></li></ul></li><li><p>单元测试应该是全自动执行的, 而且是非交互式的. 测试框架通常是定期执行的, 执行过程中必须完全自动化才有意义.</p><ul><li>输出结果需要人工检查的测试不是一个好的单元测试, 单元测试中不准使用 System.out 来进行人工验证, 必须使用 assert.</li></ul></li><li><p>保持单元测试的独立性. 为了保证单元测试稳定可靠且便于维护, 单元测试用例之间决不能互相调用, 也不能依赖执行的先后次序.</p><ul><li>method2 需要依赖 method1 的执行, 将执行结果作为method2 的输入.</li></ul></li><li><p>单元测试是可以重复执行的, 不能受到外界环境的影响.</p><ul><li>说明: <ul><li>单元测试通常会放到持续集成中, 每次有代码 check in 时单元测试都会被执行.</li><li>如果测试对外部环境(网络, 服务, 中间件等)有依赖, 容易导致持续集成机制的不可用.</li></ul></li><li>正例: <ul><li>为了不受外界环境影响, 要求设计代码时就把SUT的依赖改成注入, 在测试时用Spring这样的DI框架注入一个本地(内存)实现或者Mock实现.</li></ul></li></ul></li><li><p>对于单元测试, 要保证测试粒度足够小, 有助于精确定位问题. 单测粒度至多是类级别, 一般是方法级别.</p><ul><li>只有测试粒度小才能在出错时尽快定位到出错位置. 单测不负责检查跨类或者夸系统的交互逻辑, 那是集成测试的领域.</li></ul></li><li><p>核心业务, 核心应用, 核心模块的增量代码确保单元测试通过.</p><ul><li>新增代码及时补充单元测试, 如果新增代码影响了原有单元测试, 请及时修正.</li></ul></li><li><p>单元测试代码必须写在如下工程目录: src/test/java 不允许写在业务代码目录下.</p><ul><li>源码构建时会跳过此目录, 而单元测试框架默认是扫描此目录.</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>单元测试的基本目标: 语句覆盖率达到70%; 核心模块的语句覆盖率和分支覆盖率都要达到100%.</p><ul><li>在工程规约的应用分层中提高的DAO层, Manager层, 可重用度高的Service, 都应该进行单元测试.</li></ul></li><li><p>编写单元测试代码遵守BCDE原则, 以保证被测试模块的交付质量.</p><ul><li>B: Border, 边界值测试, 包括循环边界 特殊取值 特殊时间点 数据顺序等.</li><li>C: Correct, 正确的输入, 并得到预期的结果.</li><li>D: Design, 与设计文档相结合, 来编写单元测试.</li><li>E: Error, 强制错误信息输入 (如: 非法数据 异常流程 非业务允许输入等), 并得到预期的结果.</li></ul></li><li><p>对于数据库相关的查询, 更新, 删除等操作, 不能假设数据库里的数据是存在的, 或者直接操作数据库把数据插入进行, 请使用程序插入或者导入数据的方式来准备数据.(使用内存数据库就容易些)</p></li><li><p>和数据库相关的单元测试, 可以设定自动回滚机制, 不给数据库造成脏数据. 或者对单元测试产生的数据有明确的前后缀标识.</p><ul><li>在RDC内部单元测试中, 使用 RDC_UNIT_TEST_ 的前缀标识数据</li></ul></li><li><p>对于不可测的代码建议做必要的重构, 使代码变得可测, 避免为了达到测试要求而书写不规范测试代码.</p></li><li><p>在设计评审阶段, 开发人员需要和测试人员一起确定单元测试范围, 单元测试最好覆盖所有测试用例(UC).</p></li><li><p>单元测试作为一种质量保障手段, 不建议在项目发布后补充单元测试用例, 建议在项目提测前完成单元测试.</p></li><li><p>为了更方便地进行单元测试, 业务代码应避免以下情况:</p><ul><li>构造方法中做的事情过多.</li><li>存在过多的全局变量和静态方法.</li><li>存在过多的外部依赖.</li><li>存在过多的条件语句 (多层条件语句建议使用卫语句,策略模式,状态模式等方式重构)</li></ul></li><li><p>不要对单元测试存在如下误解:</p><ul><li>那是测试要干的事情. 本文是开发手册, 凡是本文内容都是与开发强相关的.</li><li>单元测试代码是多余的</li><li>单元测试不需要维护</li><li>单元测试和线上故障没有辩证关系</li></ul></li></ol><h1 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h1><p><strong><code>强制</code></strong></p><ol><li><p>隶属于用户个人的页面或者功能必须进行权限控制校验。</p><ul><li>防止没有做水平权限校验就可随意访问、修改 删除 别人的数据, 比如查看他人的私信内容, 修改他人的订单</li></ul></li><li><p>用户敏感数据禁止直接展示, 必须对展示数据脱敏。</p><ul><li>查看个人手机号码会显示成:158<em>**</em>9119, 隐藏中间 4 位, 防止隐私泄露。</li></ul></li><li><p>用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定, 防止 SQL 注入, 禁止字符串拼接 SQL 访问数据库。</p></li><li><p>用户请求传入的任何参数必须做有效性验证。</p><ul><li>忽略参数校验可能导致: <ul><li>page size 过大导致内存溢出</li><li>恶意 order by 导致数据库慢查询</li><li>任意重定向</li><li>SQL 注入</li><li>反序列化注入</li><li>正则输入源串拒绝服务 ReDoS</li></ul></li><li>Java 代码用正则来验证客户端的输入, 有些正则写法验证普通用户输入没有问题, 但是如果攻击人员使用的是特殊构造的字符串来验证, 有可能导致死循环的效果。</li></ul></li><li><p>禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</p></li><li><p>表单, AJAX 提交必须执行 CSRF 安全过滤</p><ul><li>CSRF(Cross-site request forgery) 跨站请求伪造是一类常见编程漏洞。</li><li>对于存在CSRF 漏洞的应用/网站, 攻击者可以事先构造好 URL, 只要受害者用户一访问, 后台便在用户不知情情况下对数据库中用户参数进行相应修改。<blockquote><p><strong>个人理解</strong> 万一ajax接口的API暴露了, 被别有用心的人利用就能构造好页面, 用于钓鱼什么的</p></blockquote></li></ul></li><li><p>在使用平台资源, 譬如短信、邮件、电话、下单、支付, 必须实现正确的防重放限制, 如数量限制、疲劳度控制、验证码校验, 避免被滥刷、资损。</p><ul><li>如注册时发送验证码到手机, 如果没有限制次数和频率, 那么可以利用此功能骚扰到其它用户, 并造成短信平台资源浪费。</li></ul></li><li><p>发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。</p></li></ol><h1 id="MySQL规约"><a href="#MySQL规约" class="headerlink" title="MySQL规约"></a>MySQL规约</h1><h2 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>表达是与否概念的字段, 必须使用 is_xxx 的方式命名, 数据类型是 unsigned tinyint (1 表示是, 0 表示否)</p><ul><li>任何字段如果为非负数, 必须是 unsigned 。</li><li>正例: 表达逻辑删除的字段名 is_deleted, 1表示删除, 0表示未删除.<blockquote><p>个人理解: 是不是简单的整型枚举也可以这么用呢</p></blockquote></li></ul></li><li><p>表名、字段名必须使用小写字母或数字; 禁止出现数字开头, 禁止两个下划线中间只出现数字。数据库字段名的修改代价很大, 因为无法进行预发布, 所以字段名称需要慎重考虑。</p><ul><li>MySQL 在 Windows 下不区分大小写, 但在 Linux 下默认是区分大小写, 因此 数据库名, 表名 字段名 都不允许出现任何大写字母.</li></ul></li><li><p>表名不使用复数名词。</p><ul><li>表名应该仅仅表示表里面的实体内容, 不应该表示实体数量, 对应于 DO 类名也是单数形式, 符合表达习惯。</li></ul></li><li><p>禁用保留字, 如 desc 、 range 、 match 、 delayed 等, 请参考 MySQL 官方保留字。</p></li><li><p>主键索引名为 pk_字段名, 唯一索引名为 uk_字段名, 普通索引名则为 idx_字段名。</p><ul><li>pk_ 即 primary key, uk_ 即  unique key, idx_ 即 index 的简称。</li></ul></li><li><p>小数类型为 decimal , 禁止使用 float 和 double 。</p><ul><li>float 和 double 在存储的时候, 存在精度损失的问题, 很可能在值的比较时, 得到不正确的结果。</li><li>如果存储的数据范围超过 decimal 的范围, 建议将数据拆成整数和小数分开存储。</li></ul></li><li><p>如果某字段存储的字符串长度几乎是固定的, 使用 char 定长字符串类型。</p></li><li><p>varchar 是可变长字符串, 不预先分配存储空间, 长度不要超过 500, </p><ul><li>如果存储长度大于此值, 定义字段类型为 text , 独立出来一张表, 用主键来对应, 避免影响其它字段索引效率。</li></ul></li><li><p>表必备三字段:  id,  gmt_create,  gmt_modified 。</p><ul><li>其中 id 必为主键, 类型为 unsigned bigint 、单表时自增、步长为 1。 </li><li>gmt_create ,gmt_modified 的类型均为 date_time 类型, 前者现在时表示主动创建, 后者过去分词表示被动更新.</li><li>GMT 是指格林尼治时间, 这样的话, 就是会让表的数据和时间关联上, 具有一定数据分析价值</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>表的命名最好是加上“业务名称_表的作用”。</p><ul><li>正例: alipay_task force_project trade_config</li></ul></li><li><p>库名与应用名称尽量一致。</p></li><li><p>如果修改字段含义或对字段表示的状态追加时, 需要及时更新字段注释。</p></li><li><p>字段允许适当冗余, 以提高查询性能, 但必须考虑数据一致, 冗余字段应遵循: </p><ol><li>不是频繁修改的字段。</li><li>不是 varchar 超长字段, 更不能是 text 字段。</li></ol><ul><li>正例: 商品类目名称使用频率高, 字段长度短, 名称基本一成不变, 可在相关联的表中冗余存储类目名称, 避免关联查询。</li></ul></li><li><p>单表行数超过 500 万行或者单表容量超过 2 GB, 才推荐进行分库分表。</p><ul><li>如果预计三年后的数据量根本达不到这个级别, 请不要在创建表时就分库分表。</li></ul></li><li><p>合适的字符存储长度, 不但节约数据库表空间、节约索引存储, 更重要的是提升检索速度。</p><ul><li><p>如下表, 其中无符号值可以避免误存负数, 且扩大了表示范围.</p><p>| 对象 | 年龄区间 | 类型 | 字节 | 表示范围 |<br>|:—-:|:—-:|:—-|:—-:|:—-|<br>| 人 | 150岁之内 | unsigned tinyint | 1 | 0 - 255 |<br>| 龟 | 数百年 | unsigned smallint | 2 | 0 - 65535 |<br>| 恐龙化石 | 数千万年 | unsigned int | 4 | 0 - 约42.9亿 |<br>| 太阳 | 约50亿年 | unsigned bigint | 8 | 0 - 约10的19次幂 |</p></li></ul></li></ol><h2 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>业务上具有唯一特性的字段, 即使是多个字段的组合, 也必须建成唯一索引。</p><ul><li>不要以为唯一索引影响了 insert 速度, 这个速度损耗可以忽略, 但提高查找速度是明显的 ;  </li><li>另外, 即使在应用层做了非常完善的校验控制, 只要没有唯一索引, 根据墨菲定律, 必然有脏数据产生。</li></ul></li><li><p>超过三个表禁止 join。需要 join 的字段, 数据类型必须保持绝对一致; 多表关联查询时, 保证被关联的字段需要有索引。</p><ul><li>即使双表 join 也要注意表索引、SQL 性能。</li></ul></li><li><p>在 varchar 字段上建立索引时, 必须指定索引长度, 没必要对全字段建立索引, 根据实际文本区分度决定索引长度即可。</p><ul><li>索引的长度与区分度是一对矛盾体, 一般对字符串类型数据, 长度为 20 的索引, 区分度会高达 90% 以上, </li><li>可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。</li></ul></li><li><p>页面搜索严禁左模糊或者全模糊, 如果需要请使用搜索引擎来解决。</p><ul><li>索引文件具有 B-Tree 的最左前缀匹配特性, 如果左边的值未确定, 那么无法使用此索引。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>如果有 order by 的场景, 请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分,</p><ul><li>并且放在索引组合顺序的最后, 避免出现 file_sort 的情况, 影响查询性能。</li><li>正例: <code>where a = ? and b = ? order by c;</code> 索引:  a_b_c</li><li>反例: 索引中有范围查找, 那么索引有序无法利用, 如: WHERE a &gt; 10 order by b; 索引 a_b 无法排序.</li></ul></li><li><p>利用覆盖索引来进行查询操作, 来避免回表操作。</p><ul><li>如果一本书需要知道第 11 章是什么标题, 会翻开第 11 章对应的那一页吗? 目录浏览一下就好, 这个目录就是起到覆盖索引的作用.</li><li>能够建立索引的种类: 主键索引、唯一索引、普通索引, 而覆盖索引是一种查询的一种效果, 用 explain 的结果, extra 列会出现:  using index 。</li><li>覆盖索引是select的数据列只用从索引中就能够取得, 不必读取数据行, 换句话说查询列要被所建的索引覆盖。<ul><li><strong>理解方式一</strong>: 索引是高效找到行的一个方法, 但是一般数据库也能使用索引找到一个列的数据, 因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据; 当能通过读取索引就可以得到想要的数据, 那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引</li><li><strong>理解方式二</strong>: 是非聚集复合索引的一种形式, 它包括在查询里的Select、Join和Where子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段, 也即, 索引包含了查询正在查找的数据）。</li></ul></li></ul></li><li><p>利用延迟关联或者子查询优化超多分页场景。</p><ul><li>MySQL 并不是跳过 offset 行, 而是取 offset + N 行, 然后返回放弃前 offset 行, 返回 N 行, 那当 offset 特别大的时候, 效率就非常的低下, 要么控制返回的总页数, 要么对超过特定阈值的页数进行 SQL 改写.</li><li>正例: 先快速定位需要获取的id段, 然后再关联:<ul><li>select a.* from table_a a, (select id from table_a where 条件 limit 100000, 20) b where a.id = b.id</li></ul></li></ul></li><li><p>SQL 性能优化的目标: 至少要达到  range 级别, 要求是 ref 级别, 如果可以是 consts最好。</p><ol><li>consts 单表中最多只有一个匹配行 （ 主键或者唯一索引 ） , 在优化阶段即可读取到数据。</li><li>ref 指的是使用普通的索引 （normal index） 。</li><li>range 对索引进行范围检索。</li></ol><ul><li>反例: explain 表的结果,  type = index , 索引物理文件全扫描, 速度非常慢, 这个 index 级别比较 range 还低, 与全表扫描是小巫见大巫。</li></ul></li><li><p>建组合索引的时候, 区分度最高的在最左边。</p><ul><li>正例: 如果 <code>where a = ? and b = ?</code>,  a 列的几乎接近于唯一值, 那么只需要单建 idx_a 索引即可。</li><li>存在非等号和等号混合判断条件时, 在建索引时, 请把等号条件的列前置。</li><li>如:  <code>where a &gt; ? and b = ?</code> 那么即使 a 的区分度更高, 也必须把 b 放在索引的最前列。</li></ul></li><li><p>防止因字段类型不同造成的隐式转换, 导致索引失效.</p></li><li><p>创建索引时避免有如下极端误解: </p><ol><li>宁缺毋滥. 认为一个查询就需要建一个索引。</li><li>宁缺毋滥. 认为索引会消耗空间、严重拖慢更新和新增速度。</li><li>抵制惟一索引. 认为业务的惟一性一律需要在应用层通过 “先查后插” 方式解决。</li></ol></li></ol><h2 id="SQL规约"><a href="#SQL规约" class="headerlink" title="SQL规约"></a>SQL规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>不要使用 count(列名) 或 count(常量) 来替代 count(<em>),  count( </em> ) 就是 SQL 92 定义的标准统计行数的语法, 跟数据库无关, 跟 NULL 和非 NULL 无关。</p><ul><li>count( * ) 会统计值为 NULL 的行, 而 count(列名) 不会统计此列为 NULL 值的行。</li></ul></li><li><p>count(distinct col) 计算该列除 NULL 之外的不重复行数。注意 count(distinct col1,  col2) 如果其中一列全为 NULL, 那么即使另一列有不同的值, 也返回为 0。</p></li><li><p>当某一列的值全是 NULL 时,  count(col) 的返回结果为 0, 但 sum(col) 的返回结果为NULL , 因此使用 sum() 时需注意 NPE 问题。</p><ul><li>正例: 可以使用如下方式来避免 sum 的 NPE 问题:  <code>SELECT IF(ISNULL(SUM(g)) ,0, SUM(g))FROM table;</code></li></ul></li><li><p>使用 ISNULL() 来判断是否为 NULL 值。注意:  NULL 与任何值的直接比较都为 NULL。</p><p> | 表达式 | 返回值 |<br> |:—-|:—-:|<br> | NULL&lt;&gt;NULL | NULL 而不是 false |<br> | NULL=NULL | NULL 而不是 true |<br> | NULL&lt;&gt;1 | NULL 而不是 true |</p></li><li><p>在代码中写分页查询逻辑时, 若 count 为 0 应直接返回, 避免执行后面的分页语句。</p></li><li><p>不得使用外键与级联, 一切外键概念必须在应用层解决。</p><ul><li>说明: 以学生和成绩的关系为例, 学生表中的 student_id 是主键, 那么成绩表中的 student_id 则为外键。<ul><li>如果更新学生表中的 student_id , 同时触发成绩表中的 student_id 更新, 则为级联更新。</li></ul></li><li>外键与级联更新适用于单机低并发, 不适合分布式、高并发集群; 级联更新是强阻塞, 存在数据库更新风暴的风险; </li><li>并且外键影响数据库的插入速度。</li></ul></li><li><p>禁止使用存储过程, 存储过程难以调试和扩展, 更没有移植性。</p></li><li><p>数据订正时, 删除和修改记录时, 要先 select, 避免出现误删除, 确认无误才能执行更新语句。</p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>in 操作能避免则避免, 若实在避免不了, 需要仔细评估 in 后边的集合元素数量, 控制在 1000 个之内。</p></li><li><p>如果有全球化需要, 所有的字符存储与表示, 均以 utf-8 编码, 注意字符统计函数的区别</p><ul><li><strong>注意</strong>: <ul><li>SELECT LENGTH( “轻松工作” );  返回为 12</li><li>SELECT CHARACTER _ LENGTH( “轻松工作” );  返回为 4</li></ul></li><li>如果需要存储表情, 那么使用 utfmb4(这才是真正的UTF-8) 来进行存储, MySQL 的 utf-8 编码只能存放3字节的字符</li></ul></li><li><p>TRUNCATE TABLE 比 DELETE 速度快, 且使用的系统和事务日志资源少, 但 TRUNCATE 无事务且不触发 trigger, 有可能造成事故, 故不建议在开发代码中使用此语句。</p><ul><li>TRUNCATE TABLE 在功能上与不带  WHERE 子句的  DELETE 语句相同。</li></ul></li></ol><h2 id="ORM映射"><a href="#ORM映射" class="headerlink" title="ORM映射"></a>ORM映射</h2><p><strong><code>强制</code></strong></p><ol><li><p>在表查询中, 一律不要使用 * 作为查询的字段列表, 需要哪些字段必须明确写明。</p><ol><li>增加查询分析器解析成本。</li><li>增减字段容易与 resultMap 配置不一致。</li></ol></li><li><p>POJO 类的 boolean 属性不能 is 开头, 而数据库字段必须加 is_, 要求在 resultMap 中进行字段与属性之间的映射。</p><ul><li>参见定义POJO类以及数据库字段定义的规定, 在 <code>&lt;resultMap&gt;</code> 中增加映射是必须的, 在 Mybatis Generator 生成的代码中, 需要进行对应的修改.</li></ul></li><li><p>不要用 resultClass 当返回参数, 即使所有类属性名与数据库字段一一对应, 也需要定义;  反过来, 每一个表也必然有一个与之对应。</p><ul><li>说明: 配置映射关系, 使字段与DO类解耦, 方便维护.</li></ul></li><li><p><code>sql.xml</code> 配置中参数注意使用: #{}, #param# 不要使用 ${} 此种方式容易出现 SQL 注入。</p></li><li><p>iBATIS 自带的 queryForList(String statementName , int start , int size) 不推荐使用。</p><ul><li>其实现方式是在数据库取到 statementName 对应的SQL语句的所有记录, 再通过 subList 取 start, size 的子集合 线上因为这个原因曾经出现过 OOM </li><li>正例: <ul><li>Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</li><li>map.put(“start”, start);</li><li>map.put(“size”, size);</li></ul></li></ul></li><li><p>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</p><ul><li>resultClass=”Hashtable”, 会置入字段名和属性值, 但是值的类型不可控 </li></ul></li><li><p>更新数据表记录时, 必须同时更新记录对应的 gmt_modified 字段值为当前时间。</p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>不要写一个大而全的数据更新接口, 传入为 POJO 类, 不管是不是自己的目标更新字段, </p><ul><li>都进行 <code>update table set c1=value1,c2=value2,c3=value3;</code> </li><li>这是不对的。执行 SQL时, 尽量不要更新无改动的字段, 一是易出错; 二是效率低 ; 三是 binlog 增加存储。</li></ul></li><li><p>@Transactional 事务不要滥用。事务会影响数据库的 QPS, 另外使用事务的地方需要考虑各方面的回滚方案, </p><ul><li>包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</li></ul></li><li><p><code>&lt;isEqual&gt;</code> 中的 compareValue 是与属性值对比的常量, 一般是数字, 表示相等时带上此条件;  </p><ul><li><code>&lt;isNotEmpty&gt;</code> 表示不为空且不为 null 时执行 ; </li><li><code>&lt;isNotNull&gt;</code> 表示不为 null 值时执行。</li></ul></li></ol><h1 id="工程规约"><a href="#工程规约" class="headerlink" title="工程规约"></a>工程规约</h1><h2 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h2><p><strong><code>推荐</code></strong></p><ol><li>图中默认上层依赖于下层, 箭头关系表示可直接依赖, 如: 开放接口层可以依赖于Web 层, 也可以直接依赖于 Service 层, 依此类推: <blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Alibaba/ApplicationLevels.png" alt="Application Level" title="">                </div>                <div class="image-caption">Application Level</div>            </figure>  <ul><li><strong>开放接口层</strong>: 可直接封装 Service 接口暴露成 RPC(Remote Procedure Calls) 接口;  通过 Web 封装成 http 接口; 进行网关安全控制, 流量控制等.</li><li><strong>终端显示层</strong>: 各个端的模板渲染并执行显示的层。当前主要是 Velocity 渲染, JS 渲染, JSP 渲染, 移动端展示层等。</li><li><strong>Web 层</strong>: 主要是对访问控制进行转发, 各类基本参数校验, 或者不复用的业务简单处理等。</li><li><strong>Service 层</strong>: 相对具体的业务逻辑服务层。</li><li><strong>Manager 层</strong>: 通用业务处理层, 它有如下特征: <ol><li>对第三方平台封装的层, 预处理返回结果及转化异常信息 ; </li><li>对 Service 层通用能力的下沉, 如缓存方案、中间件通用处理 ; </li><li>与 DAO 层交互, 对 DAO 的业务通用能力的封装, 对多个 DAO 的组合复用</li></ol></li><li><strong>DAO 层</strong>: 数据访问层, 与底层 MySQL、Oracle、 Hbase 等进行数据交互。</li><li><strong>外部接口或第三方平台</strong>: 包括其它部门 RPC 开放接口, 基础平台, 其它公司的 HTTP 接口。</li></ul></blockquote></li></ol><p><strong><code>参考</code></strong></p><ol><li><p><strong>分层异常处理规约</strong> 在 DAO 层, 产生的异常类型有很多, 无法用细粒度异常进行catch, 使用 catch(Exception e) 方式, 并 throw new DAOException(e), 不需要打印日志, </p><ul><li>因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去, 如果同台服务器再打日志, 浪费性能和存储。</li><li>在 Service 层出现异常时, 必须记录出错日志信息到磁盘, 尽可能带上必要的参数信息(能够描述出场景的大致状态), 相当于保护案发现场。</li><li>如果 Manager 层与 Service 同机部署, 日志方式与 DAO 层处理一致; 如果是单独部署, 则采用与 Service 一致的处理方式。</li><li>Web 层绝不应该继续往上抛异常, 因为已经处于顶层, 无继续处理异常的方式, 如果意识到这个异常将导致页面无法正常渲染, 那么就应该直接跳转到友好错误页面, 尽量加上友好的错误提示信息。</li><li>开放接口层要将异常处理成错误码和错误信息方式返回。</li></ul></li><li><p>分层领域模型规约: </p><p>| 缩写 | 名称 | 作用 |<br>|:—-|:—-|:—-|<br>| DO | Data Object | 与数据库表结构一一对应, 通过DAO层向上传输数据源对象 |<br>| DTO | Data Transfer Object | 数据传输对象, Service或Manager向外传输的对象 |<br>| BO | Business Object | 由Service层输出的封装业务逻辑的对象 |<br>| AO | Application Object | 应用对象, 在Web层与Service层之间抽象的复用对象模型, 极为贴近展示层, 复用度不高 |<br>| VO | View Object | 显示层对象, 通常是Web向模板引擎传输的对象 |<br>| Qurey | | 数据查询对象, 各层接收上层的查询请求, 注意超过2个参数的查询封装, 禁止使用Map类来传输 |</p></li></ol><h2 id="二方库依赖"><a href="#二方库依赖" class="headerlink" title="二方库依赖"></a>二方库依赖</h2><p><strong><code>强制</code></strong></p><ol><li><p>定义 GAV 遵从以下规则: </p><ul><li><strong>GroupID</strong> 格式:  <code>com.{公司/BU}.业务线.[子业务线]</code>, 最多 4 级。<ul><li>{公司/BU} 例如:  alibaba/taobao/tmall/aliexpress 等 BU; 子业务线可选。</li><li>正例: com.taobao.jstorm 或  com.alibaba.dubbo.register </li></ul></li><li><strong>ArtifactID</strong> 格式: 产品线名-模块名。语义不重复不遗漏, 先到仓库中心去查证一下。<ul><li>正例: dubbo-client /  fastjson-api /  jstorm-tool</li></ul></li><li><strong>Version</strong> : 详细规定参考下方。</li></ul></li><li><p>二方库版本号命名方式: 主版本号.次版本号.修订号</p><ol><li>主版本号: 产品方向改变, 或者大规模API不兼容, 或者架构不兼容升级. </li><li>次版本号: 保持相对兼容性, 增加主要功能特性, 影响范围极小的API不兼容修改.</li><li>修订号: 保持完全兼容性, 修复 bug, 新增次要功能特性等</li></ol><ul><li>说明: 注意起始版本号必须为:  1.0.0 , 而不是 0.0.1, 正式发布的类库必须先去中央仓库进行查证, 使版本号有延续性, 正式版本号不允许覆盖升级</li><li>如当前版本 1.3.3 那么下一个合理的版本号 1.3.4 或者 1.4.0 或 2.0.0</li></ul></li><li><p>线上应用不要依赖 SNAPSHOT 版本（安全包除外）; </p><ul><li>不依赖 SNAPSHOT 版本是保证应用发布的幂等性. 另外, 也可以加快编译时的打包构建.</li></ul></li><li><p>二方库的新增或升级, 保持除功能点之外的其它 jar 包仲裁结果不变。</p><ul><li>如果有改变, 必须明确评估和验证, 建议进行 dependency:resolve 前后信息比对, </li><li>如果仲裁结果完全不一致, 那么通过 dependency:tree 命令, 找出差异点, 进行<code>&lt;excludes&gt;</code>排除 jar 包。</li></ul></li><li><p>二方库里可以定义枚举类型, 参数可以使用枚举类型, 但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。</p></li><li><p>依赖于一个二方库群时, 必须定义一个统一版本变量, 避免版本号不一致。</p><ul><li>说明: 依赖 springframework-core, -context, -beans, 它们都是同一个版本</li><li>可以定义一个变量来保存版本: ${spring.version}, 定义依赖的时候, 引用该版本。</li></ul></li><li><p>禁止在子项目的 pom 依赖中出现相同的 GroupId , 相同的 ArtifactId , 但是不同的Version 。</p><ul><li>在本地调试时会使用各子项目指定的版本号, 但是合并成一个war, 只能有一个版本号出现在最后的lib目录中, 可能出现线下调试是正确的, 发布到线上却出故障的问题.</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>所有 pom 文件中的依赖声明放在 <code>&lt;dependencies&gt;</code> 语句块中, 所有版本仲裁放在<code>&lt;dependencyManagement&gt;</code> 语句块中。</p><ul><li><code>&lt;dependencyManagement&gt;</code> 里只是声明版本, 并不实现引入, 因此子项目需要显式的声明依赖,  version 和 scope 都读取自父 pom 。</li><li>而 <code>&lt;dependencies&gt;</code> 所有声明在主 pom 的 <code>&lt;dependencies&gt;</code> 里的依赖都会自动引入, 并默认被所有的子项目继承。</li></ul></li><li><p>二方库不要有配置项, 最低限度不要再增加配置项。</p></li></ol><p><strong><code>参考</code></strong></p><ol><li>为避免应用二方库的依赖冲突问题, 二方库发布者应当遵循以下原则: <ol><li><strong>精简可控原则</strong> 移除一切不必要的 API 和依赖, 只包含 Service API、必要的领域模型对象、 Utils类、常量、枚举等。<ul><li>如果依赖其它二方库, 尽量是 provided 引入, 让二方库使用者去依赖具体版本号; 无 log 具体实现的依赖, 只依赖日志框架(例如不依赖Logback而是依赖SLF4J)。</li></ul></li><li><strong>稳定可追溯原则</strong> 每个版本的变化应该被记录, 二方库由谁维护, 源码在哪里, 都需要能方便查到。除非用户主动升级版本, 否则公共二方库的行为不应该发生变化。</li></ol></li></ol><h2 id="服务器规约"><a href="#服务器规约" class="headerlink" title="服务器规约"></a>服务器规约</h2><p><strong><code>推荐</code></strong></p><ol><li><p>高并发服务器建议调小 TCP 协议的 time_wait 超时时间。</p><ul><li>说明: 操作系统默认 240 秒后, 才会关闭处于 time_wait 状态的连接, 在高并发访问下, 服务器端会因为处于 time_wait 的连接数太多,可能无法建立新的连接, 所以需要在服务器上调小此等待值。</li><li>正例: 在 linux 服务器上请通过变更 <code>/etc/sysctl.conf</code> 文件去修改该缺省值 （ 秒 ）<ul><li><code>net.ipv4.tcp_fin_timeout = 30</code></li></ul></li></ul></li><li><p>调大服务器所支持的最大文件句柄数 （File Descriptor, 简写为 fd） 。</p><ul><li>说明: 主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理, 即一个连接对应于一个 fd 。<ul><li>主流的 linux 服务器默认所支持最大 fd 数量为 1024, 当并发连接数很大时很容易因为 fd 不足而出现“ open too many files ”错误, 导致新的连接无法建立。 </li><li>建议将 linux服务器所支持的最大句柄数调高数倍 （与服务器的内存数值相关）</li></ul></li></ul></li><li><p>给 JVM 设置 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 参数, 让 JVM 碰到 OOM 场景时输出dump 信息。</p><ul><li>OOM 的发生是有概率的, 甚至有规律地相隔数月才出现一例, 出现时的现场信息对查错非常有价值。</li></ul></li><li><p>在线上生产环境, JVM 的 Xms 和 Xmx 设置一样的内存容量, 避免在GC后调整堆大小带来的压力</p></li><li><p>服务器内部重定向使用 forward;  外部重定向地址使用 URL 拼装工具类来生成, 否则会带来 URL 维护不一致的问题和潜在的安全风险。</p></li></ol><h1 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h1><ol><li><p>POJO (Plain Ordinary Java Object): 在手册中, POJO专指只有 setter/getter/toString 的简单类, 包括 DO/DTO/BO/VO等.</p></li><li><p>GAV (GroupId, AritifactId, Version): Maven 坐标, 是用来唯一标识 jar 包.</p></li><li><p>OOP(Object Oriented Programming): 泛指类,对象的编程处理方式</p></li><li><p>ORM(Object Relation Mapping): 对象关系映射, 对象领域模型与底层数据之间的转换, 本文泛指 iBATIS Mybatis 等框架</p></li><li><p>NPE(java.lang.NullPointerException): 空指针异常</p></li><li><p>SOA(Service-Oriented Architecture): 面向服务架构, 它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署, 组合和使用, 有利于提升组件可重用性, 可维护性.</p></li><li><p>一方库: 本工程内部子项目模块依赖的库 jar包</p></li><li>二方库: 公司内部发布到中央仓库, 可供公司内部其他应用依赖的库 jar包</li><li>三方库: 公司之外的开源库 jar包</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#阿里巴巴java开发手册&quot;&gt;阿里巴巴Java开发手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#编程规约&quot;&gt;编程规约&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#命名规约&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java并发</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Java-AdvancedLearning-Concurrents/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Java-AdvancedLearning-Concurrents/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#java并发">Java并发</a><ol><li><a href="#java内存模型">Java内存模型</a></li><li><a href="#理论知识">【理论知识】</a><ol><li><a href="#可能的问题">可能的问题</a></li><li><a href="#好的习惯">好的习惯</a></li></ol></li><li><a href="#块结构并发-java5之前">【块结构并发】 Java5之前</a><ol><li><a href="#synchronized">synchronized</a><ol><li><a href="#正确使用锁">正确使用锁</a></li></ol></li><li><a href="#volatile">volatile</a><ol><li><a href="#正确使用">正确使用</a></li></ol></li></ol></li><li><a href="#现代并发juc">【现代并发】JUC</a><ol><li><a href="#概念">概念</a><ol><li><a href="#cas指令">CAS指令</a></li><li><a href="#原子类">原子类</a></li><li><a href="#读写锁">读写锁</a></li></ol></li><li><a href="#具体实现">具体实现</a><ol><li><a href="#线程锁">线程锁</a></li><li><a href="#countdownlatch-锁存器">CountDownLatch 锁存器</a></li><li><a href="#concurrenthashmap">ConcurrentHashMap</a></li><li><a href="#copyonwritearraylist">CopyOnWriteArrayList</a></li></ol></li></ol></li><li><a href="#queue">Queue</a><ol><li><a href="#blockingqueue">BlockingQueue</a></li><li><a href="#transferqueue">TransferQueue</a></li></ol></li><li><a href="#控制执行">【控制执行】</a><ol><li><a href="#任务建模">任务建模</a><ol><li><a href="#schedulethreadpoolexecutor">ScheduleThreadPoolExecutor</a></li></ol></li></ol></li><li><a href="#分支合并框架">【分支合并框架】</a></li><li><a href="#java内存模型">【Java内存模型】</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><blockquote><p><a href="https://github.com/Kuangcp/JavaBase/tree/master/src/main/java/com/concurrents" target="_blank" rel="noopener">个人相关代码</a><br>主要知识来源 Java程序员修炼之道  | <a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网</a><br>该模块最早在1.5引入,由<a href="http://g.oswego.edu/" target="_blank" rel="noopener">Doug Lea</a>开发 |  <a href="http://ifeve.com/doug-lea/" target="_blank" rel="noopener">doug lea博客中文版</a></p></blockquote><blockquote><p><a href="http://www.jdon.com/concurrency.html" target="_blank" rel="noopener">参考博客: 并发编程 </a><br><a href="http://www.jdon.com/concurrent/immutable.html" target="_blank" rel="noopener">参考博客: 不可变真的意味线程安全？</a></p></blockquote><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h2 id="【理论知识】"><a href="#【理论知识】" class="headerlink" title="【理论知识】"></a>【理论知识】</h2><p><code>线程模型</code></p><ul><li>共享的，默认可见的可变状态</li><li>抢占式线程调度</li></ul><p><code>concurrent包的设计理念</code></p><ul><li>安全性 （并发类型安全性）<ul><li>并发类型安全：不管发生多少操作都能保证对象保持自相一致。一般采用的是将所有属性私有化</li></ul></li><li>活跃度<ul><li>在一个活跃的系统中，所有做出尝试的活动最终或者取得进展，或者失败</li><li>可能出现瞬时故障的情况：<ul><li>处于锁定状态，或者在等待得到线程锁</li><li>等待输入</li><li>资源的暂时故障</li><li>CPU没有足够的空闲时间运行该线程 </li></ul></li><li>永久故障的常见原因：<ul><li>死锁</li><li>不可恢复的资源问题（例如 NFS不可访问）</li><li>信号丢失</li></ul></li></ul></li><li>性能<ul><li>测量系统用给定的资源能做多少工作</li></ul></li><li>可重用性</li></ul><h3 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h3><ul><li>安全性与活跃度相对立，安全性求稳定安全，活跃度是求进展</li><li>可重用的系统倾向于对外开放内核，这会引发安全问题</li><li>一个安全但是编写幼稚的系统性能通常不会好，因为里面会用大量的锁来保证安全</li></ul><h3 id="好的习惯"><a href="#好的习惯" class="headerlink" title="好的习惯"></a>好的习惯</h3><ol><li>尽可能限制子系统之间的通信，隐藏数据对安全性非常有帮助</li><li>尽可能保证子系统内部结构的确定性，<ul><li>比如：即便子系统会以并发的，非确定性的方式进行交互，子系统内部的设计也应该按照线程和对象的静态知识</li></ul></li><li>采用客户端应用必须遵守的规则。<ul><li>这个技巧虽然强大，但是依赖于用户应用程序的合作程度，如果某个糟糕的应用不遵守规则，排查问题很困难</li></ul></li><li>在文档中记录所要求的行为，这是最逊的方法，但如果代码要部署在非常通用的环境下，就必须采用这个方法</li></ol><hr><ul><li>系统开销之源<ul><li>锁与监测</li><li>环境切换的次数</li><li>线程的个数</li><li>调度</li><li>内存的局部性</li><li>算法设计</li></ul></li></ul><h2 id="【块结构并发】-Java5之前"><a href="#【块结构并发】-Java5之前" class="headerlink" title="【块结构并发】 Java5之前"></a>【块结构并发】 Java5之前</h2><ul><li>同步和锁 synchronized：<ul><li>只能锁定对象，不能锁定原始类型</li><li>锁的范围要尽可能的小</li><li>被锁定的兑现给数组中的单个对象不会被锁定</li><li>同步方法可以视为包含整个方法的同步 <code>(this){...}</code>代码块 但是两者的二进制码的表示是不同的</li><li>静态方法会锁定其Class对象，因为没有实例对象可以锁定</li><li>如果要锁定一个对象，请慎重考虑使用显式锁定，还是getClass()， 两种方式对子类影响不同</li><li>内部类的同步是独立于外部类的</li><li>synchronized 并不是方法签名的组成部分，所以不能出现在接口的方法声明中</li><li>非同步的方法不查看或关心任何锁的状态，而且在同步方法运行时，他们仍能继续运行</li><li>Java的线程锁是可重入的。也就是说持有线程锁的线程在遇到同一个锁的同步点 时是可以继续的<ul><li>比如 一个同步方法调用另一个类的另一个同步方法</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Java/concurrent/Model.jpg" alt="线程状态模型">  </p><ul><li><p>线程的状态模型：</p><ul><li>线程创建时处于准备（Ready）状态，然后调度器会准备执行</li></ul></li><li><p>完全同步对象 策略 一个满足下面所有条件的类就是完全同步类：</p><ul><li>所有域在任何公共构造方法中的初始化都能达到一致的状态</li><li>没有公共域</li><li>从任何非私有方法返回后，都可以保证对象实例处于一致的状态  假定调用方法时状态是一致的</li><li>所有方法经证明都可在有限时间内终止</li><li>所有方法都是同步的</li><li>当处于非一致的状态时，不会调用其他实例的方法，以及调用非私有方法</li></ul></li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul><li>在synchronized代码块执行完成后，对锁定对象所做的所有修改全部会在线程释放锁之前同步到内存中<ul><li>保证了在同一时刻,只有一个线程可以执行某一个方法或者代码块.</li><li>所以这个关键字的作用就是同步 在不同线程中锁定（操作）的对象的内存块<ul><li>同步的作用不仅仅是互斥,另一个作用就是共享可变性, 当某个线程修改了可变数据并释放锁,其他线程可以获取变量的最新值</li><li>如果没有正确的同步,这种修改对其他线程是不可见的</li></ul></li></ul></li></ul><blockquote><ol><li>如果锁定的是类的成员属性,或者this, 就是对该对象进行了加锁变成了’单线程’, 就影响了整体性能</li><li>使用局部变量就会多线程且保证了数据的一致性</li><li>切记不能锁常量（或者显式声明的String）从而引起死锁</li></ol></blockquote><h4 id="正确使用锁"><a href="#正确使用锁" class="headerlink" title="正确使用锁"></a>正确使用锁</h4><blockquote><p>查看JDK源码 ForkJoinTask 的 externalAwaitDone 方法</p></blockquote><ul><li><p>1.wait方法用来使线程等待某个条件, 他必须在同步块内部被调用,这个同步块通常会锁定当前对象实例.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个模块的标准使用方式</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(condition)&#123;</span><br><span class="line">        Object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2.始终使用wait循环来调用wait方法, 永远不要在循环之外调用wait方法</p><ul><li>因为有时候, 即使并不满足被唤醒条件,但是由于其他线程调用notifyAll()方法会导致被阻塞的线程意外唤醒,从而导致不可预料的结果</li></ul></li><li>3.唤醒线程,保守的做法是使用notifyAll唤醒所有等待的线程,从优化的角度看,如果处于等待的所有线程都在等待同一个条件,而每次只有一个线程可以从这个条件中被唤醒, 那么就应该选择调用notify<blockquote><p>当多个线程共享一个变量的时候,每个读写都必须加锁进行同步, 如果没有正确的同步,就容易造成程序的活性失败和安全性失败,这样的失败是很难复现的.所以务必要保证锁的正确使用</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个就是个错误使用的案例</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">current</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个案例保证了多线程下并发时,对size变量的正确修改,但是不能保证实时读取到的变量值是正确的<br>正确的做法是 current 方法也要加上synchronized关键字</p></blockquote><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><blockquote><p><a href="https://segmentfault.com/q/1010000006733274" target="_blank" rel="noopener">Java多线程i++线程安全问题，volatile和AtomicInteger解释？</a></p></blockquote><ul><li>线程所读的值在使用之前总会从内存中读出来</li><li>线程所写的值总会在指令完成之前同步回内存中<ul><li>可以把围绕该域的操作看成成是一个小的同步块</li><li>volatile 变量不会引入线程锁，所以不可能发生死锁</li><li style="list-style: none"><input type="checkbox"> TODO 矛盾</li><li>volatile 变量是真正线程安全的，但只有写入时不依赖当前状态（读取的状态）的变量才应该声明为volatile变量</li></ul></li></ul><h4 id="正确使用"><a href="#正确使用" class="headerlink" title="正确使用"></a>正确使用</h4><blockquote><p>打开Netty中NioEventLoop的源码 有一个属性 <code>private volatile int ioRatio = 50;</code> 该变量是用于控制IO操作和其他任务运行比例的</p><ul><li>volatile是Java提供的最轻量级的同步机制,Java内存模型为volatile专门定义了一些特殊的访问规则:<ul><li>当一个变量被volatile修饰后:<ul><li>线程可见性: 当一个线程修改了被volatile修饰的变量后,无论是否加锁,其他线程都能立即看到最新的修改</li><li>禁止指令重排序优化, 普通的变量仅仅保证在该方法的执行过程中, 所有依赖赋值结果的地方都能获取正确的结果<ul><li>而不能保证变量赋值操作的顺序和程序代码的执行顺序一致<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResortJavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stop;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]s)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread workThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"i"</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        workThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></blockquote><blockquote><p>我们预期程序会在3s后停止, 但是实际上它会一直执行下去, 原因就是虚拟机对代码进行了指令重排序和优化, 优化后的指令如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!stop)</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>所以需要在stop前加上volatile修饰符, 解决了如下两个问题</p><blockquote><ol><li>main线程对stop的修改在workThread中可见</li><li>禁止指令重排序, 防止因为重排序导致的并发访问逻辑混乱</li></ol></blockquote></blockquote><ul><li>以上示例代码在Java8中是正常运行的, 并不会一直执行下去, 所以还需要找个别的Demo过来</li></ul><blockquote><p>一些人认为volatile可以替代传统锁,提升并发性能, 这个认识是错误的. volatile仅仅解决了可见性的问题, 并不能保证互斥性</p><blockquote><p>volatile最适合使用的是一个线程写, 其他线程读的场景.<br>如果有多个线程并发<code>写</code>操作,仍然需要使用<code>锁</code>或者<code>线程安全的容器</code>或者<code>原子变量</code>来代替</p></blockquote></blockquote><hr><ul><li>不可变性：<ul><li>这些对象或者没有状态（属性）或者只有final域。因为他们的状态不可变，所以是安全而又活泼，不会出现不一致的情况</li><li>初始化就会遇上问题，如果是需要初始化很多属性，可以采用工厂模式，但是构建器模式更好。<ul><li>一个是实现了构建器泛型接口的内部静态类，另一个是构建不可变类实例的私有构造方法 </li><li><a href="./src/main/java/com/concurrents/old/BuildFactory.java">思想实现代码</a></li></ul></li><li>不可变对象中的final域特别要注意：<ul><li>final声明的对象的引用是不可变的， 但是如果引用的是对象，该对象自身的属性的引用是可变的</li></ul></li><li>不可变对象的使用十分广泛，但是开发效率不行，每修改对象的状态都要构建一个新对象</li></ul></li></ul><h2 id="【现代并发】JUC"><a href="#【现代并发】JUC" class="headerlink" title="【现代并发】JUC"></a>【现代并发】JUC</h2><blockquote><p>简称为J.U.C (java.util.concurrent) | <a href="http://ifeve.com/aqs/" target="_blank" rel="noopener">The j.u.c Synchronizer Framework中文翻译版</a></p><ul><li>建议通过使用<code>线程池</code>,<code>Task(Runnable/Callable)</code>,<code>读写锁</code>,<code>原子类</code>和<code>线程安全容器</code>来代替传统的同步锁,wait和notify<ul><li>提升并发访问的性能, 降低多线程编程的难度, Netty就是这么做的</li></ul></li></ul></blockquote><blockquote><p>线程安全容器底层使用了CAS,volatile,和ReadWriteLock实现</p></blockquote><ul><li>ReentrantLock 和 sync 加解锁机制的区别?  <ul><li>一个作用于线程一个作用于临界变量</li></ul></li><li>不要依赖线程优先级<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="CAS指令"><a href="#CAS指令" class="headerlink" title="CAS指令"></a>CAS指令</h4><blockquote><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能额外损耗, 因此这种同步也被称为阻塞同步,悲观锁</p><blockquote><p>与之对应的乐观锁是, 先进行操作, 操作完成之后再判断操作是否成功, 是否有并发问题, 如果有则进行失败补偿, 如果没有就算操作成功. </p></blockquote></blockquote></li></ul><blockquote><p>Java中的非阻塞同步就是CAS 1.5就有了</p></blockquote><h4 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h4><blockquote><p><code>java.util.concurrent.atomic</code> 提供适当的原子方法 避免在共享数据上出现竞争危害的方法<br>使用Java自带的原子类, 可以避免同步锁带来的并发访问性能降低的问题, 减少犯错的机会. 对于 int, long, boolean 等成员变量大量使用原子类</p><blockquote><p>但是使用者必须通过类似 compareAndSet或者set或者与这些操作等价的<code>原子操作</code>来保证更新的原子性.</p></blockquote></blockquote><ul><li>常见的操作系统的支持， 他们是非阻塞的（无需线程锁）， 常见的方法是实现序列号机制（和数据库里的序列号机制类似），在<code>AtomicInteger</code>或<code>AtomicLong</code>上用原子<ul><li>操作<code>getAndIncrement()</code>方法， 并且提供了nextId 方法得到唯一的完全增长的数值</li></ul></li><li>注意： 原子类不是相似的类继承而来，所以 AtomicBoolean不能当Boolean用</li></ul><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><blockquote><p>在读多写少的场景下, 使用同步锁比同步块性能要好</p></blockquote><ul><li>读锁 ReentranReadWriteLock 是共享锁</li></ul><hr><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><blockquote><p><code>java.util.concurrent.locks</code></p><ul><li>块结构同步方式基于锁这样的的概念，具有缺点<ul><li>锁只有一种类型</li><li>对被锁住的对象的所有同步操作都是一样的作用</li><li>在同步代码块或方法开始时取得线程锁</li><li>在同步代码块或方法结束时释放线程锁</li><li>线程或者得到锁，或者阻塞，没有其他可能</li></ul></li></ul></blockquote><ul><li>如果要重构对线程锁的支持， 事实上该包下Lock接口也都实现了：<ul><li>添加不同类型的锁，例如 读取锁和写入锁</li><li>对锁的阻塞没有限制，允许在一个方法中加锁，另一个方法中解锁</li><li>如果线程得不到锁（例如已经被线程加锁），就允许该线程后退或者继续执行，或者做别的事情 tryLock()</li><li>允许线程尝试锁，并可以在超过时间后放弃</li><li>Lock接口的实现类：ReentrantLock 本质上和用在同步块上的锁是一样的，但是稍微灵活些<ul><li><code>lock()</code>: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html#lock--" target="_blank" rel="noopener">官方API1.8 lock</a></li><li>如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。</li><li>如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。</li><li>如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1。</li><li><code>trylock()</code>: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html#tryLock--" target="_blank" rel="noopener">官方API1.8 trylock</a></li></ul></li><li>Lock接口的实现类：ReentrantWriteLock 在需要读取很多线程而写入很少线程时，用这个性能更好</li></ul></li></ul><h4 id="CountDownLatch-锁存器"><a href="#CountDownLatch-锁存器" class="headerlink" title="CountDownLatch 锁存器"></a>CountDownLatch 锁存器</h4><ul><li><p>是一种简单的同步模式，这种模式允许线程在通过同步屏障之前做少量的准备工作</p><ul><li>构建实例时，需要提供一个数值（计数器），通过两个方法来实现这个机制</li><li><p><code>countDown()</code> 作用：计数器减一</p><ul><li>如果当前计数大于零，则将计数减少。然后什么都不做<ul><li>如果减后的计数为零，出于线程调度目的，将重新启用所有的等待线程 </li></ul></li><li>如果当前计数等于零，则不发生任何操作。</li></ul></li><li><p><code>await()</code> 作用：让线程在计数器到0之前一直等待，</p><ul><li>如果大于 0 ， 休眠这语句所处的当前线程 <ul><li>例如 <code>a.await()</code> 如果锁存器a的Count不为0 ，就把当前线程休眠掉</li></ul></li><li>如果已经是小于等于0 就什么都不做</li></ul></li></ul></li><li><p>能做到： 当一堆线程之间的同步，为了确保有指定数量正常初始化的线程 创建成功，才能开始同步 </p></li></ul><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ul><li><code>ConcurrentHashMap</code> 是 HashMap的并发版本</li><li>修改HashMap，并不需要将整个结构都锁住，只要锁住即将修改的桶（就是单个元素）<ul><li>好的HashMap 实现，在读取时不需要锁，写入时只要锁住要修改的单个桶 Java能达到这个标准，但是需要程序员去操作底层的细节才能实现</li></ul></li><li><code>ConcurrentHashMap</code>类 还实现了ConcurrentMap接口，有些提供了还提供了原子操作的新方法<ul><li><code>putIfAbsent()</code> 如果还没有对应键，就把键/值添加进去</li><li><code>remove()</code> 如果键存在而且值与当前状态相等，则用原子方式移除键值对</li><li><code>replace()</code> API 为HashMap中原子替换的操作方法提供了两种不同的形式</li></ul></li><li>例如之前的完全同步类里的公共 Map实现就是HashMap，如果换成ConcurrentHashMap 那些synchronized关键字修饰的方法就可以换成普通方法了</li><li>该类不仅提供了多线程的安全性，性能也很好</li></ul><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><ul><li><p>标准的ArrayList的替代，通过写时复制语义来实现线程安全性，也就是说修改列表的任何操作都会创建一个列表底层数组的新副本</p><ul><li>这就意味着所有成形的迭代器都不会遇到意料之外的修改 （脏读）</li></ul></li><li><p>这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效。在不能或不想进行同步遍历</p><ul><li>当读操作大于写操作会比较好用，</li></ul></li><li>但又需要从并发线程中排除冲突时，它也很有用。“快照”风格的迭代器方法在创建迭代器时使用了对数组状态的引用。此数组在迭代器的生存期内不会更改，</li><li>因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。</li><li>在迭代器上进行的元素更改操作（remove、set 和 add）不受支持。这些方法将抛出 UnsupportedOperationException。</li></ul><hr><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><blockquote><p>Queue接口全是泛型的，这样就更为方便， 自己再封装一个层</p></blockquote><p><code>BlockingQueue&lt;Pro&lt;Author&gt;&gt;</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pro</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T pro;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getPro</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pro;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pro</span><span class="params">(T pro)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pro = pro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>有了这层间接引用， 不用牺牲所包含类型（Author）在概念上的完整性，就能够添加额外的元数据了。方便统一性的修改<ul><li>用上额外元数据的用例：</li><li>测试： 比如 展示一个对象的修改历史</li><li>性能指标： 比如 到达时间，服务质量</li><li>运行时系统信息： 比如 Author实例是如何排到队列的</li></ul></li></ul><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><blockquote><p>并发扩展类， </p></blockquote><ul><li>基本方法<ul><li>put() 如果队列已满，会让放入的线程等待 队列腾出空间</li><li>take() 如果队列为空，会导致取出的线程阻塞</li><li>offer() 将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。<ul><li>当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。</li><li>另一个重载方法：将指定元素插入此队列中，在到达指定的等待时间前等待可用的空间（如果有必要）。</li></ul></li><li>poll() 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。</li></ul></li><li>基本实现<ul><li>LinkedBlockingQueue 看名字就知道实现方式以及优缺点了</li><li>ArrayBlockingQueue</li></ul></li><li>BlockingQueue 不接受 null 元素。试图 add、put 或 offer 一个 null 元素时，某些实现会抛出 NullPointerException。</li><li>BlockingQueue 的实现主要用于生产者-使用者队列</li></ul><h3 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h3><ul><li>本质上是多了一项 transfer()操作的BlockingQueue， 如果接收线程处于等待状态， 该操作会马上把工作项传给他。</li><li>否则就会阻塞直到取走工作项的线程出现 即 正在处理工作项的线程在交付当前工作项之前不会开始其他工作项的处理工作，</li><li>这样系统就可以调控上游线程获取新工作项的速度 用限定大小的阻塞队列也能达到同样的效果，TransferQueue 执行效率更高<ul><li>但是这个只有链表的实现版本</li><li>相比于BlockingQueue 用法一致， offer() 等价于 tryTransfer() 参数也是一致的，代码基本不需要改动</li></ul></li></ul><hr><h2 id="【控制执行】"><a href="#【控制执行】" class="headerlink" title="【控制执行】"></a>【控制执行】</h2><h3 id="任务建模"><a href="#任务建模" class="headerlink" title="任务建模"></a>任务建模</h3><blockquote><p>要把目标代码做成可调用（执行者调用）的结构，而不是单独开线程运行<br><a href="./src/main/java/com/concurrents/schedule/CreateModel.groovy">展示代码</a></p></blockquote><p><code>Callable接口</code></p><ul><li>通常是匿名内部实现类 </li></ul><p><code>Future接口</code></p><ul><li>用来表示异步任务，是还没有完成的任务的未来结果，主要方法：<ul><li>get() 用来获取结果，如果结果还没准备好就会阻塞直到它能去到结果，有一个可以设置超时的版本，这个版本永远不会阻塞</li><li>cancel() 运算结束前取消</li><li>isDone() 调用者用它来判断运算是否结束</li></ul></li></ul><p><code>FutureTask类</code></p><ul><li>FutureTask是Future接口的常用实现类， 并且是实现了Runnable接口。所以提供的方法是俩接口的方法<ul><li>提供了两个构造器，一个是Callable为参数，另一个以Runnable为参数</li></ul></li><li>可以基于FutureTask的Runnable特性，把任务写成Callable然后封装进一个有执行者地调度并在必要时可以取消的FutureTask</li></ul><h4 id="ScheduleThreadPoolExecutor"><a href="#ScheduleThreadPoolExecutor" class="headerlink" title="ScheduleThreadPoolExecutor"></a>ScheduleThreadPoolExecutor</h4><blockquote><p>ScheduleThreadPoolExecutor  简称 STPE 线程池类中很重要的类</p></blockquote><ul><li>线程池的大小可以预定义， 也可自适应</li><li>所安排的任务可以定期执行，也可只运行一次</li><li>STPE扩展了ThreadPoolExecutor类，很相似但不具备定期调度能力<ul><li>STPE和并发包里的类结合使用是常见的模式之一</li></ul></li></ul><hr><h2 id="【分支合并框架】"><a href="#【分支合并框架】" class="headerlink" title="【分支合并框架】"></a>【分支合并框架】</h2><ul><li>引入一种新的执行者服务，称为 ForkJoinPool</li><li>ForkJoinPool 服务处理一种比线程更小的并发单元 ForkJoinTask<ul><li>ForkJoinTask是一种由ForkJoinPool以更轻量的方式所调度的抽象</li></ul></li><li>通常使用两种任务<ul><li>小型 无需处理器耗时太久的任务</li><li>大型 需要在直接执行前进行分解（可能多次）的任务</li></ul></li><li><p>提供了支持大型任务分解的基本方法，还有自动调度和重新调度的能力</p></li><li><p>这个框架的关键特性之一就是：这些轻量的任务都能够生成新的ForkJoinTask实例，而这些实例仍然由执行他们父任务的线程池来安排调度，这就是分而治之</p></li><li>工作窃取：</li><li><p><a href="./src/main/java/com/concurrents/forkjoin/ForkJoinEasyDemo.groovy">一个简单的例子</a></p></li><li><p>由 RecursiveAction 或者 RecursiveTask 派生出来的才能作为任务单元 这俩也是派生ForkJoinTask而来</p><ul><li>RecursiveAction 要重写的方法：<code>protected void compute()</code>  </li><li>RecursiveTask 要重写的的方法：<code>protected Object compute()</code></li></ul></li><li>ForkJoinTask里的 invoke 和 invokeAll <ul><li><code>public final V invoke()</code></li><li>invoke  执行此任务的开始，如果有必要，等待它的完成，并返回其结果，或者在底层计算完成时抛出一个(未检查的)RuntimeException或错误。</li><li><code>public static &lt;T extends ForkJoinTask&lt;?&gt;&gt; Collection&lt;T&gt; invokeAll(Collection&lt;T&gt; tasks)</code></li><li>invokeAll 方法的特点是多个执行，但是只有其中有一个是出现了异常，就会取消所有的task</li></ul></li></ul><p><code>ForkJoinTask和工作窃取</code></p><ul><li>ForkJoinTask作为RecursiveAction的超类，他是从动作中返回结果的泛型类型，所以这个类扩展了ForkJoinTask<void> <ul><li>这使得ForkJoinTask非常适合用MapReduce方式（Google踢出的软件架构，用于大规模数据集的并行计算）返回数据集中归结出的结果</li></ul></void></li><li>ForkJoinTask由ForkJoinPool调度安排，这个池是一个特殊的执行者服务。这个服务维护每个线程的任务列表，并且当某个任务完成的时候，<ul><li>他能把挂在满负荷线程上的任务重新安排到空闲线程上去 这就是 <code>工作窃取</code></li></ul></li></ul><p><code>并行问题</code></p><ul><li>可以使用分支合并方法解决的问题：<ul><li>模拟大量简单对象的运动，例如粒子效果</li><li>日志文件分析</li><li>从输入中计数的数据操作，比如mapreduce操作</li></ul></li><li>以下的列表检查当前问题及其子任务是一个切实有效的方法，确认是否能用分支合并来解决问题<ul><li>问题的子任务是否无需与其他子任务有显式的协作或同步也可以工作？</li><li>子任务是不是不会对数据进行修改，只是经过计算得出些结果？</li><li>对于子任务来说，分而治之是不是很自然的事？子任务是不是会创建更多的子任务，而且他们要比派生出他们的任务粒度更细？</li><li>如果思考的结果是肯定的，就可以适用，如果思考结果是不确定的，用其他的同步方式更合适</li></ul></li></ul><h2 id="【Java内存模型】"><a href="#【Java内存模型】" class="headerlink" title="【Java内存模型】"></a>【Java内存模型】</h2><blockquote><p>Java Memory Model – JMM</p></blockquote><ul><li>同步动作和被称为偏序的数据结构描述JMM， </li><li>JMM 的主要规则：<ul><li>在监测对象上的解锁操作与后续的所操作之间存在同步约束关系</li><li>对易失性变量的写入与后续对该变量的读取之间存在同步约束关系</li><li>如果动作A受到动作B的同步约束，则A在B之前发生</li><li>如果在程序中的线程内A出现B之前，则A在B之前发生</li><li>前两个简称为先存后取 </li></ul></li><li>敏感行为：<ul><li>构造方法要在那个对象的终结期之前完成（一个对象被终结之前必须已经构造完整）</li><li>开始一个线程的动作受到这个新线程的第一个动作的同步制约</li><li>Thread.join() 受到被合并的线程的最后一个动作的同步制约</li><li>如果X在Y之前发生，并且Y在Z之前发生， 则X在Z之前发生（传递性）</li></ul></li><li><p>重要概念： <code>如果对象不可改变，确保改变对所有线程可见的相关问题就不会出现</code></p></li><li><p>代码块之间的 <code>之前发生（Happens-Before）</code> 和 <code>同步约束（Synchronizes-With）</code>关系</p><ul><li>之前发生 这种关系表明一段代码在其他代码开始之前就已经全部完成了</li><li>同步约束 这意味着动作继续执行之前必须把他的对象视图与主内存同步</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#java并发&quot;&gt;Java并发&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#java内存模型&quot;&gt;Java内存模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#理论知识&quot;&gt;【理论
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Concurrent" scheme="http://blog.kuangcp.top/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Java.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Blog-Java/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Blog-Java/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#java">Java</a><ol><li><a href="#社区">社区</a></li><li><a href="#se">SE</a></li><li><a href="#javafx">JavaFx</a></li><li><a href="#爬虫">爬虫</a></li><li><a href="#springboot">Springboot</a></li><li><a href="#buildtool">BuildTool</a></li><li><a href="#test">Test</a></li><li><a href="#精彩系列">精彩系列</a><ol><li><a href="#码农翻身">码农翻身</a></li><li><a href="#架构师">架构师</a></li></ol></li><li><a href="#java语言讨论">Java语言讨论</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><blockquote><p>和Java有关的博客和网页  </p></blockquote><h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><ul><li><a href="http://ifeve.com/category/java/" target="_blank" rel="noopener">并发编程网 Java</a></li><li><a href="http://www.infoq.com/cn/java" target="_blank" rel="noopener">InfoQ Java</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/" target="_blank" rel="noopener">IBM Java</a></li></ul><h2 id="SE"><a href="#SE" class="headerlink" title="SE"></a>SE</h2><ul><li><a href="http://blog.csdn.net/zzp16/article/details/5614588" target="_blank" rel="noopener"> 菜鸟入门：Java程序员学习之路 </a></li><li><a href="http://www.infoq.com/cn/articles/eclipse-collections?utm_campaign=rightbar_v2&amp;utm_source=infoq&amp;utm_medium=articles_link&amp;utm_content=link_text" target="_blank" rel="noopener">Eclipse Collections以及Java8的特性</a></li><li><a href="http://www.jb51.net/article/48304.htm" target="_blank" rel="noopener">Java8的特性</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">正确使用Volatile变量</a></li><li><a href="http://www.cnblogs.com/felix-/p/4310229.html" target="_blank" rel="noopener">javadoc 和 javadoc注释规范</a></li><li><p><a href="http://www.codeceo.com/article/java-resource-collection.html" target="_blank" rel="noopener">推荐！国外程序员整理的Java资源大全</a></p></li><li><p><a href="https://blogs.oracle.com/java/java-magazine-design-pattern" target="_blank" rel="noopener">oracle magazine</a></p></li></ul><hr><ul><li><a href="http://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">Java动态代理机制详解</a> <code>博客很细致，深入原理</code></li><li><a href="http://blog.csdn.net/chjttony/article/details/17838693" target="_blank" rel="noopener">使用JMockit编写java单元测试</a></li><li><a href="http://www.trinea.cn/android/java-android-thread-pool/" target="_blank" rel="noopener">Java(Android)线程池</a></li><li><a href="http://blog.liuker.cn/index.php/docker/31.html" target="_blank" rel="noopener">Docker图形化管理</a></li></ul><h2 id="JavaFx"><a href="#JavaFx" class="headerlink" title="JavaFx"></a>JavaFx</h2><ul><li><a href="https://gitee.com/xwintop/xJavaFxTool" target="_blank" rel="noopener">xJavaFxTool</a><code>基于JavaFX的工具集</code></li></ul><h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><ul><li><a href="https://juejin.im/post/5a804b2cf265da4e9c63265b" target="_blank" rel="noopener">Java网络爬虫实操</a> <code>比较全面的讲述了如何使用Java写爬虫</code></li></ul><hr><h2 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h2><ul><li><a href="http://www.cnblogs.com/page12/p/7899380.html" target="_blank" rel="noopener">Springboot入门系列博客</a></li><li><a href="https://segmentfault.com/a/1190000004315890" target="_blank" rel="noopener">Springboot配置详解</a></li><li><a href="https://coderknock.com/blog/2017/03/01/spring%20boot%E5%90%AF%E5%8A%A8dubbo.html" target="_blank" rel="noopener">Springboot启动dubbo</a><code>等一系列文章</code></li><li><a href="http://blog.csdn.net/melody_susan/article/details/78659696" target="_blank" rel="noopener">spring boot完美集成dwr3.0.2</a></li><li><a href="https://www.tianmaying.com/tutorial/spring-boot-overview" target="_blank" rel="noopener">Spring Boot——开发新一代Spring Java应用</a></li></ul><h2 id="BuildTool"><a href="#BuildTool" class="headerlink" title="BuildTool"></a>BuildTool</h2><ul><li><a href="http://blog.javachen.com/2015/01/07/build-multi-module-project-with-gradle.html" target="_blank" rel="noopener">Gradle构建多模块项目</a></li><li><a href="http://blog.csdn.net/willwcw/article/details/46517331" target="_blank" rel="noopener">tig</a></li><li><a href="http://www.jianshu.com/p/0dac3ae2a2c9" target="_blank" rel="noopener">gradle构建Springboot的镜像</a></li></ul><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-junit-ext/" target="_blank" rel="noopener">扩展 JUnit 测试并行程序</a></li><li><p><a href="https://testerhome.com/topics/2502" target="_blank" rel="noopener">自动化测试工具 JUnit4 多线程执行测试用例</a></p></li><li><p><a href="https://www.zhihu.com/question/40564744" target="_blank" rel="noopener">腾讯的点击验证码是什么原理?</a></p></li></ul><hr><h2 id="精彩系列"><a href="#精彩系列" class="headerlink" title="精彩系列"></a>精彩系列</h2><h3 id="码农翻身"><a href="#码农翻身" class="headerlink" title="码农翻身"></a>码农翻身</h3><ul><li><p><a href="http://chuansong.me/n/1501046251110" target="_blank" rel="noopener">2017精华</a> | <a href="http://blog.csdn.net/fanpeihua123/article/details/58151161" target="_blank" rel="noopener">精华文章</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514184&amp;idx=1&amp;sn=3ace64c3a9eba2adf1ef94406e2ebf2b&amp;chksm=80d67c8bb7a1f59d556bd7478626a4674ff07021726f84b4681b41ad7c6dbb4cfcf687dcf00a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">2017码农翻身文章</a></p></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513504&amp;idx=1&amp;sn=25dd6420e3056101dd3f6fdaedacaa2a&amp;chksm=80d67a63b7a1f37572a5159ff6f53810467c15c8beec94770e8360c45f45036360d77755ee78&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">2016码农翻身文章</a></li></ul><hr><ul><li><a href="https://segmentfault.com/q/1010000004701437" target="_blank" rel="noopener">当你想学别的语言的时候看这里</a><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513899&amp;idx=1&amp;sn=3cc7e1721c3533e0f83bea906b8e1be5&amp;chksm=80d67be8b7a1f2fe9da014603f0b94e231773a38151d7160c5d210e17de41f67ffe55e03f422&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">上天还是入地</a><blockquote><p>往深度挖掘，可以成为某个技术领域的专家，如搜索方面的专家、安全方面的专家，分布式文件的专家等等，不管是哪个领域，重点都不是学会使用某个工具和框架， 而是保证你可以自己的知识和技术去搞定这个领域的顶尖问题。<br>往广度发展，各个技术领域都要了解，对于某种需求，能够选取合适的软件和技术架构来实现它，把需求转化成合适的技术组件，让这些组件以合适的方式连接、部署、运行，这也需要持续地学习和不断的经验积累。</p></blockquote></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Image/fun/640.webp" alt="前后端" title="">                </div>                <div class="image-caption">前后端</div>            </figure><ul><li><a href="http://blog.csdn.net/tanxinwhu/article/details/6969086" target="_blank" rel="noopener">JDK各个版本发布时间</a></li></ul><h3 id="架构师"><a href="#架构师" class="headerlink" title="架构师"></a>架构师</h3><ul><li><a href="http://www.10tiao.com/html/194/201801/2651479837/1.html" target="_blank" rel="noopener">通向架构师的道路(比较老)</a></li></ul><h2 id="Java语言讨论"><a href="#Java语言讨论" class="headerlink" title="Java语言讨论"></a>Java语言讨论</h2><blockquote><p><a href="http://swiftlet.net/archives/2530" target="_blank" rel="noopener">冷眼看Java</a><br><a href="http://www.techug.com/post/java-python.html" target="_blank" rel="noopener">参考博客: 王垠：为Java说句公道话</a><br><a href="http://www.techug.com/post/comparing-rust-and-java.html" target="_blank" rel="noopener">参考博客: 比较 Rust 和 Java</a><br><a href="http://www.techug.com/post/kotlin-vs-java-the-whole-story.html" target="_blank" rel="noopener">参考博客: Kotlin与Java的主客观比较</a><br><a href="http://www.techug.com/post/10-java-tips.html" target="_blank" rel="noopener">参考博客: 10个实用的但偏执的Java编程技术</a><br><a href="http://www.techug.com/post/programming-philosophy.html" target="_blank" rel="noopener">参考博客: 王垠：编程的智慧</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#java&quot;&gt;Java&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#社区&quot;&gt;社区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#se&quot;&gt;SE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Server.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Blog-Server/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Blog-Server/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#server">Server</a><ol><li><a href="#终端">终端</a></li><li><a href="#内存优化">内存优化</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><blockquote><p>服务器运维相关</p></blockquote><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwNjEwNTQ4Mw==&amp;mid=2651580395&amp;idx=1&amp;sn=d311abab344aed97fe8b5244aa51e08d&amp;chksm=8cd9f90fbbae7019fc5ee8fbe423c8027527f068bcb71ad3d7a18b85a503bc4ffd377dfb9b6d&amp;mpshare=1&amp;scene=1&amp;srcid=0110cegY48pxj9fMGcObeEMT&amp;pass_ticket=9AXPGsZExYCvgc64Pq%2Fge7rdAI7U%2F%2BG%2F5NrA4rv24OXW2BDRnIZzo5eMh%2F%2FanrNZ#rd" target="_blank" rel="noopener">效率为王：终端管理工具 Tmux </a></li></ul><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><blockquote><p><a href="http://www.cnblogs.com/dongzhiquan/p/5043912.html" target="_blank" rel="noopener">参考博客 大内存页配置实战</a> <code>内存占用大, 访问随机就需要使用大内存页了</code><br><a href="http://www.oracle.com/technetwork/cn/articles/servers-storage-dev/hugepages-2099009-zhs.html" target="_blank" rel="noopener">Oracle官网的使用案例</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#server&quot;&gt;Server&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#终端&quot;&gt;终端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#内存优化&quot;&gt;内存优化&lt;/a&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Solution.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Blog-Solution/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Blog-Solution/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#解决方案">解决方案</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><blockquote><p>关于问题的解决方案</p></blockquote><p><a href="http://www.cnblogs.com/x-xk/archive/2012/11/17/2770935.html" target="_blank" rel="noopener">站内信设计思路之己见（基于上百万用户）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#解决方案&quot;&gt;解决方案&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-13 12:06&lt;/em&gt;| &lt;a href=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>View.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Blog-View/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Blog-View/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#前端">前端</a><ol><li><a href="#基础">基础</a><ol><li><a href="#规范">规范</a></li></ol></li><li><a href="#css">CSS</a></li><li><a href="#相关库">相关库</a><ol><li><a href="#jquery">Jquery</a></li><li><a href="#bootstrap">Bootstrap</a></li><li><a href="#layui">LayUI</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><blockquote><p>半学半就 <a href="https://kuangcp.github.io/main.html" target="_blank" rel="noopener">个人导航页</a></p></blockquote><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><blockquote><p><a href="https://www.cnblogs.com/Smiled/p/8377188.html" target="_blank" rel="noopener">我所理解的前端</a><br><a href="http://blog.csdn.net/limlimlim/article/details/9088161" target="_blank" rel="noopener">Javascript字典操作</a><br><a href="https://segmentfault.com/a/1190000002447815" target="_blank" rel="noopener">js数据结构和算法（五）字典和散列（hash） </a></p></blockquote><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul><li><a href="https://juejin.im/post/592d4a5b0ce463006b43b6da" target="_blank" rel="noopener">前端开发命名规范</a></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><a href="http://www.html5tricks.com/9-nick-css3-menu-button.html" target="_blank" rel="noopener">酷炫按钮</a></li></ul><h2 id="相关库"><a href="#相关库" class="headerlink" title="相关库"></a>相关库</h2><h3 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h3><ul><li><a href="http://www.codeceo.com/article/10-jquery-image-player.html#0-tsina-1-78156-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="noopener">10个超赞的jQuery图片滑块动画</a></li></ul><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><h3 id="LayUI"><a href="#LayUI" class="headerlink" title="LayUI"></a>LayUI</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#前端&quot;&gt;前端&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#基础&quot;&gt;基础&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#规范&quot;&gt;规范&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Java-AdvancedLearning-Generics/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Java-AdvancedLearning-Generics/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#泛型">泛型</a><ol><li><a href="#入门">入门</a><ol><li><a href="#简单使用">简单使用</a><ol><li><a href="#类型擦除">类型擦除</a></li></ol></li><li><a href="#约束和局限性">约束和局限性</a></li><li><a href="#泛型类型的继承规则">泛型类型的继承规则</a></li><li><a href="#通配符类型">通配符类型</a><ol><li><a href="#子类型限定的通配符-extends">子类型限定的通配符 extends</a></li><li><a href="#超类型限定的通配符-super">超类型限定的通配符 super</a><ol><li><a href="#应用">应用</a></li></ol></li><li><a href="#无限定通配符">无限定通配符</a></li><li><a href="#通配符捕获">通配符捕获</a></li></ol></li><li><a href="#反射和泛型">反射和泛型</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514015&amp;idx=1&amp;sn=12409f705c6d266e4cd062e78ce50be0&amp;chksm=80d67c5cb7a1f54a68ed83580b63b4acded0df525bb046166db2c00623a6bba0de3c5ad71884&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">开始学习的兴趣来源</a></p></blockquote><p><a href="http://www.cnblogs.com/lwbqqyumidi/p/3837629.html" target="_blank" rel="noopener">参考博客: Java总结篇系列：Java泛型</a><br>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。<br>那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。<br><a href="http://www.infoq.com/cn/articles/cf-java-generics" target="_blank" rel="noopener">参考博客: Java深度历险（五）——Java泛型</a></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote><p>泛型程序设计划分为三个熟练级别 基本级别就是仅仅使用泛型类,典型的是像ArrayList这样的集合–不必考虑他们的工作方式和原因,大多数人会停留在这个级别.直到出现了什么问题. 当把不同的泛型类混合在一起的时候,或是对类型参数一无所知的遗留代码进行对接时,可能会看到含糊不清的错误消息.如果这样的话,就需要系统的进行学习Java泛型来系统地解决问题.<br>泛型类可以看作普通类的工厂  – Java核心技术卷 2004(1.5)  </p></blockquote><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><blockquote><ul><li><a href="https://github.com/Kuangcp/JavaBase/blob/master/src/main/java/com/generic/simple/Pair.java" target="_blank" rel="noopener">简单泛型类示例</a></li></ul></blockquote><p>例如该行定义 : <code>public abstract class RoomCache&lt;P extends PlayerBO, M extends MemberBO, V extends VideoDataBO&lt;M&gt;, R extends RoomBO&lt;M, V&gt;&gt; extends AbstractCache&lt;PlatformRoomId, R&gt; {}</code></p><ul><li>类型变量使用大写的一个字母这是代表:<ul><li><code>E</code> 集合的元素类型 </li><li><code>K V</code> 表示表的关键字和值的类型 </li><li><code>T U S</code> 等就表示任意类型</li><li></li></ul></li></ul><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><ul><li>不同于C++的泛型,C++是将模板类组合出来的生成一个新的类,Java则是进行类型擦除,然后再类型强转</li><li>例如 <code>public static &lt;T extends Comparable&gt; T min (T[] list)</code><ul><li>擦除后就只剩下一个方法 <code>public static Comparable min(Comparable[] list)</code></li></ul></li><li><p><a href="https://github.com/Kuangcp/JavaBase/blob/master/src/main/java/com/generic/simple/DateInterval.java" target="_blank" rel="noopener">泛型类擦除示例</a></p></li><li><p>例如该方法签名 <code>public static  &lt;T extends Comparable &amp; Serializable&gt; T getMax(T[]list)</code></p><ul><li>限制了必须是实现了两个接口的类才能使用, 估计为了少创关键字所以使用的是extends关键字来表示T要实现两个接口</li><li>同样的可以加在类的签名上,进行限制类的泛型类型 <code>public class Pair &lt;T extends Comparable&gt;{}</code></li></ul></li></ul><blockquote><p>在Java的继承中,可以根据需要拥有多个接口超类型,但限定中至多只有一个类,如果用一个类作为限定,他必须是限定列表中的第一个</p></blockquote><hr><h3 id="约束和局限性"><a href="#约束和局限性" class="headerlink" title="约束和局限性"></a>约束和局限性</h3><blockquote><p>以下代码示例:涉及的类Pair在上述的代码中已经定义, Human和Student是继承关系<br>并且因为看的 Java核心技术卷 比较老 jdk是1.5的所以没有用7的菱形语法简化泛型 7可以省去右边的类型: <code>Pair&lt;Double&gt; pair = new Pair&lt;&gt;();</code></p></blockquote><ul><li>| <em>不能使用基本类型实例化类型参数</em><ul><li>也就是说没有<code>Pair&lt;double&gt;</code>只有<code>Pair&lt;Double&gt;</code></li><li>因为类型擦除后,类型是Object并不能放double的值, 但是这样做与Java语言中基本类型的独立状态相一致.</li><li>当包装器类型(wrapper type)不能接受替换时,可以使用独立的类和方法处理他们  </li></ul></li><li>| <em>运行时类型查询(eq或者instanceof)只适用于原始类型</em><ul><li>比如<code>Pair&lt;T&gt;</code> 和<code>Pair&lt;String&gt;</code>是等价的,因为类型擦除</li><li><code>Pair&lt;String&gt; pair1</code> <code>Pair&lt;Date&gt; pair2</code> pair1.getClass()和pair2.getClass()是等价的都是返回Pair.class</li></ul></li><li>| <em>不能抛出也不能捕获泛型类实例</em><ul><li>错误的示例:<ul><li><code>public class Problem&lt;T&gt; extends Exception{}</code></li><li><code>public static &lt;T extends Throwable&gt; void doWork(){try{}catch(T t){}}</code></li></ul></li><li>正确示例:<ul><li>在异常声明中使用类型变量 </li><li><code>public static &lt;T extends Throwable&gt; void doWork() throws T{.. catch(){throw t;}}</code></li></ul></li></ul></li><li><p>| <em>参数化类型的数组不合法</em></p><ul><li>例:<code>Pair&lt;String&gt;[] list = new Pair&lt;String&gt;[10];</code></li><li>因为擦除后 list是Pair[]类型,然后就能转成Object[], 就失去了泛型的作用</li><li>如果要使用的话最好直接使用集合 ArrayList:<code>ArrayList&lt;Pair&lt;String&gt;&gt;</code>,安全又高效<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = list;</span><br><span class="line">array[<span class="number">0</span>] = <span class="string">"hi"</span>;<span class="comment">//  编译错误</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Date&gt;(); <span class="comment">//通过数组存储的检测,但实际上类型错误了,所以禁止使用参数化类型的数组</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>| <em>不能实例化类型变量(T)</em></p><ul><li>非法 <code>new T(){}</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>&#123;</span><br><span class="line">    first = <span class="keyword">new</span> T();</span><br><span class="line">    second = <span class="keyword">new</span> T();</span><br><span class="line">&#125;</span><br><span class="line">first = T.class.newInstance() <span class="comment">//非法 T.class是不合法的</span></span><br><span class="line"><span class="comment">//要实例化一个Pair&lt;T&gt;的对象就要如下:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">initPair</span><span class="params">(Class&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(c.newInstance(), c.newInstance());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如下调用</span></span><br><span class="line">Pair&lt;String&gt; pair = Pair.initPair(String.class);</span><br><span class="line"><span class="comment">// 因为Class本身是泛型, String.class其实是Class&lt;String&gt;的实例</span></span><br><span class="line"><span class="comment">// 也不能实例化为一个数组 new T[5]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>| <em>泛型类的静态上下文中类型变量无效</em></p><ul><li>不能在静态域中使用类型变量 如下:</li><li>如果这段代码能执行,那就可以声明一个 Singleton<random> 共享随机数生成类,</random></li><li>但是声明之后,类型擦除,就只剩下了Singleton类,并不能做对应的事情,所以禁止这样的写法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> T first; <span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getFirst</span><span class="params">()</span></span>&#123; <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>| <em>注意泛型擦除后的冲突</em></p><ul><li>当类型擦除时,不能创建引发冲突的相关条件</li><li>例如 新实现一个类型变量约束的equals方法就会和Object原方法冲突 补救方法就是重命名该方法了</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span> <span class="params">(T value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ..</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>泛型规范说明</code></p><ul><li><p>要想支持擦除的转换,就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类,而这两个接口是同一接口的不同参数化</p><ul><li>以下代码就是非法的, GregorianCalendar 实现了两个接口,两个接口是Comparable接口的不同参数化,这是不允许的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Calendar</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GregorianCalendar</span> <span class="keyword">extends</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">GregorianCalendar</span>&gt;</span>&#123;&#125; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>但是如下又是合法的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GregorianCalendar</span> <span class="keyword">extends</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>很有可能是桥方法有关,不可能有两个一样的桥方法(因为两个接口其实是一个接口的不同参数化,桥方法的方法签名是一致的)</p></li></ul><hr><h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><blockquote><p>例如 父子类: Human Student  那么 Pair<human> Pair<student> 是继承(inherit)关系么,答案是否定的!!</student></human></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Human&gt; humans = <span class="keyword">new</span> Pair&lt;Human&gt;(man, woman);</span><br><span class="line">Pair&lt;Student&gt; classmates = humans;<span class="comment">// illegal, but suppose it wasn't</span></span><br><span class="line">classmates.setSecond(junior) <span class="comment">// 如果上面合法,那么这里是肯定可以执行的, 因为泛型类型变成了Student</span></span><br><span class="line"><span class="comment">//那么就有了问题了,原有的人类类型限制的对象中,出现了小学生</span></span><br><span class="line"><span class="comment">//所以不允许这样的类型变量约束的类进行多态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是数组可以这样写是因为数组会有自己的检查保护</span></span><br><span class="line">Human[] humans = &#123;man, woman&#125;;</span><br><span class="line">Student[] students = humans;</span><br><span class="line">students[<span class="number">0</span>] = junior ;<span class="comment">// 虚拟机将抛出 ArrayStoreException 异常</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>永远可以将参数化类型转换为一个原始类型, Pair<human> 是原始类型Pair的一个子类型,转换成原始类型也会产生错误<br><a href="https://github.com/Kuangcp/JavaBase/blob/master/src/test/java/com/generic/simple/PairTest.java" target="_blank" rel="noopener">相关测试类</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Human&gt; humans = <span class="keyword">new</span> Pair&lt;Human&gt;(man, woman);</span><br><span class="line">Pair other = humans;</span><br><span class="line">other.setFirst(<span class="keyword">new</span> String(<span class="string">"wtf"</span>))<span class="comment">// 只是会有一个编译时的警告(类型未检查),但实际上都看得出这明显是错误的</span></span><br><span class="line"><span class="comment">// 那么在后续代码中继续当做Human对象进行引用,必然就会有ClassCastException</span></span><br><span class="line"><span class="comment">// 所以这样的写法尽量避免,这里的设计 就失去了泛型程序设计提供的附加安全性.(挖的坑)</span></span><br></pre></td></tr></table></figure></human></p></blockquote><hr><blockquote><p>泛型类可以扩展或实现其他的泛型类,就这一点而言,和普通类没有什么区别</p></blockquote><ul><li>例如 ArrayList<t> 实现List<t>接口, 这意味着一个ArrayList<student>可以转换为List<studnet> <ul><li>但是一个ArrayList<student>不是ArrayList<human>或者List<student>.</student></human></student></li></ul></studnet></student></t></t></li></ul><hr><h3 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h3><h4 id="子类型限定的通配符-extends"><a href="#子类型限定的通配符-extends" class="headerlink" title="子类型限定的通配符 extends"></a>子类型限定的通配符 extends</h4><blockquote><p>通配符上限  顾名思义,就是限定为该类及其子类, 例如: <code>Pair&lt;? extends Human&gt;</code> 表示任何Pair泛型类型并且他的类型变量要为Human的子类  </p></blockquote><blockquote><p>例如编写一个方法 <code>public static void printMessage(Pair&lt;Human&gt; human){}</code><br>正如上面所说, Pair<student>类型的变量是不能放入这个方法的,因为泛型变量是没有继承关系, 这时候就可以使用这个通配符:  </student></p><blockquote><p><code>public static void printMessage(Pair&lt;? extends Human&gt;)</code> 可以get不能set<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Human&gt; humans = <span class="keyword">new</span> Pair&lt;Human&gt;(man, woman);</span><br><span class="line">Pair&lt;? extends Human&gt; classmates = humans;<span class="comment">// 编译通过</span></span><br><span class="line">classmates.setSecond(junior) <span class="comment">// 编译错误,泛型约束起作用了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析其泛型类实现可以理解为:</span></span><br><span class="line">? <span class="function">extends Human <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? extends Human)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 这样的话是不可能调用setFirst方法, 对于编译器来说,只是知道入参是Human的子类,但是类型并不明确,所以不能正常调用</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使用get方法就不会有问题, 泛型起作用了.将get返回值赋值给Human的引用也是完全合法的,这就是引入该统通配符的关键之处</span></span></span><br></pre></td></tr></table></figure></p></blockquote></blockquote><h4 id="超类型限定的通配符-super"><a href="#超类型限定的通配符-super" class="headerlink" title="超类型限定的通配符 super"></a>超类型限定的通配符 super</h4><blockquote><p>通配符下限  顾名思义就是限定为父类, 通配符限定和类型变量限定十分相似, 但是可以指定一个超类型限定(supertype bound)<br><code>? super Student</code> 这个通配符就限定为Student的所有超类型(super关键字已经十分准确的描述了这种关系)  </p><blockquote><p>带有超类型限定的通配符的行为和前者相反,可以为方法提供参数,但不能使用返回值即 可以 set 但是不能get</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pair&lt;? super Student&gt; 例如这种定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? <span class="keyword">super</span> Student)</span></span></span><br><span class="line"><span class="function">? <span class="keyword">super</span> Student <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 编译器不知道setFirst方法的确切类型,但是可以用任意Student对象(或子类型) 调用他, 而不能使用Human对象调用.</span></span></span><br><span class="line"><span class="function"><span class="comment">// 然而,如果调用getFirst,泛型没有起作用,只能将返回值用Object接收</span></span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/Kuangcp/JavaBase/blob/master/src/test/java/com/generic/simple/PairTest.java" target="_blank" rel="noopener">以上两种情况的相关测试类</a> </p></blockquote><blockquote><p>总结: 类定义上的泛型变量:  </p><blockquote><p>子类型限定: &lt;? extends Human&gt; 是限定了不能set,但是保证了get<br>超类型限定: &lt;? super Student&gt; 限定了不能正确get,但是保证了set.  </p></blockquote></blockquote><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-jtp04298.html" target="_blank" rel="noopener">参考博客: 使用通配符简化泛型使用</a></p></blockquote><ul><li><p>示例1:<code>public static &lt;T extends Comparable&lt;T&gt;&gt; T min(T[] list);</code></p><ul><li>限定了入参和返回值是 是实现了Comparable接口的某个类型 因为Comparable也是一个泛型类, 所以也进行限定类型</li><li>这样的写法要比 T extends Comparable 更为彻底</li><li>例如计算一个String数组的最小值 T 就是 String类型的, String是Comparable<string>的子类型<ul><li>但是当处理GregorianCalendar, GregorianCalendar是Calendar的子类, 并且Calendar实现了<code>Comparable&lt;Calendar&gt;</code></li><li>因此GregorianCalendar实现的是<code>Comparable&lt;Calendar&gt;</code>, 而不是Comparable<gregoriancalendar></gregoriancalendar></li><li>这种情况下 <code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] list)</code> 就是安全的</li></ul></string></li></ul></li><li><p>示例2: <code>public static &lt;T extends ExcelTransform&gt; List&lt;T&gt; importExcel(Class&lt;T&gt; target)</code></p><ul><li>该方法实现了, 传入继承了ExcelTransform接口的类对象, 得到该类的List集合</li><li><code>&lt;T extends ExcelTransform&gt; boolean</code> 这样写编译没报错, 那么就是说, 就是一个泛型的定义, 后面进行引用, 省的重复写</li><li>简单的写法就是 <code>public static &lt;T&gt; List&lt;T&gt; importExcel(Class&lt;T&gt; target)</code></li></ul></li><li><p>示例3: Spring4.x 添加的泛型依赖注入 , 使用的JPA就是依赖该技术   <a href="http://blog.csdn.net/u010837612/article/details/45582043" target="_blank" rel="noopener">spring学习笔记（14）——泛型依赖注入</a></p></li></ul><blockquote><p>对于应用程序员, 可能很快的学会掩盖这些声明, 想当然地认为库程序员做的都是正确的, 如果是一名库程序员, 一定要习惯于通配符<br>否则还要用户在代码中随意地添加强制类型转换直至可以通过编译.</p></blockquote><h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><blockquote><p>TODO 对其使用场景 尚有疑问,以后再解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如 Pair&lt;?&gt;</span></span><br><span class="line">? getFirst() <span class="comment">// 方法的返回值只能赋值给一个Object</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(?)</span> <span class="comment">// 方法不能被调用,甚至不能用Object调用.</span></span></span><br><span class="line"><span class="function"><span class="comment">// Pair&lt;?&gt; 和 Pair 本质的不同在于: 可以用任意Object对象调用原始的Pair类的setObject(set方法,因为类型擦除 入参是Object, 简称setObject)方法</span></span></span><br></pre></td></tr></table></figure><ul><li>例如 <a href="https://github.com/Kuangcp/JavaBase/blob/master/src/test/java/com/generic/simple/PairTest.java" target="_blank" rel="noopener">这个hasNull()方法</a>用来测试一个pair是否包含了指定的对象, 他不需要实际的类型.</li></ul><h4 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h4><blockquote><p>TODO 学习和理解使用场景</p></blockquote><ul><li><p>如果编写一个交换的方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span> <span class="params">(Pair&lt;?&gt; p)</span></span>&#123;</span><br><span class="line">    ? temp = p.getFirst(); <span class="comment">// 错误, 不允许将?作为类型</span></span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是可以编写一个辅助方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">    T temp = p.getFirst();</span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>swapHelper是一个泛型方法, 而swap不是, 它具有固定的Pair&lt;?&gt;类型的参数, 那么现在就可以这样写:</p><ul><li><code>public static void swap(Pair&lt;?&gt; p){swapHelper(p);}</code></li><li>这种情况下, swapHelper方法的参数T捕获通配符, 它不知道是哪种类型的通配符,但是这是一个明确的类型 并且<t>swapHelper 在T指出类型时,才有明确的含义</t></li><li>当然,这种情况下并不是一定要用通配符, 而且我们也实现了没有通配符的泛型方法</li></ul></li></ul><blockquote><p>但是下面这个通配符类型出现在计算结果中间的示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxMinBonus</span><span class="params">(Student[] students, Pair&lt;? <span class="keyword">super</span> Student&gt; result)</span></span>&#123;</span><br><span class="line">    minMaxBonus(students, result);</span><br><span class="line">    swapHelper(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这里,通配符捕获机制是不可避免的, 但是这种捕获只有在许多限制情况下才是合法的.</span></span><br><span class="line"><span class="comment">// 对于编译器而言, 必须能够确信通配符表达的是单个, 确定的类型.</span></span><br></pre></td></tr></table></figure><h3 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h3><blockquote><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html" target="_blank" rel="noopener">官方Java7的Class文档</a> | <a href=""></a><br>现在Class类是泛型的, 例如String.class实际上是Class<string>类的对象(事实上是唯一的对象)<br>类型参数十分有用, 这是因为他允许Class<t>方法的返回类型更加具有针对性.下面Class<t>的方法就使用了类型参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">T <span class="title">cast</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">T[] <span class="title">getEnumConstants</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Class&lt;? <span class="keyword">super</span> T&gt; <span class="title">getSuperclass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class... paramterTypes)</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class... paramterTypes)</span></span></span><br></pre></td></tr></table></figure></t></t></string></p></blockquote><ul><li>newInstance方法返回一个示例, 这个实例所属的类由默认的构造器获得, 它的返回类型目前被声明为T, 其类型与Class<t>描述的类相同, 这样就免除了类型转换.</t></li><li>如果给定的类型确实是T的一个子类型, cast方法就会返回一个现在声明为类型T的对象, 否则, 抛出一个BadCastException异常</li><li>如果这个类不是enum类或类型T的枚举值的数组, getEnumConstants方法将返回Null.</li><li>最后, getConstructor与getDeclaredConstructor方法返回一个Constructor<t>对象.Constructor类也已经变成泛型, 以便 newInstance方法有一个正确的返回类型.</t></li></ul><p>TODO 还要继续看书</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个Class对象, 得到Class对应类型的实例</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; target, String name)</span></span>;</span><br><span class="line"><span class="comment">// 加上约束</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Runable&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; target, String name)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#泛型&quot;&gt;泛型&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#入门&quot;&gt;入门&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#简单使用&quot;&gt;简单使用&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="泛型" scheme="http://blog.kuangcp.top/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Java-AdvancedLearning-ClassFile/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Java-AdvancedLearning-ClassFile/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#java基础">Java基础</a><ol><li><a href="#类和字节码">类和字节码</a><ol><li><a href="#类加载和类对象">类加载和类对象</a><ol><li><a href="#类加载器">类加载器</a></li><li><a href="#加载和连接">加载和连接</a></li><li><a href="#class对象">Class对象</a></li><li><a href="#类加载器">类加载器</a></li></ol></li><li><a href="#方法句柄">方法句柄</a></li></ol></li><li><a href="#查看class文件">查看class文件</a><ol><li><a href="#常量池">常量池</a></li><li><a href="#字节码">字节码</a><ol><li><a href="#运行时环境">运行时环境</a></li><li><a href="#操作码介绍">操作码介绍</a></li><li><a href="#加载和存储操作码">加载和存储操作码</a></li><li><a href="#数学运算操作码">数学运算操作码</a></li><li><a href="#执行控制操作码">执行控制操作码</a></li><li><a href="#调用操作码">调用操作码</a></li><li><a href="#平台操作码">平台操作码</a></li><li><a href="#操作码的快捷形式">操作码的快捷形式</a></li><li><a href="#invokedynamic">invokedynamic</a></li></ol></li></ol></li><li><a href="#序列化">序列化</a><ol><li><a href="#serialversionuid">serialVersionUID</a></li><li><a href="#其他业内主流编解码框架">其他业内主流编解码框架</a><ol><li><a href="#messagepack">MessagePack</a></li><li><a href="#protobuf">Protobuf</a><ol><li><a href="#proto文件定义">proto文件定义</a></li><li><a href="#linux上安装">Linux上安装</a></li><li><a href="#通过docker使用">通过Docker使用</a></li><li><a href="#对于java的使用">对于Java的使用</a></li></ol></li><li><a href="#thrift">Thrift</a></li><li><a href="#marshalling">Marshalling</a></li></ol></li></ol></li><li><a href="#热更新">热更新</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="类和字节码"><a href="#类和字节码" class="headerlink" title="类和字节码"></a>类和字节码</h2><blockquote><p><a href="https://github.com/Kuangcp/JavaBase/tree/master/java-classfile/src/main/java/com/github/kuangcp" target="_blank" rel="noopener">个人相关代码</a> </p></blockquote><p><strong><code>相关项目</code></strong></p><blockquote><p><a href="http://commons.apache.org/proper/commons-bcel/index.html" target="_blank" rel="noopener">Apache bcel</a></p></blockquote><h3 id="类加载和类对象"><a href="#类加载和类对象" class="headerlink" title="类加载和类对象"></a>类加载和类对象</h3><ul><li>一个<code>.class</code>文件定义了JVM中的类型，包括了域,方法，继承信息，注解和其他元数据</li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li style="list-style: none"><input type="checkbox"> TODO 学习类加载器<blockquote><p><a href="https://blog.csdn.net/yuan22003/article/details/6839335\" target="_blank" rel="noopener">类装载器、双亲委托模型、命名空间、安全性</a><br><a href="https://blog.csdn.net/wangyang1354/article/details/49448007" target="_blank" rel="noopener">java ClassLoader类解析-双亲委托机制</a></p></blockquote></li></ul><h4 id="加载和连接"><a href="#加载和连接" class="headerlink" title="加载和连接"></a>加载和连接</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p107.jpg" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><p><a href="http://ifeve.com/%e7%ac%ac%e4%b8%83%e7%ab%a0-%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%b1%bb%e5%8a%a0%e8%bd%bd%e6%9c%ba%e5%88%b6/" target="_blank" rel="noopener">参考博客: 第七章.虚拟机类加载机制</a><br><code>加载</code></p><ul><li>这个过程就是读取字节码文件，创建一个字节数组装在这些内容，加载结束后这个对象还不能直接调用 </li></ul><p><code>连接</code></p><ul><li>加载完成后，类必须连接起来，分为三步：验证，准备，解析。<ul><li>验证：<ul><li>验证文件的合理性，完整性检查，检查常量池，方法的字节码检查。主要的：</li><li>是否所有方法都遵守访问控制关键字的限定</li><li>方法调用的参数个数和静态类型是否正确</li><li>确保字节码不会试图滥用堆栈</li><li>确保变量使用之前被正确初始化了</li><li>检查变量是否仅被赋予恰当类型的值</li></ul></li><li>准备：<ul><li>分配内存，准备初始化类中的静态变量，但不会现在就初始化，也不会执行任何VM字节码</li></ul></li><li>解析：<ul><li>促使VM检查类文件中所引用的类型是不是都是已知的类型。如果有运行时有未知的类型，那又要引发一次类加载过程</li><li>当需要加载的类全部加载解析完毕后，VM就可以初始化最初那个加载的类了。</li><li>这时所有的静态变量都可以进行初始化，所有静态代码块都会运行，这一步完成后，类就能使用了</li></ul></li></ul></li></ul><h4 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h4><ul><li>加载和连接过程的最终结果是一个Class对象，Class对象可以和反射API一起实现对方法，域构造方法等类成员的间接访问</li></ul><blockquote><p>所以一个类的定义就会有一个Class对象, 但是这个对象的类型呢?怎么判断, Class对象的类型就是他的值么?</p></blockquote><h4 id="类加载器-1"><a href="#类加载器-1" class="headerlink" title="类加载器"></a>类加载器</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p110.jpg" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><ul><li>Java平台经典类加载器：<ul><li>根（引导）加载器： 通常在VM启动后不久就实例化，作用是加载系统的基础JAR(主要是rt.jar)，并且不做验证工作</li><li>扩展类加载器： 加载安装时自带的标准扩展，一般包括安全性扩展</li><li>应用或系统类加载器： 应用最广泛的类加载器，负责加载应用类，在大多SE环境中主要工作是由他完成</li><li>定制类载器： 为了企业框架定制的加载器</li></ul></li></ul><hr><h3 id="方法句柄"><a href="#方法句柄" class="headerlink" title="方法句柄"></a>方法句柄</h3><blockquote><p>主要用于反射 用到再学</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p118.jpg" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><hr><h2 id="查看class文件"><a href="#查看class文件" class="headerlink" title="查看class文件"></a>查看class文件</h2><blockquote><p>javap: JDK内置命令, 用来探视类文件内部和反编译class文件</p></blockquote><hr><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><blockquote><p>常量池是为类文件中的其他常量元素提供快捷访问方式的区域。对于JVM来说常量池相当于符号表<br><a href="http://www.cnblogs.com/LeonNew/p/5314731.html" target="_blank" rel="noopener">参考博客</a></p></blockquote><ul><li><code>javap -v class文件</code> 输出很多额外信息，# 开头的就是常量池信息<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p120.jpg" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure></li></ul><hr><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><blockquote><p><a href="https://www.cnblogs.com/beautiful-code/p/6425376.html" target="_blank" rel="noopener">参考博客: 学会阅读Java字节码</a></p></blockquote><ul><li>字节码是程序的中间表达形式，源码和机器码之间的产物</li><li>字节码是由源文件执行javac产生的</li><li>某些高级语言特性（语法糖）在字节码中给去掉了，例如循环结构，会转换成为分支指令</li><li>每个操作都由一个字节表示，因此叫做字节码</li><li>字节码是一种抽象表示方法</li><li><p>字节码进一步编译得到机器码</p></li><li><p><code>javap -c -p class文件</code> 反编译字节码文件，-p 能看到私有属性</p><ul><li>输出所有的属性以及类的定义信息</li><li>静态块</li><li>构造方法</li><li>方法信息</li><li>静态属性信息</li><li>静态方法信息</li></ul></li></ul><h4 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h4><blockquote><p>因为JVM没有CPU那样的寄存器，所以是采用的堆栈来计算的，称为操作数栈或者计算堆栈</p></blockquote><ul><li>当一个类被链接进运行时环境时，字节码会受到检查，其中很多验证都可以归结为对栈中类型模式的分析</li><li>方法需要一块内存区域作为计算堆栈来计算新值，另外每个运行的线程都需要一个调用堆栈来记录当前正在执行的方法，这两个栈会有交互</li></ul><h4 id="操作码介绍"><a href="#操作码介绍" class="headerlink" title="操作码介绍"></a>操作码介绍</h4><ul><li>字节码由操作码 opcode 序列构成，每个指令后可能会带参数，操作码希望看到栈处于指定状态中，然后他对栈进行操作处理，把参数移走，放入结果</li><li>操作码表有四列：<ul><li>名称：操作码类型的通用名称</li><li>参数：操作码的参数，以i开头的是用来作为常量池或局部变量中的查询索引的几个字节，如果有更多的参数，将会合并<ul><li>如果参数出现在括号里，就表明不是所有形式的操作码都会使用他</li></ul></li><li>堆栈布局：他展示了栈在操作码执行前后的状态。括号中的元素表示是可选的</li><li>描述：描述操作码的用处</li></ul></li></ul><p>[ ] 下面的内容需要继续阅读Java7程序员修炼之道</p><h4 id="加载和存储操作码"><a href="#加载和存储操作码" class="headerlink" title="加载和存储操作码"></a>加载和存储操作码</h4><h4 id="数学运算操作码"><a href="#数学运算操作码" class="headerlink" title="数学运算操作码"></a>数学运算操作码</h4><h4 id="执行控制操作码"><a href="#执行控制操作码" class="headerlink" title="执行控制操作码"></a>执行控制操作码</h4><h4 id="调用操作码"><a href="#调用操作码" class="headerlink" title="调用操作码"></a>调用操作码</h4><h4 id="平台操作码"><a href="#平台操作码" class="headerlink" title="平台操作码"></a>平台操作码</h4><h4 id="操作码的快捷形式"><a href="#操作码的快捷形式" class="headerlink" title="操作码的快捷形式"></a>操作码的快捷形式</h4><h4 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h4><blockquote><p>这个特性是针对 框架开发和非Java语言准备的</p></blockquote><hr><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513589&amp;idx=1&amp;sn=d402d623d9121453f1e570395c7f99d7&amp;chksm=80d67a36b7a1f32054d4c779dd26e8f97a075cf4d9ed1281f16d09f1df50a29319cd37520377&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:序列化： 一个老家伙的咸鱼翻身</a> <code>对象转化为二进制流</code></p></blockquote><h3 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h3><blockquote><p>简单的说就是类的版本控制, 标明类序列化时的版本, 版本一致表明这两个类定义一致<br>在进行反序列化时, JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)<br><a href="http://swiftlet.net/archives/1268" target="_blank" rel="noopener">参考博客</a></p></blockquote><ul><li>serialVersionUID有两种显示的生成方式： <ul><li>一个是默认的1L</li><li>一个是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段</li></ul></li></ul><blockquote><p>当你一个类实现了Serializable接口，如果没有定义serialVersionUID，Eclipse会提供这个提示功能告诉你去定义 。<br>在Eclipse中点击类中warning的图标一下，Eclipse就会自动给定两种生成的方式。<br>如果不想定义它，在Eclipse的设置中也可以把它关掉的，设置如下：<br>Window ==&gt; Preferences ==&gt; Java ==&gt; Compiler ==&gt; Error/Warnings ==&gt;Potential programming problems<br>将Serializable class without serialVersionUID的warning改成ignore即可。</p></blockquote><hr><h3 id="其他业内主流编解码框架"><a href="#其他业内主流编解码框架" class="headerlink" title="其他业内主流编解码框架"></a>其他业内主流编解码框架</h3><blockquote><p>因为Java序列化的性能和存储开销都表现不好,而且不能跨语言, 所以一般不使用Java的序列化而是使用以下流行的库</p></blockquote><h4 id="MessagePack"><a href="#MessagePack" class="headerlink" title="MessagePack"></a>MessagePack</h4><blockquote><p><a href="https://github.com/msgpack" target="_blank" rel="noopener">Github:msgpack</a> | <a href="http://hao.jobbole.com/messagepack/" target="_blank" rel="noopener">参考博客: MessagePack：一种高效二进制序列化格式</a></p></blockquote><h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><blockquote><p>Google开源的库 全称 <code>Google Protocol Buffers</code> |  <a href="https://github.com/google/protobuf" target="_blank" rel="noopener">Github : Protobuf</a></p></blockquote><blockquote><p><a href="http://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html" target="_blank" rel="noopener">参考博客: Protobuf语言指南</a> <code>较为详细, 只是版本有点旧</code><br><a href="https://juejin.im/entry/59c1214df265da0658151a2c" target="_blank" rel="noopener">参考博客: 详解如何在NodeJS中使用Google的Protobuf</a> | <a href="https://github.com/dcodeIO/protobuf.js" target="_blank" rel="noopener">protocobuf</a><br><a href="https://blog.csdn.net/hguisu/article/details/20721109" target="_blank" rel="noopener">Google 开源技术protobuf </a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">Google Protocol Buffer 的使用和原理</a></p></blockquote><blockquote><p><a href="http://blog.jobbole.com/107405/" target="_blank" rel="noopener">参考博客: 数据交换利器 Protobuf 技术浅析</a><br><a href="https://blog.csdn.net/u011518120/article/details/54604615" target="_blank" rel="noopener">参考博客: Protobuf3语言指南</a></p></blockquote><ul><li>他将数据结构以 proto后缀的文件进行描述, 通过代码生成工具, 可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性<ul><li>特点:<ul><li>结构化数据存储格式: XML JSON等</li><li>高效的编解码性能</li><li>语言无关, 平台无关, 扩展性好</li><li>官方支持 Java C++ Python三种语言, 并且Js的支持也比较好<a href="https://github.com/dcodeIO/ProtoBuf.js/" target="_blank" rel="noopener"></a></li></ul></li><li>数据描述文件和代码生成机制优点:<ul><li>文本化的数据结构描述语言, 可以实现语言和平台无关, 特别适合异构系统间的集成</li><li>通过标识字段的顺序, 可以实现协议的前向兼容 <em>在不同版本的数据结构进程间进行数据传递</em></li><li>自动代码生成, 不需要手工编写同样数据结构的C++和Java版本;</li><li>方便后续的管理和维护,相比于代码, 结构化的文档更容易管理和维护</li></ul></li></ul></li><li>习惯性规则:<ul><li>命名: <code>packageName.MessageName.proto</code></li></ul></li></ul><blockquote><p>只是编解码的工具, 不支持读半包, 粘包拆包</p></blockquote><h5 id="proto文件定义"><a href="#proto文件定义" class="headerlink" title="proto文件定义"></a>proto文件定义</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 用户数据信息</span><br><span class="line">message Article &#123;</span><br><span class="line">    required int32 articleId = 1;         // 文章id</span><br><span class="line">    optinal string articleExcerpt = 4;    // 文章摘要</span><br><span class="line">    repeated string articlePicture = 5;   // 文章附图</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面定义了一个消息, 消息具有三个属性, 且行末的注释都会变成Javadoc注释  </p></blockquote><ol><li>message 是消息定义的关键字</li><li>required 表示这个字段是必需的, 必须在序列化的时候被赋值。</li><li>optional 代表这个字段是可选的，可以为0个或1个但不能大于1个。</li><li>repeated 则代表此字段可以被重复任意多次包括0次。</li><li>int32和string是字段的类型。后面是我们定义的字段名。</li><li>最后的1，2，3则是代表每个字段的一个唯一的编号标签，在同一个消息里不可以重复。这些编号标签用与在消息二进制格式中标识你的字段，并且消息一旦定义就不能更改。<ul><li>需要说明的是标签在1到15范围的采用一个字节进行编码。所以通常将标签1到15用于频繁发生的消息字段。编号标签大小的范围是1 到 2的29次幂–1。</li><li>此外不能使用protobuf系统预留的编号标签（19000 －19999）。</li></ul></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Learn/java/protobuf/protobuf-type.jpeg" alt="数据类型对应表" title="">                </div>                <div class="image-caption">数据类型对应表</div>            </figure><p><em>复杂类型</em>  </p><blockquote><p>定义了enum枚举类型，嵌套的消息。甚至对原有的消息进行了扩展，也可以对字段设置默认值。添加注释等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package &quot;com.github.kuangcp&quot;;</span><br><span class="line">message Article &#123;</span><br><span class="line">  required int32 article_id = 1;</span><br><span class="line">  optional string article_excerpt = 2;</span><br><span class="line">  repeated string article_picture = 3;</span><br><span class="line">  optional int32  article_pagecount = 4 [default = 0];</span><br><span class="line">  enum ArticleType &#123;</span><br><span class="line">    NOVEL = 0;</span><br><span class="line">    PROSE = 1;</span><br><span class="line">    PAPER = 2;</span><br><span class="line">    POETRY = 3;</span><br><span class="line">  &#125;</span><br><span class="line">  optional ArticleType article_type = 5 [default = NOVEL];</span><br><span class="line">  message Author &#123;</span><br><span class="line">    required string name = 1; //作者的名字</span><br><span class="line">    optional string phone = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  optional Author author = 6;</span><br><span class="line">  repeated int32 article_numberofwords = 7 [packed=true];</span><br><span class="line">  reserved  9, 10, 12 to 15;</span><br><span class="line">  extensions 100 to 1000;</span><br><span class="line">&#125;</span><br><span class="line">extend Article &#123;</span><br><span class="line">  optional int32 followers_count = 101;</span><br><span class="line">  optional int32 likes_count= 102;</span><br><span class="line">&#125;</span><br><span class="line">message Other &#123;</span><br><span class="line">  optional string other_info = 1;</span><br><span class="line">  oneof test_oneof &#123;</span><br><span class="line">    string code1 = 2;</span><br><span class="line">    string code2 = 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>此外reserved关键字主要用于保留相关编号标签，主要是防止在更新proto文件删除了某些字段，而未来的使用者定义新的字段时重新使用了该编号标签。这会引起一些问题在获取老版本的消息时，譬如数据冲突，隐藏的一些bug等。所以一定要用reserved标记这些编号标签以保证不会被使用</p></blockquote><blockquote><p>当我们需要对消息进行扩展的时候，我们可以用extensions关键字来定义一些编号标签供第三方扩展。这样的好处是不需要修改原来的消息格式。就像上面proto文件，我们用extend关键字来扩展。只要扩展的字段编号标签在extensions定义的范围里。</p></blockquote><blockquote><p>对于基本数值类型，由于历史原因，不能被protobuf更有效的encode。所以在新的代码中使用packed=true可以更加有效率的encode。注意packed只能用于repeated 数值类型的字段。不能用于string类型的字段。</p></blockquote><blockquote><p>在消息Other中我们看到定义了一个oneof关键字。这个关键字作用比较有意思。当你设置了oneof里某个成员值时，它会自动清除掉oneof里的其他成员，也就是说同一时刻oneof里只有一个成员有效。这常用于你有许多optional字段时但同一时刻只能使用其中一个，就可以用oneof来加强这种效果。但需要注意的是oneof里的字段不能用required，optional，repeted关键字</p></blockquote><p><em>导入另一个proto定义</em><br><code>import &quot;article.proto&quot;;</code></p><ul><li>更新Protobuf文件的要求:<ol><li>不能改变已有的任何编号标签。</li><li>只能添加optional和repeated的字段。这样旧代码能够解析新的消息，只是那些新添加的字段会被忽略。但是序列化的时候还是会包含哪些新字段。而新代码无论是旧消息还是新消息都可以解析。</li><li>非required的字段可以被删除，但是编号标签不可以再次被使用，应该把它标记到reserved中去</li><li>非required可以被转换为扩展字段，只要字段类型和编号标签保持一致</li><li>相互兼容的类型，可以从一个类型修改为另一个类型，譬如int32的字段可以修改为int64</li></ol></li></ul><hr><blockquote><ul><li>使用上, 因为有多个消息类型, 那么会采用一个数值id作为code, 进行对应 方便沟通</li></ul></blockquote><h5 id="Linux上安装"><a href="#Linux上安装" class="headerlink" title="Linux上安装"></a>Linux上安装</h5><blockquote><p>只是安装2.5版本 <a href="http://www.cnblogs.com/brainy/archive/2012/05/13/2498671.html" target="_blank" rel="noopener">参考博客: linux下Google的Protobuf安装及使用笔记</a> | <a href="http://dofound.blog.163.com/blog/static/1711432462013524111644655/" target="_blank" rel="noopener">参考:proto buffer 安装 及 调用</a></p></blockquote><ul><li><a href="https://github.com/google/protobuf/releases/tag/v2.5.0" target="_blank" rel="noopener">下载2.5</a> 并解压 <ul><li>进入目录  <code>./configure</code> </li><li><code>make</code> 然后 <code>make check</code> 然后 <code>sudo make install</code></li><li><code>protoc --version</code> 有版本则安装成功</li></ul></li></ul><blockquote><p>注意: ./configure 时, 默认会安装在/usr/local目录下，可以加<code>--prefix=/usr</code>来指定安装到/usr/lib下  </p><blockquote><p>如果不加, 上述参数就要执行 <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib</code><br>当然,可以将这个环境变量的设置加在 .zshrc 或者 .bashrc 里<br>不然就会报错: <code>protoc: error while loading shared libraries: libprotobuf.so.8: cannot open shared object file: No such file or directory</code></p></blockquote></blockquote><h5 id="通过Docker使用"><a href="#通过Docker使用" class="headerlink" title="通过Docker使用"></a>通过Docker使用</h5><h5 id="对于Java的使用"><a href="#对于Java的使用" class="headerlink" title="对于Java的使用"></a>对于Java的使用</h5><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">Google Protocol Buffer 的使用和原理</a> <code>C++ 但是原理差不多</code></p></blockquote><p><code>生成Java文件</code><br>touch <em>hi.proto</em><br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package lm;</span><br><span class="line">message helloworld&#123;</span><br><span class="line">    required int32 id = 1;//ID</span><br><span class="line">    required string str = 2;//str</span><br><span class="line">    optional int32 opt = 3;//optional field</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>据此生成Java文件 <code>mkdir src &amp;&amp; protoc --java_out=./src hi.proto</code><br><em>也可以使用该脚本更新协议</em><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># proto文件中明确定义了一样的包结构就可以直接跑脚本</span></span><br><span class="line">basePath=<span class="string">'minigame/proto/proto'</span></span><br><span class="line">targetPath=<span class="string">'ssss'</span></span><br><span class="line">rm -rf <span class="variable">$targetPath</span> \</span><br><span class="line">&amp;&amp; mkdir <span class="variable">$targetPath</span> \</span><br><span class="line">&amp;&amp; protoc <span class="variable">$basePath</span>/*.proto --java_out=<span class="variable">$targetPath</span> \</span><br></pre></td></tr></table></figure></li></ul><p><code>使用</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个构建器</span></span><br><span class="line">helloworld.Builder msg = helloworld.newBuilder();</span><br><span class="line"><span class="comment">// 填充信息</span></span><br><span class="line">msg.setId(<span class="number">12</span>);</span><br></pre></td></tr></table></figure></p><hr><h4 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h4><blockquote><p><a href="https://thrift.apache.org/" target="_blank" rel="noopener">官网</a>源于Facebook, 支持多种语言: C++ C# Cocoa Erlang Haskell Java Ocami Perl PHP Python Ruby Smalltalk</p></blockquote><ul><li>它支持数据(对象)序列化和多种类型的RPC服务, Thrift适用于静态的数据交换, 需要预先确定好他的数据结构, 当数据结构发生变化时,需要重新编辑IDL文件</li></ul><h4 id="Marshalling"><a href="#Marshalling" class="headerlink" title="Marshalling"></a>Marshalling</h4><blockquote><p>JBOSS 内部使用的编解码框架</p></blockquote><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><blockquote><p>通过替换 class 实现不停机热更新</p></blockquote><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto-hotswapping.html" target="_blank" rel="noopener">Spring hot swapping</a></p></blockquote><ol><li>Instrumentation</li><li>自定义类加载器</li><li>OSGI 热插拔接口</li></ol><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" target="_blank" rel="noopener">Instrumentation 新功能</a><br><a href="https://www.jianshu.com/p/b72f66da679f" target="_blank" rel="noopener">基于Java Instrument的Agent实现</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/" target="_blank" rel="noopener">Java 5 特性 Instrumentation 实践</a><br><a href="https://blog.csdn.net/javierhui111/article/details/3830833" target="_blank" rel="noopener">java组件中的热插拔（osgi)</a><br><a href="https://www.cnblogs.com/cm4j/p/hot_deploy.html" target="_blank" rel="noopener">agentmain 方式 </a></p><p>相关项目: </p><p><a href="https://github.com/youxijishu/game-hot-update" target="_blank" rel="noopener">game-hot-update</a> <a href="https://www.cnblogs.com/wgslucky/p/9127681.html" target="_blank" rel="noopener">https://www.cnblogs.com/wgslucky/p/9127681.html</a><br><a href="https://github.com/chaopeng/groovy-hotswap-demo" target="_blank" rel="noopener">groovy hotswap demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#java基础&quot;&gt;Java基础&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#类和字节码&quot;&gt;类和字节码&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#类加载和类对象&quot;&gt;类加载和类对象
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="字节码" scheme="http://blog.kuangcp.top/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ZenOfPattern.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Java-ZenOfPattern/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Java-ZenOfPattern/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#设计模式之禅">设计模式之禅</a><ol><li><a href="#软件设计的一些原则">软件设计的一些原则</a><ol><li><a href="#思维原则">思维原则</a><ol><li><a href="#奥卡姆剃刀原理">奥卡姆剃刀原理</a></li></ol></li><li><a href="#首要原则">首要原则</a><ol><li><a href="#勿重复造轮子">勿重复造轮子</a></li><li><a href="#减法优于加法">减法优于加法</a></li><li><a href="#抽象优于实现">抽象优于实现</a></li><li><a href="#组合优于继承">组合优于继承</a></li><li><a href="#查询与命令分离">查询与命令分离</a></li><li><a href="#够用原则">够用原则</a></li><li><a href="#最少知识原则">最少知识原则</a></li></ol></li><li><a href="#面向对象的solid-原则">面向对象的S.O.L.I.D 原则</a><ol><li><a href="#单一职责原则">单一职责原则</a></li><li><a href="#开闭原则">开闭原则</a></li><li><a href="#里氏代换原则">里氏代换原则</a></li><li><a href="#接口隔离原则">接口隔离原则</a></li><li><a href="#依赖倒置原则">依赖倒置原则</a></li></ol></li><li><a href="#其他原则">其他原则</a><ol><li><a href="#共同封闭原则">共同封闭原则</a></li><li><a href="#共同重用原则">共同重用原则</a></li><li><a href="#好莱坞原则">好莱坞原则</a></li><li><a href="#高内聚低耦合">高内聚低耦合</a></li><li><a href="#惯例优于配置原则">惯例优于配置原则</a></li><li><a href="#关注点分离">关注点分离</a></li><li><a href="#契约式设计">契约式设计</a></li><li><a href="#无环依赖原则">无环依赖原则</a></li></ol></li></ol></li><li><a href="#设计模式">设计模式</a><ol><li><a href="#基础">基础</a></li><li><a href="#策略者模式">策略者模式</a></li><li><a href="#1创建型设计模式">1.创建型设计模式</a></li><li><a href="#2结构型设计模式">2.结构型设计模式</a></li><li><a href="#3行为设计模式">3.行为设计模式</a></li><li><a href="#常见设计模式">【常见设计模式】</a><ol><li><a href="#适配器模式">适配器模式</a></li><li><a href="#中介者模式">中介者模式</a></li><li><a href="#观察者模式">观察者模式</a><ol><li><a href="#单例模式">单例模式</a></li><li><a href="#装饰器模式">装饰器模式</a></li></ol></li><li><a href="#原型模式">原型模式</a></li><li><a href="#生成器模式">生成器模式</a></li></ol></li></ol></li><li><a href="#实践">实践</a><ol><li><a href="#经验之谈">经验之谈</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h1><h2 id="软件设计的一些原则"><a href="#软件设计的一些原则" class="headerlink" title="软件设计的一些原则"></a>软件设计的一些原则</h2><h3 id="思维原则"><a href="#思维原则" class="headerlink" title="思维原则"></a>思维原则</h3><h4 id="奥卡姆剃刀原理"><a href="#奥卡姆剃刀原理" class="headerlink" title="奥卡姆剃刀原理"></a>奥卡姆剃刀原理</h4><h3 id="首要原则"><a href="#首要原则" class="headerlink" title="首要原则"></a>首要原则</h3><h4 id="勿重复造轮子"><a href="#勿重复造轮子" class="headerlink" title="勿重复造轮子"></a>勿重复造轮子</h4><p>-<code>DRY Don’t Repeat Yourself</code><br>是一个最简单的法则，也是最容易被理解的。但它也可能是最难被应用的（因为要做到这样，我们需要在泛型设计上做相当的努力，这并不是一件容易的事）。它意味着，当我们在两个或多个地方的时候发现一些相似的代码的时候，我们需要把他们的共性抽象出来形一个唯一的新方法，并且改变现有的地方的代码让他们以一些合适的参数调用这个新的方法。</p><h4 id="减法优于加法"><a href="#减法优于加法" class="headerlink" title="减法优于加法"></a>减法优于加法</h4><ul><li><code>KISS Keep It Simple, Stupid</code><br>KISS原则在设计上可能最被推崇的，在家装设计，界面设计 ，操作设计上，复杂的东西越来越被众人所BS了，而简单的东西越来越被人所认可，比如这些UI的设计和我们中国网页（尤其是新浪的网页）者是负面的例子。<br>“宜家”（IKEA）简约、效率的家居设计、生产思路；“微软”（Microsoft）“所见即所得”的理念；“谷歌”（Google)简约、直接的商业风格，无一例外的遵循了“kiss”原则，<br>也正是“kiss”原则，成就了这些看似神奇的商业经典。而苹果公司的iPhone/iPad将这个原则实践到了极至。</li></ul><p>把一个事情搞复杂是一件简单的事，但要把一个复杂的事变简单，这是一件复杂的事。</p><h4 id="抽象优于实现"><a href="#抽象优于实现" class="headerlink" title="抽象优于实现"></a>抽象优于实现</h4><p>-<code>Program to an interface, not an implementation</code></p><ul><li>这是设计模式中最根本的哲学，注重接口，而不是实现，依赖接口，而不是实现。接口是抽象是稳定的，实现则是多种多样的。</li><li>以后面我们会面向对象的SOLID原则中会提到我们的依赖倒置原则，就是这个原则的的另一种样子。</li></ul><h4 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h4><p><code>【Composition over inheritance】</code></p><ul><li>多使用组合而不是继承, 但是这个观点是存在一定的争议的, 还是要有度的,合理搭配最为重要<ul><li>组合就是将原来继承方式中的父类放到子类作为属性?</li></ul></li></ul><p>组合<br>1.（对象）组合是一种通过创建一个组合了其它对象的对象，从而获得新功能的复用方法。<br>2.将功能委托给所组合的一个对象，从而获得新功能。<br>3.有些时候也称之为”聚合”（aggregation）或”包容”（containment），尽管有些作者对这些术语赋予了专门的含义</p><ul><li style="list-style: none"><input type="checkbox"> 再度思考</li></ul><blockquote><p><a href="http://www.cnblogs.com/narutow/p/8117352.html" target="_blank" rel="noopener">参考博客: 组合、委托与继承，面向对象中类之间的基本关系漫游</a><br><a href="https://www.xuebuyuan.com/1639556.html" target="_blank" rel="noopener">参考博客: 优先使用（对象）组合，而非（类）继承</a></p></blockquote><h4 id="查询与命令分离"><a href="#查询与命令分离" class="headerlink" title="查询与命令分离"></a>查询与命令分离</h4><p><code>【CQS Command-Query Separation】</code></p><ul><li>查询命令分离原则<ul><li>查询：当一个方法返回一个值来回应一个问题的时候，它就具有查询的性质；</li><li>命令：当一个方法要改变对象的状态的时候，它就具有命令的性质；</li></ul></li></ul><h4 id="够用原则"><a href="#够用原则" class="headerlink" title="够用原则"></a>够用原则</h4><p><code>【YAGNI  You Ain’t Gonna Need It 】</code></p><ul><li>这个原则简而言之为——只考虑和设计必须的功能，避免过度设计。只实现目前需要的功能，在以后您需要更多功能时，可以再进行添加。<ul><li>如无必要，勿增复杂性。</li><li>软件开发先是一场沟通博弈。 </li></ul></li></ul><h4 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h4><blockquote><p>【Law of Demeter – 迪米特法则】</p><ul><li>迪米特法则(Law of Demeter)，又称“最少知识原则” <code>（Principle of Least Knowledge）</code>，其来源于1987年荷兰大学的一个叫做Demeter的项目。</li><li>Craig Larman把Law of Demeter又称作“不要和陌生人说话”。在《程序员修炼之道》中讲LoD的那一章叫作“解耦合与迪米特法则”。</li><li>关于迪米特法则有一些很形象的比喻：<ul><li>如果你想让你的狗跑的话，你会对狗狗说还是对四条狗腿说？</li><li>如果你去店里买东西，你会把钱交给店员，还是会把钱包交给店员让他自己拿？ </li></ul></li><li>正式表述如下:</li><li>对于对象 ‘O’ 中一个方法’M’，M应该只能够访问以下对象中的方法:<ul><li>对象O；</li><li>与O直接相关的Component Object；</li><li>由方法M创建或者实例化的对象；</li><li>作为方法M的参数的对象。</li></ul></li></ul></blockquote><blockquote><p><a href="http://zhangyi.xyz/demeter-law-and-refactoring/" target="_blank" rel="noopener">参考博客: 迪米特法则与重构</a></p></blockquote><hr><h3 id="面向对象的S-O-L-I-D-原则"><a href="#面向对象的S-O-L-I-D-原则" class="headerlink" title="面向对象的S.O.L.I.D 原则"></a>面向对象的S.O.L.I.D 原则</h3><ul><li>一般来说这是面向对象的五大设计原则，但是，我觉得这些原则可适用于所有的软件开发。</li></ul><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p><code>Single Responsibility Principle (SRP)</code></p><ul><li>关于单一职责原则，其核心的思想是：<code>一个类，只做一件事，并把这件事做好，且只有一个引起它变化的原因。</code><ul><li>Unix/Linux是这一原则的完美体现者。各个程序都独立负责一个单一的事。</li><li>Windows是这一原则的反面示例。几乎所有的程序都交织耦合在一起。 </li></ul></li></ul><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p><code>Open/Closed Principle (OCP)</code></p><ul><li>关于开发封闭原则，其核心的思想是：模块是可扩展的，而不可修改的。也就是说，<code>对扩展是开放的，而对修改是封闭的。</code><ul><li>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li><li>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。</li></ul></li></ul><h4 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h4><p><code>Liskov substitution principle (LSP)</code></p><ul><li>软件工程大师Robert C. Martin把里氏代换原则最终简化为一句话：<code>“Subtypes must be substitutable for their base types”。</code></li><li><p>也就是，子类必须能够替换成它们的基类。</p><blockquote><p>即：子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现if/else之类对子类类型进行判断的条件。<br>里氏替换原则LSP是使代码符合开闭原则的一个重要保证。正是由于子类型的可替换性才使得父类型的模块在无需修改的情况下就可以扩展。</p></blockquote></li><li><p>这么说来，似乎有点教条化，我非常建议大家看看这个原则个两个最经典的案例——<code>“正方形不是长方形”</code>和<code>“鸵鸟不是鸟”</code>。</p></li><li>通过这两个案例，你会明白《墨子小取》中说的——<code>“娣，美人也，爱娣，非爱美人也….盗，人也；恶盗，非恶人也。”</code>——妹妹虽然是美人，但喜欢妹妹并不代表喜欢美人。</li><li>盗贼是人，但讨厌盗贼也并不代表就讨厌人类。这个原则让你考虑的不是语义上对象的间的关系，而是实际需求的环境。</li><li>在很多情况下，在设计初期我们类之间的关系不是很明确，LSP则给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系。</li><li><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><code>Interface Segregation Principle (ISP)</code></li><li>接口隔离原则意思是把功能实现在接口中，而不是类中，使用多个专门的接口比使用单一的总接口要好。</li><li>举个例子，我们对电脑有不同的使用方式，比如：写作，通讯，看电影，打游戏，上网，编程，计算，数据等，如果我们把这些功能都声明在电脑的抽类里面，那么，我们的上网本，PC机，服务器，</li><li>笔记本的实现类都要实现所有的这些接口，这就显得太复杂了。所以，我们可以把其这些功能接口隔离开来，比如：工作学习接口，编程开发接口，上网娱乐接口，计算和数据服务接口，这样，我们的不同功能的电脑就可以有所选择地继承这些接口。</li><li>这个原则可以提升我们“搭积木式”的软件开发。对于设计来说，Java中的各种Event Listener和Adapter，对于软件开发来说，不同的用户权限有不同的功能，不同的版本有不同的功能，都是这个原则的应用。</li></ul><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p><code>Dependency Inversion Principle (DIP)</code><br>高层模块不应该依赖于低层模块的实现，而是依赖于高层抽象。<br>举个例子，墙面的开关不应该依赖于电灯的开关实现，而是应该依赖于一个抽象的开关的标准接口，这样，当我们扩展程序的时候，我们的开关同样可以控制其它不同的灯，甚至不同的电器。<br>也就是说，电灯和其它电器继承并实现我们的标准开关接口，而我们的开关产商就可不需要关于其要控制什么样的设备，只需要关心那个标准的开关标准。这就是依赖倒置原则。<br>这就好像浏览器并不依赖于后面的web服务器，其只依赖于HTTP协议。这个原则实在是太重要了，社会的分工化，标准化都是这个设计原则的体现。</p><blockquote><p>下面有几点指导意见，帮助你避免在面向对象设计中违反依赖倒置原则：  </p><blockquote><p>变量不能持有具体类的引用，就像订单方法代码中，你看不到new一样。<br>不要让派生自具体类，要派生就派生抽象类abstract<br>不要覆盖基类中已实现的方法，除非你要覆盖的是比较特殊的一部分代码。  </p></blockquote></blockquote><h3 id="其他原则"><a href="#其他原则" class="headerlink" title="其他原则"></a>其他原则</h3><h4 id="共同封闭原则"><a href="#共同封闭原则" class="headerlink" title="共同封闭原则"></a>共同封闭原则</h4><p><code>Common Closure Principle（CCP）</code><br>一个包中所有的类应该对同一种类型的变化关闭。一个变化影响一个包，便影响了包中所有的类。一个更简短的说法是：一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。CCP原则就是把因为某个同样的原因而需要修改的所有类组合进一个包里。如果2个类从物理上或者从概念上联系得非常紧密，它们通常一起发生改变，那么它们应该属于同一个包。</p><p>CCP延伸了开闭原则（OCP）的“关闭”概念，当因为某个原因需要修改时，把需要修改的范围限制在一个最小范围内的包里。</p><h4 id="共同重用原则"><a href="#共同重用原则" class="headerlink" title="共同重用原则"></a>共同重用原则</h4><p><code>Common Reuse Principle (CRP)</code><br>包的所有类被一起重用。如果你重用了其中的一个类，就重用全部。换个说法是，没有被一起重用的类不应该被组合在一起。CRP原则帮助我们决定哪些类应该被放到同一个包里。依赖一个包就是依赖这个包所包含的一切。当一个包发生了改变，并发布新的版本，使用这个包的所有用户都必须在新的包环境下验证他们的工作，即使被他们使用的部分没有发生任何改变。因为如果包中包含有未被使用的类，即使用户不关心该类是否改变，但用户还是不得不升级该包并对原来的功能加以重新测试。</p><p>CCP则让系统的维护者受益。CCP让包尽可能大（CCP原则加入功能相关的类），CRP则让包尽可能小（CRP原则剔除不使用的类）。它们的出发点不一样，但不相互冲突。</p><h4 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h4><p><code>Hollywood Principle</code><br>好莱坞原则就是一句话——“don’t call us, we’ll call<br>you.”。意思是，好莱坞的经纪人们不希望你去联系他们，而是他们会在需要的时候来联系你。也就是说，所有的组件都是被动的，所有的组件初始化和调用都由容器负责。组件处在一个容器当中，由容器负责管理。</p><p>简单的来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在：</p><pre><code>不创建对象，而是描述创建对象的方式。在代码中，对象与服务没有直接联系，而是容器负责将这些联系在一起。</code></pre><p>控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。</p><p>好莱坞原则就是IoC（Inversion of Control）或DI（Dependency Injection）的基础原则。这个原则很像依赖倒置原则，依赖接口，而不是实例，但是这个原则要解决的是怎么把这个实例传入调用类中？你可能把其声明成成员，你可以通过构造函数，你可以通过函数参数。但是<br>IoC可以让你通过配置文件，一个由Service Container<br>读取的配置文件来产生实际配置的类。但是程序也有可能变得不易读了，程序的性能也有可能还会下降。</p><h4 id="高内聚低耦合"><a href="#高内聚低耦合" class="headerlink" title="高内聚低耦合"></a>高内聚低耦合</h4><p><code>【 High Cohesion &amp; Low/Loose coupling &amp; – 高内聚， 低耦合 】</code></p><ul><li>这个原则是UNIX操作系统设计的经典原则，把模块间的耦合降到最低，而努力让一个模块做到精益求精。<ul><li>内聚：一个模块内各个元素彼此结合的紧密程度</li><li>耦合：一个软件结构内不同模块之间互连程度的度量</li></ul></li><li>内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身</li></ul><blockquote><p>凝聚&gt;松耦合&gt;重用  <a href="http://www.jdon.com/forum/messageList.shtml?thread=45977#23144139" target="_blank" rel="noopener">参考博客: 为什么我停止使用Spring?</a></p></blockquote><h4 id="惯例优于配置原则"><a href="#惯例优于配置原则" class="headerlink" title="惯例优于配置原则"></a>惯例优于配置原则</h4><p><code>Convention over Configuration（CoC）</code><br>简单点说，就是将一些公认的配置方式和信息作为内部缺省的规则来使用。例如，Hibernate的映射文件，如果约定字段名和类属性一致的话，基本上就可以不要这个配置文件了。你的应用只需要指定不convention的信息即可，从而减少了大量convention而又不得不花时间和精力啰里啰嗦的东东。配置文件很多时候相当的影响开发效率。</p><p>Rails 中很少有配置文件（但不是没有，数据库连接就是一个配置文件），Rails 的fans号称期开发效率是 java 开发的 10<br>倍，估计就是这个原因。Maven也使用了CoC原则，当你执行mvn<br>-compile命令的时候，不需要指源文件放在什么地方，而编译以后的class文件放置在什么地方也没有指定，这就是CoC原则。</p><h4 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a>关注点分离</h4><p><code>Separation of Concerns (SoC)</code></p><blockquote><p>　是计算机科学中最重要的努力目标之一。这个原则，就是在软件开发中，通过各种手段，将问题的各个关注点分开。如果一个问题能分解为独立且较小的问题，就是相对较易解决的。<br>问题太过于复杂，要解决问题需要关注的点太多，而程序员的能力是有限的，不能同时关注于问题的各个方面。正如程序员的记忆力相对于计算机知识来说那么有限一样，<br>程序员解决问题的能力相对于要解决的问题的复杂性也是一样的非常有限。在我们分析问题的时候，如果我们把所有的东西混在一起讨论，那么就只会有一个结果——乱。</p></blockquote><p>我记得在上一家公司有一个项目，讨论就讨论了1年多，项目本来不复杂，但是没有使用SoC，全部的东西混为一谈，再加上一堆程序员注入了各种不同的观点和想法，整个项目一下子就失控了。<br>最后，本来一个1年的项目做了3年。</p><p>实现关注点分离的方法主要有两种，一种是标准化，另一种是抽象与包装。标准化就是制定一套标准，让使用者都遵守它，将人们的行为统一起来，这样使用标准的人就不用担心别人会有很多种不同的实现，使自己的程序不能和别人的配合。<br>JavaEE就是一个标准的大集合。每个开发者只需要关注于标准本身和他所在做的事情就行了。就像是开发镙丝钉的人只专注于开发镙丝钉就行了，而不用关注镙帽是怎么生产的，反正镙帽和镙丝钉按标来就一定能合得上。不断地把程序的某些部分抽像差包装起来，也是实现关注点分离的好方法。<br>一旦一个函数被抽像出来并实现了，那么使用函数的人就不用关心这个函数是如何实现的，同样的，一旦一个类被抽像并实现了，类的使用者也不用再关注于这个类的内部是如何实现的。<br>诸如组件，分层，面向服务，等等这些概念都是在不同的层次上做抽像和包装，以使得使用者不用关心它的内部实现细节。<br>说白了还是“高内聚，低耦合”。</p><blockquote><p><a href="http://www.cnblogs.com/wenhongyu/p/7992028.html" target="_blank" rel="noopener">参考博客: 理论篇：关注点分离(Separation of concerns, SoC)</a></p></blockquote><h4 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h4><p><code>Design by Contract (DbC)</code><br>DbC的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。例如：</p><pre><code>供应商必须提供某种产品（责任），并且他有权期望客户已经付款（权利）。客户必须付款（责任），并且有权得到产品（权利）。契约双方必须履行那些对所有契约都有效的责任，如法律和规定等。</code></pre><p>同样的，如果在程序设计中一个模块提供了某种功能，那么它要：</p><pre><code>期望所有调用它的客户模块都保证一定的进入条件：这就是模块的先验条件（客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况）。保证退出时给出特定的属性：这就是模块的后验条件——（供应商的义务，显然也是客户的权利）。在进入时假定，并在退出时保持一些特定的属性：不变式。</code></pre><p>契约就是这些权利和义务的正式形式。我们可以用“三个问题”来总结DbC，并且作为设计者要经常问：</p><pre><code>它期望的是什么？它要保证的是什么？它要保持的是什么？</code></pre><p>根据Bertrand<br>Meyer氏提出的DBC概念的描述，对于类的一个方法，都有一个前提条件以及一个后续条件，前提条件说明方法接受什么样的参数数据等，只有前提条件得到满足时，这个方法才能被调用；同时后续条件用来说明这个方法完成时的状态，如果一个方法的执行会导致这个方法的后续条件不成立，那么这个方法也不应该正常返回。</p><p>现在把前提条件以及后续条件应用到继承子类中，子类方法应该满足：</p><pre><code>前提条件不强于基类．后续条件不弱于基类．</code></pre><p>换句话说，通过基类的接口调用一个对象时，用户只知道基类前提条件以及后续条件。因此继承类不得要求用户提供比基类方法要求的更强的前提条件，亦即，继承类方法必须接受任何基类方法能接受的任何条件（参数）。同样，继承类必须顺从基类的所有后续条件，亦即，继承类方法的行为和输出不得违反由基类建立起来的任何约束，不能让用户对继承类方法的输出感到困惑。</p><p>这样，我们就有了基于契约的LSP，基于契约的LSP是LSP的一种强化。</p><h4 id="无环依赖原则"><a href="#无环依赖原则" class="headerlink" title="无环依赖原则"></a>无环依赖原则</h4><p><code>Acyclic Dependencies Principle (ADP)</code><br>包之间的依赖结构必须是一个直接的无环图形，也就是说，在依赖结构中不允许出现环（循环依赖）。如果包的依赖形成了环状结构，怎么样打破这种循环依赖呢？有2种方法可以打破这种循环依赖关系：第一种方法是创建新的包，如果A、B、C形成环路依赖，那么把这些共同类抽出来放在一个新的包D里。这样就把C依赖A变成了C依赖D以及A依赖D，从而打破了循环依赖关系。第二种方法是使用DIP（依赖倒置原则）和ISP（接口分隔原则）设计原则。</p><p>无环依赖原则（ADP）为我们解决包之间的关系耦合问题。在设计模块时，不能有循环依赖。</p><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><p><a href="https://java-design-patterns.com/" target="_blank" rel="noopener">java design patterns</a></p></blockquote><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><blockquote><p><a href="http://www.cnblogs.com/x-xk/archive/2013/01/21/2864916.html" target="_blank" rel="noopener">设计模式基础</a><br><a href="http://www.baike.com/wiki/GoF" target="_blank" rel="noopener">参考博客: GoF解释</a><br><a href="http://blog.csdn.net/column/details/zsxdesignpattern.html" target="_blank" rel="noopener">参考博客: 设计模式专栏</a></p></blockquote><blockquote><p><a href="http://blog.csdn.net/u011240877/article/details/45381071" target="_blank" rel="noopener">23种经典设计模式UML类图汇总 </a><br><a href="http://blog.csdn.net/chen4013874/article/details/51347535" target="_blank" rel="noopener">参考博客: 23种设计模式UML表示形式</a><br><a href="http://blog.csdn.net/tingting256/article/details/52534663" target="_blank" rel="noopener">参考博客: 23中设计模式类图和原理详解</a><br><a href="http://blog.csdn.net/qq_25827845/article/details/52510803" target="_blank" rel="noopener">参考博客: 23种设计模式类图总结 </a> </p></blockquote><h3 id="策略者模式"><a href="#策略者模式" class="headerlink" title="策略者模式"></a>策略者模式</h3><blockquote><p>定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。<br><a href="http://blog.csdn.net/hguisu/article/details/7558249" target="_blank" rel="noopener">参考博客: 设计模式 ( 十八 ) 策略模式Strategy（对象行为型） </a><br><a href="http://www.cnblogs.com/zdd-java/p/6143935.html" target="_blank" rel="noopener">参考博客: Java消除ifelse</a></p></blockquote><p>也就是说将一种需求的多种实现算法分别封装起来, 然后利用多态, 让调用方选择任一实现</p><h3 id="1-创建型设计模式"><a href="#1-创建型设计模式" class="headerlink" title="1.创建型设计模式"></a>1.创建型设计模式</h3><blockquote><p>单例模式(Singleton)<br>原型模式(Prototype)<br>建造者(Builder)<br>抽象工厂(Abstract Factory)<br>工厂方法(Factory Method)   </p></blockquote><ul><li>抽象了实例化过程，它们帮助一个系统独立于如何创建，组合和表示它的那些对象。</li><li>一个类创建型模型使用继承改变被实例化的类，而一个对象创建型模型将实例化委托给另一个对象</li><li>将一组固定行为的硬编码转移为定义一个较小的基本行为集，这些行为可以被组合成任意数目的更复杂性的行为。这样创建有特定行为的对象要求的不仅仅是实例化一个类</li></ul><p><em>Builder</em></p><ul><li>生成器 Builder，是一种对象构建模式，模式通常包含Builder，ConcreteBuilder。Director 和 Product四部分</li></ul><p><em>Abstract Factory</em></p><ul><li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</li></ul><p><em>Factory Method</em></p><ul><li>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类</li></ul><p><em>Prototype</em></p><ul><li>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 </li></ul><p><em>Singleton</em></p><ul><li>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li></ul><h3 id="2-结构型设计模式"><a href="#2-结构型设计模式" class="headerlink" title="2.结构型设计模式"></a>2.结构型设计模式</h3><blockquote><p>适配器模式(<strong>Adapter</strong>)<br>桥接模式(<strong>Bridge</strong>)<br>组合模式(<strong>Compontent</strong>)<br>代理模式(<strong>Proxy</strong>)<br>享元模式(<strong>Flyweight</strong>)<br>外观模式(<strong>Facade</strong>)<br>装饰模式(<strong>Decorator</strong>)  </p></blockquote><ul><li>结构型设计模式涉及如何组合类和对象以获得更大的结构</li><li>结构型模式采用继承机制来组合接口或实现。</li><li>结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能</li></ul><hr><ul><li><strong>Composite模式</strong><br>它将对象组合成树形结构以表示“部分-整体”</li><li><strong>Flyweight模式</strong><br>该模式为共享对象定义了一个结构，强调对象的空间效率，自由共享</li><li><p><strong>Facade模式</strong>（外观模式）<br>描述了如何用单个对象表示整个子系统（外部与其内部通信必须通过一个统一的对象进行交互），模式中的facade用来表示一组对象，<br>外观设计模式提供一个高层次的接口是的子系统易于使用。<br><strong>适用情况:</strong></p><blockquote><p> 1.为复杂的子系统提供一个简单的接口<br> 2.客户程序与抽象类的实现部分有很大依赖性<br> 3.构建一个层次结构的子系统时，适用外观模式定义子系统每层的入口</p></blockquote></li><li><p><strong>Bridge模式</strong> 将对象的抽象和实现分离，从而可以独立的改变他们。</p></li><li><strong>Decorator模式</strong><br>描述如何动态地为对象添加职责，模式采用递归方式组合对象，从而允许添加任意多的对象职责。</li></ul><h3 id="3-行为设计模式"><a href="#3-行为设计模式" class="headerlink" title="3.行为设计模式"></a>3.行为设计模式</h3><blockquote><p>策略模式(<strong>Strategy</strong>)<br>命令模式(<strong>Command</strong>)<br>状态模式(<strong>State</strong>)<br>解释器模式(<strong>Interpreter</strong>)<br>模板方法(<strong>Template Method</strong>)<br>责任链模式(<strong>Chain of Responsibility</strong>)<br>迭代器模式(<strong>Iterator</strong>)<br>中介者模式(<strong>Mediator</strong>)<br>备忘录模式(<strong>Memento</strong>)<br>观察者模式(<strong>Observe</strong>)<br>访问者模式(<strong>Visitor</strong>)  </p></blockquote><ul><li>行为设计模式涉及算法和对象间职责的分配，行为模式描述对象和类的模式以及其通信模式</li><li>行为模式使用继承机制在类间派发行为</li></ul><hr><h3 id="【常见设计模式】"><a href="#【常见设计模式】" class="headerlink" title="【常见设计模式】"></a>【常见设计模式】</h3><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><ul><li><strong>适配器 模式</strong>（Adapter）：适配器是的一个接口与其他接口兼容，从而给出了多个不同接口的同一抽象。一般分类结构和对象结构两种：</li><li><em>类适配器</em>：适配器类继承被适配类，实现某个接口，在客户端类中可以根据需求来建立子类</li><li><em>对象适配器</em>：适配器不是继承，是使用直接关联，或称委托方式<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/UML/Adapter.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><ul><li><strong>中介者 模式</strong>：包装了一系列对象相互作用的方式，使得对象间的相互作用是独立变化，但是与中介者紧密联系</li></ul><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ul><li><strong>观察者 模式 Observer</strong>：一个目标物件管理相依于它的管理物件，并且在它本身的状态发生改变时发出通知，这种模式常用来实现事件处理系统。（也称发布-订阅，模型-视图，源-收听者模式）<ul><li>观察者（接口）：更新信息，展示信息，给 <strong>被观察者（形参）</strong> 注册上观察者</li><li>被观察者（接口）：发出更新通知（遍历观察者集合并注册），当自身发生改动时发出通知消息</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Observer.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><blockquote><p>Singleton 一个类只有一个实例易于外界访问 Spring将该模式运用的出神入化</p></blockquote><ul><li><a href="http://www.cnblogs.com/atwanli/articles/5104898.html" target="_blank" rel="noopener">单例模式与高并发</a>当某个单例对象中含有不具有并发性的对象 就会发生并发问题, 由于只有一个对象, 为了确保数据一致, 就需要加锁, 这样就带来了严重的性能下降, 而Spring是怎么做的呢<ul><li><a href="https://blog.csdn.net/java_fancy/article/details/7439657" target="_blank" rel="noopener">参考博客 Spring如何处理线程并发</a></li><li><a href="https://bbs.csdn.net/topics/390873889" target="_blank" rel="noopener">参考博客: springmvc是单例的，开发的时候会不会影响性能呢？</a></li><li><a href="http://www.xuebuyuan.com/1628190.html" target="_blank" rel="noopener">参考博客: Spring并发访问的线程安全性问题</a> <code>Controller或者Service层中定义共享对象, 但是使用线程安全对象</code></li></ul></li></ul><blockquote><p><a href="https://bbs.csdn.net/topics/310136305" target="_blank" rel="noopener">参考博客: 单例模式和Static的区别! </a> </p><ul><li style="list-style: none"><input type="checkbox"> <code>static 有可能被实例化多个出来么</code></li></ul></blockquote><h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h5><ul><li><strong>装饰器模式</strong> 创建一个新类为某一个类动态添加新功能或增强原有的功能，避免代码重复或具体子类的数量增加</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Decorator.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>策略模式</strong> 优点：灵活添加同一问题的不同解决方案</li><li><strong>状态模式</strong> 允许对象在内部状态时变更其行为，并且修改其类：<ul><li>环境类（Context）：定义客户感兴趣的接口，维护一个子类的实例，这个实例就是当前状态</li><li>抽象状态类（State）：定义一个接口以封装与Context的一个特定状态相关的行为</li><li>具体状态类（concreteState）：每一子类实现与Context的一个状态相关的行为</li><li><strong>例题</strong>：纸巾售卖机:有四个状态!<ul><li>【状态图】</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/State_zhijin.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>【类图】</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/State_zhijin2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul></li><li><strong>例题</strong>：TCP连接状态:<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/State_TCP.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul></li><li><strong>命令模式 command</strong>：<ul><li>行为请求者 与 请求实现者 之间 紧耦合 的关系</li><li><strong>将一个请求封装成一个对象</strong>，从而可用不同的请求对客户进行参数化，支持可撤销的操作</li><li>下例：使用了接口来实现多态，子类是多个的，方法同名并功能多样的<ul><li>代码复用好，代码结构清晰【参数类表最好不要出现标志变量，最好分离出另一个方法】</li></ul></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Command.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>桥接模式</strong> ： 便于扩展，实现与抽象分离（解耦）对一个模块修改不影响别的模块</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Bridge.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>抽象工厂模式</strong> ： 提供一个创建一系列相关实例相互依赖的对象。<ul><li>当一个系统要独立于它的产品的创建，组合和表示时</li><li>当一个系统要由多个产品系列中的一个来配置时</li><li>当需强调一系列相关的产品对象的设计以便进行联合使用时</li><li>想提供一组对象而不显示他们的实现过程，只显示他们的接口</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/AbstractFactory.png" alt=""></p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><blockquote><p>struts2 就是采用该模式</p><ul><li><strong>原型模式</strong> ： 对象创建模型： 允许一个对象创建另一个可定制的对象，封装实例化细节。<ul><li>实现Cloneable接口（Java自带接口），重写clone方法（在这里实例化对象，new或反射，按需求来修改）</li><li>该例，组合关系，在对方使用clone来代替构造器来实例化对象，并做好了绑定操作，大量减少代码量</li></ul></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Clone.png" alt=""> </p><h4 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h4><ul><li><strong>生成器模式</strong>：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Builder.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><ul><li><a href="https://www.ibm.com/developerworks/cn/java/design/" target="_blank" rel="noopener">IBM 社区 Java 设计模式专题</a></li><li><a href="http://www.cnblogs.com/x-xk/archive/2012/12/21/2823401.html" target="_blank" rel="noopener">一个鸭子游戏引发的设计（多态，继承，抽象，接口，策略者模式）</a></li><li><p><a href="www.cnblogs.com/x-xk/archive/2013/01/06/2830742.html">不要再盲目的new了！你要学着针对接口编程！（具体方法，Factory，Abstract Factory</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/aGMz1u0Oh4ZHTDBFvgq0lg" target="_blank" rel="noopener">参考博客: 为什么我墙裂建议大家使用枚举来实现单例。</a></p></li><li style="list-style: none"><input type="checkbox"> 自己用Java重写一下这个例子, 并做出自己的总结</li></ul><p>反模式<br>末日金字塔: 多层嵌套</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#设计模式之禅&quot;&gt;设计模式之禅&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#软件设计的一些原则&quot;&gt;软件设计的一些原则&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#思维原则&quot;&gt;思维
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringbootDatabase.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Java-Spring-SpringbootDatabase/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Java-Spring-SpringbootDatabase/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#数据库模块">数据库模块</a><ol><li><a href="#relational-database">Relational Database</a><ol><li><a href="#多数据源配置">多数据源配置</a></li><li><a href="#连接池">连接池</a><ol><li><a href="#c3p0">c3p0</a></li><li><a href="#druid">druid</a></li><li><a href="#hikaripool">HikariPool</a></li></ol></li><li><a href="#jpa">JPA</a><ol><li><a href="#configuration">Configuration</a></li></ol></li><li><a href="#mybatis">Mybatis</a><ol><li><a href="#自定义查询">自定义查询</a><ol><li><a href="#hql">HQL</a></li><li><a href="#原生sql">原生SQL</a></li></ol></li><li><a href="#mysql">Mysql</a></li><li><a href="#映射关系">映射关系</a><ol><li><a href="#一对一">一对一</a></li><li><a href="#一对多">一对多</a></li><li><a href="#多对多">多对多</a></li></ol></li></ol></li><li><a href="#restful设计">Restful设计</a><ol><li><a href="#特别注意">【特别注意】</a></li></ol></li><li><a href="#jpa数据分页">Jpa数据分页</a></li><li><a href="#数据库上的事务支持">数据库上的事务支持</a></li></ol></li><li><a href="#non-relational-database">Non Relational database</a><ol><li><a href="#jpa">JPA</a><ol><li><a href="#redis的简单使用">Redis的简单使用</a></li><li><a href="#关于stringredistemplate的方法使用">关于StringRedisTemplate的方法使用</a></li><li><a href="#消息订阅和发布">消息订阅和发布</a></li></ol></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="数据库模块"><a href="#数据库模块" class="headerlink" title="数据库模块"></a>数据库模块</h1><blockquote><p>主要是采用的JPA，极大的缩减了代码量，但是要注意不要过度依赖框架，丧失了基本的能力</p></blockquote><h2 id="Relational-Database"><a href="#Relational-Database" class="headerlink" title="Relational Database"></a>Relational Database</h2><h3 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h3><blockquote><p>为什么要有多数据源? 思考</p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/34730e595a8c" target="_blank" rel="noopener">Spring Boot多数据源配置与使用</a></p></blockquote><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h4 id="c3p0"><a href="#c3p0" class="headerlink" title="c3p0"></a>c3p0</h4><ul><li><a href="http://www.cnblogs.com/520playboy/p/7526252.html" target="_blank" rel="noopener">参考博客</a></li></ul><h4 id="druid"><a href="#druid" class="headerlink" title="druid"></a>druid</h4><ul><li><a href="http://makaidong.com/L_Sail/1/40930_11573921.html" target="_blank" rel="noopener">druid连接池的配置</a></li></ul><h4 id="HikariPool"><a href="#HikariPool" class="headerlink" title="HikariPool"></a>HikariPool</h4><blockquote><p>性能最好的数据库连接池</p></blockquote><ul><li style="list-style: none"><input type="checkbox"> 听说代码很精简, 阅读源码学习</li></ul><hr><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><blockquote><p>连接池:1.x 默认是tomcat-jdbc连接池 2.x 是 HikariPool</p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/3b31270a44b1" target="_blank" rel="noopener">参考博客: spring boot2 整合（二）JPA</a></p></blockquote><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/htmlsingle/#howto-configure-jpa-properties" target="_blank" rel="noopener">Official Doc</a><br><strong><code>ddl-auto</code></strong></p><ul><li>JPA 默认是该配置 <code>spring.jpa.hibernate.ddl-auto</code></li><li>但是如上配置没有生效的话就要用 这个 <code>spring.jpa.properties.hibernate.hbm2ddl.auto</code> <ol><li>none 什么都不做</li><li>create-only </li><li>create 先删除, 然后建立新的表</li><li>create-drop 先删除, 然后建立新的表, 然后在SessionFactory实例关闭后再删除</li><li>update 创建和修改</li><li>validate 校验是否一致, 不一致就报错,启动失败</li></ol></li></ul></blockquote><ul><li><p><a href="http://blog.csdn.net/Amy_Queen/article/details/72454099" target="_blank" rel="noopener">Blog: 原生SQL的写法</a></p></li><li><p>[ ] 怎么映射视图到实体上?</p></li></ul><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><blockquote><p><a href="https://blog.csdn.net/juewang_love/article/details/53769906" target="_blank" rel="noopener">IDEA下创建Springboot，thymeleaf，Mybatis，Postgresql，Gradle项目</a></p></blockquote><h4 id="自定义查询"><a href="#自定义查询" class="headerlink" title="自定义查询"></a>自定义查询</h4><h5 id="HQL"><a href="#HQL" class="headerlink" title="HQL"></a>HQL</h5><ul><li>使用Hibernate语法模式,将对象和数据库的表看成一个实体,方便书写SQL,但是在Controller层和Service层<ul><li>进行写代码的时候,参数的传递全是实体对象,要不停的new,这样真的没问题么(当有各种复杂的关联关系的时候,单个对象的CURD基本没有什么问题)</li><li><code>TODO</code> 所以还不如直接写原生SQL! 那么JPA就真的没有使用的必要性了,直接用Mybatis结合插件生成自动的CRUD的代码,这样更为轻量</li><li>待后续使用后再回来填坑</li></ul></li></ul><h5 id="原生SQL"><a href="#原生SQL" class="headerlink" title="原生SQL"></a>原生SQL</h5><ul><li>涉及到数据的修改,就要加上前两个前缀,查询就直接写Query注解即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Query</span>(value = <span class="string">"update a set b=?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><ul><li><p>1.引入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-data-jpa'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-jdbc'</span>)</span><br><span class="line">runtime(<span class="string">'mysql:mysql-connector-java'</span>)</span><br></pre></td></tr></table></figure></li><li><p>2.继承接口，打好实体类的注解 @Entity </p></li><li><p>3.<em>切记 属性名不能使用下划线（数据库风格）不然写声明方法就会报错，jpa只是看下划线前半部分，会说找不到属性</em></p><ul><li>jpa在创建表时会把驼峰命名改成数据库风格的形式</li></ul></li><li><p>4.jpa是声明特定方法的接口，让jpa来实现并自动注入，如果是没有的方法，就可以使用@Query注解</p><ul><li>默认使用的是HQL（HQL是基于类的所以使用的是类的名字不是表的名字），可以设置下使用原生SQL</li></ul></li></ul><h4 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h4><h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><blockquote><p>据说这是性能最好的方式, 但是有一点让人不舒服, A的id是名存实亡的, 数据库都没有这个字段, 实际上就是B的id, 但是对象又一定要保留这个id, 不然约束通不过<br>也就是说, 创建的时候要设置A的id的值, 但是后面却用不到这个值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@OneToOne</span>(fetch = FetchType.LAZY)</span><br><span class="line">  <span class="meta">@MapsId</span></span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h5><ul><li><p>一方的配置是当前类的id，多方则按基本ER的规则来，注解中配置的是外键的名字, 所以当前类中的属性,外键名是不能重复的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 一方</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOne</span></span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String testOneId;</span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"testOneId"</span>)<span class="comment">//这个名字可以重复，最终会有一个随机码生成</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;TestMany&gt; testManySet;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 多方</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMany</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String testManyId;</span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"testOneId"</span>)</span><br><span class="line">    <span class="keyword">private</span> TestOne testOneId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>[ ] 问题: 当两个表互相引用了, 需要修改表结构 ,怎么删除重建两张表结构, 简单的命令会陷入死锁</p></li></ul><hr><h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><hr><h3 id="Restful设计"><a href="#Restful设计" class="headerlink" title="Restful设计"></a>Restful设计</h3><ul><li>1.添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-rest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2.引入自动配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestConfiguration</span> <span class="keyword">extends</span> <span class="title">RepositoryRestMvcConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RepositoryRestConfiguration <span class="title">config</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.config();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProfileResourceProcessor <span class="title">profileResourceProcessor</span><span class="params">(RepositoryRestConfiguration config)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置rest根目录是应用路径下的路径 : localhost:8080/rest</span></span><br><span class="line">        config.setBasePath(<span class="string">"/rest"</span>);</span><br><span class="line">        <span class="comment">// 允许输出id</span></span><br><span class="line">        config.exposeIdsFor(Goods.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.profileResourceProcessor(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3.配置repository的名字例如：（只要配置repository就能用REST了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RepositoryRestResource</span>(path = <span class="string">"book"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Book</span>,<span class="title">Long</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>4.启动应用，控制台有如下输出</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Java/Spring/output.png" alt="输出" title="">                </div>                <div class="image-caption">输出</div>            </figure></li><li><p>所有路径的使用方法：</p><ul><li><code>GET</code> 查询单个 <code>/repo/id</code> 成功：200 失败404</li><li><code>GET</code> 查询所有 <code>/repo</code> 成功200 失败404</li><li><code>POST</code> 新增 <code>/repo</code> json数据发送 成功 201 失败404</li><li><code>DELETE</code> 删除 <code>/repo/id</code> json数据 成功204 失败404</li><li><code>PUT</code> 更新 <code>/repo/id</code> json 更新成功200 没有该id就插入201 失败404（使用主键自动增长就不会遇到404）</li></ul></li></ul><h4 id="【特别注意】"><a href="#【特别注意】" class="headerlink" title="【特别注意】"></a>【特别注意】</h4><ul><li>rest得到的数据没有id<ul><li>添加配置 <code>config.exposeIdsFor(Goods.class);</code> 即可查看到id <a href="http://tommyziegler.com/how-to-expose-the-resourceid-with-spring-data-rest/" target="_blank" rel="noopener">参考博客</a></li></ul></li></ul><h3 id="Jpa数据分页"><a href="#Jpa数据分页" class="headerlink" title="Jpa数据分页"></a>Jpa数据分页</h3><blockquote><p><a href="https://www.tianmaying.com/tutorial/spring-jpa-page-sort" target="_blank" rel="noopener">参考博客</a></p></blockquote><ul><li>分页 page 从0开始 size是个数 sort可以不需要（如果本来就是id排序就没必要了） <ul><li>原理就是 预编译SQL然后查询总数，然后再执行 必须有两条SQL执行</li></ul></li><li>查询的结果不包含实体的id属性</li></ul><h3 id="数据库上的事务支持"><a href="#数据库上的事务支持" class="headerlink" title="数据库上的事务支持"></a>数据库上的事务支持</h3><ul><li>JPA对所有默认方法都开启了事务支持，查询类事务默认启用readOnly=true</li></ul><hr><h2 id="Non-Relational-database"><a href="#Non-Relational-database" class="headerlink" title="Non Relational database"></a>Non Relational database</h2><h3 id="JPA-1"><a href="#JPA-1" class="headerlink" title="JPA"></a>JPA</h3><h4 id="Redis的简单使用"><a href="#Redis的简单使用" class="headerlink" title="Redis的简单使用"></a>Redis的简单使用</h4><p><em>配置连接信息</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=127.0.0.1</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）0不超时</span><br><span class="line">spring.redis.timeout=0</span><br></pre></td></tr></table></figure></p><p><code>在一个配置类中复制如下代码即可使用 StringRedisTemplate RedisTemplate 的实例</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object,Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 值序列化采用 jackson2JsonRedisSerializer</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 键序列化采用 StringRedisSerializer</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">StringRedisTemplate <span class="title">template</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringRedisTemplate(connectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">`两个对象的简单使用`</span><br><span class="line">```java</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"aaa"</span>, <span class="string">"hello"</span>);</span><br><span class="line">    String result = stringRedisTemplate.opsForValue().get(<span class="string">"aaa"</span>);</span><br><span class="line">    <span class="comment">//获取所有</span></span><br><span class="line">    Set&lt;String&gt; keysList =  stringRedisTemplate.keys(<span class="string">"*"</span>);</span><br><span class="line">    <span class="keyword">for</span>(String temp :keysList)&#123;</span><br><span class="line">        log.info(temp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>以上配置的template都是只是建立在最简单的键值对上，String-String，所以对象使用的是json来存储</li><li>但是使用的时候如同使用MySQL一样，是ORM框架自动处理数据的转换</li></ul><h4 id="关于StringRedisTemplate的方法使用"><a href="#关于StringRedisTemplate的方法使用" class="headerlink" title="关于StringRedisTemplate的方法使用"></a>关于StringRedisTemplate的方法使用</h4><ul><li><p>常见数据类型的中间对象</p><ul><li>opsForValue() 操作简单键值对数据<ul><li>hasKey()</li></ul></li><li>opsForHash() 操作含有hash的数据</li><li>opsForList() 操作含有list的数据</li><li>opsForZSet() 操作含有zset（有序）的数据<ul><li>range()方法返回指定范围的数据 Java中Set类型的（诡异的是顺序保持了一致）</li></ul></li><li>opsForSet() 操作含有set的数据</li></ul></li><li><p>设置超时时间</p><ul><li><code>redisTemplate.expire(&quot;max&quot;,tempTime,TimeUnit.SECONDS);</code></li></ul></li></ul><h4 id="消息订阅和发布"><a href="#消息订阅和发布" class="headerlink" title="消息订阅和发布"></a>消息订阅和发布</h4><p><a href="https://www.tianmaying.com/tutorial/springboot-redis-message" target="_blank" rel="noopener">参考博客: Spring Boot使用Redis进行消息的发布订阅</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#数据库模块&quot;&gt;数据库模块&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#relational-database&quot;&gt;Relational Database&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringSecurity.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Java-Spring-SpringSecurity/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Java-Spring-SpringSecurity/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#springsecurity">SpringSecurity</a><ol><li><a href="#配置">配置</a><ol><li><a href="#配置静态口令使用">配置静态口令使用</a></li></ol></li></ol></li><li><a href="#使用该配置即可自定义用户名密码">使用该配置即可自定义用户名密码</a><ol><li><a href="#springboot的集成demo">SpringBoot的集成Demo</a><ol><li><a href="#创建单用户单角色的安全控制">创建单用户单角色的安全控制</a></li><li><a href="#多用户多角色的实现思路">多用户多角色的实现思路</a><ol><li><a href="#每个身份都使用一个登录实体类">每个身份都使用一个登录实体类</a></li><li><a href="#另一种思路">另一种思路：</a></li></ol></li></ol></li><li><a href="#jwt">JWT</a><ol><li><a href="#跨域问题">跨域问题</a></li></ol></li><li><a href="#oauth">Oauth</a></li><li><a href="#实现细节">实现细节</a><ol><li><a href="#关于注解的几种使用方式">关于注解的几种使用方式</a><ol><li><a href="#@secured">@Secured</a></li><li><a href="#@rolesallowed">@RolesAllowed</a></li><li><a href="#springsecurity30-开始提供了-spel表达式">SpringSecurity3.0 开始提供了 SpEL表达式</a></li></ol></li><li><a href="#保护方法应用">保护方法应用</a></li></ol></li><li><a href="#社交登录">社交登录</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><blockquote><p><a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle" target="_blank" rel="noopener">Spring Security 5.0.6 doc</a></p></blockquote><p><a href="http://www.spring4all.com/article/428" target="_blank" rel="noopener">参考博客: Spring Security 入门系列</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置静态口令使用"><a href="#配置静态口令使用" class="headerlink" title="配置静态口令使用"></a>配置静态口令使用</h3><p>当添加了Security依赖之后, 只会生成一个默认的随机密码, 如下简单配置:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用该配置即可自定义用户名密码</span></span><br><span class="line">spring.security.user.name=admin</span><br><span class="line">spring.security.user.password=secret</span><br></pre></td></tr></table></figure></p><p>如果要用 curl 访问则是 <code>curl -i  -u admin:secret  http://tomcat.kcp/hi</code>  </p><blockquote><p>注意 : 前提是要关闭 crsf 校验<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.csrf().disable();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="SpringBoot的集成Demo"><a href="#SpringBoot的集成Demo" class="headerlink" title="SpringBoot的集成Demo"></a>SpringBoot的集成Demo</h2><h3 id="创建单用户单角色的安全控制"><a href="#创建单用户单角色的安全控制" class="headerlink" title="创建单用户单角色的安全控制"></a>创建单用户单角色的安全控制</h3><ol><li>Gradle : <code>compile(&#39;org.springframework.boot:spring-boot-starter-security&#39;)</code></li><li><a href="https://gitee.com/kcp1104/codes/n2berl0tfg8wq9s4ko7xa78#SecurityConfig.java" target="_blank" rel="noopener">Security主要配置类</a></li><li><a href="https://gitee.com/kcp1104/codes/n2berl0tfg8wq9s4ko7xa78#Reader.java" target="_blank" rel="noopener">登录实体类</a></li><li>Jpa实现的Dao层 <code>public interface ReaderRepository extends JpaRepository&lt;Reader, String&gt; {}</code></li></ol><hr><h3 id="多用户多角色的实现思路"><a href="#多用户多角色的实现思路" class="headerlink" title="多用户多角色的实现思路"></a>多用户多角色的实现思路</h3><ul><li><p>使用多个实体类（实现了UserDetails接口），一个权限类，再一个多对多连接，就得到了多用户，多权限的控制</p><ul><li>在页面上加上角色的判断来控制数据显示，业务操作等功能</li></ul></li><li><p>根据书上案例代码，可以得出结论，用户表，角色表，用户角色关联表，用户表是可以多张的，角色公用一张即可，然后关联表也对应的多张，就能实现具体的业务需求</p><ul><li>例如：一个网上在线阅读书城，作家和读者以及编辑，网站后台管理员等角色的不同权限对应的页面甚至页面上细分的各个模块</li><li><code>Author</code> <code>Admin</code> <code>Reader</code> 三个类</li></ul></li><li><code>继承了UserDetails接口的实体类的配置</code> <a href="https://gitee.com/kcp1104/codes/n2berl0tfg8wq9s4ko7xa78#Readers.java" target="_blank" rel="noopener">代码片段</a></li></ul><h4 id="每个身份都使用一个登录实体类"><a href="#每个身份都使用一个登录实体类" class="headerlink" title="每个身份都使用一个登录实体类"></a>每个身份都使用一个登录实体类</h4><ul><li>然后使用不同的dao层查询，显然的实体类登录查询的效率及其低且不易扩展</li><li>设置好<code>spirng.jpa.hibernate.ddl-auto=update</code></li><li>第一次运行还会有没有实体对应的表这样的提示,说明了他正在根据多对多映射创建实体表，也体现了这个多种用户模式下需要实体等量的连接表</li><li>所以这个是要查询多张表了<ul><li>（除非UserDetailService接口的loadUserByUsername能收到表类别的参数）</li><li>也可以考虑使用一个字符串，然后用<code>特殊字符</code>把类型放进去，然后正则取出来</li><li>登录页面就需要自定义一个函数进行拼接（或者使用校验来拼接？）</li></ul></li></ul><h4 id="另一种思路："><a href="#另一种思路：" class="headerlink" title="另一种思路："></a>另一种思路：</h4><ul><li>使用一个登录用户表（序列id，用户名，密码，用户编码（对应多张表））<ul><li>角色表（序列id，用户编码，角色） </li><li>这样的话扩展就只要加表，使用同一个主键生成策略就可以了</li></ul></li></ul><blockquote><ul><li>思考：</li><li>其实这个安全框架使用的是角色控制，而不是权限控制，目前的了解，达不到Oracle那样的权限加角色的精细化控制</li></ul></blockquote><hr><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><blockquote><p><a href="/Skills/Base/WebSecurity.md#jwt">JWT相关原理</a> | <a href="https://github.com/Kuangcp/SpringBoot2-Security-Jwt" target="_blank" rel="noopener">Github SpringBoot2使用Security整合Jwt案例项目</a>  </p></blockquote><ul><li><a href="https://gitee.com/kcp1104/codes/kw31qf40iz9p8mt2x7bcd49" target="_blank" rel="noopener">个人代码片段</a>  |</li></ul><blockquote><p><a href="http://www.saily.top/2016/12/08/spring-boot-jwt/" target="_blank" rel="noopener">集成JWT到Spring Boot项目</a> | <a href="https://segmentfault.com/a/1190000009231329" target="_blank" rel="noopener">使用JWT保护你的Spring Boot应用</a><br><a href="https://juejin.im/post/58c29e0b1b69e6006bce02f4" target="_blank" rel="noopener">重拾后端之Spring Boot（四）：使用JWT和Spring Security保护REST API</a><br><a href="http://www.cnblogs.com/grissom007/p/6294746.html" target="_blank" rel="noopener">开箱即用 - jwt 无状态分布式授权</a></p></blockquote><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><blockquote><p><a href="https://segmentfault.com/q/1010000005067552" target="_blank" rel="noopener">跨域(CORS) 解决方案中，为什么 Access-Control-Allow-Methods 不起作用？</a><br><a href="https://bbs.csdn.net/topics/392006333" target="_blank" rel="noopener">WEB应用前后端分离实践 关键词：rest架构+跨域访问+JWT校验</a></p></blockquote><p><a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#csrf" target="_blank" rel="noopener">csrf</a></p><hr><h2 id="Oauth"><a href="#Oauth" class="headerlink" title="Oauth"></a>Oauth</h2><blockquote><p><a href="https://github.com/spring-projects/spring-security-oauth" target="_blank" rel="noopener">oauth</a></p></blockquote><hr><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="关于注解的几种使用方式"><a href="#关于注解的几种使用方式" class="headerlink" title="关于注解的几种使用方式"></a>关于注解的几种使用方式</h3><h4 id="Secured"><a href="#Secured" class="headerlink" title="@Secured"></a>@Secured</h4><ul><li>这是基于Spring特定的注解<h4 id="RolesAllowed"><a href="#RolesAllowed" class="headerlink" title="@RolesAllowed"></a>@RolesAllowed</h4></li><li>JSR-250的@RolesAllowed Java标准定义的注解，与上面的注解是差不多的</li><li><p>但是都是有局限性，只能判断请求是否有权限，不能进行更多的自定义判断</p><h4 id="SpringSecurity3-0-开始提供了-SpEL表达式"><a href="#SpringSecurity3-0-开始提供了-SpEL表达式" class="headerlink" title="SpringSecurity3.0 开始提供了 SpEL表达式"></a>SpringSecurity3.0 开始提供了 SpEL表达式</h4><p><code>需要先配置这个配置类，后面的注解才会生效</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSecurityConfig</span> <span class="keyword">extends</span> <span class="title">GlobalMethodSecurityConfiguration</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@PreAuthorize</code> 方法调用前，基于表达式的计算结果来限制方法的访问</p></li><li><code>@PostAuthorize</code> 允许方法调用，如果表达式是false 抛出安全异常</li><li><code>@PostFilter</code> 允许方法调用，按照表达式来过滤方法的结果</li><li><p><code>@PreFilter</code> 允许方法调用，必须进入方法前过滤输入值</p></li><li><p>方法调用前验证权限，示例:</p><ul><li><code>@PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)</code> 只允许该权限的用户访问</li><li>方法入参user，限定读者用户的text长度小于140，或者是作家用户无限制</li><li><code>@PreAuthorize(&quot;(hasRole(&#39;ROLE_READER&#39;) and #user.text.length()&lt;=140 ) or hasRole(&#39;ROLE_AUTHOR&#39;)&quot;)</code></li></ul></li><li>方法调用之后验证权限，示例;<ul><li><code>@PostAuthorize(&quot;returnObject.spitter.username == principal.username&quot;)</code></li><li>public Spittle getSpittleById(long id){} </li><li>保护方法，只有当返回的对象就是当前登录的用户时，才返回，不然抛出安全异常<br><code>以上是保护方法的调用，但是有时候保护的是数据的输入输出：</code></li></ul></li><li>过滤方法的输入输出<ul><li>事后对方法的返回值进行过滤<ul><li><code>@PreAuthorize(&quot;hasAnyRole({&#39;ROLE_ADMIN&#39;,&#39;ROLE_USER&#39;})&quot;)</code></li><li><code>@PostFilter(&quot;hasRole(&#39;ROLE_ADMIN&#39;) || filterObject.user.username == principal.name&quot;)</code></li><li><code>public List&lt;User&gt; getUsers(){}</code></li><li>该示例就是限制了如果是管理员可以获取到所有数据，普通用户只能看到自己</li><li>但是这种实现是不好的，只是一个例子，只获取自己，重载方法加个id参数就好了，上面的实现，把数据全拿出来再判断，性能上。。。</li></ul></li><li>事先对方法的参数进行过滤<ul><li><code>@PreAuthorize(&quot;hasAnyRole({&#39;ROLE_ADMIN&#39;,&#39;ROLE_USER&#39;})&quot;)</code></li><li><code>@PreFilter(&quot;hasRole(&#39;ROLE_ADMIN&#39;) || targetObject.user.username == principal.name&quot;)</code></li><li><code>public void deleteUsers(){List&lt;User&gt; users}</code></li><li>示例实现了传入一个集合，要删除的用户，但是当前用户只能删除自己，管理员才能删除集合里所有的用户</li></ul></li><li>定义许可计算器<ul><li><code>@PreFilter(&quot;hasPermission(targetObject,&#39;delete&#39;)&quot;)</code> 用户是否有权限删除目标对象？</li><li>使用了自定义的计算器类来实现这个判断，表达式简洁，但是自定义类不好写</li><li>实现PermissionEvaluator接口，新建hasPermission方法，功能就是判断是否有权限，其实就是对比目标对象是不是当前用户</li><li>创建好类后，重载GlobalMethodSecurityConfiguration配置类的createExpressionHalder方法，注册进去</li><li><code>DefaultMethodSecurityExperssionHandler ex = new De...();</code></li><li><code>ex.setPermissionEvaluator(new 自定义类);</code></li><li><code>return ex;</code></li></ul></li></ul></li></ul><h3 id="保护方法应用"><a href="#保护方法应用" class="headerlink" title="保护方法应用"></a>保护方法应用</h3><ul><li>@Secured 注解限制方法调用</li></ul><hr><h2 id="社交登录"><a href="#社交登录" class="headerlink" title="社交登录"></a>社交登录</h2><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDEwMjgwNA==&amp;mid=2247484230&amp;idx=1&amp;sn=358f684bd122888270730f2b102ee1b2&amp;chksm=fb3f1abdcc4893ab9dc400a44edfe7a9d483c070b78db1d81f70c4a3d7870d113d9287d81b0f&amp;mpshare=1&amp;scene=1&amp;srcid=0121kLxdu4ezkmeJAoJcdMZ1&amp;pass_ticket=LGmo8DCbLhUXTV%2FDVv1W9SyGxNSXxxYLrKODVeXD8f3lkWt2HnMB5b7racYt5W6V#rd" target="_blank" rel="noopener">SpringForAll社区:Spring Security源码分析（三）：Spring Social实现QQ社交登录 </a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDEwMjgwNA==&amp;mid=2247484233&amp;idx=1&amp;sn=1e84ffd8c9169db56a0d48ccb31bc842&amp;chksm=fb3f1ab2cc4893a4263799c466d73ee67971ce9deb22a91b8ae8e968621679de3bce83a2c558&amp;mpshare=1&amp;scene=1&amp;srcid=0121cjpvaOeB0nktdOSQNitj&amp;pass_ticket=LGmo8DCbLhUXTV%2FDVv1W9SyGxNSXxxYLrKODVeXD8f3lkWt2HnMB5b7racYt5W6V#rd" target="_blank" rel="noopener">SpringForAll社区:Spring Security 源码分析（四）：Spring Social实现微信社交登录 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#springsecurity&quot;&gt;SpringSecurity&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#配置&quot;&gt;配置&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#配置静态口令
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Experience.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Database-Experience/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Database-Experience/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#数据库的使用体会">数据库的使用体会</a><ol><li><a href="#关系型数据库">关系型数据库</a><ol><li><a href="#sqlserver">SQLServer</a></li><li><a href="#mysql">Mysql</a></li><li><a href="#oracle">Oracle</a></li><li><a href="#postgresql">Postgresql</a></li></ol></li><li><a href="#非关系型数据库">非关系型数据库</a><ol><li><a href="#redis">Redis</a></li><li><a href="#mangodb">MangoDB</a></li></ol></li><li><a href="#两者的对比">两者的对比</a></li></ol></li><li><a href="#关系型数据库设计">关系型数据库设计</a><ol><li><a href="#结构设计">结构设计</a><ol><li><a href="#基本表的设计">基本表的设计</a><ol><li><a href="#关于主键的设计">关于主键的设计</a></li></ol></li><li><a href="#视图的设计">视图的设计</a></li></ol></li><li><a href="#数据库中间件">数据库中间件</a></li></ol></li><li><a href="#非关系型数据库设计">非关系型数据库设计</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="数据库的使用体会"><a href="#数据库的使用体会" class="headerlink" title="数据库的使用体会"></a>数据库的使用体会</h1><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514001&amp;idx=1&amp;sn=17b72c3e69db6c4277e3045c699b7b6b&amp;chksm=80d67c52b7a1f5446020826841869221873f4578524181384592839d19c4810dc68807117e13&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:爱炫耀的数据库老头儿</a> <code>事务,undo日志</code></p></blockquote><blockquote><p><a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">DB-Engines Ranking</a> <code>数据库评分排行</code></p></blockquote><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><blockquote><p><a href="http://www.jdon.com/concurrent/acid-database.html" target="_blank" rel="noopener">参考博客: 什么是数据库ACID?</a></p></blockquote><h3 id="SQLServer"><a href="#SQLServer" class="headerlink" title="SQLServer"></a>SQLServer</h3><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><blockquote><p>结合docker配置很快，就是默认编码为什么不直接设置utf8，每次要改</p></blockquote><h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><blockquote><p>十分的庞大, 学习了他理念的设计, 感受良多</p></blockquote><h3 id="Postgresql"><a href="#Postgresql" class="headerlink" title="Postgresql"></a>Postgresql</h3><blockquote><p>听说性能强劲, 但是自己没有测试实践过, 命令行倒是很简洁, 就是数据库的逻辑理念和MySQL不一样, 迁移过去要稍微看下基础<br>实际使用上, 如果使用Docker开一个容器运行, 所消耗的资源比MySQL少多了, MySQL大概 300M PostgreSQL只要几十M</p></blockquote><h2 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><blockquote><p>数据类型丰富,处理非关系型并且结构化的数据十分方便, 结合Python使用就行云流水一般了</p></blockquote><h3 id="MangoDB"><a href="#MangoDB" class="headerlink" title="MangoDB"></a>MangoDB</h3><blockquote><p>正准备学习的文档性数据库, 混合类型: 关系型非关系型</p></blockquote><h2 id="两者的对比"><a href="#两者的对比" class="headerlink" title="两者的对比"></a>两者的对比</h2><blockquote><p><a href="http://www.infoq.com/cn/news/2017/10/SQL-NoSQL-mean-what?utm_source=news_about_rdbms&amp;utm_medium=link&amp;utm_campaign=rdbms" target="_blank" rel="noopener">为什么说SQL正在击败NoSQL，这对数据的未来意味着什么？</a></p></blockquote><hr><h1 id="关系型数据库设计"><a href="#关系型数据库设计" class="headerlink" title="关系型数据库设计"></a>关系型数据库设计</h1><h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="基本表的设计"><a href="#基本表的设计" class="headerlink" title="基本表的设计"></a>基本表的设计</h3><h4 id="关于主键的设计"><a href="#关于主键的设计" class="headerlink" title="关于主键的设计"></a>关于主键的设计</h4><blockquote><p>我哥提出, 基本表中连主键的约束都不要了, 全部由后台的代码进行约束处理</p></blockquote><ul><li>如果使用的需要高并发，数据库经常迁移，拆分，分布式，使用UUID,GUID最佳</li><li>如果是小型项目，使用整型自增即可，排序方便节约内存</li></ul><h3 id="视图的设计"><a href="#视图的设计" class="headerlink" title="视图的设计"></a>视图的设计</h3><h2 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h2><blockquote><p><a href="https://www.csdn.net/article/2015-07-16/2825228" target="_blank" rel="noopener">MyCat：开源分布式数据库中间件</a></p></blockquote><h1 id="非关系型数据库设计"><a href="#非关系型数据库设计" class="headerlink" title="非关系型数据库设计"></a>非关系型数据库设计</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#数据库的使用体会&quot;&gt;数据库的使用体会&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#关系型数据库&quot;&gt;关系型数据库&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#sqlserver&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GraphQL.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Database-GraphQL/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Database-GraphQL/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#graphql">GraphQL</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h1><blockquote><p><a href="https://graphql.org" target="_blank" rel="noopener">Official Site</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#graphql&quot;&gt;GraphQL&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-13 12:06&lt;/em&gt;| &lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MangoDB.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Database-MangoDB/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Database-MangoDB/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#mangodb">MangoDB</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="MangoDB"><a href="#MangoDB" class="headerlink" title="MangoDB"></a>MangoDB</h1><blockquote><p>非关系型和关系型混合文档型数据库</p></blockquote><blockquote><p><a href="https://segmentfault.com/a/1190000013589617" target="_blank" rel="noopener">双刃剑MongoDB的学习和避坑</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#mangodb&quot;&gt;MangoDB&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-13 12:06&lt;/em&gt;| &lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQLAdvance.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Database-MySQLAdvance/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Database-MySQLAdvance/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#mysql-advanced">MySQL Advanced</a><ol><li><a href="#部署">部署</a></li><li><a href="#性能调优">性能调优</a></li><li><a href="#sql-片段">SQL 片段</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="MySQL-Advanced"><a href="#MySQL-Advanced" class="headerlink" title="MySQL Advanced"></a>MySQL Advanced</h1><ul><li><a href="http://www.cnblogs.com/zhxilin/archive/2016/09/30/5923671.html" target="_blank" rel="noopener">Mysql Redis UDF 复制</a></li></ul><blockquote><p><a href="http://www.cnblogs.com/wangkangluo1/archive/2012/04/27/2472898.html" target="_blank" rel="noopener">参考博客: shell 下执行mysql 命令</a></p><ul><li>将需要执行的SQL写入文件 并将结果输出到文件 <code>mysql -u root -h 192.168.10.201 -p123 &lt; query.sql  &gt; result.log</code></li></ul></blockquote><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><blockquote><p>第一次看到MySQL内存上3G, 资源占用这么大, 还导致了内存不够, 直接MySQL自己退出了</p></blockquote><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><ul><li>分析SQL运行效率: <code>explain</code> + SQL</li><li>查看所有连接 <code>show processlist;</code></li></ul><blockquote><p><a href="http://www.piaoyi.org/database/MySQL-INNODB-SELECT-COUNT.html" target="_blank" rel="noopener">MySQL下INNODB引擎的SELECT COUNT(*)性能优化及思考</a></p></blockquote><h2 id="SQL-片段"><a href="#SQL-片段" class="headerlink" title="SQL 片段"></a>SQL 片段</h2><ol><li>拼接删除库下所有表的SQL <code>select concat(&#39;drop table &#39;,table_name,&#39;;&#39;) from information_schema.TABLES where table_schema=&#39;DATABASE_NAME&#39;;</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#mysql-advanced&quot;&gt;MySQL Advanced&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#部署&quot;&gt;部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#性能调优&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Oracle.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Database-Oracle/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Database-Oracle/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#oracle">Oracle</a><ol><li><a href="#安装">安装</a><ol><li><a href="#linux">Linux</a><ol><li><a href="#docker安装">Docker安装</a></li></ol></li><li><a href="#windows">Windows</a></li></ol></li><li><a href="#使用">使用</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><blockquote><p>强大的数据库, 稍微理解一下他的设计都觉得精妙</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h4><blockquote><p><a href="/Linux/Container/DockerSoft.md#安装oracle">详情&gt;&gt;</a></p></blockquote><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#oracle&quot;&gt;Oracle&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#安装&quot;&gt;安装&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#linux&quot;&gt;Linux&lt;/a&gt;&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PostgreSQL.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Database-PostgreSQL/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Database-PostgreSQL/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#postgresql">Postgresql</a><ol><li><a href="#概述">概述</a></li><li><a href="#和mysql对比">和MySQL对比</a></li><li><a href="#安装">安装</a><ol><li><a href="#安装客户端">安装客户端</a></li><li><a href="#安装服务端">安装服务端</a></li><li><a href="#docker方式安装服务端">Docker方式安装服务端</a><ol><li><a href="#pull完整版">pull完整版</a></li><li><a href="#pull精简版">pull精简版</a></li><li><a href="#dockerfile构建">Dockerfile构建</a></li><li><a href="#解释dockerfile文件">解释Dockerfile文件</a></li></ol></li></ol></li><li><a href="#使用">使用</a><ol><li><a href="#postgresql终端命令行使用">Postgresql终端命令行使用</a></li><li><a href="#用户和角色权限">用户和角色权限</a><ol><li><a href="#创建用户">创建用户</a></li><li><a href="#修改权限">修改权限</a></li></ol></li><li><a href="#java使用">Java使用</a></li></ol></li><li><a href="#基础数据">基础数据</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Postgresql"><a href="#Postgresql" class="headerlink" title="Postgresql"></a>Postgresql</h1><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.onexsoft.com/onesql.html" target="_blank" rel="noopener">该公司对于PostgreSQL的缺点陈列是否属实</a></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p><a href="http://www.cnblogs.com/fcode/articles/PostgreSQL.html" target="_blank" rel="noopener">PostgreSQL</a> | <a href="https://wiki.postgresql.org/wiki/Main_Page" target="_blank" rel="noopener">wiki</a></p></blockquote><ul><li>严格SQL标准</li><li>Schemas 和表，用户的关系：<ul><li>Schemas相当于是一个数据库进行分类的文件夹</li></ul></li></ul><h2 id="和MySQL对比"><a href="#和MySQL对比" class="headerlink" title="和MySQL对比"></a>和MySQL对比</h2><blockquote><p><a href="https://www.zhihu.com/question/20010554" target="_blank" rel="noopener">PostgreSQL 与 MySQL 相比，优势何在？</a><br><a href="https://en.wikibooks.org/wiki/Converting_MySQL_to_PostgreSQL" target="_blank" rel="noopener">Converting MySQL to PostgreSQL</a></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h3><blockquote><p><code>sudo apt-get install postgresql-client</code></p></blockquote><h3 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h3><blockquote><p><code>sudo apt install postgresql</code></p></blockquote><h3 id="Docker方式安装服务端"><a href="#Docker方式安装服务端" class="headerlink" title="Docker方式安装服务端"></a>Docker方式安装服务端</h3><blockquote><p><a href="https://hub.docker.com/_/postgres/" target="_blank" rel="noopener">官方镜像</a></p></blockquote><h4 id="pull完整版"><a href="#pull完整版" class="headerlink" title="pull完整版"></a>pull完整版</h4><ul><li>或者： <code>docker pull postgres</code> <a href="https://hub.docker.com/_/postgres/" target="_blank" rel="noopener">官方镜像</a><ul><li>运行容器 <code>docker run --name mypostgre -i -t -p 5432:5432 postgres</code></li><li>客户端连接 <code>psql -h localhost -p 5432 -U postgres</code></li></ul></li></ul><h4 id="pull精简版"><a href="#pull精简版" class="headerlink" title="pull精简版"></a>pull精简版</h4><ul><li>下拉镜像：<code>docker pull postgres:alpine</code> | 因为个人系统客户端是9.6, 所以用<code>9.6-alpine</code>镜像</li><li><p>构建容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name postgre \</span><br><span class="line">-e POSTGRES_PASSWORD=jiushi \</span><br><span class="line">-v gitea-db-data:/var/lib/postgresql/data \</span><br><span class="line">-p 5432:5432 \</span><br><span class="line">postgres:9.6-alpine</span><br></pre></td></tr></table></figure></li><li><p>容器中连接 进入postgresql终端 <code>docker exec -it postgre psql -U postgres</code></p><ul><li>客户端连接 <code>psql -h localhost -U postgres</code></li></ul></li><li>连接后 输入<code>\l</code> 列出所有数据库 即可查看连接成功与否</li></ul><h4 id="Dockerfile构建"><a href="#Dockerfile构建" class="headerlink" title="Dockerfile构建"></a>Dockerfile构建</h4><p><code>Dockerfile</code><br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-key adv --keyserver keyserver.ubuntu.com --recv-keys B97B0AFCAA1A47F044F244A07FCC7D46ACCC4CF8</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"deb http://apt.postgresql.org/pub/repos/apt/ precise-pgdg main"</span> &gt; /etc/apt/sources.list.d/pgdg.list</span></span><br><span class="line"><span class="bash">RUN apt-get update &amp;&amp; apt-get -y -q install python-software-properties software-properties-common \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get -y -q install postgresql-9.4 postgresql-client-9.4 postgresql-contrib-9.4</span></span><br><span class="line"><span class="bash">USER postgres</span></span><br><span class="line"><span class="bash">RUN /etc/init.d/postgresql start \</span></span><br><span class="line"><span class="bash">    &amp;&amp; psql --<span class="built_in">command</span> <span class="string">"CREATE USER pger WITH SUPERUSER PASSWORD 'pger';"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; createdb -O pger pgerdb</span></span><br><span class="line"><span class="bash">USER root</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"host all  all    0.0.0.0/0  md5"</span> &gt;&gt; /etc/postgresql/9.4/main/pg_hba.conf</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"listen_addresses='*'"</span> &gt;&gt; /etc/postgresql/9.4/main/postgresql.conf</span></span><br><span class="line"><span class="bash">EXPOSE 5432</span></span><br><span class="line"><span class="bash">RUN mkdir -p /var/run/postgresql &amp;&amp; chown -R postgres /var/run/postgresql</span></span><br><span class="line"><span class="bash">VOLUME  [<span class="string">"/etc/postgresql"</span>, <span class="string">"/var/log/postgresql"</span>, <span class="string">"/var/lib/postgresql"</span>]</span></span><br><span class="line"><span class="bash">USER postgres</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"/usr/lib/postgresql/9.4/bin/postgres"</span>, <span class="string">"-D"</span>, <span class="string">"/var/lib/postgresql/9.4/main"</span>, <span class="string">"-c"</span>, <span class="string">"config_file=/etc/postgresql/9.4/main/postgresql.conf"</span>]</span></span><br></pre></td></tr></table></figure></p><ul><li>构建容器 <code>docker build -t mypostgresql:9.4 .</code><ul><li>运行容器 <code>docker run --name mypostgre -i -t -p 5432:5432 mypostgresql:9.4</code></li><li>使用客户端连接<code>psql -h localhost -p 5432 -U pger -W pgerdb</code> 口令：<code>pger</code></li></ul></li></ul><h4 id="解释Dockerfile文件"><a href="#解释Dockerfile文件" class="headerlink" title="解释Dockerfile文件"></a>解释Dockerfile文件</h4><blockquote><p>待学习解释</p></blockquote><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p><a href="http://postgres.cn/docs/9.6/index.html" target="_blank" rel="noopener">PostgreSQL 9.6.0 手册</a></p></blockquote><h3 id="Postgresql终端命令行使用"><a href="#Postgresql终端命令行使用" class="headerlink" title="Postgresql终端命令行使用"></a>Postgresql终端命令行使用</h3><blockquote><p><a href="http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html" target="_blank" rel="noopener">PostgreSQL新手入门</a><br><code>用熟悉的MySQL命令来解释</code></p><ul><li><code>\l</code> show databases</li><li><code>\c dbname [user]</code> 切换数据库</li><li><code>\dt</code> show tables</li><li><code>\d tablename</code> desc tablename</li><li><code>\di</code> 查看索引</li><li><code>\du</code> 查看所有用户</li><li><code>\dn</code> 查看模式列表</li><li><code>\copyright</code> 显示版权信息</li><li><code>\encoding</code> 显示编码信息</li><li><code>\h</code> SQL命令语法上的说明，用*显示全部命令 </li><li><code>\prompt [文本]名称</code> 提示用户设定内部变数</li><li><code>\password [username]</code> 改密码</li><li><code>\q</code> exit</li><li>可以使用pg_dump和pg_dumpall来完成。比如备份sales数据库： <ul><li>pg_dump drupal&gt;/opt/Postgresql/backup/1.bak </li></ul></li></ul></blockquote><h3 id="用户和角色权限"><a href="#用户和角色权限" class="headerlink" title="用户和角色权限"></a>用户和角色权限</h3><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><ul><li><code>createuser -P -D -R -e playboy</code>  //创建一个用户,-P要设置密码，-R,不参创建其他用户，-D不能创建数据库</li><li><code>create user myth</code> 不带login属性</li><li><code>create role myth</code> 具有login属性</li><li><p><code>psql -U playboy -d playboy</code> 登录用户，一般默认是有用户同名数据库才能登录</p></li><li><p><a href="http://www.linuxidc.com/Linux/2013-04/83564p2.htm" target="_blank" rel="noopener">修改默认登录不需要密码的配置</a></p></li></ul><h4 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h4><blockquote><p><a href="http://blog.csdn.net/beiigang/article/details/8604578" target="_blank" rel="noopener">参考博客</a><br><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/05/18/2302639.html" target="_blank" rel="noopener">参考博客_角色</a><br><a href="http://www.linuxidc.com/Linux/2013-04/83564p2.htm" target="_blank" rel="noopener">配置</a></p></blockquote><ul><li><code>ALTER ROLE rolename LOGIN;</code>  设置登录权限</li><li><code>ALTER ROLE david WITH PASSWORD &#39;ufo456&#39;;</code> 设置密码登录权限<ul><li>但是，默认是不需要密码 查看pg_hba.conf 文件，发现local 的METHOD 为trust，所以不需要输入密码</li><li>将local 的METHOD 更改为password，然后保存重启postgresql。</li><li><a href="http://www.linuxidc.com/Linux/2014-02/96886.htm" target="_blank" rel="noopener">博客</a></li></ul></li><li><code>ALTER ROLE sandy VALID UNTIL &#39;2014-04-24&#39;;</code> 设置角色有效期</li><li><p><code>SELECT * from pg_roles ;</code> 查看所有角色</p></li><li><p><code>CREATE ROLE father login nosuperuser nocreatedb nocreaterole noinherit encrypted password &#39;abc123&#39;;</code> </p><ul><li>在PostgreSQL中，首先需要创建一个代表组的角色，之后再将该角色的membership 权限赋给独立的角色即可。</li></ul></li><li><code>GRANT CONNECT ON DATABASE test to father;</code> 角色赋予数据库test 连接权限和相关表的查询权限。</li></ul><h3 id="Java使用"><a href="#Java使用" class="headerlink" title="Java使用"></a>Java使用</h3><blockquote><p><a href="https://github.com/pgjdbc/pgjdbc" target="_blank" rel="noopener">Postgresql JDBC Driver</a></p></blockquote><ul><li><a href="https://springframework.guru/configuring-spring-boot-for-postgresql/" target="_blank" rel="noopener">官方：springboot使用</a><ul><li><a href="https://www.netkiller.cn/java/spring/boot/postgresql.html" target="_blank" rel="noopener">参考博客</a></li></ul></li></ul><h2 id="基础数据"><a href="#基础数据" class="headerlink" title="基础数据"></a>基础数据</h2><blockquote><p><a href="https://blog.csdn.net/jpzhu16/article/details/52140048" target="_blank" rel="noopener"> PostgreSQL中的数据类型</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#postgresql&quot;&gt;Postgresql&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#概述&quot;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#和mysql对比&quot;&gt;和My
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PostgreSQLAdvance.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Database-PostgreSQLAdvance/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Database-PostgreSQLAdvance/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#postgresql-advance">PostgreSQL Advance</a><ol><li><a href="#性能分析">性能分析</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="PostgreSQL-Advance"><a href="#PostgreSQL-Advance" class="headerlink" title="PostgreSQL Advance"></a>PostgreSQL Advance</h1><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>查询分析 同MySQL一样, 使用 <code>EXPLAIN</code> + SQL</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#postgresql-advance&quot;&gt;PostgreSQL Advance&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#性能分析&quot;&gt;性能分析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RedisAdvance.md</title>
    <link href="http://blog.kuangcp.top/2018/12/14/Memo-Database-RedisAdvance/"/>
    <id>http://blog.kuangcp.top/2018/12/14/Memo-Database-RedisAdvance/</id>
    <published>2018-12-14T12:42:49.254Z</published>
    <updated>2018-12-14T12:42:49.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#redis常用命令">Redis常用命令</a><ol><li><a href="#run-configuration">Run Configuration</a></li><li><a href="#过期策略">过期策略</a></li><li><a href="#事务">事务</a></li><li><a href="#服务器">服务器</a></li></ol></li><li><a href="#redis的应用场景">Redis的应用场景</a><ol><li><a href="#作为日志记录">作为日志记录</a></li><li><a href="#作为网站统计数据">作为网站统计数据</a></li><li><a href="#存储配置信息">存储配置信息</a></li><li><a href="#自动补全">自动补全</a></li><li><a href="#构建锁">构建锁</a></li><li><a href="#任务队列">任务队列</a></li></ol></li><li><a href="#数据安全和性能">数据安全和性能</a><ol><li><a href="#持久化策略">持久化策略</a></li><li><a href="#复制">复制</a></li><li><a href="#数据迁移">数据迁移</a></li><li><a href="#错误分析">错误分析</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h1><ul><li>关闭数据库 <code>shutdown</code> 该命令会在关闭数据库前保存数据</li><li>保存内存中数据到文件 <code>save</code></li><li>认证 <code>auth 口令</code> </li><li><p>测试联通性 <code>ping</code> 连接成功会返回pong</p></li><li><p>模糊删除 </p><ul><li>删除 6666端口 的 2数据库中<code>detail-2018-07-0*</code>模式的数据: <code>./redis-cli -p 6666 -n 2 keys &quot;detail-2018-07-0*&quot; | xargs  ./redis-cli -p 6666 -n 2 del</code></li></ul></li><li><p>查看所有连接 client list </p></li></ul><blockquote><p><a href="https://github.com/junegunn/redis-stat" target="_blank" rel="noopener">redis-stat</a></p></blockquote><h2 id="Run-Configuration"><a href="#Run-Configuration" class="headerlink" title="Run Configuration"></a>Run Configuration</h2><ul><li><p><em>slaveof</em></p><ul><li><code>redis-server --port 9999 --slaveof 127.0.0.1 6379</code> 启动一个9999端口作为6379的从服务器进行同步</li><li>或者服务启动后执行 <code>slaveof host port</code>（如果已经是从服务器，就丢去旧服务器的数据集，转而对新的主服务器进行同步）</li><li>从服务变成主服务 <code>slaveof no one</code> (同步的数据集不会丢失，迅速替换主服务器)</li></ul></li><li><p><em>loglevel</em></p><ul><li><code>./redis-server /etc/redis/6379.conf --loglevel debug</code></li></ul></li></ul><h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><ul><li><code>expire key seconds</code> 设置键的过期时间</li><li><code>PTTL/TTL key</code> 查看键剩余过期时间（生存时间） ms/s<ul><li>-1 表示永久 -2 表示没有该key</li></ul></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><code>DISCARD</code> 取消事务，放弃执行事务块内的所有命令。</li><li><code>EXEC</code><ul><li>执行所有事务块内的命令。假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，</li><li>那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</li></ul></li><li><code>MULTI</code> 标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</li><li><code>UNWATCH</code> <ul><li>取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。</li><li>因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</li></ul></li><li><code>WATCH key [key ...]</code><ul><li>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li></ul></li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><ul><li>BGREWRITEAOF</li><li>BGSAVE</li><li>CLIENT GETNAME</li><li>CLIENT KILL</li><li>CLIENT LIST</li><li>CLIENT SETNAME</li><li>CONFIG GET</li><li>CONFIG RESETSTAT</li><li>CONFIG REWRITE</li><li>CONFIG SET</li><li>DBSIZE</li><li>DEBUG OBJECT</li><li>DEBUG SEGFAULT</li><li>FLUSHALL</li><li>FLUSHDB</li><li>INFO<ul><li><a href="https://blog.csdn.net/kexiaoling/article/details/51810919" target="_blank" rel="noopener">参考: redis info 命令查看redis使用情况</a></li><li>info stats 中 total_commands_processed 是实际请求, 还是说redis自己执行的命令 TODO </li></ul></li><li>LASTSAVE</li><li>MONITOR</li><li>PSYNC</li><li>SAVE</li><li>SHUTDOWN</li><li>SLAVEOF</li><li>SLOWLOG</li><li>SYNC</li><li>TIME</li></ul><h1 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h1><blockquote><p><a href="https://my.oschina.net/u/3971241/blog/2221560" target="_blank" rel="noopener">参考博客: 为什么我们做分布式使用Redis？</a><code>缓存的场景和应对措施</code></p></blockquote><h2 id="作为日志记录"><a href="#作为日志记录" class="headerlink" title="作为日志记录"></a>作为日志记录</h2><h2 id="作为网站统计数据"><a href="#作为网站统计数据" class="headerlink" title="作为网站统计数据"></a>作为网站统计数据</h2><h2 id="存储配置信息"><a href="#存储配置信息" class="headerlink" title="存储配置信息"></a>存储配置信息</h2><h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><ul><li>搜索建议</li></ul><h2 id="构建锁"><a href="#构建锁" class="headerlink" title="构建锁"></a>构建锁</h2><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><ul><li>发送邮件</li></ul><hr><h1 id="数据安全和性能"><a href="#数据安全和性能" class="headerlink" title="数据安全和性能"></a>数据安全和性能</h1><h2 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h2><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><ul><li>使用主从复制来进行数据, 或者自己写Py脚本?</li></ul><h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><ol><li><code>JedisConnectionException:  Could not get a resource from the pool</code> cause by <code>java.util.NoSuchElementException: Unable to validate object</code><ul><li>多种原因, 由于设置了 testOnBorrow 为 true, 那么在每次获取数据时, 就会先测试性的获取一个数据, 然后校验能否正常拿到该数据 如果拿不到就抛出这个异常, 原因可能有:<ol><li>根本没有连接上Redis, 配置有问题 端口 bind 什么的</li><li>Redis 存放数据的 rdb 文件所在目录 没有存储空间了</li><li>没有内存空间了, 由于执行save操作时, 会进行fork子进程 然后进行持久化 TODO 验证</li></ol></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#redis常用命令&quot;&gt;Redis常用命令&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#run-configuration&quot;&gt;Run Configuration&lt;/a&gt;&lt;/li&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
