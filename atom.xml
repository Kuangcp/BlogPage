<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kuangcp Blog</title>
  
  <subtitle>Javaer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.kuangcp.top/"/>
  <updated>2018-12-18T01:16:56.921Z</updated>
  <id>http://blog.kuangcp.top/</id>
  
  <author>
    <name>Kuangcp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringTest.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-SpringTest/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-SpringTest/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#spring-test">Spring Test</a><ol><li><a href="#注解">注解</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h1><blockquote><p><a href="https://www.baeldung.com/mockito-annotations?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">参考博客: Getting Started with Mockito @Mock, @Spy, @Captor and @InjectMocks</a><br><a href="https://www.baeldung.com/mockito-spy" target="_blank" rel="noopener">参考博客: Mockito – Using Spies</a></p></blockquote><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul><li style="list-style: none"><input type="checkbox"> 学习</li></ul><ol><li>@MockBean </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#spring-test&quot;&gt;Spring Test&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#注解&quot;&gt;注解&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AlibabaJavaStandard.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-AlibabaJavaStandard/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-AlibabaJavaStandard/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#阿里巴巴java开发手册">阿里巴巴Java开发手册</a></li><li><a href="#编程规约">编程规约</a><ol><li><a href="#命名规约">命名规约</a></li><li><a href="#常量定义">常量定义</a></li><li><a href="#代码格式">代码格式</a></li><li><a href="#oop规约">OOP规约</a></li><li><a href="#集合处理">集合处理</a></li><li><a href="#并发处理">并发处理</a></li><li><a href="#控制语句">控制语句</a></li><li><a href="#注释规约">注释规约</a></li><li><a href="#其他">其他</a></li></ol></li><li><a href="#异常日志">异常日志</a><ol><li><a href="#异常处理">异常处理</a></li><li><a href="#日志规约">日志规约</a></li></ol></li><li><a href="#单元测试">单元测试</a></li><li><a href="#安全规约">安全规约</a></li><li><a href="#mysql规约">MySQL规约</a><ol><li><a href="#建表规约">建表规约</a></li><li><a href="#索引规约">索引规约</a></li><li><a href="#sql规约">SQL规约</a></li><li><a href="#orm映射">ORM映射</a></li></ol></li><li><a href="#工程规约">工程规约</a><ol><li><a href="#应用分层">应用分层</a></li><li><a href="#二方库依赖">二方库依赖</a></li><li><a href="#服务器规约">服务器规约</a></li></ol></li><li><a href="#专有名词">专有名词</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="阿里巴巴Java开发手册"><a href="#阿里巴巴Java开发手册" class="headerlink" title="阿里巴巴Java开发手册"></a>阿里巴巴Java开发手册</h1><blockquote><p><a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">Github: p3c</a><code>含该手册PDF GitBook等版本</code> | <a href="https://yq.aliyun.com/articles/656256?spm=a2c4e.11155472.0.0.7ba85338l1Ef0N" target="_blank" rel="noopener">《阿里巴巴Java开发手册》详尽</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/ml5271169588/article/details/6975701" target="_blank" rel="noopener">FindBugs、PMD和CheckStyle对比</a></p></blockquote><h1 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h1><h2 id="命名规约"><a href="#命名规约" class="headerlink" title="命名规约"></a>命名规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>所有命名不能以<code>美元符和下划线</code>开始和结束</p></li><li><p>禁止拼音混合英文, 更不允许直接使用中文的方式。</p><ul><li>正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。</li></ul></li><li><p>类名用<code>UpperCamelCase风格</code> 但以下情形例外:  DO / BO / DTO / VO / AO / PO / UID 例如: <code>UserDO</code></p></li><li><p>方法名、参数名、成员变量、局部变量 都统一使用 <code>lowerCamelCase风格</code></p></li><li><p>常量名全部大写, 下划线隔开, 力求语义表达完整清楚, 不要嫌名字长(枚举类中的也是)。</p></li><li><p>抽象类使用<code>Abstract或者Base</code>开头, 异常类使用Exception结尾 测试类命名以它要测试的类的名称开始，以Test结尾</p></li><li><p>数组定义 <code>String[] name</code> 而不是 <code>String name[]</code></p></li><li><p>POJO 类中布尔类型的变量不能is开头, 否则部分框架解析会引起序列化错误。 </p></li><li><p>包名统一使用小写, 点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式, 但是类名如果有复数含义, 类名可以使用复数形式。</p><ul><li>正例:  应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（ 此规则参考spring 的框架结构）</li></ul></li><li><p>杜绝完全不规范的缩写,  避免望文不知义。</p><ul><li>反例:  AbstractClass“ 缩写” 命名成 AbsClass;  condition“ 缩写” 命名成 condi, 此类随意缩写严重降低了代码的可阅读性。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>为了达到代码自解释的目标, 任何自定义编程元素在命名时, 使用尽量完整的单词组合来表达其意。</p><ul><li>正例:  从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。</li></ul></li><li><p>如果使用到了设计模式, 建议在类名中体现出具体模式。将设计模式体现在名字中, 有利于阅读者快速理解架构设计理念<code>LoginProxy</code></p></li><li><p>接口类中的方法和属性不要加任何修饰符号（ public 也不要加） , 保持代码的简洁性, 并加上有效的 Javadoc 注释。</p><ul><li>尽量不要在接口里定义变量, 如果一定要定义变量, 肯定是与接口方法相关, 并且是整个应用的基础常量。</li></ul></li></ol><p><strong><code>接口和实现类的命名有两套规则</code></strong></p><ol><li><p><code>强制</code> 对于 Service 和 DAO 类, 基于 SOA 的理念, 暴露出来的服务一定是接口, 内部的实现类用 Impl 的后缀与接口区别。</p><ul><li>正例:  CacheServiceImpl 实现 CacheService 接口。</li></ul></li><li><p><code>推荐</code> 如果是形容能力的接口名称, 取对应的形容词做接口名 （ 通常是–able 的形式）。</p><ul><li>正例:  AbstractTranslator 实现 Translatable。</li></ul></li></ol><p><strong><code>参考</code></strong></p><ol><li><p>枚举类名建议带上 Enum 后缀, 枚举成员名称需要全大写, 单词间用下划线隔开。</p><ul><li>说明:  枚举其实就是特殊的常量类, 域成员均为常量, 且构造方法被默认强制是私有。</li><li>正例:  枚举名字为 <code>ProcessStatusEnum</code> 的成员名称:  <code>SUCCESS</code>或者<code>UNKOWN_REASON</code></li></ul></li><li><p>MVC各层命名规约</p><ul><li>Service/Dao层<ul><li>获取单个对象 get 做前缀</li><li>获取多个对象 list, 复数形式结尾</li><li>获取统计值的方法 count </li><li>插入 save</li><li>删除 remove</li><li>修改 update<ul><li>领域模型</li><li>数据对象 <strong><em>xxxDO</em></strong> xxx是数据表名</li><li>数据传输对象 <strong><em>xxxDTO</em></strong> xxx是业务领域相关的名称</li><li>展示对象 <strong><em>xxxVO</em></strong> xxx是网页名称 使用了模板框架</li><li>POJO是 <strong><em>DO DTO BO VO</em></strong> 统称, 禁止命名为 xxxPOJO</li><li>有关这些缩写的详细说明  <a href="/Java/AdvancedLearning/GrammarAndType.md#object">详细定义和解释</a></li></ul></li></ul></li></ul></li></ol><ol><li><strong><code>Tomcat组织推荐的代码风格</code></strong><ol><li>使用空格进行缩进, 而不是制表符</li><li>用于 Java 源的100个字符行宽度, 用于文档源（.txt, .xml）的80个字符行宽度</li><li>Java 源代码: {在行末, 4个空格缩进</li><li>XML 源文件: 2个空格缩进</li></ol></li></ol><hr><h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><p><strong><code>强制</code></strong></p><ol><li><p>不允许出现魔法值(未经定义的常量)直接出现</p></li><li><p>long 或者 Long 初始赋值时,  使用大写的 L , 不能是小写的 l, 小写容易跟数字 1 混淆, 造成误解</p></li></ol><ol><li>不要使用一个常量类维护所有的常量, 应该按常量的功能, 进行归类, 分开维护.<ul><li>大而全的常量类, 只能用搜索 才能快速定位, 不利于理解和维护</li><li>例如 缓存相关常量放在类 <code>CacheConsts</code> 下;  系统配置相关常量放在类 <code>ConfigConsts</code> 下</li></ul></li></ol><ol><li>常量的复用层次的安排<ul><li><em>跨应用共享常量</em> : 二方库中 通常是client.jar中的<code>constant</code>目录下</li><li><em>应用内共享常量</em> : 一方库的modules中的<code>constant</code>目录下<ul><li>易懂变量也要统一定义成 应用内共享变量, 比如两个开发者在两个模块定义了相同含义的常量, 但是值却不一样, 这样就很容易埋下隐患</li></ul></li><li><em>子工程内共享常量</em> : 当前子工程的<code>constant</code>目录下</li><li><em>包内共享常量</em>: 当前包下单独的<code>constant</code>目录下</li><li><em>类内共享常量</em>: 直接在类内部 <code>private static final</code> 定义</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>如果变量值仅在一个范围内变化, 且带有名称之外的延伸属性,  定义为枚举类。下面正例中的数字就是延伸信息, 表示星期几。</p><ul><li><code>public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6),SUNDAY(7);}</code></li></ul></li><li><p>枚举类的定义 不能直接使用枚举的 ordinal() 作为枚举常量的值在程序中使用, 而应该自己定义一个变量, ordinal 方法的Javadoc上也有说明</p><ul><li>Most programmers will have no use for this method. It is designed for use by sophisticated enum-based data structures, such as EnumSet and EnumMap</li></ul></li></ol><hr><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><p><strong><code>强制</code></strong></p><ol><li><p>大括号约定: </p><ul><li>如果是大括号内为空, 则简洁地写成{}即可, 不需要换行;  </li><li>如果是非空代码块则: <ul><li>左大括号前不换行, 左大括号后换行。</li><li>右大括号前换行, 右大括号后还有 else 等代码则不换行;  表示终止的右大括号后必须换行。</li></ul></li></ul></li><li><p>小括号和字符之间不出现空格; </p><ul><li>反例:  <code>if (空格 a == b 空格)</code></li></ul></li><li><p><code>if/for/while/switch/do</code>等保留字与括号之间必须加空格.</p></li><li><p>任何二目、 三目运算符的左右两边都需要加一个空格。</p></li><li><p>缩进采用4个空格(Google的风格是两个空格), 而不是tab字符, 对应的IDE要调整一下</p></li><li><p>注释的双斜线与注释内容之间有且仅有一个空格。 <code>// 注释</code></p></li><li><p>单行字符不超过120个, 超出需换行: </p><ul><li>第二行比第一行缩进4个空格, 第三行以后就和第二行平齐就可以了</li><li>运算符与下文一起换行</li><li>方法调用的点符号与下文一起换行</li><li>调用方法 多个参数, 需在逗号后进行换行</li><li>括号之前不要换行</li></ul></li><li><p>方法参数在定义和传入时, 多个参数逗号后边必须加空格 :  <code>method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></p></li><li><p>文件编码统一采用<code>UTF-8</code> IDE中换行符采用Unix格式(LF) <code>使用别的编码的话会开心死的</code></p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>方法体内执行语句组, 变量的定义语句组, 不同的业务逻辑之间或者不同的语义之间插入一个空行, 相同业务逻辑和语义之间不需要插入空行</p><ul><li>也没必要插入多个空行进行分隔</li></ul></li><li><p>没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。(很傻的做法)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>    a = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">public</span> String b = <span class="number">2</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">float</span>  c = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>避免使用一个类的对象来引用该类的静态变量或静态方法。无谓增加编译器解析成本, 直接用<code>类名</code>来访问即可。</p></li><li><p>所有的覆写方法, 必须加 @Override 注解</p><ul><li>例如 getObject() 与 get0bject() 的问题, 前者是字母o,后者是数字0 通过使用覆盖的注解, 可以准确判断是否覆盖成功</li><li>另外, 如果在抽象类中对方法签名进行修改, 其实现类 会立即编译报错</li></ul></li><li><p>相同参数类型, 相同业务含义, 才可以使用Java的可变参数, 避免使用Object.</p><ul><li>说明:  可变参数必须放置在参数列表的最后。 <code>提倡尽量不用可变参数编程</code></li><li>正例:  <code>public User getUsers(String type, Integer... ids) {...}</code></li></ul></li><li><p>外部正在调用或者二方库依赖的接口, 不允许修改方法签名, 避免对接口调用方产生影响。</p><ul><li>接口过时必须加 <code>@Deprecated</code> 注解, 并清晰地说明采用的新接口或者新服务是什么。</li></ul></li><li><p>不能使用过时的类或方法</p><ul><li>说明:  <code>java.net.URLDecoder</code> 中的方法 <code>decode(String encodeStr)</code> 这个方法已经过时, </li><li>应该使用双参数 <code>decode(String source, String encode)</code>。接口提供方既然明确是过时接口, </li><li>那么有义务同时提供新的接口;  作为调用方来说, 有义务去考证过时方法的新实现是什么。</li></ul></li><li><p>Object 的 equals 方法容易抛空指针异常, 应使用常量或确定有值的对象来调用equals。</p><ul><li>使用<code>&quot;t&quot;.equals(test)</code>方式</li><li>推荐使用<code>java.util.Object.equals</code> (jdk7引入的工具类)</li></ul></li><li><p>所有的相同类型的包装类对象之间的 <em>值的比较</em> , 全部使用equals方法比较, </p><ul><li>注意: 对于 <code>Integer var = ?</code> 在 -128 至 127 范围内的赋值,  Integer 对象是在<code>IntegerCache.cache 产生</code>, 会复用已有对象, </li><li>这个区间内的 Integer 值可以直接使用 == 进行判断, 但是这个区间之外的所有数据, 都会在堆上产生, 并不会复用已有对象, 所以 <code>==</code> 就会失效</li><li>这是一个大坑！, <strong>推荐统一使用 equals 方法进行判断</strong></li></ul></li><li><p>关于基本数据类型与包装数据类型的使用标准如下: </p><ul><li>所有的 POJO 类属性必须使用包装数据类型。</li><li>RPC 方法的 返回值 和 参数 必须使用包装数据类型</li><li>所有的局部变量 推荐使用基本数据类型</li><li><code>说明</code>:  POJO 类属性没有初值是提醒使用者在需要使用时, 必须自己显式地进行赋值, 任何NPE 问题, 或者入库检查, 都由使用者来保证。<ul><li>数据库的查询结果可能是 null, 因为自动拆箱, 用基本数据类型接收有 NPE 风险。</li></ul></li><li><code>反例</code>:  比如显示成交总额涨跌情况, 即正负 x%,  x 为基本数据类型, 调用的 RPC 服务, 调用不成功时, 返回的是默认值, <ul><li>页面显示为 0%, 这是不合理的, 应该显示成中划线。所以包装数据类型的 null 值, 能够表示额外的信息</li><li>如: 远程调用失败, 异常退出。</li></ul></li></ul></li><li><p>定义 <code>DO/DTO/VO</code>等POJO类时, 不要给任何成员属性设定 <strong>默认值</strong></p><ul><li><code>反例</code>:  POJO 类的 createTime属性 默认值为 new Date();<ul><li>但是这个属性在数据提取时并没有置入具体值, 在更新其它字段时又附带更新了此字段, 导致创建时间被修改成当前时间。</li></ul></li></ul></li><li><p>序列化类新增属性时, 不要修改<code>serialVersionUID</code>字段, 避免反序列化失败</p><ul><li>如果完全不兼容升级, 为了避免反序列化混乱, 就需要修改<code>serialVersionUID</code>的值 <code>(idea可以配置使用快捷键自动生成)</code></li><li><code>说明</code>:  当 serialVersionUID 不一致会抛出序列化运行时异常。</li></ul></li><li><p>构造方法里面禁止加入任何业务逻辑, 如果有初始化逻辑, 请放在 init 方法中。</p></li><li><p>POJO 类必须写 toString 方法。 如果继承了另一个 POJO 类, 注意在前面加一下 super.toString() <code>lombok解救众生</code></p><ul><li>说明:  在方法执行抛出异常时, 可以直接调用 POJO 的 toString()方法打印其属性值, 便于排查问题</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>使用索引访问用 String 的 split 方法得到的数组时, 需做最后一个分隔符后有无内容的检查, 否则会有 <code>IndexOutOfBoundsException</code> 的风险。</p><ul><li><code>System.out.println(&quot;a,b,c,,&quot;.split(&quot;,&quot;).length);</code> 预期是大于3,结果却是3</li></ul></li><li><p>当一个类有多个构造方法, 或者多个同名方法, 这些方法应该按顺序放置在一起, 优于下条规则</p></li><li><p>类内方法的定义顺序依次是 共有方法或保护方法 -&gt; 私有方法 -&gt; setter/getter方法(lombok可省)</p><ul><li>公有方法是类的调用者和维护者最关心的方法, 首屏展示最好;  </li><li>保护方法虽然只是子类关心, 也可能是 <strong>模板设计模式</strong> 下的核心方法;  </li><li>而私有方法外部一般不需要特别关心, 是一个黑盒实现;  </li><li>因为承载的信息价值较低, 所有 Service 和 DAO 的 <code>getter/setter</code> 方法放在类的最后, 用了lombok就省去了。</li></ul></li><li><p>setter 方法中, 参数名称与类成员变量名称一致,  this.成员名 = 参数名。</p><ul><li>在<code>getter/setter</code> 方法中,  不要增加业务逻辑, 增加排查问题的难度。</li></ul></li><li><p>循环体中的字符串的连接方式, 使用<code>StringBuffer</code>的<code>append</code>方法进行扩展</p><ul><li>说明:  反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象, 然后进行 append 操作, </li><li><p>最后通过 toString 方法返回 String 对象, 造成内存资源浪费。</p><blockquote><p>验证循环中String的拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String target = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>; a&lt;<span class="number">10</span>; a++)&#123;</span><br><span class="line">            target += a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. javac test.java 编译</span></span><br><span class="line"><span class="comment">// 2. javap -c -l test 反编译, 就能大致看到new StringBuilder了</span></span><br></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>final 可以声明类、成员变量、方法、以及本地变量, 下列情况使用 final 关键字: </p><ol><li>不允许被继承的类, 如:  String 类。</li><li>不允许修改引用的域对象, 如:  POJO 类的域变量。</li><li>不允许被重写的方法, 如:  POJO 类的 setter 方法。</li><li>不允许运行过程中重新赋值的局部变量。</li><li>避免上下文重复使用一个变量, 使用 final 描述可以强制重新定义一个变量, 方便更好地进行重构。<ul><li>这里就隐含了一个习惯, 不应该把一个变量到处传, 到处用,赋值, 很难追踪调试</li></ul></li></ol></li><li><p>慎用Object的clone方法来拷贝对象 <code>详见API</code></p><ul><li>说明:  对象的 clone 方法默认是浅拷贝, 最好重写该方法, 实现属性对象的拷贝。</li></ul></li><li><p>类成员与方法访问控制从严: </p><ol><li>如果不允许外部直接通过 new 来创建对象, 那么构造方法显式声明并 private</li><li><strong>工具类</strong> 不允许有 public 或 default 的构造方法</li><li>类非static成员变量 或者 成员方法 若 <strong>只与</strong> 子类共享, 必须是 protected</li><li>成员属性或方法 若 <strong>仅</strong> 本类中使用, 必须是 private</li><li>若是static成员变量, 必须考虑是否final</li><li>类static 成员变量如果仅在本类使用, 必须是 private。</li></ol><ul><li><strong>注意</strong> 说明:  任何类、方法、参数、变量, 都需要严控访问范围。过于宽泛的访问范围, 不利于模块解耦。<ul><li>思考: 如果是一个 private 的方法, 想删除就删除, 可是一个 public 的 service 方法, 或者一个 public 的成员变量, 删除一下, 不得手心冒点汗吗？</li><li>变量像自己的小孩, 尽量在自己的视线内, 变量作用域太大,  无限制的到处跑, 那么你会担心的。</li></ul></li></ul></li></ol><hr><h2 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h2><p><strong><code>强制</code></strong></p><ol><li><p>关于 hashCode 和 equals 的处理, 遵循如下规则:</p><ul><li>只要重写 equals, 就必须重写 hashCode</li><li>因为 Set 存储的是不重复的对象, 依据 hashCode 和 equals 进行判断, 所以 Set 存储的方法必须重写这两个方法</li><li>如果自定义对象作为 Map 的键, 那么必须重写 hashCode 和 equals</li><li><code>说明</code>:  String 重写了 hashCode 和 equals 方法, 所以我们可以非常愉快地使用 String 对象作为 key 来使用。</li></ul></li><li><p>ArrayList 的 subList 结果不可强转成 ArrayList 否则会抛出 ClassCastException异常,  </p><ul><li>即 <code>java.util.RandomAccessSubList cannot be cast to java.util.ArrayList.</code></li><li><code>说明</code>: subList返回的是 ArrayList 的内部类 SubList, 并不是ArrayList, 而是ArrayList的一个视图, 对于SubList的所有操作最终都会反映到原列表上</li></ul></li><li><p>在 <code>subList</code> 场景中, 高度注意对原集合元素 <strong>个数的修改</strong>, 会导致子列表的 <strong>遍历、增加、删除</strong> 均会产生 <code>ConcurrentModificationException</code> </p></li><li><p>使用集合转数组的方法, 必须使用集合的 <code>toArray(T[] array)</code> , 传入的是类型完全一样的数组, 数组大小就是 <code>list.size()</code></p><ul><li>使用 toArray 带参方法, 入参分配的数组空间不够大时,  toArray 方法内部将重新分配内存空间, 并返回新数组地址, 原数组不做更改; </li><li>如果数组元素大于实际所需, 下标超出的数组元素将被置为 null, 其它数组元素保持原值, 因此最好将方法入参数组大小定义与集合元素个数一致。</li><li><em>注意</em> 直接使用 toArray 无参方法存在问题, 此方法返回值只能是 Object[]类, 若强转其它类型数组将出现 ClassCastException 错误。</li></ul></li><li><p>把数组转换成集合: 使用工具类<code>Arrays.asList()</code>时, 不能使用其修改集合相关的方法, 其<code>add/remove/clear</code>方法会抛出<code>UnsupportedOperationException</code>异常。</p><ul><li>因为 asList 的返回对象是一个继承于 AbstractList 的内部类 Arrays, 实现集合的那些修改方法时 都是直接抛出异常</li><li><code>Arrays.asList</code>体现的是适配器模式, 只是转换接口, 后台的数据仍是固定长度的数组。</li><li>案例: <code>String[] str = new String[] { &quot;a&quot;, &quot;b&quot; }; List list = Arrays.asList(str);</code><ul><li><em>第一种情况</em>:  <code>list.add(&quot;c&quot;);</code>  运行时异常。</li><li><em>第二种情况</em>:  <code>str[0]= &quot;gujin&quot;;</code> 那么 <code>list.get(0)</code> 也会随之修改。</li></ul></li></ul></li><li><p>泛型通配符<code>&lt;? extends T&gt;</code>来接收返回的数据, 此写法的泛型集合不能使用 add 方法。</p><ul><li>而<code>&lt;? super T&gt;</code>不能使用 get 方法, 做为接口调用赋值时易出错。</li><li><em>说明</em>:  扩展说一下 <code>PECS(Producer Extends Consumer Super)</code>原则:  <ul><li>第一、 频繁往外读取内容的, 适合用<code>&lt;? extends T&gt;</code>。 </li><li>第二、 经常往里插入的, 适合用<code>&lt;? super T&gt;</code>。<ul><li>说明: 苹果装箱后返回一个<code>&lt;? extends Fruits&gt;</code>对象, 此对象就不能往里加任何水果, 包括苹果。</li></ul></li></ul></li></ul></li><li><p>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。 remove 元素请使用 Iterator方式, 如果并发操作, 需要对 Iterator 对象加锁。</p><p> <em>正例: </em></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String item = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (删除元素的条件) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <em>反例: </em></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; a = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"1"</span>);</span><br><span class="line">list.add(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"1"</span>.equals(item)) &#123;</span><br><span class="line">        list.remove(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <em>说明</em>:  以上代码的执行结果肯定会出乎大家的意料, 那么试一下把“1”换成“2”, 会是同样的结果吗？</p></li><li><p>在 JDK7 版本以上,  Comparator 要满足自反性, 传递性, 对称性, 不然 <code>Arrays.sort</code> , <code>Collections.sort</code> 会报 <code>IllegalArgumentException</code> </p><ul><li>1 ） 自反性:  x ,  y 的比较结果和 y ,  x 的比较结果相反。</li><li>2 ） 传递性:  x &gt; y , y &gt; z ,则 x &gt; z 。</li><li><p>3 ） 对称性:  x = y ,则 x , z 比较结果和 y ,  z 比较结果相同。</p><p><em>反例:  下例中没有处理相等的情况, 实际使用中可能会出现异常: </em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() &gt; o2.getId() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>集合初始化时, 尽量指定集合初始容量值。</p><ul><li>HashMap 使用 HashMap(int initialCapacity) 初始化</li><li>正例: <code>initialCapacity=(需要存储的元素个数/负载因子)+1</code>。注意负载因子（即 loaderfactor）默认为<code>0.75</code><ul><li>如果暂时无法确定初始值大小, 请设置为 16（即默认值） 。</li></ul></li><li>反例:  HashMap 需要放置 1024 个元素,  由于没有设置容量初始大小, 随着元素不断增加, 容量<code>7</code>次被迫扩大,  resize 需要重建 hash 表, 严重影响性能。</li></ul></li><li><p>使用 <code>entrySet</code> 遍历 Map 类集合 KV , 而不是 <code>keySet</code> 方式进行遍历</p><ul><li><code>keySet</code> 其实是遍历了 2 次, 一次是转为 <code>Iterator</code> 对象, 另一次是从 hashMap 中取出key 所对应的 value 。</li><li>而 <code>entrySet</code> 只是遍历了一次就把 key 和 value 都放到了 entry 中, 效率更高。 如果是 JDK8, 使用 lambda 的 foreach 方法。</li><li>说明: values() 返回的是V值集合, 是一个 list 集合对象; keySet()返回的是K值集合, 是一个 Set集合对象;entrySet()返回的是 K - V 值组合集合。</li></ul></li><li><p>高度注意 Map 类集合 <code>K/V</code> 能不能存储 null 值的情况, 如下表格:</p><ul><li><p>反例:  由于 HashMap 的干扰, 很多人认为 ConcurrentHashMap 是可以置入 null 值, 而事实上, 存储 null 值时会抛出 NPE 异常。</p><p>|  集合类   |    Key  |   Value  |  Super   |  说明  |<br>| — | — | — | — | — |<br>|Hashtable|! NULL|! NULL|Dictionary|线程安全|<br>|ConcurrentHashMap|! NULL|! NULL|AbstractMap|锁分段技术（ JDK8:CAS）|<br>|TreeMap|! NULL|NULL|AbstractMap|线程不安全|<br>|HashMap|NULL|NULL|AbstractMap|线程不安全|</p></li></ul></li><li><p>合理利用好集合的有序性 (sort) 和稳定性 (order) , 避免集合的无序性 (unsort) 和不稳定性 (unorder) 带来的负面影响。</p><ul><li>稳定性指集合每次遍历的元素次序是一定的。</li><li>有序性是指遍历的结果是按某种比较规则依次排列的。</li><li>如:  ArrayList 是 order / unsort; <ul><li>HashMap 是 unorder/unsort; </li><li>TreeSet 是 order / sort 。</li></ul></li></ul></li><li><p>利用 Set元素唯一的特性, 可以快速对一个集合进行去重操作, 避免使用 List的contains 方法进行遍历、对比、去重操作。</p><ul><li>OrderSet也是一个很重要的类</li></ul></li></ol><h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><p><strong><code>强制</code></strong></p><ol><li><p>获取单例对象需要保证线程安全, 其中的方法也要保证线程安全。</p><ul><li>资源驱动类、工具类、单例工厂类都需要注意。</li></ul></li><li><p>创建线程或线程池时请指定有意义的线程名称, 方便出错时回溯。</p></li><li><p>线程资源必须通过线程池提供, 不允许在应用中自行显式创建线程。</p><ul><li>使用线程池的好处是减少在创建和销毁线程上所花的时间, 以及系统资源的开销,解决资源不足的问题, 如果不使用线程池, 有可能造成系统创建大量同类线程而导致消耗完内存或者 过度切换 的问题</li></ul></li><li><p>线程池不允许使用 <strong>Executors</strong> 去创建, 而是通过 <strong>ThreadPoolExecutor</strong> 的方式, 这样的处理方式让写的同学更加明确线程池的运行规则, 规避资源耗尽的风险。</p><ul><li>Executors 返回的线程池对象的弊端如下:<ol><li>FixedThreadPool 和 SingleThreadPool :<ul><li>允许的请求队列长度为 Integer.MAX_VALUE , 可能会堆积大量的请求, 从而导致 OOM 。</li></ul></li><li>CachedThreadPool 和 ScheduledThreadPool :<ul><li>允许的创建线程数量为 Integer.MAX_VALUE , 可能会创建大量的线程, 从而导致 OOM 。</li></ul></li></ol></li></ul></li><li><p>SimpleDateFormat 是线程不安全的类, 一般不要定义为 static 变量, 如果定义为static , 必须加锁, 或者使用 DateUtils 工具类。</p><ul><li>如果是 JDK 8 的应用, 可以使用 Instant 代替 Date ,  LocalDateTime 代替 Calendar , DateTimeFormatter 代替 Simpledateformatter , </li><li>官方给出的解释:  simple beautiful strongimmutable thread - safe 。<blockquote><p>或者如下处理实例化  </p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;      </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;           </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>高并发时, 同步调用应该去考量锁的性能损耗。</p><ul><li>能用无锁数据结构, 就不要用锁 ;  </li><li>能锁区块, 就不要锁整个方法体 ;  </li><li>能用对象锁, 就不要用类锁。</li><li>尽可能使得加锁的代码块工作量尽可能的小, 避免在锁代码块中调用 RPC 方法;</li></ul></li><li><p>对多个资源、数据库表、对象同时加锁时, 需要保持一致的加锁顺序, 否则可能会造成死锁。</p><ul><li>线程一需要对表 A 、 B 、 C 依次全部加锁后才可以进行更新操作, 那么线程二的加锁顺序也必须是 A 、 B 、 C , 否则可能出现死锁。</li></ul></li><li><p>并发修改同一记录时, 避免更新丢失, 要么在应用层加锁, 要么在缓存加锁, 要么在数据库层使用乐观锁, 使用 version 作为更新依据。</p><ul><li>如果每次访问冲突概率小于 20%, 推荐使用乐观锁, 否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</li></ul></li><li><p>多线程并行处理定时任务时,  Timer 运行多个 TimeTask 时, 只要其中之一没有捕获抛出的异常, 其它任务便会自动终止运行</p><ul><li>使用 ScheduledExecutorService 则没有这个问题。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>使用 CountDownLatch 进行异步转同步操作, 每个线程退出前必须调用 countDown方法, 线程执行代码注意 catch 异常, 确保 countDown 方法被执行到, 避免主线程无法执行至 await 方法, 直到超时才返回结果。</p><ul><li>注意, 子线程抛出异常堆栈, 不能在主线程 try - catch 到。</li></ul></li><li><p>避免 Random 实例被多线程使用, 虽然共享该实例是线程安全的, 但会因竞争同一 seed 导致的性能下降。</p><ul><li>Random 实例包括 java.util.Random 的实例或者  Math.random() 实例。</li><li>在JDK7之后, 可以直接使用 TreadLocalRandom, 而在JDK7以前, 需要编码保证每个线程持有一个实例</li></ul></li><li><p>在并发场景下, 通过双重检查锁 （double - checked locking） 实现延迟初始化的优化问题隐患 </p><ul><li>可参考 The “Double - Checked Locking is Broken” Declaration ,</li><li>推荐问题解决方案中较为简单一种 （ 适用于 JDK 5 及以上版本 ） , 将目标属性声明为  volatile 型 。</li></ul></li><li><p>volatile 解决多线程内存不可见问题。对于一写多读, 是可以解决变量同步问题</p><ul><li>但是如果多写, 同样无法解决线程安全问题。如果是 count++ 操作, 使用如下类实现: <ul><li>AtomicInteger count =  new AtomicInteger(); count . addAndGet( 1 );  </li></ul></li><li>如果是 JDK 8, 推荐使用 LongAdder 对象, 比 AtomicLong 性能更好 （ 减少乐观锁的重试次数 ） 。</li></ul></li><li><p>HashMap 在容量不够进行 resize 时由于高并发可能出现死链, 导致 CPU 飙升, 在开发过程中可以使用其他数据结构或加锁来规避此风险。</p></li><li><p>ThreadLocal 无法解决共享对象的更新问题,  ThreadLocal 对象建议使用 static 修饰。</p><ul><li>这个变量是针对一个线程内所有操作共有的, 所以设置为静态变量, 所有此类实例共享此静态变量,  </li><li>也就是说在类第一次被使用时装载, 只分配一块存储空间, 所有此类的对象 ( 只要是这个线程内定义的 ) 都可以操控这个变量。</li></ul></li></ol><hr><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p><strong><code>强制</code></strong></p><ol><li><p>在一个 switch 块内, 每个 case 要么通过 break/return 等来终止, 要么注释说明程序将继续执行到哪一个 case 为止 ;  </p><ul><li>在一个 switch 块内, 都必须包含一个 default 语句并且放在最后, 即使它什么代码也没有。</li></ul></li><li><p>在 if/else/for/while/do 语句结构中必须使用大括号, 即使只有一行代码</p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>表达异常的分支时, 少用 if-else 的方式, 这种方式可以改写:</p><ul><li>逻辑上超过 3 层的 if-else 代码可以使用卫语句, 状态模式, 策略模式来实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 卫语句就是将错误情况提前返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">today</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isBusy())&#123;</span><br><span class="line">        System.out.println(<span class="string">"change time."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isFree())&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>除常用方法（如 getXxx/isXxx）等外, 不要在条件判断中执行其它复杂的语句</p><ul><li>并且将复杂逻辑判断的结果赋值给一个有意义的布尔变量名, 以提高可读性。</li><li>很多 if 语句内的逻辑判断都是相当复杂, 不能一眼看出在判断什么, 需要停顿,分析一下表达式才能理解 if 语句存在的意义</li><li>如果有个boolean变量接收, 变量名就起到了注释的作用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> existed = (file.open(fileName, <span class="string">"w"</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...);</span><br><span class="line"><span class="keyword">if</span>(existed)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">if</span> ((file.open(fileName, <span class="string">"w"</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...);)&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>循环体中的语句要考量性能, 以下操作尽量移至循环体外处理, 如定义对象、变量、获取数据库连接</p><ul><li>进行不必要的 try-catch 操作 (需要考虑这个 try-catch 是否可以移至循环体外而不影响逻辑)。</li></ul></li><li><p>接口入参保护, 这种场景常见的是用于做批量操作的接口。</p></li><li><p>方法中 <strong>必须</strong> 进行参数校验的场景: </p><ol><li>调用频次低的方法。</li><li>执行时间开销很大的方法. 此情形中,参数校验时间几乎可以忽略不计, <ul><li>但如果因为参数错误导致中间执行回退, 或者错误, 那得不偿失。</li></ul></li><li>需要极高稳定性和可用性的方法。</li><li>对外提供的开放接口, 不管是 RPC/API/HTTP 接口。</li><li>敏感权限入口。</li></ol></li><li><p>方法中 <strong>不需要</strong> 参数校验的场景: </p><ol><li>极有可能被循环调用的方法, 不建议对参数进行校验。但在方法说明里必须注明外部参数检查要求。</li><li>底层的方法调用频度都比较高。毕竟是像纯净水过滤的最后一道, 参数错误不太可能到底层才会暴露问题。<ul><li>一般 DAO 层与 Service层都在同一个应用中, 部署在同一台服务器中, 所以 DAO 的参数校验, 可以省略。</li></ul></li><li>被声明成 private 只会被自己代码所调用的方法, 如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题, 此时可以不校验参数。</li></ol></li></ol><h2 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>类、类属性、类方法的注释必须使用 Javadoc 规范, 使用 /*<em> 内容 </em>/ 格式, 不得使用 // xxx 方式。</p><ul><li>为了能在IDE中快速查看注释</li></ul></li><li><p>所有的抽象方法 （包括接口中的方法） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外, 还必须指出该方法做什么事情, 实现什么功能。</p><ul><li>并且声明 对子类的实现要求, 或者调用注意事项</li></ul></li><li><p>所有的类都必须添加创建者和创建日期。</p></li><li><p>方法内部单行注释, 在被注释语句上方另起一行, 使用//注释(而不是行尾注释)。方法内部多行注释使用 /<em> </em>/ 注释, 注意与代码对齐。</p></li><li><p>所有的枚举类型字段必须要有注释, 说明每个数据项的用途。</p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>与其“半吊子”英文来注释, 不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</p><ul><li>反例: TCP连接超时 解释成 传输控制协议连接超时, 反而更难以理解</li></ul></li><li><p>代码修改的同时, 注释也要进行相应的修改, 尤其是参数、返回值、异常、核心逻辑等的修改。</p><ul><li>代码与注释更新不同步, 就像路网与导航软件更新不同步一样, 如果导航软件严重滞后, 就失去了导航的意义。</li></ul></li><li><p>谨慎注释掉代码, 尽量要配合说明, 而不是简单的注释掉, 如果无用, 则删除即可</p><ul><li>代码被注释掉有两种可能性: <ol><li>后续会恢复此段代码逻辑, 若无注释,难以知晓注释动机</li><li>永久不用: 建议直接删除, 仓库有历史记录的</li></ol></li></ul></li><li><p>对于注释的要求: </p><ol><li>第一、能够准确反应设计思想和代码逻辑</li><li>第二、能够描述业务含义, 使别的程序员能够迅速了解到代码背后的信息。</li><li>完全没有注释的大段代码对于阅读者形同天书, 注释是给自己看的, 即使隔很长时间, 也能清晰理解当时的思路 ;  </li><li>注释也是给继任者看的, 使其能够快速接替自己的工作。</li></ol></li><li><p>好的命名、代码结构是自解释的, 注释力求精简准确、表达到位。避免出现注释的一个极端:过多过滥的注释, 代码的逻辑一旦修改, 修改注释是相当大的负担。</p></li><li><p>特殊注释标记, 请注明标记人与标记时间。注意及时处理这些标记, 通过标记扫描, 经常清理此类标记。 线上故障有时候就是来源于这些标记处的代码。</p><ol><li>待办事项 (TODO) : 标记人, 标记时间,  [ 预计处理时间 ]<ul><li>表示需要实现, 但目前还未实现的功能。这实际上是一个 Javadoc 的标签, 目前的 Javadoc还没有实现, 但已经被广泛使用。只能应用于类, 接口和方法 （ 因为它是一个 Javadoc 标签 ） 。</li></ul></li><li>错误, 不能工作 （FIXME） : 标记人, 标记时间,  [ 预计处理时间 ]<ul><li>在注释中用 FIXME 标记错误的代码, 不能工作, 需要及时纠正的情况。</li></ul></li></ol></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong><code>强制</code></strong></p><ol><li><p>在使用正则表达式时, 利用好其预编译功能, 可以有效加快正则匹配速度。</p><ul><li>不要在方法体内定义:  Pattern pattern =  Pattern.compile( 规则 );</li></ul></li><li><p>velocity 调用 POJO 类的属性时, 建议直接使用属性名取值即可, 模板引擎会自动按规范调用 POJO 的 getXxx() , </p><ul><li>如果是 boolean 基本数据类型变量 （boolean 命名不需要加 is前缀 ） , 会自动调用 isXxx() 方法。</li><li><strong>注意</strong> 如果是 Boolean 包装类对象, 优先调用 getXxx() 的方法。</li></ul></li><li><p>后台输送给页面的变量必须加 $!{var} ——中间的感叹号。</p><ul><li>如果 var 为 null 或者不存在, 那么 ${var} 会直接显示在页面上。</li></ul></li><li><p>注意 Math.random() 这个方法返回是 double 类型, 注意取值的范围 0 &lt;= x &lt;1 （ 能够取到零值, 注意除零异常 ） , </p><ul><li>如果想获取整数类型的随机数, 不要将 x 放大 10 的若干倍然后取整, 直接使用 Random 对象的 nextInt 或者 nextLong 方法。</li></ul></li><li><p>获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</p><ul><li>如果想获取更加精确的纳秒级时间值, 用 System.nanoTime(), 在 JDK8 中, 针对统计时间等场景, 推荐使用 Instant 类。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>尽量不要在视图模板中加入变量声明、逻辑运算符, 更不要加入任何复杂的逻辑。</p><ul><li>根据MVC理论, 视图的原则是展示, 不要抢模板和控制器的活</li></ul></li><li><p>任何数据结构的构造或初始化, 都应指定大小, 避免数据结构无限增长吃光内存。</p></li><li><p>及时清理不再使用的代码段或配置信息, 避免程序过度臃肿, 代码冗余</p><ul><li>对于暂时被注释掉, 后续可能恢复使用的代码片段, 在注释代码上方, 统一规定使用三个斜杠来说明注释掉代码的理由</li></ul></li></ol><h1 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong><code>强制</code></strong></p><ol><li><p>Java类库中定义的一类 RuntimeException 可以通过预先检查进行规避, 而不应该通过 catch 来处理</p><ul><li>比如 IndexOutOfBoundsException NullPointerException 等等.</li><li>无法通过预检查的异常除外, 如在解析一个外部传来的字符串形式的数字时, 通过 catch NumberFormatException 来实现</li><li>正例: if (obj != null){…}</li><li>反例: try{obj.method()} catch(NullPointerException e){…}</li></ul></li><li><p>异常不要用来做流程控制, 条件控制, 因为异常的处理效率比条件分支低.</p></li><li><p>对大段代码进行 try-catch,  这是不负责任的表现。 </p><ul><li>catch 时请分清稳定代码和非稳定代码, 稳定代码指的是无论如何不会出错的代码。</li><li>对于非稳定代码的 catch 尽可能进行区分异常类型, 再做对应的异常处理。</li><li>但是! 新手来说,分不清稳不稳定, 最好用大 try 块, 避免有异常遗漏没有处理</li></ul></li><li><p>捕获异常是为了处理它, 不要捕获了却什么都不处理而抛弃之, 如果不想处理它, 请将该异常抛给它的调用者。</p><ul><li>最外层的业务使用者, 必须处理异常, 将其转化为用户可以理解的内容。</li></ul></li><li><p>有 try 块放到了事务代码中,  catch 异常后, 如果需要回滚事务, 一定要注意手动回滚事务。</p></li><li><p>finally 块必须对资源对象、流对象进行关闭, 有异常也要做 try-catch 。</p><ul><li>对于 JDK7及以上, 可以使用 try-with-resources 方式。</li></ul></li><li><p>不能在 finally 块中使用 return ,  finally 块中的 return 返回后方法结束执行, 不会再执行 try 块中的 return 语句。</p><ul><li>? try 还没走完就进了 finally ? </li></ul></li><li><p>捕获与抛出的异常, 必须是完全匹配, 或者捕获的异常是抛出的异常的父类。</p><ul><li>说明: 如果预期对方抛的是绣球, 实际接到的是铅球, 就会产生意外情况。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>方法的返回值可以为 null, 不强制返回空集合, 或者空对象等, 必须添加注释充分说明什么情况下会返回 null 值。<strong>调用方</strong>需要进行 null 判断防止 NPE 问题。</p><ul><li>本规约明确 <strong>防止 NPE 是调用者的责任</strong>。即使被调用方法返回空集合或者空对象, 对调用者来说, 也并非高枕无忧, 必须考虑到远程调用失败, 运行时异常等场景返回 null 的情况。</li></ul></li><li><p>防止 NPE, 是程序员的基本修养, 注意 NPE 产生的场景: </p><ol><li>返回类型为基本数据类型, return包装类型的对象时, 自动拆箱有可能产生 NPE.<ul><li>反例:  <code>public int f() {  return Integer对象};</code> 如果为 null , 自动拆箱将抛出 NPE</li></ul></li><li>数据库的查询结果可能为 null</li><li>集合里的元素即使 isNotEmpty , 取出的数据元素也可能为 null </li><li>远程调用返回对象时, 一律要求进行 NPE 检查</li><li>对于 Session 中获取的数据, 建议 NPE 检查</li><li>级联调用 <code>obj.getA().getB().getC();</code> 一连串调用, 易产生 NPE </li></ol></li><li><p>在代码中使用“抛异常”还是“返回错误码”</p><ul><li>对于公司外的 http/api 开放接口必须使用“错误码”; </li><li>而应用内部推荐异常抛出; </li><li>跨应用间 RPC 调用优先考虑 <strong>使用 Result 方式</strong>, 封装 isSuccess()方法, “错误码”, “错误简短信息”。</li><li>关于 RPC 方法返回方式使用 Result 方式的理由: <ol><li>使用抛异常返回方式, 调用方如果没有捕获到就会产生运行时错误。</li><li>如果不加栈信息, 只是 new 自定义异常, 加入自己的理解的 error message, 对于调用端解决问题的帮助不会太多<ul><li>如果加了栈信息, 在频繁调用出错的情况下, 数据序列化和传输的性能损耗也是问题。</li></ul></li></ol></li></ul></li><li><p>定义时区分 unchecked/checked 异常, 避免直接抛出 RuntimeException, 更不允许抛出 Exception 或者 Throwable, 应使用有业务含义的自定义异常</p><ul><li>推荐业界已定义过的自定义异常, 如:  DAOException /  ServiceException 等。</li></ul></li><li><p>避免出现重复的代码 （Don ’ t Repeat Yourself） , 即 DRY 原则。</p><ul><li>随意复制和粘贴代码, 必然会导致代码的重复, 在以后需要修改时, 需要修改所有的副本, 容易遗漏。必要时抽取共性方法, 或者抽象公共类, 甚至是组件化.</li><li>正例: 一个类中有多个public方法, 都需要进行数行相同的参数校验操作, 这个时候请抽取:</li><li><code>private boolean checkParam(DTO dto){...}</code></li></ul></li></ol><h2 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>应用中不可直接使用日志系统 （Log4j, Logback） 中的 API , 而应依赖使用日志框架 SLF4J 中的API, 使用门面模式的日志框架, 有利于维护和各个类的日志处理方式统一。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(A.class);</span><br></pre></td></tr></table></figure></li><li><p>日志文件推荐至少保存 15 天, 因为有些异常具备以“周”为频次发生的特点。</p></li><li><p>应用中的扩展日志 （ 如打点、临时监控、访问日志等 ） 命名方式: appName_logType_logName.log 。 </p><ul><li>logType: 日志类型<ul><li>推荐分类有stats / desc / monitor / visit 等</li></ul></li><li>logName: 日志描述<ul><li>这种命名的好处: 通过文件名就可知道日志文件属于什么应用, 什么类型, 什么目的, 也有利于归类查找。</li></ul></li><li>推荐对日志进行分类, 错误日志和业务日志尽量分开存放, 便于开发人员查看, 也便于通过日志对系统进行及时监控。</li></ul></li><li><p>对 trace / debug / info 级别的日志输出, 必须使用条件输出形式或者使用占位符的方式。</p><ul><li><code>logger.debug(&quot;Processing trade with id : &quot; + id + &quot; symbol : &quot; + symbol);</code></li><li>如果日志级别是 warn , 上述日志不会打印, 但是会执行字符串拼接操作</li><li>并且若 symbol 是对象, 会执行 toString() 方法, 浪费了系统资源, 执行了上述操作, 最终日志却没有打印。</li></ul></li><li><p>避免重复打印日志, 浪费磁盘空间, 务必在 log4j.xml 中设置 <code>additivity = false</code></p><ul><li><code>&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code></li></ul></li><li><p>异常信息应该包括两类信息: 案发现场信息和异常堆栈信息。如果不处理,就要通过关键字 throws 上抛</p><ul><li><code>logger.error(各类参数或者对象toString + &quot;_&quot; + e.getMessage(), e)</code></li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>可以使用 warn 日志级别来记录<code>用户输入参数错误</code>的情况, 避免用户投诉时, 无所适从。</p><ul><li>注意日志输出的级别,  error 级别只记录系统逻辑出错、异常等重要的错误信息。</li><li>如非必要, 请不要在此场景打出 error 级别。</li></ul></li><li><p>谨慎地记录日志。生产环境禁止输出 debug 日志 ;  有选择地输出 info 日志 ;  如果使用 warn 来记录刚上线时的业务行为信息, 一定要注意日志输出量的问题, 避免把服务器磁盘撑爆, 并记得及时删除这些观察日志。</p><ul><li>大量地输出无效日志, 不利于系统性能提升, 也不利于快速定位错误点。</li><li>记录日志时请思考: <ul><li>这些日志真的有人看吗？</li><li>看到这条日志你能做什么？</li><li>能不能给问题排查带来好处？</li></ul></li></ul></li></ol><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p><strong><code>强制</code></strong></p><ol><li><p>好的单元测试必须遵守 AIR 原则 </p><ul><li>单元测试在线上运行时, 就像空气 AIR 一样不存在, 但是测试质量的保障上, 却是非常关键的</li><li>好的单元测试宏观上来说, 具有自动化, 独立性, 可重复执行的特点<ul><li>A: Automatic  </li><li>I: Independent</li><li>R: Repeatable</li></ul></li></ul></li><li><p>单元测试应该是全自动执行的, 而且是非交互式的. 测试框架通常是定期执行的, 执行过程中必须完全自动化才有意义.</p><ul><li>输出结果需要人工检查的测试不是一个好的单元测试, 单元测试中不准使用 System.out 来进行人工验证, 必须使用 assert.</li></ul></li><li><p>保持单元测试的独立性. 为了保证单元测试稳定可靠且便于维护, 单元测试用例之间决不能互相调用, 也不能依赖执行的先后次序.</p><ul><li>method2 需要依赖 method1 的执行, 将执行结果作为method2 的输入.</li></ul></li><li><p>单元测试是可以重复执行的, 不能受到外界环境的影响.</p><ul><li>说明: <ul><li>单元测试通常会放到持续集成中, 每次有代码 check in 时单元测试都会被执行.</li><li>如果测试对外部环境(网络, 服务, 中间件等)有依赖, 容易导致持续集成机制的不可用.</li></ul></li><li>正例: <ul><li>为了不受外界环境影响, 要求设计代码时就把SUT的依赖改成注入, 在测试时用Spring这样的DI框架注入一个本地(内存)实现或者Mock实现.</li></ul></li></ul></li><li><p>对于单元测试, 要保证测试粒度足够小, 有助于精确定位问题. 单测粒度至多是类级别, 一般是方法级别.</p><ul><li>只有测试粒度小才能在出错时尽快定位到出错位置. 单测不负责检查跨类或者夸系统的交互逻辑, 那是集成测试的领域.</li></ul></li><li><p>核心业务, 核心应用, 核心模块的增量代码确保单元测试通过.</p><ul><li>新增代码及时补充单元测试, 如果新增代码影响了原有单元测试, 请及时修正.</li></ul></li><li><p>单元测试代码必须写在如下工程目录: src/test/java 不允许写在业务代码目录下.</p><ul><li>源码构建时会跳过此目录, 而单元测试框架默认是扫描此目录.</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>单元测试的基本目标: 语句覆盖率达到70%; 核心模块的语句覆盖率和分支覆盖率都要达到100%.</p><ul><li>在工程规约的应用分层中提高的DAO层, Manager层, 可重用度高的Service, 都应该进行单元测试.</li></ul></li><li><p>编写单元测试代码遵守BCDE原则, 以保证被测试模块的交付质量.</p><ul><li>B: Border, 边界值测试, 包括循环边界 特殊取值 特殊时间点 数据顺序等.</li><li>C: Correct, 正确的输入, 并得到预期的结果.</li><li>D: Design, 与设计文档相结合, 来编写单元测试.</li><li>E: Error, 强制错误信息输入 (如: 非法数据 异常流程 非业务允许输入等), 并得到预期的结果.</li></ul></li><li><p>对于数据库相关的查询, 更新, 删除等操作, 不能假设数据库里的数据是存在的, 或者直接操作数据库把数据插入进行, 请使用程序插入或者导入数据的方式来准备数据.(使用内存数据库就容易些)</p></li><li><p>和数据库相关的单元测试, 可以设定自动回滚机制, 不给数据库造成脏数据. 或者对单元测试产生的数据有明确的前后缀标识.</p><ul><li>在RDC内部单元测试中, 使用 RDC_UNIT_TEST_ 的前缀标识数据</li></ul></li><li><p>对于不可测的代码建议做必要的重构, 使代码变得可测, 避免为了达到测试要求而书写不规范测试代码.</p></li><li><p>在设计评审阶段, 开发人员需要和测试人员一起确定单元测试范围, 单元测试最好覆盖所有测试用例(UC).</p></li><li><p>单元测试作为一种质量保障手段, 不建议在项目发布后补充单元测试用例, 建议在项目提测前完成单元测试.</p></li><li><p>为了更方便地进行单元测试, 业务代码应避免以下情况:</p><ul><li>构造方法中做的事情过多.</li><li>存在过多的全局变量和静态方法.</li><li>存在过多的外部依赖.</li><li>存在过多的条件语句 (多层条件语句建议使用卫语句,策略模式,状态模式等方式重构)</li></ul></li><li><p>不要对单元测试存在如下误解:</p><ul><li>那是测试要干的事情. 本文是开发手册, 凡是本文内容都是与开发强相关的.</li><li>单元测试代码是多余的</li><li>单元测试不需要维护</li><li>单元测试和线上故障没有辩证关系</li></ul></li></ol><h1 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h1><p><strong><code>强制</code></strong></p><ol><li><p>隶属于用户个人的页面或者功能必须进行权限控制校验。</p><ul><li>防止没有做水平权限校验就可随意访问、修改 删除 别人的数据, 比如查看他人的私信内容, 修改他人的订单</li></ul></li><li><p>用户敏感数据禁止直接展示, 必须对展示数据脱敏。</p><ul><li>查看个人手机号码会显示成:158<em>**</em>9119, 隐藏中间 4 位, 防止隐私泄露。</li></ul></li><li><p>用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定, 防止 SQL 注入, 禁止字符串拼接 SQL 访问数据库。</p></li><li><p>用户请求传入的任何参数必须做有效性验证。</p><ul><li>忽略参数校验可能导致: <ul><li>page size 过大导致内存溢出</li><li>恶意 order by 导致数据库慢查询</li><li>任意重定向</li><li>SQL 注入</li><li>反序列化注入</li><li>正则输入源串拒绝服务 ReDoS</li></ul></li><li>Java 代码用正则来验证客户端的输入, 有些正则写法验证普通用户输入没有问题, 但是如果攻击人员使用的是特殊构造的字符串来验证, 有可能导致死循环的效果。</li></ul></li><li><p>禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</p></li><li><p>表单, AJAX 提交必须执行 CSRF 安全过滤</p><ul><li>CSRF(Cross-site request forgery) 跨站请求伪造是一类常见编程漏洞。</li><li>对于存在CSRF 漏洞的应用/网站, 攻击者可以事先构造好 URL, 只要受害者用户一访问, 后台便在用户不知情情况下对数据库中用户参数进行相应修改。<blockquote><p><strong>个人理解</strong> 万一ajax接口的API暴露了, 被别有用心的人利用就能构造好页面, 用于钓鱼什么的</p></blockquote></li></ul></li><li><p>在使用平台资源, 譬如短信、邮件、电话、下单、支付, 必须实现正确的防重放限制, 如数量限制、疲劳度控制、验证码校验, 避免被滥刷、资损。</p><ul><li>如注册时发送验证码到手机, 如果没有限制次数和频率, 那么可以利用此功能骚扰到其它用户, 并造成短信平台资源浪费。</li></ul></li><li><p>发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。</p></li></ol><h1 id="MySQL规约"><a href="#MySQL规约" class="headerlink" title="MySQL规约"></a>MySQL规约</h1><h2 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>表达是与否概念的字段, 必须使用 is_xxx 的方式命名, 数据类型是 unsigned tinyint (1 表示是, 0 表示否)</p><ul><li>任何字段如果为非负数, 必须是 unsigned 。</li><li>正例: 表达逻辑删除的字段名 is_deleted, 1表示删除, 0表示未删除.<blockquote><p>个人理解: 是不是简单的整型枚举也可以这么用呢</p></blockquote></li></ul></li><li><p>表名、字段名必须使用小写字母或数字; 禁止出现数字开头, 禁止两个下划线中间只出现数字。数据库字段名的修改代价很大, 因为无法进行预发布, 所以字段名称需要慎重考虑。</p><ul><li>MySQL 在 Windows 下不区分大小写, 但在 Linux 下默认是区分大小写, 因此 数据库名, 表名 字段名 都不允许出现任何大写字母.</li></ul></li><li><p>表名不使用复数名词。</p><ul><li>表名应该仅仅表示表里面的实体内容, 不应该表示实体数量, 对应于 DO 类名也是单数形式, 符合表达习惯。</li></ul></li><li><p>禁用保留字, 如 desc 、 range 、 match 、 delayed 等, 请参考 MySQL 官方保留字。</p></li><li><p>主键索引名为 pk_字段名, 唯一索引名为 uk_字段名, 普通索引名则为 idx_字段名。</p><ul><li>pk_ 即 primary key, uk_ 即  unique key, idx_ 即 index 的简称。</li></ul></li><li><p>小数类型为 decimal , 禁止使用 float 和 double 。</p><ul><li>float 和 double 在存储的时候, 存在精度损失的问题, 很可能在值的比较时, 得到不正确的结果。</li><li>如果存储的数据范围超过 decimal 的范围, 建议将数据拆成整数和小数分开存储。</li></ul></li><li><p>如果某字段存储的字符串长度几乎是固定的, 使用 char 定长字符串类型。</p></li><li><p>varchar 是可变长字符串, 不预先分配存储空间, 长度不要超过 500, </p><ul><li>如果存储长度大于此值, 定义字段类型为 text , 独立出来一张表, 用主键来对应, 避免影响其它字段索引效率。</li></ul></li><li><p>表必备三字段:  id,  gmt_create,  gmt_modified 。</p><ul><li>其中 id 必为主键, 类型为 unsigned bigint 、单表时自增、步长为 1。 </li><li>gmt_create ,gmt_modified 的类型均为 date_time 类型, 前者现在时表示主动创建, 后者过去分词表示被动更新.</li><li>GMT 是指格林尼治时间, 这样的话, 就是会让表的数据和时间关联上, 具有一定数据分析价值</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>表的命名最好是加上“业务名称_表的作用”。</p><ul><li>正例: alipay_task force_project trade_config</li></ul></li><li><p>库名与应用名称尽量一致。</p></li><li><p>如果修改字段含义或对字段表示的状态追加时, 需要及时更新字段注释。</p></li><li><p>字段允许适当冗余, 以提高查询性能, 但必须考虑数据一致, 冗余字段应遵循: </p><ol><li>不是频繁修改的字段。</li><li>不是 varchar 超长字段, 更不能是 text 字段。</li></ol><ul><li>正例: 商品类目名称使用频率高, 字段长度短, 名称基本一成不变, 可在相关联的表中冗余存储类目名称, 避免关联查询。</li></ul></li><li><p>单表行数超过 500 万行或者单表容量超过 2 GB, 才推荐进行分库分表。</p><ul><li>如果预计三年后的数据量根本达不到这个级别, 请不要在创建表时就分库分表。</li></ul></li><li><p>合适的字符存储长度, 不但节约数据库表空间、节约索引存储, 更重要的是提升检索速度。</p><ul><li><p>如下表, 其中无符号值可以避免误存负数, 且扩大了表示范围.</p><p>| 对象 | 年龄区间 | 类型 | 字节 | 表示范围 |<br>|:—-:|:—-:|:—-|:—-:|:—-|<br>| 人 | 150岁之内 | unsigned tinyint | 1 | 0 - 255 |<br>| 龟 | 数百年 | unsigned smallint | 2 | 0 - 65535 |<br>| 恐龙化石 | 数千万年 | unsigned int | 4 | 0 - 约42.9亿 |<br>| 太阳 | 约50亿年 | unsigned bigint | 8 | 0 - 约10的19次幂 |</p></li></ul></li></ol><h2 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>业务上具有唯一特性的字段, 即使是多个字段的组合, 也必须建成唯一索引。</p><ul><li>不要以为唯一索引影响了 insert 速度, 这个速度损耗可以忽略, 但提高查找速度是明显的 ;  </li><li>另外, 即使在应用层做了非常完善的校验控制, 只要没有唯一索引, 根据墨菲定律, 必然有脏数据产生。</li></ul></li><li><p>超过三个表禁止 join。需要 join 的字段, 数据类型必须保持绝对一致; 多表关联查询时, 保证被关联的字段需要有索引。</p><ul><li>即使双表 join 也要注意表索引、SQL 性能。</li></ul></li><li><p>在 varchar 字段上建立索引时, 必须指定索引长度, 没必要对全字段建立索引, 根据实际文本区分度决定索引长度即可。</p><ul><li>索引的长度与区分度是一对矛盾体, 一般对字符串类型数据, 长度为 20 的索引, 区分度会高达 90% 以上, </li><li>可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。</li></ul></li><li><p>页面搜索严禁左模糊或者全模糊, 如果需要请使用搜索引擎来解决。</p><ul><li>索引文件具有 B-Tree 的最左前缀匹配特性, 如果左边的值未确定, 那么无法使用此索引。</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>如果有 order by 的场景, 请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分,</p><ul><li>并且放在索引组合顺序的最后, 避免出现 file_sort 的情况, 影响查询性能。</li><li>正例: <code>where a = ? and b = ? order by c;</code> 索引:  a_b_c</li><li>反例: 索引中有范围查找, 那么索引有序无法利用, 如: WHERE a &gt; 10 order by b; 索引 a_b 无法排序.</li></ul></li><li><p>利用覆盖索引来进行查询操作, 来避免回表操作。</p><ul><li>如果一本书需要知道第 11 章是什么标题, 会翻开第 11 章对应的那一页吗? 目录浏览一下就好, 这个目录就是起到覆盖索引的作用.</li><li>能够建立索引的种类: 主键索引、唯一索引、普通索引, 而覆盖索引是一种查询的一种效果, 用 explain 的结果, extra 列会出现:  using index 。</li><li>覆盖索引是select的数据列只用从索引中就能够取得, 不必读取数据行, 换句话说查询列要被所建的索引覆盖。<ul><li><strong>理解方式一</strong>: 索引是高效找到行的一个方法, 但是一般数据库也能使用索引找到一个列的数据, 因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据; 当能通过读取索引就可以得到想要的数据, 那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引</li><li><strong>理解方式二</strong>: 是非聚集复合索引的一种形式, 它包括在查询里的Select、Join和Where子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段, 也即, 索引包含了查询正在查找的数据）。</li></ul></li></ul></li><li><p>利用延迟关联或者子查询优化超多分页场景。</p><ul><li>MySQL 并不是跳过 offset 行, 而是取 offset + N 行, 然后返回放弃前 offset 行, 返回 N 行, 那当 offset 特别大的时候, 效率就非常的低下, 要么控制返回的总页数, 要么对超过特定阈值的页数进行 SQL 改写.</li><li>正例: 先快速定位需要获取的id段, 然后再关联:<ul><li>select a.* from table_a a, (select id from table_a where 条件 limit 100000, 20) b where a.id = b.id</li></ul></li></ul></li><li><p>SQL 性能优化的目标: 至少要达到  range 级别, 要求是 ref 级别, 如果可以是 consts最好。</p><ol><li>consts 单表中最多只有一个匹配行 （ 主键或者唯一索引 ） , 在优化阶段即可读取到数据。</li><li>ref 指的是使用普通的索引 （normal index） 。</li><li>range 对索引进行范围检索。</li></ol><ul><li>反例: explain 表的结果,  type = index , 索引物理文件全扫描, 速度非常慢, 这个 index 级别比较 range 还低, 与全表扫描是小巫见大巫。</li></ul></li><li><p>建组合索引的时候, 区分度最高的在最左边。</p><ul><li>正例: 如果 <code>where a = ? and b = ?</code>,  a 列的几乎接近于唯一值, 那么只需要单建 idx_a 索引即可。</li><li>存在非等号和等号混合判断条件时, 在建索引时, 请把等号条件的列前置。</li><li>如:  <code>where a &gt; ? and b = ?</code> 那么即使 a 的区分度更高, 也必须把 b 放在索引的最前列。</li></ul></li><li><p>防止因字段类型不同造成的隐式转换, 导致索引失效.</p></li><li><p>创建索引时避免有如下极端误解: </p><ol><li>宁缺毋滥. 认为一个查询就需要建一个索引。</li><li>宁缺毋滥. 认为索引会消耗空间、严重拖慢更新和新增速度。</li><li>抵制惟一索引. 认为业务的惟一性一律需要在应用层通过 “先查后插” 方式解决。</li></ol></li></ol><h2 id="SQL规约"><a href="#SQL规约" class="headerlink" title="SQL规约"></a>SQL规约</h2><p><strong><code>强制</code></strong></p><ol><li><p>不要使用 count(列名) 或 count(常量) 来替代 count(<em>),  count( </em> ) 就是 SQL 92 定义的标准统计行数的语法, 跟数据库无关, 跟 NULL 和非 NULL 无关。</p><ul><li>count( * ) 会统计值为 NULL 的行, 而 count(列名) 不会统计此列为 NULL 值的行。</li></ul></li><li><p>count(distinct col) 计算该列除 NULL 之外的不重复行数。注意 count(distinct col1,  col2) 如果其中一列全为 NULL, 那么即使另一列有不同的值, 也返回为 0。</p></li><li><p>当某一列的值全是 NULL 时,  count(col) 的返回结果为 0, 但 sum(col) 的返回结果为NULL , 因此使用 sum() 时需注意 NPE 问题。</p><ul><li>正例: 可以使用如下方式来避免 sum 的 NPE 问题:  <code>SELECT IF(ISNULL(SUM(g)) ,0, SUM(g))FROM table;</code></li></ul></li><li><p>使用 ISNULL() 来判断是否为 NULL 值。注意:  NULL 与任何值的直接比较都为 NULL。</p><p> | 表达式 | 返回值 |<br> |:—-|:—-:|<br> | NULL&lt;&gt;NULL | NULL 而不是 false |<br> | NULL=NULL | NULL 而不是 true |<br> | NULL&lt;&gt;1 | NULL 而不是 true |</p></li><li><p>在代码中写分页查询逻辑时, 若 count 为 0 应直接返回, 避免执行后面的分页语句。</p></li><li><p>不得使用外键与级联, 一切外键概念必须在应用层解决。</p><ul><li>说明: 以学生和成绩的关系为例, 学生表中的 student_id 是主键, 那么成绩表中的 student_id 则为外键。<ul><li>如果更新学生表中的 student_id , 同时触发成绩表中的 student_id 更新, 则为级联更新。</li></ul></li><li>外键与级联更新适用于单机低并发, 不适合分布式、高并发集群; 级联更新是强阻塞, 存在数据库更新风暴的风险; </li><li>并且外键影响数据库的插入速度。</li></ul></li><li><p>禁止使用存储过程, 存储过程难以调试和扩展, 更没有移植性。</p></li><li><p>数据订正时, 删除和修改记录时, 要先 select, 避免出现误删除, 确认无误才能执行更新语句。</p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>in 操作能避免则避免, 若实在避免不了, 需要仔细评估 in 后边的集合元素数量, 控制在 1000 个之内。</p></li><li><p>如果有全球化需要, 所有的字符存储与表示, 均以 utf-8 编码, 注意字符统计函数的区别</p><ul><li><strong>注意</strong>: <ul><li>SELECT LENGTH( “轻松工作” );  返回为 12</li><li>SELECT CHARACTER _ LENGTH( “轻松工作” );  返回为 4</li></ul></li><li>如果需要存储表情, 那么使用 utfmb4(这才是真正的UTF-8) 来进行存储, MySQL 的 utf-8 编码只能存放3字节的字符</li></ul></li><li><p>TRUNCATE TABLE 比 DELETE 速度快, 且使用的系统和事务日志资源少, 但 TRUNCATE 无事务且不触发 trigger, 有可能造成事故, 故不建议在开发代码中使用此语句。</p><ul><li>TRUNCATE TABLE 在功能上与不带  WHERE 子句的  DELETE 语句相同。</li></ul></li></ol><h2 id="ORM映射"><a href="#ORM映射" class="headerlink" title="ORM映射"></a>ORM映射</h2><p><strong><code>强制</code></strong></p><ol><li><p>在表查询中, 一律不要使用 * 作为查询的字段列表, 需要哪些字段必须明确写明。</p><ol><li>增加查询分析器解析成本。</li><li>增减字段容易与 resultMap 配置不一致。</li></ol></li><li><p>POJO 类的 boolean 属性不能 is 开头, 而数据库字段必须加 is_, 要求在 resultMap 中进行字段与属性之间的映射。</p><ul><li>参见定义POJO类以及数据库字段定义的规定, 在 <code>&lt;resultMap&gt;</code> 中增加映射是必须的, 在 Mybatis Generator 生成的代码中, 需要进行对应的修改.</li></ul></li><li><p>不要用 resultClass 当返回参数, 即使所有类属性名与数据库字段一一对应, 也需要定义;  反过来, 每一个表也必然有一个与之对应。</p><ul><li>说明: 配置映射关系, 使字段与DO类解耦, 方便维护.</li></ul></li><li><p><code>sql.xml</code> 配置中参数注意使用: #{}, #param# 不要使用 ${} 此种方式容易出现 SQL 注入。</p></li><li><p>iBATIS 自带的 queryForList(String statementName , int start , int size) 不推荐使用。</p><ul><li>其实现方式是在数据库取到 statementName 对应的SQL语句的所有记录, 再通过 subList 取 start, size 的子集合 线上因为这个原因曾经出现过 OOM </li><li>正例: <ul><li>Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</li><li>map.put(“start”, start);</li><li>map.put(“size”, size);</li></ul></li></ul></li><li><p>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</p><ul><li>resultClass=”Hashtable”, 会置入字段名和属性值, 但是值的类型不可控 </li></ul></li><li><p>更新数据表记录时, 必须同时更新记录对应的 gmt_modified 字段值为当前时间。</p></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>不要写一个大而全的数据更新接口, 传入为 POJO 类, 不管是不是自己的目标更新字段, </p><ul><li>都进行 <code>update table set c1=value1,c2=value2,c3=value3;</code> </li><li>这是不对的。执行 SQL时, 尽量不要更新无改动的字段, 一是易出错; 二是效率低 ; 三是 binlog 增加存储。</li></ul></li><li><p>@Transactional 事务不要滥用。事务会影响数据库的 QPS, 另外使用事务的地方需要考虑各方面的回滚方案, </p><ul><li>包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</li></ul></li><li><p><code>&lt;isEqual&gt;</code> 中的 compareValue 是与属性值对比的常量, 一般是数字, 表示相等时带上此条件;  </p><ul><li><code>&lt;isNotEmpty&gt;</code> 表示不为空且不为 null 时执行 ; </li><li><code>&lt;isNotNull&gt;</code> 表示不为 null 值时执行。</li></ul></li></ol><h1 id="工程规约"><a href="#工程规约" class="headerlink" title="工程规约"></a>工程规约</h1><h2 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h2><p><strong><code>推荐</code></strong></p><ol><li>图中默认上层依赖于下层, 箭头关系表示可直接依赖, 如: 开放接口层可以依赖于Web 层, 也可以直接依赖于 Service 层, 依此类推: <blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Alibaba/ApplicationLevels.png" alt="Application Level" title="">                </div>                <div class="image-caption">Application Level</div>            </figure>  <ul><li><strong>开放接口层</strong>: 可直接封装 Service 接口暴露成 RPC(Remote Procedure Calls) 接口;  通过 Web 封装成 http 接口; 进行网关安全控制, 流量控制等.</li><li><strong>终端显示层</strong>: 各个端的模板渲染并执行显示的层。当前主要是 Velocity 渲染, JS 渲染, JSP 渲染, 移动端展示层等。</li><li><strong>Web 层</strong>: 主要是对访问控制进行转发, 各类基本参数校验, 或者不复用的业务简单处理等。</li><li><strong>Service 层</strong>: 相对具体的业务逻辑服务层。</li><li><strong>Manager 层</strong>: 通用业务处理层, 它有如下特征: <ol><li>对第三方平台封装的层, 预处理返回结果及转化异常信息 ; </li><li>对 Service 层通用能力的下沉, 如缓存方案、中间件通用处理 ; </li><li>与 DAO 层交互, 对 DAO 的业务通用能力的封装, 对多个 DAO 的组合复用</li></ol></li><li><strong>DAO 层</strong>: 数据访问层, 与底层 MySQL、Oracle、 Hbase 等进行数据交互。</li><li><strong>外部接口或第三方平台</strong>: 包括其它部门 RPC 开放接口, 基础平台, 其它公司的 HTTP 接口。</li></ul></blockquote></li></ol><p><strong><code>参考</code></strong></p><ol><li><p><strong>分层异常处理规约</strong> 在 DAO 层, 产生的异常类型有很多, 无法用细粒度异常进行catch, 使用 catch(Exception e) 方式, 并 throw new DAOException(e), 不需要打印日志, </p><ul><li>因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去, 如果同台服务器再打日志, 浪费性能和存储。</li><li>在 Service 层出现异常时, 必须记录出错日志信息到磁盘, 尽可能带上必要的参数信息(能够描述出场景的大致状态), 相当于保护案发现场。</li><li>如果 Manager 层与 Service 同机部署, 日志方式与 DAO 层处理一致; 如果是单独部署, 则采用与 Service 一致的处理方式。</li><li>Web 层绝不应该继续往上抛异常, 因为已经处于顶层, 无继续处理异常的方式, 如果意识到这个异常将导致页面无法正常渲染, 那么就应该直接跳转到友好错误页面, 尽量加上友好的错误提示信息。</li><li>开放接口层要将异常处理成错误码和错误信息方式返回。</li></ul></li><li><p>分层领域模型规约: </p><p>| 缩写 | 名称 | 作用 |<br>|:—-|:—-|:—-|<br>| DO | Data Object | 与数据库表结构一一对应, 通过DAO层向上传输数据源对象 |<br>| DTO | Data Transfer Object | 数据传输对象, Service或Manager向外传输的对象 |<br>| BO | Business Object | 由Service层输出的封装业务逻辑的对象 |<br>| AO | Application Object | 应用对象, 在Web层与Service层之间抽象的复用对象模型, 极为贴近展示层, 复用度不高 |<br>| VO | View Object | 显示层对象, 通常是Web向模板引擎传输的对象 |<br>| Qurey | | 数据查询对象, 各层接收上层的查询请求, 注意超过2个参数的查询封装, 禁止使用Map类来传输 |</p></li></ol><h2 id="二方库依赖"><a href="#二方库依赖" class="headerlink" title="二方库依赖"></a>二方库依赖</h2><p><strong><code>强制</code></strong></p><ol><li><p>定义 GAV 遵从以下规则: </p><ul><li><strong>GroupID</strong> 格式:  <code>com.{公司/BU}.业务线.[子业务线]</code>, 最多 4 级。<ul><li>{公司/BU} 例如:  alibaba/taobao/tmall/aliexpress 等 BU; 子业务线可选。</li><li>正例: com.taobao.jstorm 或  com.alibaba.dubbo.register </li></ul></li><li><strong>ArtifactID</strong> 格式: 产品线名-模块名。语义不重复不遗漏, 先到仓库中心去查证一下。<ul><li>正例: dubbo-client /  fastjson-api /  jstorm-tool</li></ul></li><li><strong>Version</strong> : 详细规定参考下方。</li></ul></li><li><p>二方库版本号命名方式: 主版本号.次版本号.修订号</p><ol><li>主版本号: 产品方向改变, 或者大规模API不兼容, 或者架构不兼容升级. </li><li>次版本号: 保持相对兼容性, 增加主要功能特性, 影响范围极小的API不兼容修改.</li><li>修订号: 保持完全兼容性, 修复 bug, 新增次要功能特性等</li></ol><ul><li>说明: 注意起始版本号必须为:  1.0.0 , 而不是 0.0.1, 正式发布的类库必须先去中央仓库进行查证, 使版本号有延续性, 正式版本号不允许覆盖升级</li><li>如当前版本 1.3.3 那么下一个合理的版本号 1.3.4 或者 1.4.0 或 2.0.0</li></ul></li><li><p>线上应用不要依赖 SNAPSHOT 版本（安全包除外）; </p><ul><li>不依赖 SNAPSHOT 版本是保证应用发布的幂等性. 另外, 也可以加快编译时的打包构建.</li></ul></li><li><p>二方库的新增或升级, 保持除功能点之外的其它 jar 包仲裁结果不变。</p><ul><li>如果有改变, 必须明确评估和验证, 建议进行 dependency:resolve 前后信息比对, </li><li>如果仲裁结果完全不一致, 那么通过 dependency:tree 命令, 找出差异点, 进行<code>&lt;excludes&gt;</code>排除 jar 包。</li></ul></li><li><p>二方库里可以定义枚举类型, 参数可以使用枚举类型, 但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。</p></li><li><p>依赖于一个二方库群时, 必须定义一个统一版本变量, 避免版本号不一致。</p><ul><li>说明: 依赖 springframework-core, -context, -beans, 它们都是同一个版本</li><li>可以定义一个变量来保存版本: ${spring.version}, 定义依赖的时候, 引用该版本。</li></ul></li><li><p>禁止在子项目的 pom 依赖中出现相同的 GroupId , 相同的 ArtifactId , 但是不同的Version 。</p><ul><li>在本地调试时会使用各子项目指定的版本号, 但是合并成一个war, 只能有一个版本号出现在最后的lib目录中, 可能出现线下调试是正确的, 发布到线上却出故障的问题.</li></ul></li></ol><p><strong><code>推荐</code></strong></p><ol><li><p>所有 pom 文件中的依赖声明放在 <code>&lt;dependencies&gt;</code> 语句块中, 所有版本仲裁放在<code>&lt;dependencyManagement&gt;</code> 语句块中。</p><ul><li><code>&lt;dependencyManagement&gt;</code> 里只是声明版本, 并不实现引入, 因此子项目需要显式的声明依赖,  version 和 scope 都读取自父 pom 。</li><li>而 <code>&lt;dependencies&gt;</code> 所有声明在主 pom 的 <code>&lt;dependencies&gt;</code> 里的依赖都会自动引入, 并默认被所有的子项目继承。</li></ul></li><li><p>二方库不要有配置项, 最低限度不要再增加配置项。</p></li></ol><p><strong><code>参考</code></strong></p><ol><li>为避免应用二方库的依赖冲突问题, 二方库发布者应当遵循以下原则: <ol><li><strong>精简可控原则</strong> 移除一切不必要的 API 和依赖, 只包含 Service API、必要的领域模型对象、 Utils类、常量、枚举等。<ul><li>如果依赖其它二方库, 尽量是 provided 引入, 让二方库使用者去依赖具体版本号; 无 log 具体实现的依赖, 只依赖日志框架(例如不依赖Logback而是依赖SLF4J)。</li></ul></li><li><strong>稳定可追溯原则</strong> 每个版本的变化应该被记录, 二方库由谁维护, 源码在哪里, 都需要能方便查到。除非用户主动升级版本, 否则公共二方库的行为不应该发生变化。</li></ol></li></ol><h2 id="服务器规约"><a href="#服务器规约" class="headerlink" title="服务器规约"></a>服务器规约</h2><p><strong><code>推荐</code></strong></p><ol><li><p>高并发服务器建议调小 TCP 协议的 time_wait 超时时间。</p><ul><li>说明: 操作系统默认 240 秒后, 才会关闭处于 time_wait 状态的连接, 在高并发访问下, 服务器端会因为处于 time_wait 的连接数太多,可能无法建立新的连接, 所以需要在服务器上调小此等待值。</li><li>正例: 在 linux 服务器上请通过变更 <code>/etc/sysctl.conf</code> 文件去修改该缺省值 （ 秒 ）<ul><li><code>net.ipv4.tcp_fin_timeout = 30</code></li></ul></li></ul></li><li><p>调大服务器所支持的最大文件句柄数 （File Descriptor, 简写为 fd） 。</p><ul><li>说明: 主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理, 即一个连接对应于一个 fd 。<ul><li>主流的 linux 服务器默认所支持最大 fd 数量为 1024, 当并发连接数很大时很容易因为 fd 不足而出现“ open too many files ”错误, 导致新的连接无法建立。 </li><li>建议将 linux服务器所支持的最大句柄数调高数倍 （与服务器的内存数值相关）</li></ul></li></ul></li><li><p>给 JVM 设置 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 参数, 让 JVM 碰到 OOM 场景时输出dump 信息。</p><ul><li>OOM 的发生是有概率的, 甚至有规律地相隔数月才出现一例, 出现时的现场信息对查错非常有价值。</li></ul></li><li><p>在线上生产环境, JVM 的 Xms 和 Xmx 设置一样的内存容量, 避免在GC后调整堆大小带来的压力</p></li><li><p>服务器内部重定向使用 forward;  外部重定向地址使用 URL 拼装工具类来生成, 否则会带来 URL 维护不一致的问题和潜在的安全风险。</p></li></ol><h1 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h1><ol><li><p>POJO (Plain Ordinary Java Object): 在手册中, POJO专指只有 setter/getter/toString 的简单类, 包括 DO/DTO/BO/VO等.</p></li><li><p>GAV (GroupId, AritifactId, Version): Maven 坐标, 是用来唯一标识 jar 包.</p></li><li><p>OOP(Object Oriented Programming): 泛指类,对象的编程处理方式</p></li><li><p>ORM(Object Relation Mapping): 对象关系映射, 对象领域模型与底层数据之间的转换, 本文泛指 iBATIS Mybatis 等框架</p></li><li><p>NPE(java.lang.NullPointerException): 空指针异常</p></li><li><p>SOA(Service-Oriented Architecture): 面向服务架构, 它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署, 组合和使用, 有利于提升组件可重用性, 可维护性.</p></li><li><p>一方库: 本工程内部子项目模块依赖的库 jar包</p></li><li>二方库: 公司内部发布到中央仓库, 可供公司内部其他应用依赖的库 jar包</li><li>三方库: 公司之外的开源库 jar包</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#阿里巴巴java开发手册&quot;&gt;阿里巴巴Java开发手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#编程规约&quot;&gt;编程规约&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#命名规约&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Server.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Blog-Server/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Blog-Server/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#server">Server</a><ol><li><a href="#终端">终端</a></li><li><a href="#内存优化">内存优化</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><blockquote><p>服务器运维相关</p></blockquote><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwNjEwNTQ4Mw==&amp;mid=2651580395&amp;idx=1&amp;sn=d311abab344aed97fe8b5244aa51e08d&amp;chksm=8cd9f90fbbae7019fc5ee8fbe423c8027527f068bcb71ad3d7a18b85a503bc4ffd377dfb9b6d&amp;mpshare=1&amp;scene=1&amp;srcid=0110cegY48pxj9fMGcObeEMT&amp;pass_ticket=9AXPGsZExYCvgc64Pq%2Fge7rdAI7U%2F%2BG%2F5NrA4rv24OXW2BDRnIZzo5eMh%2F%2FanrNZ#rd" target="_blank" rel="noopener">效率为王：终端管理工具 Tmux </a></li></ul><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><blockquote><p><a href="http://www.cnblogs.com/dongzhiquan/p/5043912.html" target="_blank" rel="noopener">参考博客 大内存页配置实战</a> <code>内存占用大, 访问随机就需要使用大内存页了</code><br><a href="http://www.oracle.com/technetwork/cn/articles/servers-storage-dev/hugepages-2099009-zhs.html" target="_blank" rel="noopener">Oracle官网的使用案例</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#server&quot;&gt;Server&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#终端&quot;&gt;终端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#内存优化&quot;&gt;内存优化&lt;/a&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Solution.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Blog-Solution/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Blog-Solution/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#解决方案">解决方案</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><blockquote><p>关于问题的解决方案</p></blockquote><p><a href="http://www.cnblogs.com/x-xk/archive/2012/11/17/2770935.html" target="_blank" rel="noopener">站内信设计思路之己见（基于上百万用户）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#解决方案&quot;&gt;解决方案&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-13 12:06&lt;/em&gt;| &lt;a href=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>View.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Blog-View/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Blog-View/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#前端">前端</a><ol><li><a href="#基础">基础</a><ol><li><a href="#规范">规范</a></li></ol></li><li><a href="#css">CSS</a></li><li><a href="#相关库">相关库</a><ol><li><a href="#jquery">Jquery</a></li><li><a href="#bootstrap">Bootstrap</a></li><li><a href="#layui">LayUI</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><blockquote><p>半学半就 <a href="https://kuangcp.github.io/main.html" target="_blank" rel="noopener">个人导航页</a></p></blockquote><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><blockquote><p><a href="https://www.cnblogs.com/Smiled/p/8377188.html" target="_blank" rel="noopener">我所理解的前端</a><br><a href="http://blog.csdn.net/limlimlim/article/details/9088161" target="_blank" rel="noopener">Javascript字典操作</a><br><a href="https://segmentfault.com/a/1190000002447815" target="_blank" rel="noopener">js数据结构和算法（五）字典和散列（hash） </a></p></blockquote><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul><li><a href="https://juejin.im/post/592d4a5b0ce463006b43b6da" target="_blank" rel="noopener">前端开发命名规范</a></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><a href="http://www.html5tricks.com/9-nick-css3-menu-button.html" target="_blank" rel="noopener">酷炫按钮</a></li></ul><h2 id="相关库"><a href="#相关库" class="headerlink" title="相关库"></a>相关库</h2><h3 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h3><ul><li><a href="http://www.codeceo.com/article/10-jquery-image-player.html#0-tsina-1-78156-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="noopener">10个超赞的jQuery图片滑块动画</a></li></ul><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><h3 id="LayUI"><a href="#LayUI" class="headerlink" title="LayUI"></a>LayUI</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#前端&quot;&gt;前端&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#基础&quot;&gt;基础&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#规范&quot;&gt;规范&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-AdvancedLearning-Generics/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-AdvancedLearning-Generics/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#泛型">泛型</a><ol><li><a href="#入门">入门</a><ol><li><a href="#简单使用">简单使用</a><ol><li><a href="#类型擦除">类型擦除</a></li></ol></li><li><a href="#约束和局限性">约束和局限性</a></li><li><a href="#泛型类型的继承规则">泛型类型的继承规则</a></li><li><a href="#通配符类型">通配符类型</a><ol><li><a href="#子类型限定的通配符-extends">子类型限定的通配符 extends</a></li><li><a href="#超类型限定的通配符-super">超类型限定的通配符 super</a><ol><li><a href="#应用">应用</a></li></ol></li><li><a href="#无限定通配符">无限定通配符</a></li><li><a href="#通配符捕获">通配符捕获</a></li></ol></li><li><a href="#反射和泛型">反射和泛型</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514015&amp;idx=1&amp;sn=12409f705c6d266e4cd062e78ce50be0&amp;chksm=80d67c5cb7a1f54a68ed83580b63b4acded0df525bb046166db2c00623a6bba0de3c5ad71884&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">开始学习的兴趣来源</a></p></blockquote><p><a href="http://www.cnblogs.com/lwbqqyumidi/p/3837629.html" target="_blank" rel="noopener">参考博客: Java总结篇系列：Java泛型</a><br>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。<br>那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。<br><a href="http://www.infoq.com/cn/articles/cf-java-generics" target="_blank" rel="noopener">参考博客: Java深度历险（五）——Java泛型</a></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote><p>泛型程序设计划分为三个熟练级别 基本级别就是仅仅使用泛型类,典型的是像ArrayList这样的集合–不必考虑他们的工作方式和原因,大多数人会停留在这个级别.直到出现了什么问题. 当把不同的泛型类混合在一起的时候,或是对类型参数一无所知的遗留代码进行对接时,可能会看到含糊不清的错误消息.如果这样的话,就需要系统的进行学习Java泛型来系统地解决问题.<br>泛型类可以看作普通类的工厂  – Java核心技术卷 2004(1.5)  </p></blockquote><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><blockquote><ul><li><a href="https://github.com/Kuangcp/JavaBase/blob/master/src/main/java/com/generic/simple/Pair.java" target="_blank" rel="noopener">简单泛型类示例</a></li></ul></blockquote><p>例如该行定义 : <code>public abstract class RoomCache&lt;P extends PlayerBO, M extends MemberBO, V extends VideoDataBO&lt;M&gt;, R extends RoomBO&lt;M, V&gt;&gt; extends AbstractCache&lt;PlatformRoomId, R&gt; {}</code></p><ul><li>类型变量使用大写的一个字母这是代表:<ul><li><code>E</code> 集合的元素类型 </li><li><code>K V</code> 表示表的关键字和值的类型 </li><li><code>T U S</code> 等就表示任意类型</li><li></li></ul></li></ul><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><ul><li>不同于C++的泛型,C++是将模板类组合出来的生成一个新的类,Java则是进行类型擦除,然后再类型强转</li><li>例如 <code>public static &lt;T extends Comparable&gt; T min (T[] list)</code><ul><li>擦除后就只剩下一个方法 <code>public static Comparable min(Comparable[] list)</code></li></ul></li><li><p><a href="https://github.com/Kuangcp/JavaBase/blob/master/src/main/java/com/generic/simple/DateInterval.java" target="_blank" rel="noopener">泛型类擦除示例</a></p></li><li><p>例如该方法签名 <code>public static  &lt;T extends Comparable &amp; Serializable&gt; T getMax(T[]list)</code></p><ul><li>限制了必须是实现了两个接口的类才能使用, 估计为了少创关键字所以使用的是extends关键字来表示T要实现两个接口</li><li>同样的可以加在类的签名上,进行限制类的泛型类型 <code>public class Pair &lt;T extends Comparable&gt;{}</code></li></ul></li></ul><blockquote><p>在Java的继承中,可以根据需要拥有多个接口超类型,但限定中至多只有一个类,如果用一个类作为限定,他必须是限定列表中的第一个</p></blockquote><hr><h3 id="约束和局限性"><a href="#约束和局限性" class="headerlink" title="约束和局限性"></a>约束和局限性</h3><blockquote><p>以下代码示例:涉及的类Pair在上述的代码中已经定义, Human和Student是继承关系<br>并且因为看的 Java核心技术卷 比较老 jdk是1.5的所以没有用7的菱形语法简化泛型 7可以省去右边的类型: <code>Pair&lt;Double&gt; pair = new Pair&lt;&gt;();</code></p></blockquote><ul><li>| <em>不能使用基本类型实例化类型参数</em><ul><li>也就是说没有<code>Pair&lt;double&gt;</code>只有<code>Pair&lt;Double&gt;</code></li><li>因为类型擦除后,类型是Object并不能放double的值, 但是这样做与Java语言中基本类型的独立状态相一致.</li><li>当包装器类型(wrapper type)不能接受替换时,可以使用独立的类和方法处理他们  </li></ul></li><li>| <em>运行时类型查询(eq或者instanceof)只适用于原始类型</em><ul><li>比如<code>Pair&lt;T&gt;</code> 和<code>Pair&lt;String&gt;</code>是等价的,因为类型擦除</li><li><code>Pair&lt;String&gt; pair1</code> <code>Pair&lt;Date&gt; pair2</code> pair1.getClass()和pair2.getClass()是等价的都是返回Pair.class</li></ul></li><li>| <em>不能抛出也不能捕获泛型类实例</em><ul><li>错误的示例:<ul><li><code>public class Problem&lt;T&gt; extends Exception{}</code></li><li><code>public static &lt;T extends Throwable&gt; void doWork(){try{}catch(T t){}}</code></li></ul></li><li>正确示例:<ul><li>在异常声明中使用类型变量 </li><li><code>public static &lt;T extends Throwable&gt; void doWork() throws T{.. catch(){throw t;}}</code></li></ul></li></ul></li><li><p>| <em>参数化类型的数组不合法</em></p><ul><li>例:<code>Pair&lt;String&gt;[] list = new Pair&lt;String&gt;[10];</code></li><li>因为擦除后 list是Pair[]类型,然后就能转成Object[], 就失去了泛型的作用</li><li>如果要使用的话最好直接使用集合 ArrayList:<code>ArrayList&lt;Pair&lt;String&gt;&gt;</code>,安全又高效<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = list;</span><br><span class="line">array[<span class="number">0</span>] = <span class="string">"hi"</span>;<span class="comment">//  编译错误</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Date&gt;(); <span class="comment">//通过数组存储的检测,但实际上类型错误了,所以禁止使用参数化类型的数组</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>| <em>不能实例化类型变量(T)</em></p><ul><li>非法 <code>new T(){}</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>&#123;</span><br><span class="line">    first = <span class="keyword">new</span> T();</span><br><span class="line">    second = <span class="keyword">new</span> T();</span><br><span class="line">&#125;</span><br><span class="line">first = T.class.newInstance() <span class="comment">//非法 T.class是不合法的</span></span><br><span class="line"><span class="comment">//要实例化一个Pair&lt;T&gt;的对象就要如下:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">initPair</span><span class="params">(Class&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(c.newInstance(), c.newInstance());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如下调用</span></span><br><span class="line">Pair&lt;String&gt; pair = Pair.initPair(String.class);</span><br><span class="line"><span class="comment">// 因为Class本身是泛型, String.class其实是Class&lt;String&gt;的实例</span></span><br><span class="line"><span class="comment">// 也不能实例化为一个数组 new T[5]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>| <em>泛型类的静态上下文中类型变量无效</em></p><ul><li>不能在静态域中使用类型变量 如下:</li><li>如果这段代码能执行,那就可以声明一个 Singleton<random> 共享随机数生成类,</random></li><li>但是声明之后,类型擦除,就只剩下了Singleton类,并不能做对应的事情,所以禁止这样的写法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> T first; <span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getFirst</span><span class="params">()</span></span>&#123; <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>| <em>注意泛型擦除后的冲突</em></p><ul><li>当类型擦除时,不能创建引发冲突的相关条件</li><li>例如 新实现一个类型变量约束的equals方法就会和Object原方法冲突 补救方法就是重命名该方法了</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span> <span class="params">(T value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ..</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>泛型规范说明</code></p><ul><li><p>要想支持擦除的转换,就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类,而这两个接口是同一接口的不同参数化</p><ul><li>以下代码就是非法的, GregorianCalendar 实现了两个接口,两个接口是Comparable接口的不同参数化,这是不允许的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Calendar</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GregorianCalendar</span> <span class="keyword">extends</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">GregorianCalendar</span>&gt;</span>&#123;&#125; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>但是如下又是合法的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GregorianCalendar</span> <span class="keyword">extends</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>很有可能是桥方法有关,不可能有两个一样的桥方法(因为两个接口其实是一个接口的不同参数化,桥方法的方法签名是一致的)</p></li></ul><hr><h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><blockquote><p>例如 父子类: Human Student  那么 Pair<human> Pair<student> 是继承(inherit)关系么,答案是否定的!!</student></human></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Human&gt; humans = <span class="keyword">new</span> Pair&lt;Human&gt;(man, woman);</span><br><span class="line">Pair&lt;Student&gt; classmates = humans;<span class="comment">// illegal, but suppose it wasn't</span></span><br><span class="line">classmates.setSecond(junior) <span class="comment">// 如果上面合法,那么这里是肯定可以执行的, 因为泛型类型变成了Student</span></span><br><span class="line"><span class="comment">//那么就有了问题了,原有的人类类型限制的对象中,出现了小学生</span></span><br><span class="line"><span class="comment">//所以不允许这样的类型变量约束的类进行多态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是数组可以这样写是因为数组会有自己的检查保护</span></span><br><span class="line">Human[] humans = &#123;man, woman&#125;;</span><br><span class="line">Student[] students = humans;</span><br><span class="line">students[<span class="number">0</span>] = junior ;<span class="comment">// 虚拟机将抛出 ArrayStoreException 异常</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>永远可以将参数化类型转换为一个原始类型, Pair<human> 是原始类型Pair的一个子类型,转换成原始类型也会产生错误<br><a href="https://github.com/Kuangcp/JavaBase/blob/master/src/test/java/com/generic/simple/PairTest.java" target="_blank" rel="noopener">相关测试类</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Human&gt; humans = <span class="keyword">new</span> Pair&lt;Human&gt;(man, woman);</span><br><span class="line">Pair other = humans;</span><br><span class="line">other.setFirst(<span class="keyword">new</span> String(<span class="string">"wtf"</span>))<span class="comment">// 只是会有一个编译时的警告(类型未检查),但实际上都看得出这明显是错误的</span></span><br><span class="line"><span class="comment">// 那么在后续代码中继续当做Human对象进行引用,必然就会有ClassCastException</span></span><br><span class="line"><span class="comment">// 所以这样的写法尽量避免,这里的设计 就失去了泛型程序设计提供的附加安全性.(挖的坑)</span></span><br></pre></td></tr></table></figure></human></p></blockquote><hr><blockquote><p>泛型类可以扩展或实现其他的泛型类,就这一点而言,和普通类没有什么区别</p></blockquote><ul><li>例如 ArrayList<t> 实现List<t>接口, 这意味着一个ArrayList<student>可以转换为List<studnet> <ul><li>但是一个ArrayList<student>不是ArrayList<human>或者List<student>.</student></human></student></li></ul></studnet></student></t></t></li></ul><hr><h3 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h3><h4 id="子类型限定的通配符-extends"><a href="#子类型限定的通配符-extends" class="headerlink" title="子类型限定的通配符 extends"></a>子类型限定的通配符 extends</h4><blockquote><p>通配符上限  顾名思义,就是限定为该类及其子类, 例如: <code>Pair&lt;? extends Human&gt;</code> 表示任何Pair泛型类型并且他的类型变量要为Human的子类  </p></blockquote><blockquote><p>例如编写一个方法 <code>public static void printMessage(Pair&lt;Human&gt; human){}</code><br>正如上面所说, Pair<student>类型的变量是不能放入这个方法的,因为泛型变量是没有继承关系, 这时候就可以使用这个通配符:  </student></p><blockquote><p><code>public static void printMessage(Pair&lt;? extends Human&gt;)</code> 可以get不能set<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Human&gt; humans = <span class="keyword">new</span> Pair&lt;Human&gt;(man, woman);</span><br><span class="line">Pair&lt;? extends Human&gt; classmates = humans;<span class="comment">// 编译通过</span></span><br><span class="line">classmates.setSecond(junior) <span class="comment">// 编译错误,泛型约束起作用了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析其泛型类实现可以理解为:</span></span><br><span class="line">? <span class="function">extends Human <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? extends Human)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 这样的话是不可能调用setFirst方法, 对于编译器来说,只是知道入参是Human的子类,但是类型并不明确,所以不能正常调用</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使用get方法就不会有问题, 泛型起作用了.将get返回值赋值给Human的引用也是完全合法的,这就是引入该统通配符的关键之处</span></span></span><br></pre></td></tr></table></figure></p></blockquote></blockquote><h4 id="超类型限定的通配符-super"><a href="#超类型限定的通配符-super" class="headerlink" title="超类型限定的通配符 super"></a>超类型限定的通配符 super</h4><blockquote><p>通配符下限  顾名思义就是限定为父类, 通配符限定和类型变量限定十分相似, 但是可以指定一个超类型限定(supertype bound)<br><code>? super Student</code> 这个通配符就限定为Student的所有超类型(super关键字已经十分准确的描述了这种关系)  </p><blockquote><p>带有超类型限定的通配符的行为和前者相反,可以为方法提供参数,但不能使用返回值即 可以 set 但是不能get</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pair&lt;? super Student&gt; 例如这种定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? <span class="keyword">super</span> Student)</span></span></span><br><span class="line"><span class="function">? <span class="keyword">super</span> Student <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 编译器不知道setFirst方法的确切类型,但是可以用任意Student对象(或子类型) 调用他, 而不能使用Human对象调用.</span></span></span><br><span class="line"><span class="function"><span class="comment">// 然而,如果调用getFirst,泛型没有起作用,只能将返回值用Object接收</span></span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/Kuangcp/JavaBase/blob/master/src/test/java/com/generic/simple/PairTest.java" target="_blank" rel="noopener">以上两种情况的相关测试类</a> </p></blockquote><blockquote><p>总结: 类定义上的泛型变量:  </p><blockquote><p>子类型限定: &lt;? extends Human&gt; 是限定了不能set,但是保证了get<br>超类型限定: &lt;? super Student&gt; 限定了不能正确get,但是保证了set.  </p></blockquote></blockquote><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-jtp04298.html" target="_blank" rel="noopener">参考博客: 使用通配符简化泛型使用</a></p></blockquote><ul><li><p>示例1:<code>public static &lt;T extends Comparable&lt;T&gt;&gt; T min(T[] list);</code></p><ul><li>限定了入参和返回值是 是实现了Comparable接口的某个类型 因为Comparable也是一个泛型类, 所以也进行限定类型</li><li>这样的写法要比 T extends Comparable 更为彻底</li><li>例如计算一个String数组的最小值 T 就是 String类型的, String是Comparable<string>的子类型<ul><li>但是当处理GregorianCalendar, GregorianCalendar是Calendar的子类, 并且Calendar实现了<code>Comparable&lt;Calendar&gt;</code></li><li>因此GregorianCalendar实现的是<code>Comparable&lt;Calendar&gt;</code>, 而不是Comparable<gregoriancalendar></gregoriancalendar></li><li>这种情况下 <code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] list)</code> 就是安全的</li></ul></string></li></ul></li><li><p>示例2: <code>public static &lt;T extends ExcelTransform&gt; List&lt;T&gt; importExcel(Class&lt;T&gt; target)</code></p><ul><li>该方法实现了, 传入继承了ExcelTransform接口的类对象, 得到该类的List集合</li><li><code>&lt;T extends ExcelTransform&gt; boolean</code> 这样写编译没报错, 那么就是说, 就是一个泛型的定义, 后面进行引用, 省的重复写</li><li>简单的写法就是 <code>public static &lt;T&gt; List&lt;T&gt; importExcel(Class&lt;T&gt; target)</code></li></ul></li><li><p>示例3: Spring4.x 添加的泛型依赖注入 , 使用的JPA就是依赖该技术   <a href="http://blog.csdn.net/u010837612/article/details/45582043" target="_blank" rel="noopener">spring学习笔记（14）——泛型依赖注入</a></p></li></ul><blockquote><p>对于应用程序员, 可能很快的学会掩盖这些声明, 想当然地认为库程序员做的都是正确的, 如果是一名库程序员, 一定要习惯于通配符<br>否则还要用户在代码中随意地添加强制类型转换直至可以通过编译.</p></blockquote><h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><blockquote><p>TODO 对其使用场景 尚有疑问,以后再解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如 Pair&lt;?&gt;</span></span><br><span class="line">? getFirst() <span class="comment">// 方法的返回值只能赋值给一个Object</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(?)</span> <span class="comment">// 方法不能被调用,甚至不能用Object调用.</span></span></span><br><span class="line"><span class="function"><span class="comment">// Pair&lt;?&gt; 和 Pair 本质的不同在于: 可以用任意Object对象调用原始的Pair类的setObject(set方法,因为类型擦除 入参是Object, 简称setObject)方法</span></span></span><br></pre></td></tr></table></figure><ul><li>例如 <a href="https://github.com/Kuangcp/JavaBase/blob/master/src/test/java/com/generic/simple/PairTest.java" target="_blank" rel="noopener">这个hasNull()方法</a>用来测试一个pair是否包含了指定的对象, 他不需要实际的类型.</li></ul><h4 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h4><blockquote><p>TODO 学习和理解使用场景</p></blockquote><ul><li><p>如果编写一个交换的方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span> <span class="params">(Pair&lt;?&gt; p)</span></span>&#123;</span><br><span class="line">    ? temp = p.getFirst(); <span class="comment">// 错误, 不允许将?作为类型</span></span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是可以编写一个辅助方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">    T temp = p.getFirst();</span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>swapHelper是一个泛型方法, 而swap不是, 它具有固定的Pair&lt;?&gt;类型的参数, 那么现在就可以这样写:</p><ul><li><code>public static void swap(Pair&lt;?&gt; p){swapHelper(p);}</code></li><li>这种情况下, swapHelper方法的参数T捕获通配符, 它不知道是哪种类型的通配符,但是这是一个明确的类型 并且<t>swapHelper 在T指出类型时,才有明确的含义</t></li><li>当然,这种情况下并不是一定要用通配符, 而且我们也实现了没有通配符的泛型方法</li></ul></li></ul><blockquote><p>但是下面这个通配符类型出现在计算结果中间的示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxMinBonus</span><span class="params">(Student[] students, Pair&lt;? <span class="keyword">super</span> Student&gt; result)</span></span>&#123;</span><br><span class="line">    minMaxBonus(students, result);</span><br><span class="line">    swapHelper(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这里,通配符捕获机制是不可避免的, 但是这种捕获只有在许多限制情况下才是合法的.</span></span><br><span class="line"><span class="comment">// 对于编译器而言, 必须能够确信通配符表达的是单个, 确定的类型.</span></span><br></pre></td></tr></table></figure><h3 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h3><blockquote><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html" target="_blank" rel="noopener">官方Java7的Class文档</a> | <a href=""></a><br>现在Class类是泛型的, 例如String.class实际上是Class<string>类的对象(事实上是唯一的对象)<br>类型参数十分有用, 这是因为他允许Class<t>方法的返回类型更加具有针对性.下面Class<t>的方法就使用了类型参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">T <span class="title">cast</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">T[] <span class="title">getEnumConstants</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Class&lt;? <span class="keyword">super</span> T&gt; <span class="title">getSuperclass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class... paramterTypes)</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class... paramterTypes)</span></span></span><br></pre></td></tr></table></figure></t></t></string></p></blockquote><ul><li>newInstance方法返回一个示例, 这个实例所属的类由默认的构造器获得, 它的返回类型目前被声明为T, 其类型与Class<t>描述的类相同, 这样就免除了类型转换.</t></li><li>如果给定的类型确实是T的一个子类型, cast方法就会返回一个现在声明为类型T的对象, 否则, 抛出一个BadCastException异常</li><li>如果这个类不是enum类或类型T的枚举值的数组, getEnumConstants方法将返回Null.</li><li>最后, getConstructor与getDeclaredConstructor方法返回一个Constructor<t>对象.Constructor类也已经变成泛型, 以便 newInstance方法有一个正确的返回类型.</t></li></ul><p>TODO 还要继续看书</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个Class对象, 得到Class对应类型的实例</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; target, String name)</span></span>;</span><br><span class="line"><span class="comment">// 加上约束</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Runable&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; target, String name)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#泛型&quot;&gt;泛型&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#入门&quot;&gt;入门&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#简单使用&quot;&gt;简单使用&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="泛型" scheme="http://blog.kuangcp.top/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Database-GraphQL/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Database-GraphQL/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#graphql">GraphQL</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h1><blockquote><p><a href="https://graphql.org" target="_blank" rel="noopener">Official Site</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#graphql&quot;&gt;GraphQL&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-13 12:06&lt;/em&gt;| &lt;a
      
    
    </summary>
    
      <category term="数据库" scheme="http://blog.kuangcp.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="GraphQL" scheme="http://blog.kuangcp.top/tags/GraphQL/"/>
    
      <category term="基础" scheme="http://blog.kuangcp.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-AdvancedLearning-ClassFile/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-AdvancedLearning-ClassFile/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#java基础">Java基础</a><ol><li><a href="#类和字节码">类和字节码</a><ol><li><a href="#类加载和类对象">类加载和类对象</a><ol><li><a href="#类加载器">类加载器</a></li><li><a href="#加载和连接">加载和连接</a></li><li><a href="#class对象">Class对象</a></li><li><a href="#类加载器">类加载器</a></li></ol></li><li><a href="#方法句柄">方法句柄</a></li></ol></li><li><a href="#查看class文件">查看class文件</a><ol><li><a href="#常量池">常量池</a></li><li><a href="#字节码">字节码</a><ol><li><a href="#运行时环境">运行时环境</a></li><li><a href="#操作码介绍">操作码介绍</a></li><li><a href="#加载和存储操作码">加载和存储操作码</a></li><li><a href="#数学运算操作码">数学运算操作码</a></li><li><a href="#执行控制操作码">执行控制操作码</a></li><li><a href="#调用操作码">调用操作码</a></li><li><a href="#平台操作码">平台操作码</a></li><li><a href="#操作码的快捷形式">操作码的快捷形式</a></li><li><a href="#invokedynamic">invokedynamic</a></li></ol></li></ol></li><li><a href="#序列化">序列化</a><ol><li><a href="#serialversionuid">serialVersionUID</a></li><li><a href="#其他业内主流编解码框架">其他业内主流编解码框架</a><ol><li><a href="#messagepack">MessagePack</a></li><li><a href="#protobuf">Protobuf</a><ol><li><a href="#proto文件定义">proto文件定义</a></li><li><a href="#linux上安装">Linux上安装</a></li><li><a href="#通过docker使用">通过Docker使用</a></li><li><a href="#对于java的使用">对于Java的使用</a></li></ol></li><li><a href="#thrift">Thrift</a></li><li><a href="#marshalling">Marshalling</a></li></ol></li></ol></li><li><a href="#热更新">热更新</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="类和字节码"><a href="#类和字节码" class="headerlink" title="类和字节码"></a>类和字节码</h2><blockquote><p><a href="https://github.com/Kuangcp/JavaBase/tree/master/java-classfile/src/main/java/com/github/kuangcp" target="_blank" rel="noopener">个人相关代码</a> </p></blockquote><p><strong><code>相关项目</code></strong></p><blockquote><p><a href="http://commons.apache.org/proper/commons-bcel/index.html" target="_blank" rel="noopener">Apache bcel</a></p></blockquote><h3 id="类加载和类对象"><a href="#类加载和类对象" class="headerlink" title="类加载和类对象"></a>类加载和类对象</h3><ul><li>一个<code>.class</code>文件定义了JVM中的类型，包括了域,方法，继承信息，注解和其他元数据</li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li style="list-style: none"><input type="checkbox"> TODO 学习类加载器<blockquote><p><a href="https://blog.csdn.net/yuan22003/article/details/6839335\" target="_blank" rel="noopener">类装载器、双亲委托模型、命名空间、安全性</a><br><a href="https://blog.csdn.net/wangyang1354/article/details/49448007" target="_blank" rel="noopener">java ClassLoader类解析-双亲委托机制</a></p></blockquote></li></ul><h4 id="加载和连接"><a href="#加载和连接" class="headerlink" title="加载和连接"></a>加载和连接</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p107.jpg" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><p><a href="http://ifeve.com/%e7%ac%ac%e4%b8%83%e7%ab%a0-%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%b1%bb%e5%8a%a0%e8%bd%bd%e6%9c%ba%e5%88%b6/" target="_blank" rel="noopener">参考博客: 第七章.虚拟机类加载机制</a><br><code>加载</code></p><ul><li>这个过程就是读取字节码文件，创建一个字节数组装在这些内容，加载结束后这个对象还不能直接调用 </li></ul><p><code>连接</code></p><ul><li>加载完成后，类必须连接起来，分为三步：验证，准备，解析。<ul><li>验证：<ul><li>验证文件的合理性，完整性检查，检查常量池，方法的字节码检查。主要的：</li><li>是否所有方法都遵守访问控制关键字的限定</li><li>方法调用的参数个数和静态类型是否正确</li><li>确保字节码不会试图滥用堆栈</li><li>确保变量使用之前被正确初始化了</li><li>检查变量是否仅被赋予恰当类型的值</li></ul></li><li>准备：<ul><li>分配内存，准备初始化类中的静态变量，但不会现在就初始化，也不会执行任何VM字节码</li></ul></li><li>解析：<ul><li>促使VM检查类文件中所引用的类型是不是都是已知的类型。如果有运行时有未知的类型，那又要引发一次类加载过程</li><li>当需要加载的类全部加载解析完毕后，VM就可以初始化最初那个加载的类了。</li><li>这时所有的静态变量都可以进行初始化，所有静态代码块都会运行，这一步完成后，类就能使用了</li></ul></li></ul></li></ul><h4 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h4><ul><li>加载和连接过程的最终结果是一个Class对象，Class对象可以和反射API一起实现对方法，域构造方法等类成员的间接访问</li></ul><blockquote><p>所以一个类的定义就会有一个Class对象, 但是这个对象的类型呢?怎么判断, Class对象的类型就是他的值么?</p></blockquote><h4 id="类加载器-1"><a href="#类加载器-1" class="headerlink" title="类加载器"></a>类加载器</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p110.jpg" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><ul><li>Java平台经典类加载器：<ul><li>根（引导）加载器： 通常在VM启动后不久就实例化，作用是加载系统的基础JAR(主要是rt.jar)，并且不做验证工作</li><li>扩展类加载器： 加载安装时自带的标准扩展，一般包括安全性扩展</li><li>应用或系统类加载器： 应用最广泛的类加载器，负责加载应用类，在大多SE环境中主要工作是由他完成</li><li>定制类载器： 为了企业框架定制的加载器</li></ul></li></ul><hr><h3 id="方法句柄"><a href="#方法句柄" class="headerlink" title="方法句柄"></a>方法句柄</h3><blockquote><p>主要用于反射 用到再学</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p118.jpg" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure><hr><h2 id="查看class文件"><a href="#查看class文件" class="headerlink" title="查看class文件"></a>查看class文件</h2><blockquote><p>javap: JDK内置命令, 用来探视类文件内部和反编译class文件</p></blockquote><hr><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><blockquote><p>常量池是为类文件中的其他常量元素提供快捷访问方式的区域。对于JVM来说常量池相当于符号表<br><a href="http://www.cnblogs.com/LeonNew/p/5314731.html" target="_blank" rel="noopener">参考博客</a></p></blockquote><ul><li><code>javap -v class文件</code> 输出很多额外信息，# 开头的就是常量池信息<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p120.jpg" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure></li></ul><hr><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><blockquote><p><a href="https://www.cnblogs.com/beautiful-code/p/6425376.html" target="_blank" rel="noopener">参考博客: 学会阅读Java字节码</a></p></blockquote><ul><li>字节码是程序的中间表达形式，源码和机器码之间的产物</li><li>字节码是由源文件执行javac产生的</li><li>某些高级语言特性（语法糖）在字节码中给去掉了，例如循环结构，会转换成为分支指令</li><li>每个操作都由一个字节表示，因此叫做字节码</li><li>字节码是一种抽象表示方法</li><li><p>字节码进一步编译得到机器码</p></li><li><p><code>javap -c -p class文件</code> 反编译字节码文件，-p 能看到私有属性</p><ul><li>输出所有的属性以及类的定义信息</li><li>静态块</li><li>构造方法</li><li>方法信息</li><li>静态属性信息</li><li>静态方法信息</li></ul></li></ul><h4 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h4><blockquote><p>因为JVM没有CPU那样的寄存器，所以是采用的堆栈来计算的，称为操作数栈或者计算堆栈</p></blockquote><ul><li>当一个类被链接进运行时环境时，字节码会受到检查，其中很多验证都可以归结为对栈中类型模式的分析</li><li>方法需要一块内存区域作为计算堆栈来计算新值，另外每个运行的线程都需要一个调用堆栈来记录当前正在执行的方法，这两个栈会有交互</li></ul><h4 id="操作码介绍"><a href="#操作码介绍" class="headerlink" title="操作码介绍"></a>操作码介绍</h4><ul><li>字节码由操作码 opcode 序列构成，每个指令后可能会带参数，操作码希望看到栈处于指定状态中，然后他对栈进行操作处理，把参数移走，放入结果</li><li>操作码表有四列：<ul><li>名称：操作码类型的通用名称</li><li>参数：操作码的参数，以i开头的是用来作为常量池或局部变量中的查询索引的几个字节，如果有更多的参数，将会合并<ul><li>如果参数出现在括号里，就表明不是所有形式的操作码都会使用他</li></ul></li><li>堆栈布局：他展示了栈在操作码执行前后的状态。括号中的元素表示是可选的</li><li>描述：描述操作码的用处</li></ul></li></ul><p>[ ] 下面的内容需要继续阅读Java7程序员修炼之道</p><h4 id="加载和存储操作码"><a href="#加载和存储操作码" class="headerlink" title="加载和存储操作码"></a>加载和存储操作码</h4><h4 id="数学运算操作码"><a href="#数学运算操作码" class="headerlink" title="数学运算操作码"></a>数学运算操作码</h4><h4 id="执行控制操作码"><a href="#执行控制操作码" class="headerlink" title="执行控制操作码"></a>执行控制操作码</h4><h4 id="调用操作码"><a href="#调用操作码" class="headerlink" title="调用操作码"></a>调用操作码</h4><h4 id="平台操作码"><a href="#平台操作码" class="headerlink" title="平台操作码"></a>平台操作码</h4><h4 id="操作码的快捷形式"><a href="#操作码的快捷形式" class="headerlink" title="操作码的快捷形式"></a>操作码的快捷形式</h4><h4 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h4><blockquote><p>这个特性是针对 框架开发和非Java语言准备的</p></blockquote><hr><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513589&amp;idx=1&amp;sn=d402d623d9121453f1e570395c7f99d7&amp;chksm=80d67a36b7a1f32054d4c779dd26e8f97a075cf4d9ed1281f16d09f1df50a29319cd37520377&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:序列化： 一个老家伙的咸鱼翻身</a> <code>对象转化为二进制流</code></p></blockquote><h3 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h3><blockquote><p>简单的说就是类的版本控制, 标明类序列化时的版本, 版本一致表明这两个类定义一致<br>在进行反序列化时, JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)<br><a href="http://swiftlet.net/archives/1268" target="_blank" rel="noopener">参考博客</a></p></blockquote><ul><li>serialVersionUID有两种显示的生成方式： <ul><li>一个是默认的1L</li><li>一个是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段</li></ul></li></ul><blockquote><p>当你一个类实现了Serializable接口，如果没有定义serialVersionUID，Eclipse会提供这个提示功能告诉你去定义 。<br>在Eclipse中点击类中warning的图标一下，Eclipse就会自动给定两种生成的方式。<br>如果不想定义它，在Eclipse的设置中也可以把它关掉的，设置如下：<br>Window ==&gt; Preferences ==&gt; Java ==&gt; Compiler ==&gt; Error/Warnings ==&gt;Potential programming problems<br>将Serializable class without serialVersionUID的warning改成ignore即可。</p></blockquote><hr><h3 id="其他业内主流编解码框架"><a href="#其他业内主流编解码框架" class="headerlink" title="其他业内主流编解码框架"></a>其他业内主流编解码框架</h3><blockquote><p>因为Java序列化的性能和存储开销都表现不好,而且不能跨语言, 所以一般不使用Java的序列化而是使用以下流行的库</p></blockquote><h4 id="MessagePack"><a href="#MessagePack" class="headerlink" title="MessagePack"></a>MessagePack</h4><blockquote><p><a href="https://github.com/msgpack" target="_blank" rel="noopener">Github:msgpack</a> | <a href="http://hao.jobbole.com/messagepack/" target="_blank" rel="noopener">参考博客: MessagePack：一种高效二进制序列化格式</a></p></blockquote><h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><blockquote><p>Google开源的库 全称 <code>Google Protocol Buffers</code> |  <a href="https://github.com/google/protobuf" target="_blank" rel="noopener">Github : Protobuf</a></p></blockquote><blockquote><p><a href="http://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html" target="_blank" rel="noopener">参考博客: Protobuf语言指南</a> <code>较为详细, 只是版本有点旧</code><br><a href="https://juejin.im/entry/59c1214df265da0658151a2c" target="_blank" rel="noopener">参考博客: 详解如何在NodeJS中使用Google的Protobuf</a> | <a href="https://github.com/dcodeIO/protobuf.js" target="_blank" rel="noopener">protocobuf</a><br><a href="https://blog.csdn.net/hguisu/article/details/20721109" target="_blank" rel="noopener">Google 开源技术protobuf </a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">Google Protocol Buffer 的使用和原理</a></p></blockquote><blockquote><p><a href="http://blog.jobbole.com/107405/" target="_blank" rel="noopener">参考博客: 数据交换利器 Protobuf 技术浅析</a><br><a href="https://blog.csdn.net/u011518120/article/details/54604615" target="_blank" rel="noopener">参考博客: Protobuf3语言指南</a></p></blockquote><ul><li>他将数据结构以 proto后缀的文件进行描述, 通过代码生成工具, 可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性<ul><li>特点:<ul><li>结构化数据存储格式: XML JSON等</li><li>高效的编解码性能</li><li>语言无关, 平台无关, 扩展性好</li><li>官方支持 Java C++ Python三种语言, 并且Js的支持也比较好<a href="https://github.com/dcodeIO/ProtoBuf.js/" target="_blank" rel="noopener"></a></li></ul></li><li>数据描述文件和代码生成机制优点:<ul><li>文本化的数据结构描述语言, 可以实现语言和平台无关, 特别适合异构系统间的集成</li><li>通过标识字段的顺序, 可以实现协议的前向兼容 <em>在不同版本的数据结构进程间进行数据传递</em></li><li>自动代码生成, 不需要手工编写同样数据结构的C++和Java版本;</li><li>方便后续的管理和维护,相比于代码, 结构化的文档更容易管理和维护</li></ul></li></ul></li><li>习惯性规则:<ul><li>命名: <code>packageName.MessageName.proto</code></li></ul></li></ul><blockquote><p>只是编解码的工具, 不支持读半包, 粘包拆包</p></blockquote><h5 id="proto文件定义"><a href="#proto文件定义" class="headerlink" title="proto文件定义"></a>proto文件定义</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 用户数据信息</span><br><span class="line">message Article &#123;</span><br><span class="line">    required int32 articleId = 1;         // 文章id</span><br><span class="line">    optinal string articleExcerpt = 4;    // 文章摘要</span><br><span class="line">    repeated string articlePicture = 5;   // 文章附图</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面定义了一个消息, 消息具有三个属性, 且行末的注释都会变成Javadoc注释  </p></blockquote><ol><li>message 是消息定义的关键字</li><li>required 表示这个字段是必需的, 必须在序列化的时候被赋值。</li><li>optional 代表这个字段是可选的，可以为0个或1个但不能大于1个。</li><li>repeated 则代表此字段可以被重复任意多次包括0次。</li><li>int32和string是字段的类型。后面是我们定义的字段名。</li><li>最后的1，2，3则是代表每个字段的一个唯一的编号标签，在同一个消息里不可以重复。这些编号标签用与在消息二进制格式中标识你的字段，并且消息一旦定义就不能更改。<ul><li>需要说明的是标签在1到15范围的采用一个字节进行编码。所以通常将标签1到15用于频繁发生的消息字段。编号标签大小的范围是1 到 2的29次幂–1。</li><li>此外不能使用protobuf系统预留的编号标签（19000 －19999）。</li></ul></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Learn/java/protobuf/protobuf-type.jpeg" alt="数据类型对应表" title="">                </div>                <div class="image-caption">数据类型对应表</div>            </figure><p><em>复杂类型</em>  </p><blockquote><p>定义了enum枚举类型，嵌套的消息。甚至对原有的消息进行了扩展，也可以对字段设置默认值。添加注释等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package &quot;com.github.kuangcp&quot;;</span><br><span class="line">message Article &#123;</span><br><span class="line">  required int32 article_id = 1;</span><br><span class="line">  optional string article_excerpt = 2;</span><br><span class="line">  repeated string article_picture = 3;</span><br><span class="line">  optional int32  article_pagecount = 4 [default = 0];</span><br><span class="line">  enum ArticleType &#123;</span><br><span class="line">    NOVEL = 0;</span><br><span class="line">    PROSE = 1;</span><br><span class="line">    PAPER = 2;</span><br><span class="line">    POETRY = 3;</span><br><span class="line">  &#125;</span><br><span class="line">  optional ArticleType article_type = 5 [default = NOVEL];</span><br><span class="line">  message Author &#123;</span><br><span class="line">    required string name = 1; //作者的名字</span><br><span class="line">    optional string phone = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  optional Author author = 6;</span><br><span class="line">  repeated int32 article_numberofwords = 7 [packed=true];</span><br><span class="line">  reserved  9, 10, 12 to 15;</span><br><span class="line">  extensions 100 to 1000;</span><br><span class="line">&#125;</span><br><span class="line">extend Article &#123;</span><br><span class="line">  optional int32 followers_count = 101;</span><br><span class="line">  optional int32 likes_count= 102;</span><br><span class="line">&#125;</span><br><span class="line">message Other &#123;</span><br><span class="line">  optional string other_info = 1;</span><br><span class="line">  oneof test_oneof &#123;</span><br><span class="line">    string code1 = 2;</span><br><span class="line">    string code2 = 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>此外reserved关键字主要用于保留相关编号标签，主要是防止在更新proto文件删除了某些字段，而未来的使用者定义新的字段时重新使用了该编号标签。这会引起一些问题在获取老版本的消息时，譬如数据冲突，隐藏的一些bug等。所以一定要用reserved标记这些编号标签以保证不会被使用</p></blockquote><blockquote><p>当我们需要对消息进行扩展的时候，我们可以用extensions关键字来定义一些编号标签供第三方扩展。这样的好处是不需要修改原来的消息格式。就像上面proto文件，我们用extend关键字来扩展。只要扩展的字段编号标签在extensions定义的范围里。</p></blockquote><blockquote><p>对于基本数值类型，由于历史原因，不能被protobuf更有效的encode。所以在新的代码中使用packed=true可以更加有效率的encode。注意packed只能用于repeated 数值类型的字段。不能用于string类型的字段。</p></blockquote><blockquote><p>在消息Other中我们看到定义了一个oneof关键字。这个关键字作用比较有意思。当你设置了oneof里某个成员值时，它会自动清除掉oneof里的其他成员，也就是说同一时刻oneof里只有一个成员有效。这常用于你有许多optional字段时但同一时刻只能使用其中一个，就可以用oneof来加强这种效果。但需要注意的是oneof里的字段不能用required，optional，repeted关键字</p></blockquote><p><em>导入另一个proto定义</em><br><code>import &quot;article.proto&quot;;</code></p><ul><li>更新Protobuf文件的要求:<ol><li>不能改变已有的任何编号标签。</li><li>只能添加optional和repeated的字段。这样旧代码能够解析新的消息，只是那些新添加的字段会被忽略。但是序列化的时候还是会包含哪些新字段。而新代码无论是旧消息还是新消息都可以解析。</li><li>非required的字段可以被删除，但是编号标签不可以再次被使用，应该把它标记到reserved中去</li><li>非required可以被转换为扩展字段，只要字段类型和编号标签保持一致</li><li>相互兼容的类型，可以从一个类型修改为另一个类型，譬如int32的字段可以修改为int64</li></ol></li></ul><hr><blockquote><ul><li>使用上, 因为有多个消息类型, 那么会采用一个数值id作为code, 进行对应 方便沟通</li></ul></blockquote><h5 id="Linux上安装"><a href="#Linux上安装" class="headerlink" title="Linux上安装"></a>Linux上安装</h5><blockquote><p>只是安装2.5版本 <a href="http://www.cnblogs.com/brainy/archive/2012/05/13/2498671.html" target="_blank" rel="noopener">参考博客: linux下Google的Protobuf安装及使用笔记</a> | <a href="http://dofound.blog.163.com/blog/static/1711432462013524111644655/" target="_blank" rel="noopener">参考:proto buffer 安装 及 调用</a></p></blockquote><ul><li><a href="https://github.com/google/protobuf/releases/tag/v2.5.0" target="_blank" rel="noopener">下载2.5</a> 并解压 <ul><li>进入目录  <code>./configure</code> </li><li><code>make</code> 然后 <code>make check</code> 然后 <code>sudo make install</code></li><li><code>protoc --version</code> 有版本则安装成功</li></ul></li></ul><blockquote><p>注意: ./configure 时, 默认会安装在/usr/local目录下，可以加<code>--prefix=/usr</code>来指定安装到/usr/lib下  </p><blockquote><p>如果不加, 上述参数就要执行 <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib</code><br>当然,可以将这个环境变量的设置加在 .zshrc 或者 .bashrc 里<br>不然就会报错: <code>protoc: error while loading shared libraries: libprotobuf.so.8: cannot open shared object file: No such file or directory</code></p></blockquote></blockquote><h5 id="通过Docker使用"><a href="#通过Docker使用" class="headerlink" title="通过Docker使用"></a>通过Docker使用</h5><h5 id="对于Java的使用"><a href="#对于Java的使用" class="headerlink" title="对于Java的使用"></a>对于Java的使用</h5><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">Google Protocol Buffer 的使用和原理</a> <code>C++ 但是原理差不多</code></p></blockquote><p><code>生成Java文件</code><br>touch <em>hi.proto</em><br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package lm;</span><br><span class="line">message helloworld&#123;</span><br><span class="line">    required int32 id = 1;//ID</span><br><span class="line">    required string str = 2;//str</span><br><span class="line">    optional int32 opt = 3;//optional field</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>据此生成Java文件 <code>mkdir src &amp;&amp; protoc --java_out=./src hi.proto</code><br><em>也可以使用该脚本更新协议</em><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># proto文件中明确定义了一样的包结构就可以直接跑脚本</span></span><br><span class="line">basePath=<span class="string">'minigame/proto/proto'</span></span><br><span class="line">targetPath=<span class="string">'ssss'</span></span><br><span class="line">rm -rf <span class="variable">$targetPath</span> \</span><br><span class="line">&amp;&amp; mkdir <span class="variable">$targetPath</span> \</span><br><span class="line">&amp;&amp; protoc <span class="variable">$basePath</span>/*.proto --java_out=<span class="variable">$targetPath</span> \</span><br></pre></td></tr></table></figure></li></ul><p><code>使用</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个构建器</span></span><br><span class="line">helloworld.Builder msg = helloworld.newBuilder();</span><br><span class="line"><span class="comment">// 填充信息</span></span><br><span class="line">msg.setId(<span class="number">12</span>);</span><br></pre></td></tr></table></figure></p><hr><h4 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h4><blockquote><p><a href="https://thrift.apache.org/" target="_blank" rel="noopener">官网</a>源于Facebook, 支持多种语言: C++ C# Cocoa Erlang Haskell Java Ocami Perl PHP Python Ruby Smalltalk</p></blockquote><ul><li>它支持数据(对象)序列化和多种类型的RPC服务, Thrift适用于静态的数据交换, 需要预先确定好他的数据结构, 当数据结构发生变化时,需要重新编辑IDL文件</li></ul><h4 id="Marshalling"><a href="#Marshalling" class="headerlink" title="Marshalling"></a>Marshalling</h4><blockquote><p>JBOSS 内部使用的编解码框架</p></blockquote><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><blockquote><p>通过替换 class 实现不停机热更新</p></blockquote><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto-hotswapping.html" target="_blank" rel="noopener">Spring hot swapping</a></p></blockquote><ol><li>Instrumentation</li><li>自定义类加载器</li><li>OSGI 热插拔接口</li></ol><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" target="_blank" rel="noopener">Instrumentation 新功能</a><br><a href="https://www.jianshu.com/p/b72f66da679f" target="_blank" rel="noopener">基于Java Instrument的Agent实现</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/" target="_blank" rel="noopener">Java 5 特性 Instrumentation 实践</a><br><a href="https://blog.csdn.net/javierhui111/article/details/3830833" target="_blank" rel="noopener">java组件中的热插拔（osgi)</a><br><a href="https://www.cnblogs.com/cm4j/p/hot_deploy.html" target="_blank" rel="noopener">agentmain 方式 </a></p><p>相关项目: </p><p><a href="https://github.com/youxijishu/game-hot-update" target="_blank" rel="noopener">game-hot-update</a> <a href="https://www.cnblogs.com/wgslucky/p/9127681.html" target="_blank" rel="noopener">https://www.cnblogs.com/wgslucky/p/9127681.html</a><br><a href="https://github.com/chaopeng/groovy-hotswap-demo" target="_blank" rel="noopener">groovy hotswap demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#java基础&quot;&gt;Java基础&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#类和字节码&quot;&gt;类和字节码&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#类加载和类对象&quot;&gt;类加载和类对象
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="字节码" scheme="http://blog.kuangcp.top/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ZenOfPattern.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-ZenOfPattern/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-ZenOfPattern/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#设计模式之禅">设计模式之禅</a><ol><li><a href="#软件设计的一些原则">软件设计的一些原则</a><ol><li><a href="#思维原则">思维原则</a><ol><li><a href="#奥卡姆剃刀原理">奥卡姆剃刀原理</a></li></ol></li><li><a href="#首要原则">首要原则</a><ol><li><a href="#勿重复造轮子">勿重复造轮子</a></li><li><a href="#减法优于加法">减法优于加法</a></li><li><a href="#抽象优于实现">抽象优于实现</a></li><li><a href="#组合优于继承">组合优于继承</a></li><li><a href="#查询与命令分离">查询与命令分离</a></li><li><a href="#够用原则">够用原则</a></li><li><a href="#最少知识原则">最少知识原则</a></li></ol></li><li><a href="#面向对象的solid-原则">面向对象的S.O.L.I.D 原则</a><ol><li><a href="#单一职责原则">单一职责原则</a></li><li><a href="#开闭原则">开闭原则</a></li><li><a href="#里氏代换原则">里氏代换原则</a></li><li><a href="#接口隔离原则">接口隔离原则</a></li><li><a href="#依赖倒置原则">依赖倒置原则</a></li></ol></li><li><a href="#其他原则">其他原则</a><ol><li><a href="#共同封闭原则">共同封闭原则</a></li><li><a href="#共同重用原则">共同重用原则</a></li><li><a href="#好莱坞原则">好莱坞原则</a></li><li><a href="#高内聚低耦合">高内聚低耦合</a></li><li><a href="#惯例优于配置原则">惯例优于配置原则</a></li><li><a href="#关注点分离">关注点分离</a></li><li><a href="#契约式设计">契约式设计</a></li><li><a href="#无环依赖原则">无环依赖原则</a></li></ol></li></ol></li><li><a href="#设计模式">设计模式</a><ol><li><a href="#基础">基础</a></li><li><a href="#策略者模式">策略者模式</a></li><li><a href="#1创建型设计模式">1.创建型设计模式</a></li><li><a href="#2结构型设计模式">2.结构型设计模式</a></li><li><a href="#3行为设计模式">3.行为设计模式</a></li><li><a href="#常见设计模式">【常见设计模式】</a><ol><li><a href="#适配器模式">适配器模式</a></li><li><a href="#中介者模式">中介者模式</a></li><li><a href="#观察者模式">观察者模式</a><ol><li><a href="#单例模式">单例模式</a></li><li><a href="#装饰器模式">装饰器模式</a></li></ol></li><li><a href="#原型模式">原型模式</a></li><li><a href="#生成器模式">生成器模式</a></li></ol></li></ol></li><li><a href="#实践">实践</a><ol><li><a href="#经验之谈">经验之谈</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h1><h2 id="软件设计的一些原则"><a href="#软件设计的一些原则" class="headerlink" title="软件设计的一些原则"></a>软件设计的一些原则</h2><h3 id="思维原则"><a href="#思维原则" class="headerlink" title="思维原则"></a>思维原则</h3><h4 id="奥卡姆剃刀原理"><a href="#奥卡姆剃刀原理" class="headerlink" title="奥卡姆剃刀原理"></a>奥卡姆剃刀原理</h4><h3 id="首要原则"><a href="#首要原则" class="headerlink" title="首要原则"></a>首要原则</h3><h4 id="勿重复造轮子"><a href="#勿重复造轮子" class="headerlink" title="勿重复造轮子"></a>勿重复造轮子</h4><p>-<code>DRY Don’t Repeat Yourself</code><br>是一个最简单的法则，也是最容易被理解的。但它也可能是最难被应用的（因为要做到这样，我们需要在泛型设计上做相当的努力，这并不是一件容易的事）。它意味着，当我们在两个或多个地方的时候发现一些相似的代码的时候，我们需要把他们的共性抽象出来形一个唯一的新方法，并且改变现有的地方的代码让他们以一些合适的参数调用这个新的方法。</p><h4 id="减法优于加法"><a href="#减法优于加法" class="headerlink" title="减法优于加法"></a>减法优于加法</h4><ul><li><code>KISS Keep It Simple, Stupid</code><br>KISS原则在设计上可能最被推崇的，在家装设计，界面设计 ，操作设计上，复杂的东西越来越被众人所BS了，而简单的东西越来越被人所认可，比如这些UI的设计和我们中国网页（尤其是新浪的网页）者是负面的例子。<br>“宜家”（IKEA）简约、效率的家居设计、生产思路；“微软”（Microsoft）“所见即所得”的理念；“谷歌”（Google)简约、直接的商业风格，无一例外的遵循了“kiss”原则，<br>也正是“kiss”原则，成就了这些看似神奇的商业经典。而苹果公司的iPhone/iPad将这个原则实践到了极至。</li></ul><p>把一个事情搞复杂是一件简单的事，但要把一个复杂的事变简单，这是一件复杂的事。</p><h4 id="抽象优于实现"><a href="#抽象优于实现" class="headerlink" title="抽象优于实现"></a>抽象优于实现</h4><p>-<code>Program to an interface, not an implementation</code></p><ul><li>这是设计模式中最根本的哲学，注重接口，而不是实现，依赖接口，而不是实现。接口是抽象是稳定的，实现则是多种多样的。</li><li>以后面我们会面向对象的SOLID原则中会提到我们的依赖倒置原则，就是这个原则的的另一种样子。</li></ul><h4 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h4><p><code>【Composition over inheritance】</code></p><ul><li>多使用组合而不是继承, 但是这个观点是存在一定的争议的, 还是要有度的,合理搭配最为重要<ul><li>组合就是将原来继承方式中的父类放到子类作为属性?</li></ul></li></ul><p>组合<br>1.（对象）组合是一种通过创建一个组合了其它对象的对象，从而获得新功能的复用方法。<br>2.将功能委托给所组合的一个对象，从而获得新功能。<br>3.有些时候也称之为”聚合”（aggregation）或”包容”（containment），尽管有些作者对这些术语赋予了专门的含义</p><ul><li style="list-style: none"><input type="checkbox"> 再度思考</li></ul><blockquote><p><a href="http://www.cnblogs.com/narutow/p/8117352.html" target="_blank" rel="noopener">参考博客: 组合、委托与继承，面向对象中类之间的基本关系漫游</a><br><a href="https://www.xuebuyuan.com/1639556.html" target="_blank" rel="noopener">参考博客: 优先使用（对象）组合，而非（类）继承</a></p></blockquote><h4 id="查询与命令分离"><a href="#查询与命令分离" class="headerlink" title="查询与命令分离"></a>查询与命令分离</h4><p><code>【CQS Command-Query Separation】</code></p><ul><li>查询命令分离原则<ul><li>查询：当一个方法返回一个值来回应一个问题的时候，它就具有查询的性质；</li><li>命令：当一个方法要改变对象的状态的时候，它就具有命令的性质；</li></ul></li></ul><h4 id="够用原则"><a href="#够用原则" class="headerlink" title="够用原则"></a>够用原则</h4><p><code>【YAGNI  You Ain’t Gonna Need It 】</code></p><ul><li>这个原则简而言之为——只考虑和设计必须的功能，避免过度设计。只实现目前需要的功能，在以后您需要更多功能时，可以再进行添加。<ul><li>如无必要，勿增复杂性。</li><li>软件开发先是一场沟通博弈。 </li></ul></li></ul><h4 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h4><blockquote><p>【Law of Demeter – 迪米特法则】</p><ul><li>迪米特法则(Law of Demeter)，又称“最少知识原则” <code>（Principle of Least Knowledge）</code>，其来源于1987年荷兰大学的一个叫做Demeter的项目。</li><li>Craig Larman把Law of Demeter又称作“不要和陌生人说话”。在《程序员修炼之道》中讲LoD的那一章叫作“解耦合与迪米特法则”。</li><li>关于迪米特法则有一些很形象的比喻：<ul><li>如果你想让你的狗跑的话，你会对狗狗说还是对四条狗腿说？</li><li>如果你去店里买东西，你会把钱交给店员，还是会把钱包交给店员让他自己拿？ </li></ul></li><li>正式表述如下:</li><li>对于对象 ‘O’ 中一个方法’M’，M应该只能够访问以下对象中的方法:<ul><li>对象O；</li><li>与O直接相关的Component Object；</li><li>由方法M创建或者实例化的对象；</li><li>作为方法M的参数的对象。</li></ul></li></ul></blockquote><blockquote><p><a href="http://zhangyi.xyz/demeter-law-and-refactoring/" target="_blank" rel="noopener">参考博客: 迪米特法则与重构</a></p></blockquote><hr><h3 id="面向对象的S-O-L-I-D-原则"><a href="#面向对象的S-O-L-I-D-原则" class="headerlink" title="面向对象的S.O.L.I.D 原则"></a>面向对象的S.O.L.I.D 原则</h3><ul><li>一般来说这是面向对象的五大设计原则，但是，我觉得这些原则可适用于所有的软件开发。</li></ul><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p><code>Single Responsibility Principle (SRP)</code></p><ul><li>关于单一职责原则，其核心的思想是：<code>一个类，只做一件事，并把这件事做好，且只有一个引起它变化的原因。</code><ul><li>Unix/Linux是这一原则的完美体现者。各个程序都独立负责一个单一的事。</li><li>Windows是这一原则的反面示例。几乎所有的程序都交织耦合在一起。 </li></ul></li></ul><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p><code>Open/Closed Principle (OCP)</code></p><ul><li>关于开发封闭原则，其核心的思想是：模块是可扩展的，而不可修改的。也就是说，<code>对扩展是开放的，而对修改是封闭的。</code><ul><li>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li><li>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。</li></ul></li></ul><h4 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h4><p><code>Liskov substitution principle (LSP)</code></p><ul><li>软件工程大师Robert C. Martin把里氏代换原则最终简化为一句话：<code>“Subtypes must be substitutable for their base types”。</code></li><li><p>也就是，子类必须能够替换成它们的基类。</p><blockquote><p>即：子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现if/else之类对子类类型进行判断的条件。<br>里氏替换原则LSP是使代码符合开闭原则的一个重要保证。正是由于子类型的可替换性才使得父类型的模块在无需修改的情况下就可以扩展。</p></blockquote></li><li><p>这么说来，似乎有点教条化，我非常建议大家看看这个原则个两个最经典的案例——<code>“正方形不是长方形”</code>和<code>“鸵鸟不是鸟”</code>。</p></li><li>通过这两个案例，你会明白《墨子小取》中说的——<code>“娣，美人也，爱娣，非爱美人也….盗，人也；恶盗，非恶人也。”</code>——妹妹虽然是美人，但喜欢妹妹并不代表喜欢美人。</li><li>盗贼是人，但讨厌盗贼也并不代表就讨厌人类。这个原则让你考虑的不是语义上对象的间的关系，而是实际需求的环境。</li><li>在很多情况下，在设计初期我们类之间的关系不是很明确，LSP则给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系。</li><li><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><code>Interface Segregation Principle (ISP)</code></li><li>接口隔离原则意思是把功能实现在接口中，而不是类中，使用多个专门的接口比使用单一的总接口要好。</li><li>举个例子，我们对电脑有不同的使用方式，比如：写作，通讯，看电影，打游戏，上网，编程，计算，数据等，如果我们把这些功能都声明在电脑的抽类里面，那么，我们的上网本，PC机，服务器，</li><li>笔记本的实现类都要实现所有的这些接口，这就显得太复杂了。所以，我们可以把其这些功能接口隔离开来，比如：工作学习接口，编程开发接口，上网娱乐接口，计算和数据服务接口，这样，我们的不同功能的电脑就可以有所选择地继承这些接口。</li><li>这个原则可以提升我们“搭积木式”的软件开发。对于设计来说，Java中的各种Event Listener和Adapter，对于软件开发来说，不同的用户权限有不同的功能，不同的版本有不同的功能，都是这个原则的应用。</li></ul><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p><code>Dependency Inversion Principle (DIP)</code><br>高层模块不应该依赖于低层模块的实现，而是依赖于高层抽象。<br>举个例子，墙面的开关不应该依赖于电灯的开关实现，而是应该依赖于一个抽象的开关的标准接口，这样，当我们扩展程序的时候，我们的开关同样可以控制其它不同的灯，甚至不同的电器。<br>也就是说，电灯和其它电器继承并实现我们的标准开关接口，而我们的开关产商就可不需要关于其要控制什么样的设备，只需要关心那个标准的开关标准。这就是依赖倒置原则。<br>这就好像浏览器并不依赖于后面的web服务器，其只依赖于HTTP协议。这个原则实在是太重要了，社会的分工化，标准化都是这个设计原则的体现。</p><blockquote><p>下面有几点指导意见，帮助你避免在面向对象设计中违反依赖倒置原则：  </p><blockquote><p>变量不能持有具体类的引用，就像订单方法代码中，你看不到new一样。<br>不要让派生自具体类，要派生就派生抽象类abstract<br>不要覆盖基类中已实现的方法，除非你要覆盖的是比较特殊的一部分代码。  </p></blockquote></blockquote><h3 id="其他原则"><a href="#其他原则" class="headerlink" title="其他原则"></a>其他原则</h3><h4 id="共同封闭原则"><a href="#共同封闭原则" class="headerlink" title="共同封闭原则"></a>共同封闭原则</h4><p><code>Common Closure Principle（CCP）</code><br>一个包中所有的类应该对同一种类型的变化关闭。一个变化影响一个包，便影响了包中所有的类。一个更简短的说法是：一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。CCP原则就是把因为某个同样的原因而需要修改的所有类组合进一个包里。如果2个类从物理上或者从概念上联系得非常紧密，它们通常一起发生改变，那么它们应该属于同一个包。</p><p>CCP延伸了开闭原则（OCP）的“关闭”概念，当因为某个原因需要修改时，把需要修改的范围限制在一个最小范围内的包里。</p><h4 id="共同重用原则"><a href="#共同重用原则" class="headerlink" title="共同重用原则"></a>共同重用原则</h4><p><code>Common Reuse Principle (CRP)</code><br>包的所有类被一起重用。如果你重用了其中的一个类，就重用全部。换个说法是，没有被一起重用的类不应该被组合在一起。CRP原则帮助我们决定哪些类应该被放到同一个包里。依赖一个包就是依赖这个包所包含的一切。当一个包发生了改变，并发布新的版本，使用这个包的所有用户都必须在新的包环境下验证他们的工作，即使被他们使用的部分没有发生任何改变。因为如果包中包含有未被使用的类，即使用户不关心该类是否改变，但用户还是不得不升级该包并对原来的功能加以重新测试。</p><p>CCP则让系统的维护者受益。CCP让包尽可能大（CCP原则加入功能相关的类），CRP则让包尽可能小（CRP原则剔除不使用的类）。它们的出发点不一样，但不相互冲突。</p><h4 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h4><p><code>Hollywood Principle</code><br>好莱坞原则就是一句话——“don’t call us, we’ll call<br>you.”。意思是，好莱坞的经纪人们不希望你去联系他们，而是他们会在需要的时候来联系你。也就是说，所有的组件都是被动的，所有的组件初始化和调用都由容器负责。组件处在一个容器当中，由容器负责管理。</p><p>简单的来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在：</p><pre><code>不创建对象，而是描述创建对象的方式。在代码中，对象与服务没有直接联系，而是容器负责将这些联系在一起。</code></pre><p>控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。</p><p>好莱坞原则就是IoC（Inversion of Control）或DI（Dependency Injection）的基础原则。这个原则很像依赖倒置原则，依赖接口，而不是实例，但是这个原则要解决的是怎么把这个实例传入调用类中？你可能把其声明成成员，你可以通过构造函数，你可以通过函数参数。但是<br>IoC可以让你通过配置文件，一个由Service Container<br>读取的配置文件来产生实际配置的类。但是程序也有可能变得不易读了，程序的性能也有可能还会下降。</p><h4 id="高内聚低耦合"><a href="#高内聚低耦合" class="headerlink" title="高内聚低耦合"></a>高内聚低耦合</h4><p><code>【 High Cohesion &amp; Low/Loose coupling &amp; – 高内聚， 低耦合 】</code></p><ul><li>这个原则是UNIX操作系统设计的经典原则，把模块间的耦合降到最低，而努力让一个模块做到精益求精。<ul><li>内聚：一个模块内各个元素彼此结合的紧密程度</li><li>耦合：一个软件结构内不同模块之间互连程度的度量</li></ul></li><li>内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身</li></ul><blockquote><p>凝聚&gt;松耦合&gt;重用  <a href="http://www.jdon.com/forum/messageList.shtml?thread=45977#23144139" target="_blank" rel="noopener">参考博客: 为什么我停止使用Spring?</a></p></blockquote><h4 id="惯例优于配置原则"><a href="#惯例优于配置原则" class="headerlink" title="惯例优于配置原则"></a>惯例优于配置原则</h4><p><code>Convention over Configuration（CoC）</code><br>简单点说，就是将一些公认的配置方式和信息作为内部缺省的规则来使用。例如，Hibernate的映射文件，如果约定字段名和类属性一致的话，基本上就可以不要这个配置文件了。你的应用只需要指定不convention的信息即可，从而减少了大量convention而又不得不花时间和精力啰里啰嗦的东东。配置文件很多时候相当的影响开发效率。</p><p>Rails 中很少有配置文件（但不是没有，数据库连接就是一个配置文件），Rails 的fans号称期开发效率是 java 开发的 10<br>倍，估计就是这个原因。Maven也使用了CoC原则，当你执行mvn<br>-compile命令的时候，不需要指源文件放在什么地方，而编译以后的class文件放置在什么地方也没有指定，这就是CoC原则。</p><h4 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a>关注点分离</h4><p><code>Separation of Concerns (SoC)</code></p><blockquote><p>　是计算机科学中最重要的努力目标之一。这个原则，就是在软件开发中，通过各种手段，将问题的各个关注点分开。如果一个问题能分解为独立且较小的问题，就是相对较易解决的。<br>问题太过于复杂，要解决问题需要关注的点太多，而程序员的能力是有限的，不能同时关注于问题的各个方面。正如程序员的记忆力相对于计算机知识来说那么有限一样，<br>程序员解决问题的能力相对于要解决的问题的复杂性也是一样的非常有限。在我们分析问题的时候，如果我们把所有的东西混在一起讨论，那么就只会有一个结果——乱。</p></blockquote><p>我记得在上一家公司有一个项目，讨论就讨论了1年多，项目本来不复杂，但是没有使用SoC，全部的东西混为一谈，再加上一堆程序员注入了各种不同的观点和想法，整个项目一下子就失控了。<br>最后，本来一个1年的项目做了3年。</p><p>实现关注点分离的方法主要有两种，一种是标准化，另一种是抽象与包装。标准化就是制定一套标准，让使用者都遵守它，将人们的行为统一起来，这样使用标准的人就不用担心别人会有很多种不同的实现，使自己的程序不能和别人的配合。<br>JavaEE就是一个标准的大集合。每个开发者只需要关注于标准本身和他所在做的事情就行了。就像是开发镙丝钉的人只专注于开发镙丝钉就行了，而不用关注镙帽是怎么生产的，反正镙帽和镙丝钉按标来就一定能合得上。不断地把程序的某些部分抽像差包装起来，也是实现关注点分离的好方法。<br>一旦一个函数被抽像出来并实现了，那么使用函数的人就不用关心这个函数是如何实现的，同样的，一旦一个类被抽像并实现了，类的使用者也不用再关注于这个类的内部是如何实现的。<br>诸如组件，分层，面向服务，等等这些概念都是在不同的层次上做抽像和包装，以使得使用者不用关心它的内部实现细节。<br>说白了还是“高内聚，低耦合”。</p><blockquote><p><a href="http://www.cnblogs.com/wenhongyu/p/7992028.html" target="_blank" rel="noopener">参考博客: 理论篇：关注点分离(Separation of concerns, SoC)</a></p></blockquote><h4 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h4><p><code>Design by Contract (DbC)</code><br>DbC的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。例如：</p><pre><code>供应商必须提供某种产品（责任），并且他有权期望客户已经付款（权利）。客户必须付款（责任），并且有权得到产品（权利）。契约双方必须履行那些对所有契约都有效的责任，如法律和规定等。</code></pre><p>同样的，如果在程序设计中一个模块提供了某种功能，那么它要：</p><pre><code>期望所有调用它的客户模块都保证一定的进入条件：这就是模块的先验条件（客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况）。保证退出时给出特定的属性：这就是模块的后验条件——（供应商的义务，显然也是客户的权利）。在进入时假定，并在退出时保持一些特定的属性：不变式。</code></pre><p>契约就是这些权利和义务的正式形式。我们可以用“三个问题”来总结DbC，并且作为设计者要经常问：</p><pre><code>它期望的是什么？它要保证的是什么？它要保持的是什么？</code></pre><p>根据Bertrand<br>Meyer氏提出的DBC概念的描述，对于类的一个方法，都有一个前提条件以及一个后续条件，前提条件说明方法接受什么样的参数数据等，只有前提条件得到满足时，这个方法才能被调用；同时后续条件用来说明这个方法完成时的状态，如果一个方法的执行会导致这个方法的后续条件不成立，那么这个方法也不应该正常返回。</p><p>现在把前提条件以及后续条件应用到继承子类中，子类方法应该满足：</p><pre><code>前提条件不强于基类．后续条件不弱于基类．</code></pre><p>换句话说，通过基类的接口调用一个对象时，用户只知道基类前提条件以及后续条件。因此继承类不得要求用户提供比基类方法要求的更强的前提条件，亦即，继承类方法必须接受任何基类方法能接受的任何条件（参数）。同样，继承类必须顺从基类的所有后续条件，亦即，继承类方法的行为和输出不得违反由基类建立起来的任何约束，不能让用户对继承类方法的输出感到困惑。</p><p>这样，我们就有了基于契约的LSP，基于契约的LSP是LSP的一种强化。</p><h4 id="无环依赖原则"><a href="#无环依赖原则" class="headerlink" title="无环依赖原则"></a>无环依赖原则</h4><p><code>Acyclic Dependencies Principle (ADP)</code><br>包之间的依赖结构必须是一个直接的无环图形，也就是说，在依赖结构中不允许出现环（循环依赖）。如果包的依赖形成了环状结构，怎么样打破这种循环依赖呢？有2种方法可以打破这种循环依赖关系：第一种方法是创建新的包，如果A、B、C形成环路依赖，那么把这些共同类抽出来放在一个新的包D里。这样就把C依赖A变成了C依赖D以及A依赖D，从而打破了循环依赖关系。第二种方法是使用DIP（依赖倒置原则）和ISP（接口分隔原则）设计原则。</p><p>无环依赖原则（ADP）为我们解决包之间的关系耦合问题。在设计模块时，不能有循环依赖。</p><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><p><a href="https://java-design-patterns.com/" target="_blank" rel="noopener">java design patterns</a></p></blockquote><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><blockquote><p><a href="http://www.cnblogs.com/x-xk/archive/2013/01/21/2864916.html" target="_blank" rel="noopener">设计模式基础</a><br><a href="http://www.baike.com/wiki/GoF" target="_blank" rel="noopener">参考博客: GoF解释</a><br><a href="http://blog.csdn.net/column/details/zsxdesignpattern.html" target="_blank" rel="noopener">参考博客: 设计模式专栏</a></p></blockquote><blockquote><p><a href="http://blog.csdn.net/u011240877/article/details/45381071" target="_blank" rel="noopener">23种经典设计模式UML类图汇总 </a><br><a href="http://blog.csdn.net/chen4013874/article/details/51347535" target="_blank" rel="noopener">参考博客: 23种设计模式UML表示形式</a><br><a href="http://blog.csdn.net/tingting256/article/details/52534663" target="_blank" rel="noopener">参考博客: 23中设计模式类图和原理详解</a><br><a href="http://blog.csdn.net/qq_25827845/article/details/52510803" target="_blank" rel="noopener">参考博客: 23种设计模式类图总结 </a> </p></blockquote><h3 id="策略者模式"><a href="#策略者模式" class="headerlink" title="策略者模式"></a>策略者模式</h3><blockquote><p>定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。<br><a href="http://blog.csdn.net/hguisu/article/details/7558249" target="_blank" rel="noopener">参考博客: 设计模式 ( 十八 ) 策略模式Strategy（对象行为型） </a><br><a href="http://www.cnblogs.com/zdd-java/p/6143935.html" target="_blank" rel="noopener">参考博客: Java消除ifelse</a></p></blockquote><p>也就是说将一种需求的多种实现算法分别封装起来, 然后利用多态, 让调用方选择任一实现</p><h3 id="1-创建型设计模式"><a href="#1-创建型设计模式" class="headerlink" title="1.创建型设计模式"></a>1.创建型设计模式</h3><blockquote><p>单例模式(Singleton)<br>原型模式(Prototype)<br>建造者(Builder)<br>抽象工厂(Abstract Factory)<br>工厂方法(Factory Method)   </p></blockquote><ul><li>抽象了实例化过程，它们帮助一个系统独立于如何创建，组合和表示它的那些对象。</li><li>一个类创建型模型使用继承改变被实例化的类，而一个对象创建型模型将实例化委托给另一个对象</li><li>将一组固定行为的硬编码转移为定义一个较小的基本行为集，这些行为可以被组合成任意数目的更复杂性的行为。这样创建有特定行为的对象要求的不仅仅是实例化一个类</li></ul><p><em>Builder</em></p><ul><li>生成器 Builder，是一种对象构建模式，模式通常包含Builder，ConcreteBuilder。Director 和 Product四部分</li></ul><p><em>Abstract Factory</em></p><ul><li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</li></ul><p><em>Factory Method</em></p><ul><li>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类</li></ul><p><em>Prototype</em></p><ul><li>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 </li></ul><p><em>Singleton</em></p><ul><li>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li></ul><h3 id="2-结构型设计模式"><a href="#2-结构型设计模式" class="headerlink" title="2.结构型设计模式"></a>2.结构型设计模式</h3><blockquote><p>适配器模式(<strong>Adapter</strong>)<br>桥接模式(<strong>Bridge</strong>)<br>组合模式(<strong>Compontent</strong>)<br>代理模式(<strong>Proxy</strong>)<br>享元模式(<strong>Flyweight</strong>)<br>外观模式(<strong>Facade</strong>)<br>装饰模式(<strong>Decorator</strong>)  </p></blockquote><ul><li>结构型设计模式涉及如何组合类和对象以获得更大的结构</li><li>结构型模式采用继承机制来组合接口或实现。</li><li>结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能</li></ul><hr><ul><li><strong>Composite模式</strong><br>它将对象组合成树形结构以表示“部分-整体”</li><li><strong>Flyweight模式</strong><br>该模式为共享对象定义了一个结构，强调对象的空间效率，自由共享</li><li><p><strong>Facade模式</strong>（外观模式）<br>描述了如何用单个对象表示整个子系统（外部与其内部通信必须通过一个统一的对象进行交互），模式中的facade用来表示一组对象，<br>外观设计模式提供一个高层次的接口是的子系统易于使用。<br><strong>适用情况:</strong></p><blockquote><p> 1.为复杂的子系统提供一个简单的接口<br> 2.客户程序与抽象类的实现部分有很大依赖性<br> 3.构建一个层次结构的子系统时，适用外观模式定义子系统每层的入口</p></blockquote></li><li><p><strong>Bridge模式</strong> 将对象的抽象和实现分离，从而可以独立的改变他们。</p></li><li><strong>Decorator模式</strong><br>描述如何动态地为对象添加职责，模式采用递归方式组合对象，从而允许添加任意多的对象职责。</li></ul><h3 id="3-行为设计模式"><a href="#3-行为设计模式" class="headerlink" title="3.行为设计模式"></a>3.行为设计模式</h3><blockquote><p>策略模式(<strong>Strategy</strong>)<br>命令模式(<strong>Command</strong>)<br>状态模式(<strong>State</strong>)<br>解释器模式(<strong>Interpreter</strong>)<br>模板方法(<strong>Template Method</strong>)<br>责任链模式(<strong>Chain of Responsibility</strong>)<br>迭代器模式(<strong>Iterator</strong>)<br>中介者模式(<strong>Mediator</strong>)<br>备忘录模式(<strong>Memento</strong>)<br>观察者模式(<strong>Observe</strong>)<br>访问者模式(<strong>Visitor</strong>)  </p></blockquote><ul><li>行为设计模式涉及算法和对象间职责的分配，行为模式描述对象和类的模式以及其通信模式</li><li>行为模式使用继承机制在类间派发行为</li></ul><hr><h3 id="【常见设计模式】"><a href="#【常见设计模式】" class="headerlink" title="【常见设计模式】"></a>【常见设计模式】</h3><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><ul><li><strong>适配器 模式</strong>（Adapter）：适配器是的一个接口与其他接口兼容，从而给出了多个不同接口的同一抽象。一般分类结构和对象结构两种：</li><li><em>类适配器</em>：适配器类继承被适配类，实现某个接口，在客户端类中可以根据需求来建立子类</li><li><em>对象适配器</em>：适配器不是继承，是使用直接关联，或称委托方式<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/UML/Adapter.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><ul><li><strong>中介者 模式</strong>：包装了一系列对象相互作用的方式，使得对象间的相互作用是独立变化，但是与中介者紧密联系</li></ul><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ul><li><strong>观察者 模式 Observer</strong>：一个目标物件管理相依于它的管理物件，并且在它本身的状态发生改变时发出通知，这种模式常用来实现事件处理系统。（也称发布-订阅，模型-视图，源-收听者模式）<ul><li>观察者（接口）：更新信息，展示信息，给 <strong>被观察者（形参）</strong> 注册上观察者</li><li>被观察者（接口）：发出更新通知（遍历观察者集合并注册），当自身发生改动时发出通知消息</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Observer.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><blockquote><p>Singleton 一个类只有一个实例易于外界访问 Spring将该模式运用的出神入化</p></blockquote><ul><li><a href="http://www.cnblogs.com/atwanli/articles/5104898.html" target="_blank" rel="noopener">单例模式与高并发</a>当某个单例对象中含有不具有并发性的对象 就会发生并发问题, 由于只有一个对象, 为了确保数据一致, 就需要加锁, 这样就带来了严重的性能下降, 而Spring是怎么做的呢<ul><li><a href="https://blog.csdn.net/java_fancy/article/details/7439657" target="_blank" rel="noopener">参考博客 Spring如何处理线程并发</a></li><li><a href="https://bbs.csdn.net/topics/390873889" target="_blank" rel="noopener">参考博客: springmvc是单例的，开发的时候会不会影响性能呢？</a></li><li><a href="http://www.xuebuyuan.com/1628190.html" target="_blank" rel="noopener">参考博客: Spring并发访问的线程安全性问题</a> <code>Controller或者Service层中定义共享对象, 但是使用线程安全对象</code></li></ul></li></ul><blockquote><p><a href="https://bbs.csdn.net/topics/310136305" target="_blank" rel="noopener">参考博客: 单例模式和Static的区别! </a> </p><ul><li style="list-style: none"><input type="checkbox"> <code>static 有可能被实例化多个出来么</code></li></ul></blockquote><h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h5><ul><li><strong>装饰器模式</strong> 创建一个新类为某一个类动态添加新功能或增强原有的功能，避免代码重复或具体子类的数量增加</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Decorator.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>策略模式</strong> 优点：灵活添加同一问题的不同解决方案</li><li><strong>状态模式</strong> 允许对象在内部状态时变更其行为，并且修改其类：<ul><li>环境类（Context）：定义客户感兴趣的接口，维护一个子类的实例，这个实例就是当前状态</li><li>抽象状态类（State）：定义一个接口以封装与Context的一个特定状态相关的行为</li><li>具体状态类（concreteState）：每一子类实现与Context的一个状态相关的行为</li><li><strong>例题</strong>：纸巾售卖机:有四个状态!<ul><li>【状态图】</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/State_zhijin.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>【类图】</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/State_zhijin2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul></li><li><strong>例题</strong>：TCP连接状态:<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/State_TCP.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul></li><li><strong>命令模式 command</strong>：<ul><li>行为请求者 与 请求实现者 之间 紧耦合 的关系</li><li><strong>将一个请求封装成一个对象</strong>，从而可用不同的请求对客户进行参数化，支持可撤销的操作</li><li>下例：使用了接口来实现多态，子类是多个的，方法同名并功能多样的<ul><li>代码复用好，代码结构清晰【参数类表最好不要出现标志变量，最好分离出另一个方法】</li></ul></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Command.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>桥接模式</strong> ： 便于扩展，实现与抽象分离（解耦）对一个模块修改不影响别的模块</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Bridge.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>抽象工厂模式</strong> ： 提供一个创建一系列相关实例相互依赖的对象。<ul><li>当一个系统要独立于它的产品的创建，组合和表示时</li><li>当一个系统要由多个产品系列中的一个来配置时</li><li>当需强调一系列相关的产品对象的设计以便进行联合使用时</li><li>想提供一组对象而不显示他们的实现过程，只显示他们的接口</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/AbstractFactory.png" alt=""></p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><blockquote><p>struts2 就是采用该模式</p><ul><li><strong>原型模式</strong> ： 对象创建模型： 允许一个对象创建另一个可定制的对象，封装实例化细节。<ul><li>实现Cloneable接口（Java自带接口），重写clone方法（在这里实例化对象，new或反射，按需求来修改）</li><li>该例，组合关系，在对方使用clone来代替构造器来实例化对象，并做好了绑定操作，大量减少代码量</li></ul></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Clone.png" alt=""> </p><h4 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h4><ul><li><strong>生成器模式</strong>：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Builder.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><ul><li><a href="https://www.ibm.com/developerworks/cn/java/design/" target="_blank" rel="noopener">IBM 社区 Java 设计模式专题</a></li><li><a href="http://www.cnblogs.com/x-xk/archive/2012/12/21/2823401.html" target="_blank" rel="noopener">一个鸭子游戏引发的设计（多态，继承，抽象，接口，策略者模式）</a></li><li><p><a href="www.cnblogs.com/x-xk/archive/2013/01/06/2830742.html">不要再盲目的new了！你要学着针对接口编程！（具体方法，Factory，Abstract Factory</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/aGMz1u0Oh4ZHTDBFvgq0lg" target="_blank" rel="noopener">参考博客: 为什么我墙裂建议大家使用枚举来实现单例。</a></p></li><li style="list-style: none"><input type="checkbox"> 自己用Java重写一下这个例子, 并做出自己的总结</li></ul><p>反模式<br>末日金字塔: 多层嵌套</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#设计模式之禅&quot;&gt;设计模式之禅&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#软件设计的一些原则&quot;&gt;软件设计的一些原则&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#思维原则&quot;&gt;思维
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Oracle</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Database-Oracle/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Database-Oracle/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#oracle">Oracle</a><ol><li><a href="#安装">安装</a><ol><li><a href="#linux">Linux</a><ol><li><a href="#docker安装">Docker安装</a></li></ol></li><li><a href="#windows">Windows</a></li></ol></li><li><a href="#使用">使用</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><blockquote><p>强大的数据库, 稍微理解一下他的设计都觉得精妙</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h4><blockquote><p><a href="/Linux/Container/DockerSoft.md#安装oracle">详情&gt;&gt;</a></p></blockquote><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#oracle&quot;&gt;Oracle&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#安装&quot;&gt;安装&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#linux&quot;&gt;Linux&lt;/a&gt;&lt;ol&gt;
&lt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://blog.kuangcp.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle" scheme="http://blog.kuangcp.top/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>SpringbootDatabase.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-SpringbootDatabase/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-SpringbootDatabase/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#数据库模块">数据库模块</a><ol><li><a href="#relational-database">Relational Database</a><ol><li><a href="#多数据源配置">多数据源配置</a></li><li><a href="#连接池">连接池</a><ol><li><a href="#c3p0">c3p0</a></li><li><a href="#druid">druid</a></li><li><a href="#hikaripool">HikariPool</a></li></ol></li><li><a href="#jpa">JPA</a><ol><li><a href="#configuration">Configuration</a></li></ol></li><li><a href="#mybatis">Mybatis</a><ol><li><a href="#自定义查询">自定义查询</a><ol><li><a href="#hql">HQL</a></li><li><a href="#原生sql">原生SQL</a></li></ol></li><li><a href="#mysql">Mysql</a></li><li><a href="#映射关系">映射关系</a><ol><li><a href="#一对一">一对一</a></li><li><a href="#一对多">一对多</a></li><li><a href="#多对多">多对多</a></li></ol></li></ol></li><li><a href="#restful设计">Restful设计</a><ol><li><a href="#特别注意">【特别注意】</a></li></ol></li><li><a href="#jpa数据分页">Jpa数据分页</a></li><li><a href="#数据库上的事务支持">数据库上的事务支持</a></li></ol></li><li><a href="#non-relational-database">Non Relational database</a><ol><li><a href="#jpa">JPA</a><ol><li><a href="#redis的简单使用">Redis的简单使用</a></li><li><a href="#关于stringredistemplate的方法使用">关于StringRedisTemplate的方法使用</a></li><li><a href="#消息订阅和发布">消息订阅和发布</a></li></ol></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="数据库模块"><a href="#数据库模块" class="headerlink" title="数据库模块"></a>数据库模块</h1><blockquote><p>主要是采用的JPA，极大的缩减了代码量，但是要注意不要过度依赖框架，丧失了基本的能力</p></blockquote><h2 id="Relational-Database"><a href="#Relational-Database" class="headerlink" title="Relational Database"></a>Relational Database</h2><h3 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h3><blockquote><p>为什么要有多数据源? 思考</p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/34730e595a8c" target="_blank" rel="noopener">Spring Boot多数据源配置与使用</a></p></blockquote><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h4 id="c3p0"><a href="#c3p0" class="headerlink" title="c3p0"></a>c3p0</h4><ul><li><a href="http://www.cnblogs.com/520playboy/p/7526252.html" target="_blank" rel="noopener">参考博客</a></li></ul><h4 id="druid"><a href="#druid" class="headerlink" title="druid"></a>druid</h4><ul><li><a href="http://makaidong.com/L_Sail/1/40930_11573921.html" target="_blank" rel="noopener">druid连接池的配置</a></li></ul><h4 id="HikariPool"><a href="#HikariPool" class="headerlink" title="HikariPool"></a>HikariPool</h4><blockquote><p>性能最好的数据库连接池</p></blockquote><ul><li style="list-style: none"><input type="checkbox"> 听说代码很精简, 阅读源码学习</li></ul><hr><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><blockquote><p>连接池:1.x 默认是tomcat-jdbc连接池 2.x 是 HikariPool</p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/3b31270a44b1" target="_blank" rel="noopener">参考博客: spring boot2 整合（二）JPA</a></p></blockquote><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/htmlsingle/#howto-configure-jpa-properties" target="_blank" rel="noopener">Official Doc</a><br><strong><code>ddl-auto</code></strong></p><ul><li>JPA 默认是该配置 <code>spring.jpa.hibernate.ddl-auto</code></li><li>但是如上配置没有生效的话就要用 这个 <code>spring.jpa.properties.hibernate.hbm2ddl.auto</code> <ol><li>none 什么都不做</li><li>create-only </li><li>create 先删除, 然后建立新的表</li><li>create-drop 先删除, 然后建立新的表, 然后在SessionFactory实例关闭后再删除</li><li>update 创建和修改</li><li>validate 校验是否一致, 不一致就报错,启动失败</li></ol></li></ul></blockquote><ul><li><p><a href="http://blog.csdn.net/Amy_Queen/article/details/72454099" target="_blank" rel="noopener">Blog: 原生SQL的写法</a></p></li><li><p>[ ] 怎么映射视图到实体上?</p></li></ul><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><blockquote><p><a href="https://blog.csdn.net/juewang_love/article/details/53769906" target="_blank" rel="noopener">IDEA下创建Springboot，thymeleaf，Mybatis，Postgresql，Gradle项目</a></p></blockquote><h4 id="自定义查询"><a href="#自定义查询" class="headerlink" title="自定义查询"></a>自定义查询</h4><h5 id="HQL"><a href="#HQL" class="headerlink" title="HQL"></a>HQL</h5><ul><li>使用Hibernate语法模式,将对象和数据库的表看成一个实体,方便书写SQL,但是在Controller层和Service层<ul><li>进行写代码的时候,参数的传递全是实体对象,要不停的new,这样真的没问题么(当有各种复杂的关联关系的时候,单个对象的CURD基本没有什么问题)</li><li><code>TODO</code> 所以还不如直接写原生SQL! 那么JPA就真的没有使用的必要性了,直接用Mybatis结合插件生成自动的CRUD的代码,这样更为轻量</li><li>待后续使用后再回来填坑</li></ul></li></ul><h5 id="原生SQL"><a href="#原生SQL" class="headerlink" title="原生SQL"></a>原生SQL</h5><ul><li>涉及到数据的修改,就要加上前两个前缀,查询就直接写Query注解即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Query</span>(value = <span class="string">"update a set b=?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><ul><li><p>1.引入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-data-jpa'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-jdbc'</span>)</span><br><span class="line">runtime(<span class="string">'mysql:mysql-connector-java'</span>)</span><br></pre></td></tr></table></figure></li><li><p>2.继承接口，打好实体类的注解 @Entity </p></li><li><p>3.<em>切记 属性名不能使用下划线（数据库风格）不然写声明方法就会报错，jpa只是看下划线前半部分，会说找不到属性</em></p><ul><li>jpa在创建表时会把驼峰命名改成数据库风格的形式</li></ul></li><li><p>4.jpa是声明特定方法的接口，让jpa来实现并自动注入，如果是没有的方法，就可以使用@Query注解</p><ul><li>默认使用的是HQL（HQL是基于类的所以使用的是类的名字不是表的名字），可以设置下使用原生SQL</li></ul></li></ul><h4 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h4><h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><blockquote><p>据说这是性能最好的方式, 但是有一点让人不舒服, A的id是名存实亡的, 数据库都没有这个字段, 实际上就是B的id, 但是对象又一定要保留这个id, 不然约束通不过<br>也就是说, 创建的时候要设置A的id的值, 但是后面却用不到这个值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@OneToOne</span>(fetch = FetchType.LAZY)</span><br><span class="line">  <span class="meta">@MapsId</span></span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h5><ul><li><p>一方的配置是当前类的id，多方则按基本ER的规则来，注解中配置的是外键的名字, 所以当前类中的属性,外键名是不能重复的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 一方</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOne</span></span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String testOneId;</span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"testOneId"</span>)<span class="comment">//这个名字可以重复，最终会有一个随机码生成</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;TestMany&gt; testManySet;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 多方</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMany</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String testManyId;</span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"testOneId"</span>)</span><br><span class="line">    <span class="keyword">private</span> TestOne testOneId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>[ ] 问题: 当两个表互相引用了, 需要修改表结构 ,怎么删除重建两张表结构, 简单的命令会陷入死锁</p></li></ul><hr><h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><hr><h3 id="Restful设计"><a href="#Restful设计" class="headerlink" title="Restful设计"></a>Restful设计</h3><ul><li>1.添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-rest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2.引入自动配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestConfiguration</span> <span class="keyword">extends</span> <span class="title">RepositoryRestMvcConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RepositoryRestConfiguration <span class="title">config</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.config();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProfileResourceProcessor <span class="title">profileResourceProcessor</span><span class="params">(RepositoryRestConfiguration config)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置rest根目录是应用路径下的路径 : localhost:8080/rest</span></span><br><span class="line">        config.setBasePath(<span class="string">"/rest"</span>);</span><br><span class="line">        <span class="comment">// 允许输出id</span></span><br><span class="line">        config.exposeIdsFor(Goods.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.profileResourceProcessor(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3.配置repository的名字例如：（只要配置repository就能用REST了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RepositoryRestResource</span>(path = <span class="string">"book"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Book</span>,<span class="title">Long</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>4.启动应用，控制台有如下输出</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Java/Spring/output.png" alt="输出" title="">                </div>                <div class="image-caption">输出</div>            </figure></li><li><p>所有路径的使用方法：</p><ul><li><code>GET</code> 查询单个 <code>/repo/id</code> 成功：200 失败404</li><li><code>GET</code> 查询所有 <code>/repo</code> 成功200 失败404</li><li><code>POST</code> 新增 <code>/repo</code> json数据发送 成功 201 失败404</li><li><code>DELETE</code> 删除 <code>/repo/id</code> json数据 成功204 失败404</li><li><code>PUT</code> 更新 <code>/repo/id</code> json 更新成功200 没有该id就插入201 失败404（使用主键自动增长就不会遇到404）</li></ul></li></ul><h4 id="【特别注意】"><a href="#【特别注意】" class="headerlink" title="【特别注意】"></a>【特别注意】</h4><ul><li>rest得到的数据没有id<ul><li>添加配置 <code>config.exposeIdsFor(Goods.class);</code> 即可查看到id <a href="http://tommyziegler.com/how-to-expose-the-resourceid-with-spring-data-rest/" target="_blank" rel="noopener">参考博客</a></li></ul></li></ul><h3 id="Jpa数据分页"><a href="#Jpa数据分页" class="headerlink" title="Jpa数据分页"></a>Jpa数据分页</h3><blockquote><p><a href="https://www.tianmaying.com/tutorial/spring-jpa-page-sort" target="_blank" rel="noopener">参考博客</a></p></blockquote><ul><li>分页 page 从0开始 size是个数 sort可以不需要（如果本来就是id排序就没必要了） <ul><li>原理就是 预编译SQL然后查询总数，然后再执行 必须有两条SQL执行</li></ul></li><li>查询的结果不包含实体的id属性</li></ul><h3 id="数据库上的事务支持"><a href="#数据库上的事务支持" class="headerlink" title="数据库上的事务支持"></a>数据库上的事务支持</h3><ul><li>JPA对所有默认方法都开启了事务支持，查询类事务默认启用readOnly=true</li></ul><hr><h2 id="Non-Relational-database"><a href="#Non-Relational-database" class="headerlink" title="Non Relational database"></a>Non Relational database</h2><h3 id="JPA-1"><a href="#JPA-1" class="headerlink" title="JPA"></a>JPA</h3><h4 id="Redis的简单使用"><a href="#Redis的简单使用" class="headerlink" title="Redis的简单使用"></a>Redis的简单使用</h4><p><em>配置连接信息</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=127.0.0.1</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）0不超时</span><br><span class="line">spring.redis.timeout=0</span><br></pre></td></tr></table></figure></p><p><code>在一个配置类中复制如下代码即可使用 StringRedisTemplate RedisTemplate 的实例</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object,Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 值序列化采用 jackson2JsonRedisSerializer</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 键序列化采用 StringRedisSerializer</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">StringRedisTemplate <span class="title">template</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringRedisTemplate(connectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">`两个对象的简单使用`</span><br><span class="line">```java</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"aaa"</span>, <span class="string">"hello"</span>);</span><br><span class="line">    String result = stringRedisTemplate.opsForValue().get(<span class="string">"aaa"</span>);</span><br><span class="line">    <span class="comment">//获取所有</span></span><br><span class="line">    Set&lt;String&gt; keysList =  stringRedisTemplate.keys(<span class="string">"*"</span>);</span><br><span class="line">    <span class="keyword">for</span>(String temp :keysList)&#123;</span><br><span class="line">        log.info(temp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>以上配置的template都是只是建立在最简单的键值对上，String-String，所以对象使用的是json来存储</li><li>但是使用的时候如同使用MySQL一样，是ORM框架自动处理数据的转换</li></ul><h4 id="关于StringRedisTemplate的方法使用"><a href="#关于StringRedisTemplate的方法使用" class="headerlink" title="关于StringRedisTemplate的方法使用"></a>关于StringRedisTemplate的方法使用</h4><ul><li><p>常见数据类型的中间对象</p><ul><li>opsForValue() 操作简单键值对数据<ul><li>hasKey()</li></ul></li><li>opsForHash() 操作含有hash的数据</li><li>opsForList() 操作含有list的数据</li><li>opsForZSet() 操作含有zset（有序）的数据<ul><li>range()方法返回指定范围的数据 Java中Set类型的（诡异的是顺序保持了一致）</li></ul></li><li>opsForSet() 操作含有set的数据</li></ul></li><li><p>设置超时时间</p><ul><li><code>redisTemplate.expire(&quot;max&quot;,tempTime,TimeUnit.SECONDS);</code></li></ul></li></ul><h4 id="消息订阅和发布"><a href="#消息订阅和发布" class="headerlink" title="消息订阅和发布"></a>消息订阅和发布</h4><p><a href="https://www.tianmaying.com/tutorial/springboot-redis-message" target="_blank" rel="noopener">参考博客: Spring Boot使用Redis进行消息的发布订阅</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#数据库模块&quot;&gt;数据库模块&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#relational-database&quot;&gt;Relational Database&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringSecurity.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-SpringSecurity/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-SpringSecurity/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#springsecurity">SpringSecurity</a><ol><li><a href="#配置">配置</a><ol><li><a href="#配置静态口令使用">配置静态口令使用</a></li></ol></li></ol></li><li><a href="#使用该配置即可自定义用户名密码">使用该配置即可自定义用户名密码</a><ol><li><a href="#springboot的集成demo">SpringBoot的集成Demo</a><ol><li><a href="#创建单用户单角色的安全控制">创建单用户单角色的安全控制</a></li><li><a href="#多用户多角色的实现思路">多用户多角色的实现思路</a><ol><li><a href="#每个身份都使用一个登录实体类">每个身份都使用一个登录实体类</a></li><li><a href="#另一种思路">另一种思路：</a></li></ol></li></ol></li><li><a href="#jwt">JWT</a><ol><li><a href="#跨域问题">跨域问题</a></li></ol></li><li><a href="#oauth">Oauth</a></li><li><a href="#实现细节">实现细节</a><ol><li><a href="#关于注解的几种使用方式">关于注解的几种使用方式</a><ol><li><a href="#@secured">@Secured</a></li><li><a href="#@rolesallowed">@RolesAllowed</a></li><li><a href="#springsecurity30-开始提供了-spel表达式">SpringSecurity3.0 开始提供了 SpEL表达式</a></li></ol></li><li><a href="#保护方法应用">保护方法应用</a></li></ol></li><li><a href="#社交登录">社交登录</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><blockquote><p><a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle" target="_blank" rel="noopener">Spring Security 5.0.6 doc</a></p></blockquote><p><a href="http://www.spring4all.com/article/428" target="_blank" rel="noopener">参考博客: Spring Security 入门系列</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置静态口令使用"><a href="#配置静态口令使用" class="headerlink" title="配置静态口令使用"></a>配置静态口令使用</h3><p>当添加了Security依赖之后, 只会生成一个默认的随机密码, 如下简单配置:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用该配置即可自定义用户名密码</span></span><br><span class="line">spring.security.user.name=admin</span><br><span class="line">spring.security.user.password=secret</span><br></pre></td></tr></table></figure></p><p>如果要用 curl 访问则是 <code>curl -i  -u admin:secret  http://tomcat.kcp/hi</code>  </p><blockquote><p>注意 : 前提是要关闭 crsf 校验<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.csrf().disable();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="SpringBoot的集成Demo"><a href="#SpringBoot的集成Demo" class="headerlink" title="SpringBoot的集成Demo"></a>SpringBoot的集成Demo</h2><h3 id="创建单用户单角色的安全控制"><a href="#创建单用户单角色的安全控制" class="headerlink" title="创建单用户单角色的安全控制"></a>创建单用户单角色的安全控制</h3><ol><li>Gradle : <code>compile(&#39;org.springframework.boot:spring-boot-starter-security&#39;)</code></li><li><a href="https://gitee.com/kcp1104/codes/n2berl0tfg8wq9s4ko7xa78#SecurityConfig.java" target="_blank" rel="noopener">Security主要配置类</a></li><li><a href="https://gitee.com/kcp1104/codes/n2berl0tfg8wq9s4ko7xa78#Reader.java" target="_blank" rel="noopener">登录实体类</a></li><li>Jpa实现的Dao层 <code>public interface ReaderRepository extends JpaRepository&lt;Reader, String&gt; {}</code></li></ol><hr><h3 id="多用户多角色的实现思路"><a href="#多用户多角色的实现思路" class="headerlink" title="多用户多角色的实现思路"></a>多用户多角色的实现思路</h3><ul><li><p>使用多个实体类（实现了UserDetails接口），一个权限类，再一个多对多连接，就得到了多用户，多权限的控制</p><ul><li>在页面上加上角色的判断来控制数据显示，业务操作等功能</li></ul></li><li><p>根据书上案例代码，可以得出结论，用户表，角色表，用户角色关联表，用户表是可以多张的，角色公用一张即可，然后关联表也对应的多张，就能实现具体的业务需求</p><ul><li>例如：一个网上在线阅读书城，作家和读者以及编辑，网站后台管理员等角色的不同权限对应的页面甚至页面上细分的各个模块</li><li><code>Author</code> <code>Admin</code> <code>Reader</code> 三个类</li></ul></li><li><code>继承了UserDetails接口的实体类的配置</code> <a href="https://gitee.com/kcp1104/codes/n2berl0tfg8wq9s4ko7xa78#Readers.java" target="_blank" rel="noopener">代码片段</a></li></ul><h4 id="每个身份都使用一个登录实体类"><a href="#每个身份都使用一个登录实体类" class="headerlink" title="每个身份都使用一个登录实体类"></a>每个身份都使用一个登录实体类</h4><ul><li>然后使用不同的dao层查询，显然的实体类登录查询的效率及其低且不易扩展</li><li>设置好<code>spirng.jpa.hibernate.ddl-auto=update</code></li><li>第一次运行还会有没有实体对应的表这样的提示,说明了他正在根据多对多映射创建实体表，也体现了这个多种用户模式下需要实体等量的连接表</li><li>所以这个是要查询多张表了<ul><li>（除非UserDetailService接口的loadUserByUsername能收到表类别的参数）</li><li>也可以考虑使用一个字符串，然后用<code>特殊字符</code>把类型放进去，然后正则取出来</li><li>登录页面就需要自定义一个函数进行拼接（或者使用校验来拼接？）</li></ul></li></ul><h4 id="另一种思路："><a href="#另一种思路：" class="headerlink" title="另一种思路："></a>另一种思路：</h4><ul><li>使用一个登录用户表（序列id，用户名，密码，用户编码（对应多张表））<ul><li>角色表（序列id，用户编码，角色） </li><li>这样的话扩展就只要加表，使用同一个主键生成策略就可以了</li></ul></li></ul><blockquote><ul><li>思考：</li><li>其实这个安全框架使用的是角色控制，而不是权限控制，目前的了解，达不到Oracle那样的权限加角色的精细化控制</li></ul></blockquote><hr><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><blockquote><p><a href="/Skills/Base/WebSecurity.md#jwt">JWT相关原理</a> | <a href="https://github.com/Kuangcp/SpringBoot2-Security-Jwt" target="_blank" rel="noopener">Github SpringBoot2使用Security整合Jwt案例项目</a>  </p></blockquote><ul><li><a href="https://gitee.com/kcp1104/codes/kw31qf40iz9p8mt2x7bcd49" target="_blank" rel="noopener">个人代码片段</a>  |</li></ul><blockquote><p><a href="http://www.saily.top/2016/12/08/spring-boot-jwt/" target="_blank" rel="noopener">集成JWT到Spring Boot项目</a> | <a href="https://segmentfault.com/a/1190000009231329" target="_blank" rel="noopener">使用JWT保护你的Spring Boot应用</a><br><a href="https://juejin.im/post/58c29e0b1b69e6006bce02f4" target="_blank" rel="noopener">重拾后端之Spring Boot（四）：使用JWT和Spring Security保护REST API</a><br><a href="http://www.cnblogs.com/grissom007/p/6294746.html" target="_blank" rel="noopener">开箱即用 - jwt 无状态分布式授权</a></p></blockquote><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><blockquote><p><a href="https://segmentfault.com/q/1010000005067552" target="_blank" rel="noopener">跨域(CORS) 解决方案中，为什么 Access-Control-Allow-Methods 不起作用？</a><br><a href="https://bbs.csdn.net/topics/392006333" target="_blank" rel="noopener">WEB应用前后端分离实践 关键词：rest架构+跨域访问+JWT校验</a></p></blockquote><p><a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#csrf" target="_blank" rel="noopener">csrf</a></p><hr><h2 id="Oauth"><a href="#Oauth" class="headerlink" title="Oauth"></a>Oauth</h2><blockquote><p><a href="https://github.com/spring-projects/spring-security-oauth" target="_blank" rel="noopener">oauth</a></p></blockquote><hr><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="关于注解的几种使用方式"><a href="#关于注解的几种使用方式" class="headerlink" title="关于注解的几种使用方式"></a>关于注解的几种使用方式</h3><h4 id="Secured"><a href="#Secured" class="headerlink" title="@Secured"></a>@Secured</h4><ul><li>这是基于Spring特定的注解<h4 id="RolesAllowed"><a href="#RolesAllowed" class="headerlink" title="@RolesAllowed"></a>@RolesAllowed</h4></li><li>JSR-250的@RolesAllowed Java标准定义的注解，与上面的注解是差不多的</li><li><p>但是都是有局限性，只能判断请求是否有权限，不能进行更多的自定义判断</p><h4 id="SpringSecurity3-0-开始提供了-SpEL表达式"><a href="#SpringSecurity3-0-开始提供了-SpEL表达式" class="headerlink" title="SpringSecurity3.0 开始提供了 SpEL表达式"></a>SpringSecurity3.0 开始提供了 SpEL表达式</h4><p><code>需要先配置这个配置类，后面的注解才会生效</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSecurityConfig</span> <span class="keyword">extends</span> <span class="title">GlobalMethodSecurityConfiguration</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@PreAuthorize</code> 方法调用前，基于表达式的计算结果来限制方法的访问</p></li><li><code>@PostAuthorize</code> 允许方法调用，如果表达式是false 抛出安全异常</li><li><code>@PostFilter</code> 允许方法调用，按照表达式来过滤方法的结果</li><li><p><code>@PreFilter</code> 允许方法调用，必须进入方法前过滤输入值</p></li><li><p>方法调用前验证权限，示例:</p><ul><li><code>@PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)</code> 只允许该权限的用户访问</li><li>方法入参user，限定读者用户的text长度小于140，或者是作家用户无限制</li><li><code>@PreAuthorize(&quot;(hasRole(&#39;ROLE_READER&#39;) and #user.text.length()&lt;=140 ) or hasRole(&#39;ROLE_AUTHOR&#39;)&quot;)</code></li></ul></li><li>方法调用之后验证权限，示例;<ul><li><code>@PostAuthorize(&quot;returnObject.spitter.username == principal.username&quot;)</code></li><li>public Spittle getSpittleById(long id){} </li><li>保护方法，只有当返回的对象就是当前登录的用户时，才返回，不然抛出安全异常<br><code>以上是保护方法的调用，但是有时候保护的是数据的输入输出：</code></li></ul></li><li>过滤方法的输入输出<ul><li>事后对方法的返回值进行过滤<ul><li><code>@PreAuthorize(&quot;hasAnyRole({&#39;ROLE_ADMIN&#39;,&#39;ROLE_USER&#39;})&quot;)</code></li><li><code>@PostFilter(&quot;hasRole(&#39;ROLE_ADMIN&#39;) || filterObject.user.username == principal.name&quot;)</code></li><li><code>public List&lt;User&gt; getUsers(){}</code></li><li>该示例就是限制了如果是管理员可以获取到所有数据，普通用户只能看到自己</li><li>但是这种实现是不好的，只是一个例子，只获取自己，重载方法加个id参数就好了，上面的实现，把数据全拿出来再判断，性能上。。。</li></ul></li><li>事先对方法的参数进行过滤<ul><li><code>@PreAuthorize(&quot;hasAnyRole({&#39;ROLE_ADMIN&#39;,&#39;ROLE_USER&#39;})&quot;)</code></li><li><code>@PreFilter(&quot;hasRole(&#39;ROLE_ADMIN&#39;) || targetObject.user.username == principal.name&quot;)</code></li><li><code>public void deleteUsers(){List&lt;User&gt; users}</code></li><li>示例实现了传入一个集合，要删除的用户，但是当前用户只能删除自己，管理员才能删除集合里所有的用户</li></ul></li><li>定义许可计算器<ul><li><code>@PreFilter(&quot;hasPermission(targetObject,&#39;delete&#39;)&quot;)</code> 用户是否有权限删除目标对象？</li><li>使用了自定义的计算器类来实现这个判断，表达式简洁，但是自定义类不好写</li><li>实现PermissionEvaluator接口，新建hasPermission方法，功能就是判断是否有权限，其实就是对比目标对象是不是当前用户</li><li>创建好类后，重载GlobalMethodSecurityConfiguration配置类的createExpressionHalder方法，注册进去</li><li><code>DefaultMethodSecurityExperssionHandler ex = new De...();</code></li><li><code>ex.setPermissionEvaluator(new 自定义类);</code></li><li><code>return ex;</code></li></ul></li></ul></li></ul><h3 id="保护方法应用"><a href="#保护方法应用" class="headerlink" title="保护方法应用"></a>保护方法应用</h3><ul><li>@Secured 注解限制方法调用</li></ul><hr><h2 id="社交登录"><a href="#社交登录" class="headerlink" title="社交登录"></a>社交登录</h2><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDEwMjgwNA==&amp;mid=2247484230&amp;idx=1&amp;sn=358f684bd122888270730f2b102ee1b2&amp;chksm=fb3f1abdcc4893ab9dc400a44edfe7a9d483c070b78db1d81f70c4a3d7870d113d9287d81b0f&amp;mpshare=1&amp;scene=1&amp;srcid=0121kLxdu4ezkmeJAoJcdMZ1&amp;pass_ticket=LGmo8DCbLhUXTV%2FDVv1W9SyGxNSXxxYLrKODVeXD8f3lkWt2HnMB5b7racYt5W6V#rd" target="_blank" rel="noopener">SpringForAll社区:Spring Security源码分析（三）：Spring Social实现QQ社交登录 </a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDEwMjgwNA==&amp;mid=2247484233&amp;idx=1&amp;sn=1e84ffd8c9169db56a0d48ccb31bc842&amp;chksm=fb3f1ab2cc4893a4263799c466d73ee67971ce9deb22a91b8ae8e968621679de3bce83a2c558&amp;mpshare=1&amp;scene=1&amp;srcid=0121cjpvaOeB0nktdOSQNitj&amp;pass_ticket=LGmo8DCbLhUXTV%2FDVv1W9SyGxNSXxxYLrKODVeXD8f3lkWt2HnMB5b7racYt5W6V#rd" target="_blank" rel="noopener">SpringForAll社区:Spring Security 源码分析（四）：Spring Social实现微信社交登录 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#springsecurity&quot;&gt;SpringSecurity&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#配置&quot;&gt;配置&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#配置静态口令
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-SpringMVC/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-SpringMVC/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#springmvc">SpringMVC</a><ol><li><a href="#mvc思想">MVC思想</a><ol><li><a href="#原理">原理</a></li></ol></li><li><a href="#api">API</a></li><li><a href="#传统项目配置完整流程">传统项目配置完整流程</a><ol><li><a href="#配置依赖">配置依赖</a><ol><li><a href="#maven">Maven</a></li><li><a href="#gradle">Gradle</a></li></ol></li><li><a href="#webxml">web.xml</a></li><li><a href="#applicationcontextxml">ApplicationContext.xml</a><ol><li><a href="#全局异常处理">全局异常处理</a></li><li><a href="#自定义错误页面">自定义错误页面</a></li><li><a href="#中文编码问题">中文编码问题</a></li></ol></li><li><a href="#创建controller">创建Controller</a></li></ol></li><li><a href="#使用">使用</a><ol><li><a href="#自定义拦截器">自定义拦截器</a></li><li><a href="#q&amp;a">Q&amp;A</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><blockquote><p><a href="https://legacy.gitbook.com/book/linesh/spring-mvc-documentation-linesh-translation/details" target="_blank" rel="noopener">Spring MVC 4.2.4.RELEASE 中文文档</a></p></blockquote><h2 id="MVC思想"><a href="#MVC思想" class="headerlink" title="MVC思想"></a>MVC思想</h2><blockquote><p><a href="http://blog.csdn.net/besley/article/details/8479943" target="_blank" rel="noopener">参考博客</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/mvc.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure></p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>统一使用一个Servlet 进行请求的收发, 通过配置的URL对应的方法, 进行调用, 然后返回视图解析器进行渲染</p></blockquote><hr><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><blockquote><p><a href="http://www.csdn.net/article/2013-05-02/2815115-stop-designing-fragile-web-api" target="_blank" rel="noopener">简洁的API设计</a></p></blockquote><hr><h2 id="传统项目配置完整流程"><a href="#传统项目配置完整流程" class="headerlink" title="传统项目配置完整流程"></a>传统项目配置完整流程</h2><blockquote><p>也就是Maven的Web结构，甚至是Eclipse那样的DynamicWeb项目结构， <a href="https://www.cnblogs.com/Sinte-Beuve/p/5730553.html" target="_blank" rel="noopener">参考 博客</a></p></blockquote><h3 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h3><h4 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.3.9.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果使用JSP作为视图层,还需 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework:spring-web:4.3.9.RELEASE'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework:spring-webmvc:4.3.9.RELEASE'</span>)</span><br></pre></td></tr></table></figure><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ApplicationContext-xml"><a href="#ApplicationContext-xml" class="headerlink" title="ApplicationContext.xml"></a>ApplicationContext.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.sprinControllergframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context/spring-context-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--启用spring的一些annotation --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.test.controller"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--HandlerMapping 无需配置，springmvc可以默认启动--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--静态资源映射--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--本项目把静态资源放在了WEB-INF的statics目录下，资源映射如下--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/css/**" location="/WEB-INF/statics/css/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/js/**" location="/WEB-INF/statics/js/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/image/**" location="/WEB-INF/statics/image/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--但是项目部署到linux下发现WEB-INF的静态资源会出现无法解析的情况，但是本地tomcat访问正常，因此建议还是直接把静态资源放在webapp的statics下，映射配置如下--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/css/**" location="/statics/css/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/js/**" location="/statics/js/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/image/**" location="/statics/images/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置注解驱动 可以将request参数与绑定到controller参数上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀(如果最后一个还是表示文件夹,则最后的斜杠不要漏了) 使用JSP--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;bean id="defaultViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="prefix" value="/WEB-INF/views/"/&gt;&amp;lt;!&amp;ndash;设置JSP文件的目录位置&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="suffix" value=".jsp"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springmvc文件上传需要配置的节点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"20971500"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resolveLazily"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        model.put(<span class="string">"ex"</span>, ex);</span><br><span class="line">        ex.printStackTrace();<span class="comment">//打印异常信息</span></span><br><span class="line">        <span class="comment">// 根据不同错误转向不同页面</span></span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> CSRFException) &#123;<span class="comment">//受到csrf攻击</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"/errorPage/error"</span>, model);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BusinessException) &#123;<span class="comment">//业务逻辑处理出错</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"errorPage/businessError"</span>, model);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> ParameterException) &#123;<span class="comment">//参数处理出错。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"errorPage/parameterError"</span>, model);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//其他数据类型错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"errorPage/error"</span>, model);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但如果是前后端分离的话， 就只能统一处理异常然后然后对应的错误码和提示信息了<br><a href="http://www.cnblogs.com/exmyth/p/5601288.html" target="_blank" rel="noopener">参考博客</a><br><a href="https://blog.csdn.net/xin917480852/article/details/78023911" target="_blank" rel="noopener">ResponseBody方案</a></p></blockquote><h4 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义错误页面 需要放在静态资源下面</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">containerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (container -&gt; &#123;</span><br><span class="line">        ErrorPage error401Page = <span class="keyword">new</span> ErrorPage(HttpStatus.FORBIDDEN, <span class="string">"/500.html"</span>);</span><br><span class="line">        ErrorPage error404Page = <span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">"/404.html"</span>);</span><br><span class="line">        ErrorPage error500Page = <span class="keyword">new</span> ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, <span class="string">"/500.html"</span>);</span><br><span class="line">        container.addErrorPages(error401Page, error404Page, error500Page);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中文编码问题"><a href="#中文编码问题" class="headerlink" title="中文编码问题"></a>中文编码问题</h4><blockquote><p><a href="http://www.cnblogs.com/dyllove98/p/3180158.html" target="_blank" rel="noopener">参考博客</a> <code>但是奇怪的是某些方法用第二种正常，有些还是要用第一种</code></p><ol><li>单个方法：<code>@GetMapping(value = &quot;/target/all&quot;,  produces = &quot;application/json; charset=utf-8&quot;)</code></li><li>或者整个应用 注意：<code>&lt;/mvc:annotation-driven&gt;</code> 只能有一个，要将上面的覆盖掉<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                   <span class="comment">&lt;!-- 如果是前后端使用JSON作为主要数据交换格式就把JSON列为第一个， 否则就会被认为是Text --&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json; charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/plain; charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html; charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="创建Controller"><a href="#创建Controller" class="headerlink" title="创建Controller"></a>创建Controller</h3><p>包 com.test.controller 下创建一个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hi"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hi"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hi"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>使用上 ResponseEntity 让响应结果规范<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/handle"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  URI location = ...;</span><br><span class="line">  HttpHeaders responseHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">  responseHeaders.setLocation(location);</span><br><span class="line">  responseHeaders.set(<span class="string">"MyResponseHeader"</span>, <span class="string">"MyValue"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;String&gt;(<span class="string">"Hello World"</span>, responseHeaders, HttpStatus.CREATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>在Springboot框架中，static templates 文件夹下分别代表了tomcat管理的静态文件和MVC负责跳转的HTML文件或JSP文件<br>在static中对于路径的使用一定要带上应用路径，而在templates中就只要写相对路径即可</p></blockquote><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><ul><li><a href="http://www.jianshu.com/p/f14ed6ca4e56" target="_blank" rel="noopener">相关博客</a>|<a href="http://blog.csdn.net/catoop/article/details/50501696" target="_blank" rel="noopener">相关博客</a></li></ul><p><code>定义拦截器类</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MythInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        request.setAttribute(<span class="string">"startTime"</span>,startTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// true就继续跳转，false就停止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = (Long)request.getAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        request.removeAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        log.info(request.getRequestURL()+<span class="string">"发起请求耗时:[ "</span>+ (endTime - startTime) +<span class="string">"  ms]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>配置MVC的配置类</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line">    <span class="comment">//自定义拦截器bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MythInterceptor <span class="title">mythInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MythInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拦截器的URL正则</span></span><br><span class="line">        registry.addInterceptor(mythInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><blockquote><p>URL 中带了 jsessionid 参数，导致页面各种问题</p><ul><li>一种原因：禁用cookie导致的</li><li>最终解决： chrome中在设置里清除localhost的所有cookie和缓存</li></ul></blockquote><ul><li><a href="https://yq.aliyun.com/articles/101169" target="_blank" rel="noopener">解决问题参考博客</a></li><li><p><a href="http://sxsoft.blog.163.com/blog/static/190412229200911103116773" target="_blank" rel="noopener">jsessionid的作用</a></p></li><li><p>[ ] ModelAndView中的addObject 的值能用js获取到么</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#springmvc&quot;&gt;SpringMVC&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#mvc思想&quot;&gt;MVC思想&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#原理&quot;&gt;原理&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-SpringBoot/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-SpringBoot/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#springboot">SpringBoot</a><ol><li><a href="#思考">思考</a></li><li><a href="#参考教程">参考教程</a><ol><li><a href="#系列">系列</a></li></ol></li><li><a href="#开始使用">开始使用</a></li><li><a href="#安装springbootcli">安装SpringBootCLI</a></li><li><a href="#测试模块">测试模块</a></li><li><a href="#配置文件">配置文件</a><ol><li><a href="#多种配置文件并切换">多种配置文件并切换</a><ol><li><a href="#yml方式">yml方式</a></li><li><a href="#yml和properties结合">yml和Properties结合</a></li></ol></li><li><a href="#应用配置文件">应用配置文件</a></li></ol></li><li><a href="#日志模块">日志模块</a></li><li><a href="#web模块">Web模块</a><ol><li><a href="#lisener">Lisener</a><ol><li><a href="#servletcontextlistener">ServletContextListener</a></li></ol></li><li><a href="#上传下载文件">上传下载文件</a></li><li><a href="#错误页面跳转配置">错误页面跳转配置</a></li><li><a href="#跨域">跨域</a></li></ol></li><li><a href="#全局异常处理">全局异常处理</a></li><li><a href="#https的配置">HTTPS的配置</a></li><li><a href="#线程池">线程池</a></li><li><a href="#项目部署">项目部署</a><ol><li><a href="#生成指定文件">生成指定文件</a><ol><li><a href="#war">war</a></li><li><a href="#jar">jar</a></li></ol></li><li><a href="#构建docker镜像">构建docker镜像</a><ol><li><a href="#手动方式">手动方式</a></li><li><a href="#gradle结合docker">gradle结合docker</a></li></ol></li><li><a href="#热部署">热部署</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><blockquote><p><a href="https://spring.io/projects/spring-boot#learn" target="_blank" rel="noopener">首页</a></p></blockquote><blockquote><p>一个简化Spring开发的框架,微服务SpringCloud的基础<br><a href="https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/htmlsingle/" target="_blank" rel="noopener">1.5.14 官方文档</a></p></blockquote><ul><li><a href="https://github.com/spring-projects/spring-boot/releases" target="_blank" rel="noopener">Github:Springboot</a></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p><a href="https://www.zhihu.com/question/39483566" target="_blank" rel="noopener">SpringBoot优缺点</a> </p><ul><li><code>大大降低编程门槛, 但是, 将大量细节隐藏在默认配置中, 需要详细阅读文档和源码才能更好的玩转SpringBoot, 不然到处是坑</code></li></ul></li><li><p><a href="https://www.cnblogs.com/trgl/p/7353782.html" target="_blank" rel="noopener">SpringBoot启动流程解析</a><code>原理才是王道</code></p></li><li><p><a href="https://yq.aliyun.com/articles/6056" target="_blank" rel="noopener">spring boot应用启动原理分析 </a></p></li><li><p>Spring 是单例模式, 全部使用IOC容器进行管理, 那么怎么处理并发呢, </p><ul><li>答案是 ? 多线程 然后 ThreadLocal 分别存储了各自的数据, 所以才说, 不能在Controller层 放置属性, 使其具有状态, 从而导致并发问题</li><li>那么WebSocket服务器, 处理并发会不会有并发问题?</li></ul></li><li><p><a href="http://www.ityouknow.com/springboot/2018/06/12/spring-boo-java-simple.html" target="_blank" rel="noopener">为什么说 Java 程序员到了必须掌握 Spring Boot 的时候？</a></p></li></ul><blockquote><p><a href="https://spring.io/guides/gs/actuator-service/" target="_blank" rel="noopener">Guide</a></p></blockquote><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><ul><li><a href="http://springboot.fun/" target="_blank" rel="noopener">SpringBoot中文索引</a></li><li><a href="http://www.spring4all.com/article/246" target="_blank" rel="noopener">参考博客: Spring Boot 入门系列</a></li><li><a href="https://juejin.im/post/598dd709f265da3e213f0c57" target="_blank" rel="noopener">Springboot探索</a></li><li><a href="http://blog.csdn.net/jsyxcjw/article/details/46763639" target="_blank" rel="noopener">SpringBoot入门</a></li></ul><h3 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h3><ul><li><a href="https://github.com/guoxiaoxu/guo-projects/tree/master/guns-admin/note" target="_blank" rel="noopener">一系列专栏</a></li><li><a href="http://tengj.top/tags/Spring-Boot/" target="_blank" rel="noopener">个人博客专栏: SpringBoot干货系列</a></li><li><a href="http://www.ityouknow.com/spring-boot" target="_blank" rel="noopener">SpringBoot系列文章</a></li><li><a href="https://www.jianshu.com/u/092df3f77bca" target="_blank" rel="noopener">恒宇少年</a><code>大量Boot博客</code></li></ul><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><blockquote><p>使用Idea的话就可以直接创建项目 使用别的可以下载zip进行导入 | <a href="http://start.spring.io/" target="_blank" rel="noopener">官方初始项目构建 下载地址</a></p></blockquote><p><em>目录结构最好如下</em> <code>*Application类要处于所有用了Springboot注解的类的顶级目录, 这样默认才能扫描到</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── config/</span><br><span class="line">├── controller/</span><br><span class="line">├── dao/</span><br><span class="line">├── domain/</span><br><span class="line">├── GraduateApplication.java</span><br><span class="line">├── service/</span><br><span class="line">├── ServletInitializer.java</span><br><span class="line">└── util/</span><br></pre></td></tr></table></figure></p><h2 id="安装SpringBootCLI"><a href="#安装SpringBootCLI" class="headerlink" title="安装SpringBootCLI"></a>安装SpringBootCLI</h2><ul><li>使用 SDKMAN 进行安装<ul><li>使用git bash运行  <code>curl -s get.sdkman.io | bash</code></li><li><code>source &quot;/Users/{yourname}/.sdkman/bin/sdkman-init.sh&quot;</code>根据实际目录去运行</li><li>spring –version</li></ul></li><li>官方下载地址 <a href="https://repo.spring.io/release/org/springframework/boot/spring-boot-cli/" target="_blank" rel="noopener">所有版本</a></li></ul><h2 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h2><ul><li style="list-style: none"><input type="checkbox"> 了解这些测试注解 的作用和使用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖于Springboot环境的测试类的必备注解</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内存数据库测试</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.github.kuagncp"</span>) <span class="comment">// 如果有类没注入需要手动设置扫面</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br></pre></td></tr></table></figure><ul><li>可以使用MockMvc来测试Controller层的代码</li><li>可以使用MockMvc的SpringSecurity支持来测试安全模块</li><li>使用 WebIntegraionTest 测试运行中的Web容器<ul><li>启动嵌入式的Servlet容器来进行测试，下断言</li></ul></li><li>使用随机端口启动服务器 配置local.server.port=0</li><li>使用Selenium来测试HTML页面，模拟浏览器的动作，查看系统运行状态</li></ul><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote><p>配置文件(<code>application.properties或者yml</code>)加载顺序 <a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config-application-property-files" target="_blank" rel="noopener">官方文档说明</a></p><blockquote><p>1.当前Jar/War目录下的/config目录 <code>file:./config/</code><br>2.当前目录 <code>file:./</code><br>3.classpath 里的/config目录 <code>classpath:/config/</code><br>4.classpath 根目录 <code>classpath:/</code>  </p></blockquote></blockquote><blockquote><p>自定义配置文件名就要运行时加参数  </p><blockquote><p><code>java -jar myproject.jar --spring.config.name=myproject</code><br><code>java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties</code> <br></p></blockquote></blockquote><ul><li><a href="http://www.itwendao.com/article/detail/391009.html" target="_blank" rel="noopener">配置文件的使用</a></li><li><a href="https://www.tuicool.com/articles/veUjQba" target="_blank" rel="noopener">Spring boot配置文件 application.properties</a></li><li><a href="https://my.oschina.net/wangnian/blog/666641" target="_blank" rel="noopener">SpringBoot常用配置</a></li><li><a href="https://segmentfault.com/a/1190000008968295" target="_blank" rel="noopener">使用Gradle整合SpringBoot+Vue.js-开发调试与打包</a></li><li><p><a href="https://yq.aliyun.com/articles/182720" target="_blank" rel="noopener">配置文件加密</a></p></li><li><p><a href="http://www.cnblogs.com/java-zhao/p/5542154.html" target="_blank" rel="noopener">自定义配置文件</a><code>将应用配置外置并注入成bean</code></p></li><li><a href="http://www.cnblogs.com/xiaoqi/p/6955288.html" target="_blank" rel="noopener">配置文件外置</a></li></ul><h3 id="多种配置文件并切换"><a href="#多种配置文件并切换" class="headerlink" title="多种配置文件并切换"></a>多种配置文件并切换</h3><h4 id="yml方式"><a href="#yml方式" class="headerlink" title="yml方式"></a>yml方式</h4><ul><li><p>单文件<code>配置文件 application.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">     profiles:</span></span><br><span class="line"><span class="attr">       active:</span> <span class="string">development</span> <span class="comment"># 选用开发模式</span></span><br><span class="line"><span class="bullet">   -</span><span class="bullet">--</span></span><br><span class="line"><span class="attr">   spring:</span></span><br><span class="line"><span class="attr">     profiles:</span> <span class="string">development</span></span><br><span class="line">     <span class="string">//一系列配置</span></span><br><span class="line"><span class="bullet">   -</span><span class="bullet">--</span></span><br><span class="line"><span class="attr">   spring:</span></span><br><span class="line"><span class="attr">     profiles:</span> <span class="string">production</span></span><br><span class="line">     <span class="string">//一系列配置</span></span><br></pre></td></tr></table></figure></li><li><p>或者 多文件放 <code>application-{profile}.yml</code></p></li></ul><h4 id="yml和Properties结合"><a href="#yml和Properties结合" class="headerlink" title="yml和Properties结合"></a>yml和Properties结合</h4><ul><li>格式：<code>application-{profile}.properties</code></li><li>将上面的开发部分，发行部分的配置创建两个配置文件 <code>application-dev.properties</code> 和 <code>application-prod.properties</code></li><li>在主配置文件<code>application.yml</code>中指明<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev或者是prod</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="应用配置文件"><a href="#应用配置文件" class="headerlink" title="应用配置文件"></a>应用配置文件</h3><blockquote><p>依赖于 <code>org.springframework.boot:spring-boot-configuration-processor</code><br>配置对应的实体类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"graduate.main"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String delimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>应用配置类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MainConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoCustomConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>application.yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">graduate:</span></span><br><span class="line"><span class="attr">  main:</span></span><br><span class="line"><span class="attr">    delimiter:</span> <span class="string">,</span></span><br></pre></td></tr></table></figure></p><hr><h2 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h2><p>默认可以通过 application.properties 配置框架的日志,以及应用具体到包和类的日志等级,日志文件等等</p><blockquote><p><a href="https://www.cnblogs.com/lixuwu/p/5804793.html" target="_blank" rel="noopener">参考博客: Spring boot——logback 基础使用篇（一）</a></p></blockquote><blockquote><p><a href="https://springframework.guru/using-logback-spring-boot/" target="_blank" rel="noopener">参考博客: springboot use logback</a><code>能根据Profile配置,还能写if</code></p></blockquote><p>使用 logback 则需要配置 logback.xml 或者 logback-spring.xml 建议使用后者</p><hr><h2 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h2><h3 id="Lisener"><a href="#Lisener" class="headerlink" title="Lisener"></a>Lisener</h3><h4 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Servlet容器初始化"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Servlet容器销毁"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上传下载文件"><a href="#上传下载文件" class="headerlink" title="上传下载文件"></a>上传下载文件</h3><blockquote><p>第一种直接上传到应用的webroot或者resources目录下，第二种上传到数据库中，第三种使用ftp。</p></blockquote><ul><li><a href="http://www.cnblogs.com/studyCenter/p/6665171.html" target="_blank" rel="noopener">Springboot上传文件</a></li><li>上传文件有大小限制，使用如下方法进行配置 <a href="http://makaidong.com/studyDetail/11882_45833.html" target="_blank" rel="noopener">参考博客</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipartConfigElement <span class="title">multipartConfigElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MultipartConfigFactory factory = <span class="keyword">new</span> MultipartConfigFactory();</span><br><span class="line">    <span class="comment">//单个文件最大</span></span><br><span class="line">    factory.setMaxFileSize(<span class="string">"80MB"</span>); <span class="comment">//KB,MB</span></span><br><span class="line">    <span class="comment">// 设置总上传数据总大小</span></span><br><span class="line">    factory.setMaxRequestSize(<span class="string">"102400KB"</span>);</span><br><span class="line">    <span class="keyword">return</span> factory.createMultipartConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="错误页面跳转配置"><a href="#错误页面跳转配置" class="headerlink" title="错误页面跳转配置"></a>错误页面跳转配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">containerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (container -&gt; &#123;</span><br><span class="line">            ErrorPage error401Page = <span class="keyword">new</span> ErrorPage(HttpStatus.FORBIDDEN, <span class="string">"/403.html"</span>);</span><br><span class="line">            ErrorPage error404Page = <span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">"/404.html"</span>);</span><br><span class="line">            ErrorPage error500Page = <span class="keyword">new</span> ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, <span class="string">"/500.html"</span>);</span><br><span class="line">            container.addErrorPages(error401Page, error404Page, error500Page);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><blockquote><p>不同的域名（主机）端口都会导致跨域问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> CorsConfiguration <span class="title">buildConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>); <span class="comment">// 允许任何域名使用</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>); <span class="comment">// 允许任何头</span></span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">"*"</span>); <span class="comment">// 允许任何方法（post、get等）</span></span><br><span class="line">        <span class="keyword">return</span> corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, buildConfig()); <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><ol><li>新建类, 加上注解 ControllerAdvice</li><li>方法上使用注解 <code>ExceptionHandler(Exception.class)</code> 处理所有异常</li><li>然后返回值的写法和普通Controller一样, 返回JSON就<code>ResponseBody</code></li></ol><hr><h2 id="HTTPS的配置"><a href="#HTTPS的配置" class="headerlink" title="HTTPS的配置"></a>HTTPS的配置</h2><blockquote><p><a href="https://www.drissamri.be/blog/java/enable-https-in-spring-boot/" target="_blank" rel="noopener">参考博客</a></p></blockquote><ul><li>签发证书：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -<span class="built_in">alias</span> tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  context-path:</span> <span class="string">/myth</span></span><br><span class="line"><span class="attr">  ssl:</span></span><br><span class="line"><span class="attr">    key-store:</span> <span class="attr">classpath:keystore.p12</span></span><br><span class="line"><span class="attr">    key-store-password:</span> <span class="string">demo1429336</span></span><br><span class="line"><span class="attr">    key-store-type:</span> <span class="string">PKCS12</span></span><br><span class="line"><span class="attr">    key-alias:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">  session:</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p><code>任意的一个@Configuration注解类里添加</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="title">servletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TomcatEmbeddedServletContainerFactory factory =</span><br><span class="line">        <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//SecurityConstraint必须存在，可以通过其为不同的URL设置不同的重定向策略。</span></span><br><span class="line">                SecurityConstraint securityConstraint = <span class="keyword">new</span> SecurityConstraint();</span><br><span class="line">                securityConstraint.setUserConstraint(<span class="string">"CONFIDENTIAL"</span>);</span><br><span class="line">                SecurityCollection collection = <span class="keyword">new</span> SecurityCollection();</span><br><span class="line">                collection.addPattern(<span class="string">"/*"</span>);</span><br><span class="line">                securityConstraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(securityConstraint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    factory.addAdditionalTomcatConnectors(createHttpConnector());</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connector <span class="title">createHttpConnector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connector connector = <span class="keyword">new</span> Connector(<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>);</span><br><span class="line">    connector.setScheme(<span class="string">"http"</span>);</span><br><span class="line">    connector.setSecure(<span class="keyword">false</span>);</span><br><span class="line">    connector.setPort(<span class="number">8887</span>);<span class="comment">//http端口（这是要新增加的一个端口）</span></span><br><span class="line">    connector.setRedirectPort(<span class="number">8888</span>);<span class="comment">// https 端口配置文件中tomcat启动的默认端口</span></span><br><span class="line">    <span class="keyword">return</span> connector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>另一种方式 <a href="http://www.cnblogs.com/xinzhao/p/4950689.html" target="_blank" rel="noopener">参考博客</a><br><code>方式不一样，没有成功</code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############ 证书颁发机构</span></span><br><span class="line"><span class="comment"># CA机构私钥</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"><span class="comment"># CA证书</span></span><br><span class="line">openssl req -x509 -new -key ca.key -out ca.crt</span><br><span class="line"><span class="comment">############ 服务端</span></span><br><span class="line"><span class="comment"># 生成服务端私钥</span></span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"><span class="comment"># 生成服务端证书请求文件</span></span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line"><span class="comment"># 使用CA证书生成服务端证书  关于sha256，默认使用的是sha1，在新版本的chrome中会被认为是不安全的，因为使用了过时的加密算法。</span></span><br><span class="line">openssl x509 -req -sha256 -<span class="keyword">in</span> server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650 -out server.crt    </span><br><span class="line"><span class="comment"># 打包服务端的资料为pkcs12格式(非必要，只是换一种格式存储上一步生成的证书) 生成过程中，需要创建访问密码，请记录下来。</span></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -<span class="keyword">in</span> server.crt -inkey server.key -out server.pkcs12</span><br><span class="line"><span class="comment"># 生成服务端的keystore（.jks文件, 非必要，Java程序通常使用该格式的证书） 生成过程中，需要创建访问密码，请记录下来。</span></span><br><span class="line">keytool -importkeystore -srckeystore server.pkcs12 -destkeystore server.jks -srcstoretype pkcs12</span><br><span class="line"><span class="comment"># 把ca证书放到keystore中（非必要）</span></span><br><span class="line">keytool -importcert -keystore server.jks -file ca.crt</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li><a href="https://hacpai.com/article/1501152977477?p=1&amp;m=0" target="_blank" rel="noopener">参考博客</a></li><li>多线程以及异常处理 <a href="http://www.liuhaihua.cn/archives/496733.html" target="_blank" rel="noopener">参考博客</a><ul><li>因为多线程的特性，所以异常只能在子线程中处理不能抛出到主线程里，但是 Spring实现的线程池可以返回一个异常信息对象</li></ul></li></ul><hr><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><h3 id="生成指定文件"><a href="#生成指定文件" class="headerlink" title="生成指定文件"></a>生成指定文件</h3><h4 id="war"><a href="#war" class="headerlink" title="war"></a>war</h4><ul><li><p>部署为war必须的类，一般在创建项目时选war就会自动生成，选jar就要手动添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(DemoApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>maven： <code>mvn war</code> 即可 mvn package -DskipTests</p></li><li>gradle: <code>gradle war</code> 然后 <code>gradle bootRepackage</code> 即可</li></ul><h4 id="jar"><a href="#jar" class="headerlink" title="jar"></a>jar</h4><ul><li>没有特殊的配置，打包即用<ul><li>maven: <code>mvn package</code> 即可生成可执行的jar</li><li>gradle:<code>gradle jar</code> 然后 <code>gradle bootRepackage</code> 也生成可执行jar</li></ul></li></ul><h3 id="构建docker镜像"><a href="#构建docker镜像" class="headerlink" title="构建docker镜像"></a>构建docker镜像</h3><blockquote><p>方便监控应用状态，cpu 内存 流量, <a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">官方文档</a></p></blockquote><h4 id="手动方式"><a href="#手动方式" class="headerlink" title="手动方式"></a>手动方式</h4><ul><li>先构建得到war或jar，然后根据dockerfile构建一个镜像<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> frolvlad/alpine-oraclejdk8:slim</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> weixin-1.0.0.war app.war</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.war"</span>]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="gradle结合docker"><a href="#gradle结合docker" class="headerlink" title="gradle结合docker"></a>gradle结合docker</h4><h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><blockquote><p><a href="https://nilzzzz.github.io/2017/11/SpringBoot1/" target="_blank" rel="noopener">参考博客: SpringBoot热部署</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#springboot&quot;&gt;SpringBoot&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#思考&quot;&gt;思考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#参考教程&quot;&gt;参考教程&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringAOP.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-SpringAOP/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-SpringAOP/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#aop">AOP</a><ol><li><a href="#动态代理">动态代理</a><ol><li><a href="#asm">asm</a></li><li><a href="#cglib">cglib</a></li></ol></li><li><a href="#基本概念">基本概念</a></li><li><a href="#基本配置">基本配置</a></li><li><a href="#注意">注意</a><ol><li><a href="#1-spring-aop还是完全用aspectj">1 Spring AOP还是完全用AspectJ？</a></li><li><a href="#2-spring-aop中使用@aspectj还是xml">2 Spring AOP中使用@AspectJ还是XML？</a></li><li><a href="#3-混合切面类型">3 混合切面类型</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><blockquote><p>Aspect Oriented Programming  面向切面编程</p></blockquote><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><blockquote><p>这是AOP的起源, 最初是JDK的动态Proxy -&gt; cglib/asm </p></blockquote><blockquote><p><a href="https://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">参考博客: Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a></p></blockquote><h3 id="asm"><a href="#asm" class="headerlink" title="asm"></a>asm</h3><h3 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h3><blockquote><p>基于asm</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><table><thead><tr><th style="text-align:left">英文</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>JoinPoint</code></td><td style="text-align:left">切入面、连接点、切入点（所有方法）</td></tr><tr><td style="text-align:left"><code>PointCut</code></td><td style="text-align:left">切点（特殊的连接点，需要增强的连接点）</td></tr><tr><td style="text-align:left"><code>Advice</code></td><td style="text-align:left">增强（切入点的逻辑，待添加的功能）</td></tr><tr><td style="text-align:left"><code>Aspect</code></td><td style="text-align:left">切面（切点和增强的合集）</td></tr><tr><td style="text-align:left"><code>Target</code></td><td style="text-align:left">目标对象（被增强的实例）</td></tr><tr><td style="text-align:left"><code>Weave</code></td><td style="text-align:left">织入（增强切点的过程）</td></tr><tr><td style="text-align:left"><code>Proxy</code></td><td style="text-align:left">代理（增强后的类，一般是使用了代理类） 装饰器模式</td></tr><tr><td style="text-align:left"><code>Introduction</code></td><td style="text-align:left">引介（为类添加属性和方法） 用的较少因为破坏了OOP思想</td></tr></tbody></table><hr><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p><code>XML文件头</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>方法级别的添加代理，Servlet中的过滤器也类似（但是那个是类级别的）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基本类 提供切点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"cn.spring.aop.Student"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 增强部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"adder"</span> <span class="attr">class</span>=<span class="string">"cn.spring.aop.NewDeal"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用aop的自动提示也要配置上面的头文件声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aspect表示切面 ref 标明增强方法的类来源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myAop"</span> <span class="attr">ref</span>=<span class="string">"adder"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- execution 是表达式（正则一样的功能）匹配的是具体的切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.spring.aop.Student.run(..))"</span> <span class="attr">id</span>=<span class="string">"needAdd"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 织入 的过程 将增强和切入点结合 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"add"</span> <span class="attr">pointcut-ref</span>=<span class="string">"needAdd"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"af"</span> <span class="attr">pointcut-ref</span>=<span class="string">"needAdd"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"around"</span> <span class="attr">pointcut-ref</span>=<span class="string">"needAdd"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>要注意环绕的写法 <code>public void around(ProceedingJoinPoint m)throws Throwable{</code>  </p><ul><li><a href="https://www.oschina.net/code/snippet_246557_9205" target="_blank" rel="noopener">Spring AOP中的around</a>  </li></ul></li><li><p>然后在test类中直接getBean（基类）但是实际上是获取到的是装饰好的代理对象  </p><ul><li><a href="http://blog.csdn.net/yuqinying112/article/details/7335416" target="_blank" rel="noopener">Spring AOP配置(转)</a>  </li><li><a href="http://www.cnblogs.com/yangy608/archive/2010/11/14/1876833.html" target="_blank" rel="noopener">aop:config详解</a>  </li></ul></li><li><p>善用debug 调试看是否获取到的是代理对象 $proxy</p></li><li><p>在Spring的配置文件中，所有的切面和通知器都必须定义在<code>&lt;aop:config&gt;</code> 元素内部。 一个<code>application context</code>可以包含多个 <code>&lt;aop:config&gt;</code>。 一个<code>&lt;aop:config&gt;</code> 可以包含 <code>pointcut</code>， <code>advisor</code> 和 <code>aspect</code> 元素（注意它们必须按照这样的顺序进行声明）。 </p></li></ul><h3 id="1-Spring-AOP还是完全用AspectJ？"><a href="#1-Spring-AOP还是完全用AspectJ？" class="headerlink" title="1 Spring AOP还是完全用AspectJ？"></a>1 Spring AOP还是完全用AspectJ？</h3><p>做能起作用的最简单的事。Spring AOP比完全使用AspectJ更加简单，因为它不需要引入AspectJ的编译器／织入器到你开发和构建过程中。<br>如果你仅仅需要在Spring bean上通知执行操作，那么Spring AOP是合适的选择。如果你需要通知domain对象或其它没有在Spring容器中<br>管理的任意对象，那么你需要使用AspectJ。如果你想通知除了简单的方法执行之外的连接点（如：调用连接点、字段get或set的连接点等等），<br>也需要使用AspectJ。<br>当使用AspectJ时，你可以选择使用AspectJ语言（也称为“代码风格”）或@AspectJ注解风格。<br>如果切面在你的设计中扮演一个很大的角色，并且你能在Eclipse中使用AspectJ Development Tools (AJDT)， 那么首选AspectJ语言 :-<br>因为该语言专门被设计用来编写切面，所以会更清晰、更简单。如果你没有使用<br>Eclipse，或者在你的应用中只有很少的切面并没有作为一个主要的角色，你或许应该考虑使用@AspectJ风格<br>并在你的IDE中附加一个普通的Java编辑器，并且在你的构建脚本中增加切面织入（链接）的段落。</p><h3 id="2-Spring-AOP中使用-AspectJ还是XML？"><a href="#2-Spring-AOP中使用-AspectJ还是XML？" class="headerlink" title="2 Spring AOP中使用@AspectJ还是XML？"></a>2 Spring AOP中使用@AspectJ还是XML？</h3><p>如果你选择使用Spring AOP，那么你可以选择@AspectJ或者XML风格。总的来说，如果你使用Java 5， 我们建议使用@AspectJ风格。<br>显然如果你不是运行在Java 5上，XML风格是最佳选择。XML和@AspectJ 之间权衡的细节将在下面进行讨论。<br>XML风格对现有的Spring用户来说更加习惯。它可以使用在任何Java级别中（参考连接点表达式内部的命名连接点，虽然它也需要Java 5）<br>并且通过纯粹的POJO来支持。当使用AOP作为工具来配置企业服务时（一个好的例子是当你认为连接点表达式是你的配置中的一部分时，<br>你可能想单独更改它）XML会是一个很好的选择。对于XML风格，从你的配置中可以清晰的表明在系统中存在那些切面。<br>XML风格有两个缺点。第一是它不能完全将需求实现的地方封装到一个位置。DRY原则中说系统中的每一项知识都必须具有单一、无歧义、权威的表示。<br>当使用XML风格时，如何实现一个需求的知识被分割到支撑类的声明中以及XML配置文件中。当使用@AspectJ风格时就只有一个单独的模块 -切面-<br>信息被封装了起来。 第二是XML风格同@AspectJ风格所能表达的内容相比有更多的限制：仅仅支持”singleton”切面实例模型，并且不能在XML中组合命名连接点的声<br>明。 例如，在@AspectJ风格中我们可以编写如下的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(execution(* get*())) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">propertyAccess</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line"><span class="meta">@Pointcut</span>(execution(org.xyz.Account+ *(..)) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationReturningAnAccount</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line"><span class="meta">@Pointcut</span>(propertyAccess() &amp;&amp; operationReturningAnAccount()) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountPropertyAccess</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在XML风格中能声明开头的两个连接点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"propertyAccess"</span> <span class="attr">expression</span>=<span class="string">"execution(* get*())"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"operationReturningAnAccount"</span>  <span class="attr">expression</span>=<span class="string">"execution(org.xyz.Account+ *(..))"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>但是不能通过组合这些来定义accountPropertyAccess连接点</p><ul><li>@AspectJ风格支持其它的实例模型以及更丰富的连接点组合。它具有将将切面保持为一个模块单元的优点。 还有一个优点就是@AspectJ切面能被Spring AOP和AspectJ两者都理解 </li><li>所以如果稍后你认为你需要AspectJ 的能力去实现附加的需求，那么你非常容易转移到基于AspectJ的途径。总而言之，我们更喜欢@AspectJ风格只要你有切面 去做超出简单的“配置”企业服务之外的事情。</li></ul><h3 id="3-混合切面类型"><a href="#3-混合切面类型" class="headerlink" title="3 混合切面类型"></a>3 混合切面类型</h3><p>我们完全可以混合使用以下几种风格的切面定义：使用自动代理的@AspectJ 风格的切面，<code>schema-defined &lt;aop:aspect&gt;</code> 的切面，<br>和用 <code>&lt;aop:advisor&gt;</code> 声明的advisor，甚至是使用Spring 1.2风格的代理和拦截器。<br>由于以上几种风格的切面定义的都使用了相同的底层机制，因此可以很好的共存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#aop&quot;&gt;AOP&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#动态代理&quot;&gt;动态代理&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#asm&quot;&gt;asm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-Spring/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-Spring-Spring/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#spring">Spring</a><ol><li><a href="#配置使用">配置使用</a><ol><li><a href="#通过构建工具">通过构建工具</a></li><li><a href="#注解方式">注解方式</a><ol><li><a href="#xml文件配置">xml文件配置</a></li><li><a href="#常用的注解">常用的注解</a></li></ol></li><li><a href="#xml方式">xml方式</a><ol><li><a href="#xml方式和注解方式的比较">xml方式和注解方式的比较</a></li></ol></li></ol></li><li><a href="#spring技巧">Spring技巧</a><ol><li><a href="#获取context上下文环境">获取Context上下文环境</a><ol><li><a href="#在jsp或servlet中获取">在JSP或Servlet中获取</a></li></ol></li><li><a href="#spring-和-servletcontextlist">Spring 和 ServletContextList</a></li></ol></li></ol></li><li><a href="#基础">基础</a><ol><li><a href="#生命周期">生命周期</a></li><li><a href="#iocdi-控制反转">IOC/DI 控制反转</a></li><li><a href="#scheduling">Scheduling</a></li><li><a href="#websocket">Websocket</a><ol><li><a href="#maven配置">maven配置</a></li></ol></li><li><a href="#web开发上的一些优秀的习惯">Web开发上的一些优秀的习惯</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><blockquote><p><a href="https://spring.io/" target="_blank" rel="noopener">Spring官网</a> | <a href="http://www.spring4all.com/" target="_blank" rel="noopener">spring4all社区</a></p></blockquote><blockquote><p><a href="http://www.spring4all.com/article/558" target="_blank" rel="noopener">Spring For All 社区 -&gt;  Spring 官方教程翻译</a></p></blockquote><blockquote><p><a href="https://www.tutorialspoint.com/spring/index.htm" target="_blank" rel="noopener">Spring Tutorial</a></p></blockquote><h2 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h2><blockquote><p><strong>通过原始的复制jar方式 :</strong> 官网下载对应的jar, 添加到ide中</p></blockquote><h3 id="通过构建工具"><a href="#通过构建工具" class="headerlink" title="通过构建工具"></a>通过构建工具</h3><p>Maven 中 pom.xml 中, Gradle是 build.gradle 添加以下等依赖:</p><p><em>核心依赖</em></p><ol><li>spring-core</li><li>spring-beans</li><li>spring-context</li></ol><p><em>其他,可选</em></p><ol><li>spring-aop</li><li>spring-websocket</li><li>spring-jdbc </li><li>spring-tx </li><li>spring-web</li><li>spring-webmvc</li><li>spring-test</li></ol><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><blockquote><p>需要在配置文件 xml配置文件 中配置包扫描 才能生效</p></blockquote><h4 id="xml文件配置"><a href="#xml文件配置" class="headerlink" title="xml文件配置"></a>xml文件配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 头部分要添加Context --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对使用了注解的包进行扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.github.kuangcp"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> 只需要这个配置文件就可以使用注解来使用Spring框架</p></blockquote><h4 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h4><ul><li><p>标注为bean</p><ul><li><code>@Component([value=]&quot;id&quot;)</code>不写则默认是当前类名</li><li>@Entity</li><li>@Service</li><li>@Repository</li><li>@Controller 和 @RestController</li></ul></li><li><p>自动注入</p><ul><li><code>@Resource([value=]&quot;id&quot;)</code> 按名字注入</li><li><code>@Autowried</code> 根据类型自动注入（只对单例起作用）和 <code>Resource(类名首字母小写)</code> 等价</li><li><code>@Qualifier(&quot;id&quot;)</code>自动注入后的进一步精确（多个的情况：）</li></ul></li><li><p><strong>注意 :</strong> 关于自动注入, 在属性上打 @Autowried 注解是不建议的, 作者建议采用构造器方式:  <a href="http://olivergierke.de/2013/11/why-field-injection-is-evil/" target="_blank" rel="noopener">Why field injection is evil</a></p></li><li><p>AOP</p><ul><li>@Aspect 注明是切面类</li><li>@Before(“execution(public void com.wjt276.dao.impl.UserDaoImpl.save(com.wjt276.model.User))”) 和xml方式的before对应</li></ul></li><li><p>bean扫描</p><ul><li>ComponentScan 扫描指定包下Spring注解的类</li></ul></li></ul><blockquote><p><a href="http://olivergierke.de/2013/11/why-field-injection-is-evil/" target="_blank" rel="noopener">参考博客: Why field injection is evil</a></p></blockquote><hr><h3 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h3><ul><li>只用到bean的头，主要配置内容：<code>&lt;bean&gt;&lt;property&gt;&lt;/property&gt;&lt;/bean&gt;</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- 对使用了注解的包进行扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.spring.aop"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 一般而言，bean都是单实例的 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"cn.spring.entity.Person"</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"myth"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"addr"</span> <span class="attr">value</span>=<span class="string">"vol"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"construct"</span> <span class="attr">class</span>=<span class="string">"cn.spring.entity.ConstructorEntity"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 如果是不同的类型的参数 顺序可以随意，但是数据类型一样的话就要严格按顺序了--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"String_1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 注意引用类型是要写全路径，基本数据类型是可以直接写小写 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;constructor-arg type="java.lang.String" value="String_2"&gt;&lt;/constructor-arg&gt; --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"TestConstruct"</span> <span class="attr">class</span>=<span class="string">"cn.spring.entity.TestConstruct"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"entity"</span> <span class="attr">ref</span>=<span class="string">"construct"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 加载属性文件 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"property_config"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>cn/spring/entity/db.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 测试获取属性文件 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"show_db"</span> <span class="attr">class</span>=<span class="string">"cn.spring.entity.TestProperties"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 特别注意大小写问题 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="xml方式和注解方式的比较"><a href="#xml方式和注解方式的比较" class="headerlink" title="xml方式和注解方式的比较"></a>xml方式和注解方式的比较</h4><ul><li>当你确定切面是实现一个给定需求的最佳方法时，你如何选择是使用Spring AOP还是AspectJ，以及选择 Aspect语言（代码）风格、@AspectJ声明风格或XML风格？</li><li>这个决定会受到多个因素的影响，包括应用的需求、 开发工具和小组对AOP的精通程度。</li><li><strong>个人理解</strong>：使用bean的时候使用注解，AOP使用xml方式，更直观</li></ul><hr><h2 id="Spring技巧"><a href="#Spring技巧" class="headerlink" title="Spring技巧"></a>Spring技巧</h2><h3 id="获取Context上下文环境"><a href="#获取Context上下文环境" class="headerlink" title="获取Context上下文环境"></a>获取Context上下文环境</h3><h4 id="在JSP或Servlet中获取"><a href="#在JSP或Servlet中获取" class="headerlink" title="在JSP或Servlet中获取"></a>在JSP或Servlet中获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(config.getServletContext());</span><br></pre></td></tr></table></figure><h3 id="Spring-和-ServletContextList"><a href="#Spring-和-ServletContextList" class="headerlink" title="Spring 和 ServletContextList"></a>Spring 和 ServletContextList</h3><ul><li>想要启动Tomcat之后，初始化运行一些方法，把数据从数据库拿出放入redis中，然后使用了ServletContextListener<ul><li>然后还是按照往常一样的使用Spring自动注入的便利，来使用service层获取数据，但是忽略了启动顺序</li><li><strong>context-param -&gt; listener -&gt; filter -&gt; servlet</strong></li><li>所以在启动这个初始化方法的时候，其实Spring的环境是还没有加载的，所以没有扫描，也就没有了自动注入，也就有了空指针异常</li><li>所以要使用如下方法得到Spring的Context（上下文），获取bean，再操作</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123; </span><br><span class="line">        ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(event.getServletContext());</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"># 基础</span><br><span class="line">## 生命周期</span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"></span><br><span class="line">- [ ] 完善</span><br><span class="line"></span><br><span class="line">##  IOC/DI 控制反转</span><br><span class="line">- DI 译为依赖注入 所有的bean都在IOC容器中（单例的）多例的不在该容器中进行管理</span><br><span class="line">- 通过注入 可以注入基本属性 对象属性，集合属性，构造器，properties等</span><br><span class="line">- 不采用Spring的IOC容器使用Java基础来实现：</span><br><span class="line">   - **静态代理** </span><br><span class="line">       - 针对每个具体类分别编写代理类</span><br><span class="line">       - 针对一个接口编写一个代理类</span><br><span class="line">   - **动态代理**</span><br><span class="line">       - 针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类 </span><br><span class="line"></span><br><span class="line">属性上 <span class="meta">@Autowired</span> 即可, 但是现在不建议直接在属性上使用注解, 而是建议在构造器上, 为了避免 手动使用<span class="keyword">new</span> 实例化Bean, 然后里面本该注入的属性全部为<span class="keyword">null</span></span><br><span class="line">可以用lombok来协助</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(onConstructor = @__(<span class="meta">@Autowired</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> look up 方法注入</li></ul><hr><h2 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h2><blockquote><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#scheduling" target="_blank" rel="noopener">Official Doc</a></p></blockquote><blockquote><p><a href="https://www.baeldung.com/spring-scheduled-tasks" target="_blank" rel="noopener">参考博客: The @Scheduled Annotation in Spring</a><br><a href="http://qinghua.github.io/spring-scheduler/" target="_blank" rel="noopener">参考博客: Spring Scheduler的使用与坑</a><br><a href="https://www.cnblogs.com/jingmoxukong/p/5825806.html#%E5%AE%8C%E6%95%B4%E8%8C%83%E4%BE%8B" target="_blank" rel="noopener">参考博客: [Spring]支持注解的Spring调度器</a><br><a href="https://blog.csdn.net/yyx1025988443/article/details/78698046" target="_blank" rel="noopener">参考博客: spring scheduled的动态线程池调度和任务进度的监控</a></p></blockquote><p>其主体是 TaskExecutor 和 TaskScheduler 组成的, 也就是调度和执行</p><ul><li><a href="http://www.cronmaker.com/" target="_blank" rel="noopener">cron maker</a></li><li><a href=""></a></li></ul><hr><h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><h3 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-messaging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> Spring方式, 现在用boot用多了, 都忘了怎么配置Spring了</li></ul><hr><h2 id="Web开发上的一些优秀的习惯"><a href="#Web开发上的一些优秀的习惯" class="headerlink" title="Web开发上的一些优秀的习惯"></a>Web开发上的一些优秀的习惯</h2><ul><li>使用AOP来简化开发MVC的代码</li><li>繁杂的代码如何简化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#spring&quot;&gt;Spring&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#配置使用&quot;&gt;配置使用&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#通过构建工具&quot;&gt;通过构建工具&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ProgramThinking</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-AdvancedLearning-ProgramThinking/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-AdvancedLearning-ProgramThinking/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#开发思想">开发思想</a><ol><li><a href="#抽象">抽象</a></li><li><a href="#命令式编程和响应式编程">命令式编程和响应式编程</a><ol><li><a href="#命令式编程">命令式编程</a></li><li><a href="#响应式编程">响应式编程</a></li></ol></li><li><a href="#面向过程">面向过程</a></li><li><a href="#面向对象">面向对象</a><ol><li><a href="#oop">OOP</a></li><li><a href="#面向过程和面向对象的对比">面向过程和面向对象的对比</a></li></ol></li><li><a href="#ddd-领域驱动设计">DDD 领域驱动设计</a><ol><li><a href="#聚合">聚合</a></li><li><a href="#参考实践项目">参考实践项目</a></li></ol></li><li><a href="#数据的操作">数据的操作</a><ol><li><a href="#curd">CURD</a></li><li><a href="#cqrs">CQRS</a></li></ol></li><li><a href="#组件模型">组件模型</a><ol><li><a href="#soa">SOA</a></li><li><a href="#msa">MSA</a></li></ol></li><li><a href="#other">Other</a><ol><li><a href="#国际化的配置">国际化的配置</a></li></ol></li></ol></li><li><a href="#设计软件的方法">设计软件的方法</a><ol><li><a href="#契约式设计">契约式设计</a></li><li><a href="#精益思想">精益思想</a></li></ol></li><li><a href="#编程习惯">编程习惯</a><ol><li><a href="#晓风轻的经验">晓风轻的经验</a><ol><li><a href="#接口定义">接口定义</a></li><li><a href="#日志建议">日志建议</a></li><li><a href="#异常处理">异常处理</a></li><li><a href="#工具类规范">工具类规范</a></li></ol></li><li><a href="#代码质量分析">代码质量分析</a><ol><li><a href="#checkstyle">Checkstyle</a></li><li><a href="#findbugs">FindBugs</a></li><li><a href="#阿里巴巴的代码检查">阿里巴巴的代码检查</a></li></ol></li><li><a href="#配置文件">配置文件</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="开发思想"><a href="#开发思想" class="headerlink" title="开发思想"></a>开发思想</h1><blockquote><p>有关开发的理论性思想,编写,测试,部署等</p></blockquote><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513062&amp;idx=1&amp;sn=a3b4a2962d8e82471192d9606b0a2722&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:抽象：程序员必备的能力 </a></li></ul><blockquote><p>稍微注意一下就会发现: 抽象层次越高，接口的语意就越模糊，适用的范围就越广，到最后就会变成数学模型或者概念。<br>但是抽象成数学模型和算法通常是可遇而不可求的， 这种情况下，我们需要退而求其次，试图抽象成若干个正交的概念，来降低复杂度。<br>你在处理x轴相关的事情时，不用考虑其他的y和z 相关的东西，因为你知道他们不会受到影响， 这样问题的复杂度就从3维一下子下降到1维！更容易把握了。<br>如果你说了，我的整个系统还没法抽象成正交的概念， 那只好再退一步，在局部使用接口。<br>其实 一组定义良好的接口一定是正交的，不然的话接口之间的依赖就会让实现非常麻烦。 </p><blockquote><p>在著名的《设计模式》一书中，其实在反复强调一点: 发现变化并且封装变化，针对接口编程而不是实现编程。 很多人看书是只关注具体的模式，而忽略了模式的本质目的。  </p></blockquote></blockquote><p>抽象能力的高低，很大程度上反映了一个程序员的能力的高低</p><ul><li><a href="http://ifeve.com/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6%e4%b8%ad%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%a5%bd%e5%a4%84%e4%b8%8e%e9%97%ae%e9%a2%98-%e4%bc%aa%e5%85%b1%e4%ba%ab%e5%ae%9e%e4%be%8b%e5%88%86%e6%9e%90/" target="_blank" rel="noopener">计算机科学中抽象的好处与问题—伪共享实例分析</a><code>计算机科学中的任何问题都可以通过加上一层间接层来解决，这是很正确的，但是也正是因为一层一层的抽象和包装，导致出了问题后很难定位，你都不知道问题究竟是出现在哪一层。所以要想提高技术水平不仅要知其然（看得见最顶层的包装）也要知其所以然（看得见底层的包装），每一层如果都懂或者说了解一些，那么出了问题很大程度上都可以凭直觉定位，即使不能凭直觉也可以通过各种手段debug，只会最顶层的抽象很多时候就只能望bug兴叹了。</code></li></ul><h2 id="命令式编程和响应式编程"><a href="#命令式编程和响应式编程" class="headerlink" title="命令式编程和响应式编程"></a>命令式编程和响应式编程</h2><h3 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h3><blockquote><p>编写改变状态的一条条命令</p></blockquote><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><blockquote><p><a href="http://reactivex.io/intro.html" target="_blank" rel="noopener">ReactiveX</a></p></blockquote><p>组合异步的序列<br>设计模式是 观察者模式的扩展, 数据结构是序列串流, 避免了并发, 是非阻塞的</p><p>数据流驱动</p><p>异步</p><ul><li>非阻塞<ul><li>不是 (同步非阻塞 : 当时不阻塞后续回调) 而是异步</li></ul></li></ul><p>多路复用</p><hr><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><blockquote><p>只有数据和函数, 使用函数改变数据状态</p></blockquote><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote><p>OO  Object Oriented</p></blockquote><blockquote><p><a href="http://www.jdon.com/48231" target="_blank" rel="noopener">参考博客: 再见面向对象编程？</a></p></blockquote><blockquote><p>思考:</p><ul><li>遇到需求时, 先分析需要哪些独立的实体, 然后分析用户的行为, 行为就是API</li><li>实体的基本属性和行为确定好, 并且确定好各自的生命周期(一般是属性, 状态的变化)</li><li>并且要注意设计时要尽量解耦, 即使需求上是和时间, 天气, 等一些外部状态影响的, 但是也应该在此之上抽象, 解耦, 方便测试和开发<blockquote><ul><li>例如 <code>活动</code> 具有 开始时间和结束时间 的需求, 如果只用时间去设计行为的话, 测试的时候就需要去模拟那些时间, 如果引入<code>状态</code>这个属性(开启,关闭)</li><li>就可以方便的调试了, 只需更改这个状态即可控制 活动 这个对象的行为, 当然, 变化的时间也是通过控制 <code>状态</code> 来控制 活动 的</li></ul></blockquote></li></ul></blockquote><p><code>编写出完成需求的代码不难, 难的是写出, 优雅, 简洁, 设计良好, 可读性, 扩展性高的代码</code></p><h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener">维基 OOP</a> | <a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">中文版</a></p></blockquote><h3 id="面向过程和面向对象的对比"><a href="#面向过程和面向对象的对比" class="headerlink" title="面向过程和面向对象的对比"></a>面向过程和面向对象的对比</h3><blockquote><p>示例 把大象塞进冰箱:</p><blockquote><p>面向过程, 冰箱开门() 冰箱装进( 大象) 冰箱关门()<br>面向对象 冰箱.开门().装入(大象).关门()</p></blockquote></blockquote><ul><li>面向过程<ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展</li></ul></li><li>面向对象    <ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul></li></ul><hr><h2 id="DDD-领域驱动设计"><a href="#DDD-领域驱动设计" class="headerlink" title="DDD 领域驱动设计"></a>DDD 领域驱动设计</h2><blockquote><p><a href="http://www.jdon.com/ddd.html" target="_blank" rel="noopener">领域驱动设计(DDD:Domain-Driven Design)</a><code>入门贴</code></p></blockquote><blockquote><p><a href="http://ishare.iask.sina.com.cn/f/69200951.html" target="_blank" rel="noopener">领域驱动设计 软件核心复杂性应对之道 Eric J. Evans 在线阅读</a><br><a href="http://www.infoq.com/cn/minibooks/domain-driven-design-quickly" target="_blank" rel="noopener">领域驱动设计精简版 </a></p></blockquote><blockquote><p><a href="http://kb.cnblogs.com/page/117717/" target="_blank" rel="noopener">参考博客</a> | <a href="http://www.cnblogs.com/netfocus/p/3307971.html" target="_blank" rel="noopener">讨论</a> | <a href="http://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html" target="_blank" rel="noopener">基础</a></p></blockquote><blockquote><p><a href="http://www.cnblogs.com/netfocus/archive/2012/09/08/2676985.html" target="_blank" rel="noopener">参考博客: 危险的DDD聚合根</a> 初步感受是DDD禁不起变化, 必须要在起初就设计好一个完备的体系<br><a href="http://www.jdon.com/47313" target="_blank" rel="noopener">参考博客: DDD应用的思考</a><code>提出了关于领域设计的困惑</code></p></blockquote><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合根的修改行为应该属于聚合根实体对象自己，用聚合根行为守护其内部状态的一致性是DDD设计核心，如果聚合根内部的状态直接暴露给外界（通过领域服务）任意修改，那么会导致状态变化混乱，难以调试和跟踪。</p><ul><li>现在书写的这个项目就和这个理念相一致, 但是总说是OOP 没有提及DDD <em>TODO</em><ul><li>整个系统中涉及到的实体对象, 需要持久化的属就独立出来作为一个PO对象, 然后Spring Data JPA 接管DAO操作</li><li>然后在对象中建立 修改PO对象行为 的方法, 而不是以往 MVC 那样的设计, 业务全在Service里面, 对实体自身属性的基本操作也在Service里面</li></ul></li></ul><h3 id="参考实践项目"><a href="#参考实践项目" class="headerlink" title="参考实践项目"></a>参考实践项目</h3><blockquote><p><a href="https://github.com/tangxuehua/enode" target="_blank" rel="noopener">enode</a><code>C#实现</code><br><a href="https://github.com/liangzeng/cqrs" target="_blank" rel="noopener">CQRS</a></p></blockquote><hr><h2 id="数据的操作"><a href="#数据的操作" class="headerlink" title="数据的操作"></a>数据的操作</h2><h3 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h3><h3 id="CQRS"><a href="#CQRS" class="headerlink" title="CQRS"></a>CQRS</h3><blockquote><p><a href="http://www.cqrs.nu/" target="_blank" rel="noopener">www.cqrs.nu</a><code>CQRS Guides</code><br><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing" target="_blank" rel="noopener">event-sourcing</a>| <a href="https://docs.microsoft.com/zh-cn/azure/architecture/patterns/event-sourcing" target="_blank" rel="noopener">中文版</a>   <code>微软关于azure的技术性文档</code>  </p></blockquote><blockquote><p><a href="https://ookami86.github.io/event-sourcing-in-practice/" target="_blank" rel="noopener">event-sourcing-in-practice</a><br><a href="https://www.cnblogs.com/netfocus/category/361988.html" target="_blank" rel="noopener">参考博客:  CQRS &amp; Event Sourcing </a><br><a href="https://www.jianshu.com/p/9a3f8d514fcd" target="_blank" rel="noopener">参考博客: 领域驱动设计的实践 – CQRS &amp; Event Sourcing</a> <code>图文并茂的讲解CQRS思想</code></p></blockquote><blockquote><p><a href="https://github.com/kloiasoft/eventapis" target="_blank" rel="noopener">eventapis</a><code>Java实现的CQRS</code><br><a href="http://cqrsjourney.github.io/" target="_blank" rel="noopener">CQRS journey</a> <code>微软团队的项目</code></p></blockquote><hr><h2 id="组件模型"><a href="#组件模型" class="headerlink" title="组件模型"></a>组件模型</h2><h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><blockquote><p><a href="http://www.jdon.com/soa.html" target="_blank" rel="noopener">参考博客: SOA面向服务架构</a></p></blockquote><p><em><a href="http://www.jdon.com/45857" target="_blank" rel="noopener">Spring Web 应用的最大败笔</a></em></p><ul><li>传统意义上的SOA 内部封装的是数据表的DTO 也被称为 失血模型,贫血模型,  从而导致SOA服务内部腐烂堵塞，违背SOA自治和可用性等原则约束<ul><li>我现在使用Java的SpringMVC进行开发的东西, MVC架构, 然后JavaBean, Dao层或者JPA的Repository, Service层, Controller层, 而且还使用了好几年了</li></ul><ol><li>Web层负责处理用户输入，并返回正确的响应返回给用户。 web层与服务层通信。</li><li>服务层作为一个事务边界。它也负责授权和包含我们的应用程序的业务逻辑。服务层管理的域模型对象，并与其他服务和存储库层进行通信。</li><li>存储库/数据访问层负责与所使用的数据的存储进行通信。</li></ol><ul><li>正如这个毕业设计的项目  <a href="https://github.com/Kuangcp/Graduate" target="_blank" rel="noopener">Graduate</a>, 显然的都具有如上提到的各种缺陷, </li><li>每一个 DTO 只具有属性, 而没有方法, 一个DTO就要对应一个服务, 服务之间再相互注入, 就会有很有依赖, 甚至循环依赖</li></ul></li></ul><h3 id="MSA"><a href="#MSA" class="headerlink" title="MSA"></a>MSA</h3><blockquote><p>微服务</p></blockquote><blockquote><p>　<a href="https://blog.csdn.net/ztguang/article/details/52894794" target="_blank" rel="noopener">参考博客: SOA 与 MSA（微服务架构）</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513674&amp;idx=1&amp;sn=fbc727b7c8ff6d03f5d53478b6d4e585&amp;chksm=80d67a89b7a1f39ff0c3589a4a4076e323fab18379fc8d085c133b88e4db104f87988b29d246&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:从SOA到微服务</a></p></blockquote><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513873&amp;idx=1&amp;sn=2383f099fb353e59649167e723575158&amp;chksm=80d67bd2b7a1f2c4ae61704b8a2bd330764d20f0e2fafa6fdff55c99ea68272b3cff851684cc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:我是一个函数</a> <code>详解了RPC, 也就是RMI(远程过程调用)规范的实现</code></li></ul><blockquote><p><a href="http://www.spring4all.com/article/609" target="_blank" rel="noopener">微服务 MSA</a></p></blockquote><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="国际化的配置"><a href="#国际化的配置" class="headerlink" title="国际化的配置"></a>国际化的配置</h3><ul><li>将配置文件按语言分别配置</li><li>然后在加载时设定语言的配置, 然后加载对应文件夹下的配置文件</li></ul><hr><h1 id="设计软件的方法"><a href="#设计软件的方法" class="headerlink" title="设计软件的方法"></a>设计软件的方法</h1><h2 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h2><blockquote><p>Design by Contract  (Dbc)</p></blockquote><blockquote><p><a href="https://baike.baidu.com/item/%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">百度百科解释 </a></p></blockquote><h2 id="精益思想"><a href="#精益思想" class="headerlink" title="精益思想"></a>精益思想</h2><blockquote><p>持续集成、持续交付、持续部署</p></blockquote><hr><h1 id="编程习惯"><a href="#编程习惯" class="headerlink" title="编程习惯"></a>编程习惯</h1><h2 id="晓风轻的经验"><a href="#晓风轻的经验" class="headerlink" title="晓风轻的经验"></a>晓风轻的经验</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/28705206" target="_blank" rel="noopener">知乎专栏-程序员你为什么这么累？</a> | <a href="https://github.com/xwjie/PLMCodeTemplate" target="_blank" rel="noopener">该专栏对应的源码</a> | <a href="https://xwjie.github.io/rule/" target="_blank" rel="noopener">个人站点版, 更为方便</a></p><ol><li><a href="https://zhuanlan.zhihu.com/p/28708259" target="_blank" rel="noopener">接口定义</a></li><li><a href="https://zhuanlan.zhihu.com/p/28717374" target="_blank" rel="noopener">Controller规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/28629319" target="_blank" rel="noopener">日志建议</a></li><li><a href="https://zhuanlan.zhihu.com/p/29005176" target="_blank" rel="noopener">异常处理规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/29129469" target="_blank" rel="noopener">参数校验和国际化规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/29199049" target="_blank" rel="noopener">工具类规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/29390147" target="_blank" rel="noopener">函数编写建议</a></li><li><a href="https://zhuanlan.zhihu.com/p/29191233" target="_blank" rel="noopener">配置文件的定义</a></li></ol></li><li><p>[ ] 详细的阅读</p></li></ul><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><ul><li>先有统一的接口定义规范，然后有AOP实现。先有思想再有技术。</li><li>现在知道为什么要返回统一的一个ResultBean了：<ul><li>为了统一格式</li><li>为了应用AOP</li><li>为了包装异常信息</li></ul></li></ul><h3 id="日志建议"><a href="#日志建议" class="headerlink" title="日志建议"></a>日志建议</h3><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li>所以，我对开发人员的要求就是，绝大部分场景，不允许捕获异常，不要乱加空判断。只有明显不需要关心的异常，如关闭资源的时候的io异常，可以捕获然后什么都不干，其他时候，不允许捕获异常，都抛出去，到controller处理。空判断大部分时候不需要，你如果写了空判断，你就必须测试为空和不为空二种场景，要么就不要写空判断。</li><li>强调，有些空判断是要的，如：参数是用户输入的情况下。但是，大部分场景是不需要的（我们的IT系统里面，一半以上不需要），如参数是其它系统传过来，或者其他地方获取的传过来的，99.99%都不会为空，你判断来干嘛？就抛一个空指针到前台怎么啦？何况基本上不会出现。</li><li>总结：<ul><li>开发组长定义好异常，异常继承RuntimeException。</li><li>不允许开发人员捕获异常。（异常上对开发人员就这点要求！异常都抛出到controller上用AOP处理）</li><li>后台（如队列等）异常一定要有通知机制，要第一时间知道异常。</li><li>少加空判断，加了空判断就要测试为空的场景！</li></ul></li></ul><h3 id="工具类规范"><a href="#工具类规范" class="headerlink" title="工具类规范"></a>工具类规范</h3><ol><li>方法参数要抽象(尽量往上找到父类和接口), 返回值要具体</li><li>隐藏实现: 不要在业务代码中直接调用三方工具, 应该自己写一个类, 然后调用三方库的方法, 方便以后修改</li><li>多使用重载编写功能齐全的对外接口和方法</li><li>单独存放, 单独维护, </li></ol><hr><blockquote><p>优先使用组合而不是继承, 继承破坏了封装性, 因为父类的很多细节对子类是可见的, 父类的变化可能极大的影响子类<br>面向接口编程, 而不是实现编程 </p></blockquote><h2 id="代码质量分析"><a href="#代码质量分析" class="headerlink" title="代码质量分析"></a>代码质量分析</h2><ul><li>测试对代码的覆盖率</li><li>代码的格式是否清晰，有助于差异比较和可读性</li><li>是否很可能会出现NPE</li><li>是否忘记了域对象中的equals和hashCode方法</li></ul><h3 id="Checkstyle"><a href="#Checkstyle" class="headerlink" title="Checkstyle"></a>Checkstyle</h3><h3 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h3><h3 id="阿里巴巴的代码检查"><a href="#阿里巴巴的代码检查" class="headerlink" title="阿里巴巴的代码检查"></a>阿里巴巴的代码检查</h3><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>千万业务代码里面不要和读取配置的代码耦合在一起。切记！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#开发思想&quot;&gt;开发思想&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#抽象&quot;&gt;抽象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#命令式编程和响应式编程&quot;&gt;命令式编程和响应式编程&lt;
      
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.kuangcp.top/categories/Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>MultipleLanguage</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-AdvancedLearning-MultipleLanguage/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-AdvancedLearning-MultipleLanguage/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#jvm上的多语言使用">JVM上的多语言使用</a><ol><li><a href="#语言生态学">语言生态学</a><ol><li><a href="#重新实现的语言和原生语言">重新实现的语言和原生语言</a></li></ol></li><li><a href="#jvm上的多语言编程">JVM上的多语言编程</a><ol><li><a href="#groovy">Groovy</a></li><li><a href="#scala">Scala</a></li><li><a href="#clojure">Clojure</a></li><li><a href="#为什么非要用java语言">为什么非要用Java语言</a></li><li><a href="#jvm对备选语言的支持">JVM对备选语言的支持</a></li><li><a href="#编译器小说">编译器小说</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="JVM上的多语言使用"><a href="#JVM上的多语言使用" class="headerlink" title="JVM上的多语言使用"></a>JVM上的多语言使用</h1><h2 id="语言生态学"><a href="#语言生态学" class="headerlink" title="语言生态学"></a>语言生态学</h2><ul><li>大致讨论 解释型和编译型， 动态和静态， 命令式和函数式</li><li>Java是运行时编译，静态类型的命令式语言。强调安全性，代码清晰，性能，并表现出一定程度的繁琐和死板（例如部署）</li></ul><p><strong><code>解释型和编译型</code></strong></p><ul><li>在80 90 年代，边界较为清晰，类C语言是编译型，Perl和Python是解释型。但Java是两者都有</li><li>基于JVM来划分的边界是：该语言是否将源码编译为类文件并且执行，不产生类文件的语言会由解释器逐行执行。有些语言既有编译器又有解释器，有些是既有解释器又有产生字节码的即时编译器JIT</li></ul><p><strong><code>动态和静态类型</code></strong></p><ul><li>动态类型语言，变量在不同的时间可能会有不同的类型 动态类型语言是跟踪变量的值的类型信息，静态类型语言是跟踪变量的类型信息</li><li>静态类型适合做编译型语言</li></ul><p><strong><code>命令式和函数式</code></strong></p><ul><li>Java是典型的命令式语言，命令式语言把程序的运行状态建模为可修改的数据，用一系列的指令来改变状态。因此在命令式语言中，程序状态是核心概念</li><li>命令式语言主要分为两类，一种是面向过程语言，一种是面向对象语言<ul><li>面向过程：Basic Fortran 这种语言将代码和数据完全分离开，有简单的代码操作数据范式</li><li>面向对象：数据和代码（方法形式）封装在对象中，面向对象语言中或多或少会存在元数据（比如：类信息）引入的额外结构</li></ul></li><li>函数式语言他把计算本身当成最重要的概念。函数式语言和过程式语言一样对值进行操作，但他不会修改输入，而是像数学函数一样返回新值<ul><li>函数被看成是一个小处理机，输入值并输出值，他们没有自己的状态，并且将他们和任何外部状态绑定在一起也没有意义<blockquote><p>Groovy带一点函数式风格，Scala对FP的利用更为充分，Clojure是纯粹的函数式语言，没有丁点儿面向对象特性</p></blockquote></li></ul></li></ul><h3 id="重新实现的语言和原生语言"><a href="#重新实现的语言和原生语言" class="headerlink" title="重新实现的语言和原生语言"></a>重新实现的语言和原生语言</h3><blockquote><p>一般来说，以JVM为目标的语言较重新实现的语言能将自己的类型系统和JVM的类型系统结合的更紧密</p></blockquote><ul><li>重新实现已有语言的JVM语言：<ul><li>JRuby：Ruby是一个动态类型的面向对象语言，有些函数式特性，在JVM上基本算解释型的</li><li>Jython：动态的面向对象语言。运行方式是先生成Python字节码再转化成JVM字节码。这使得他能以看起来像是Python的典型解释型模式下运行</li><li>Rhino：他在JVM上提供了一个JavaScript实现，既支持编译模式，也支持解释模式</li></ul></li></ul><h2 id="JVM上的多语言编程"><a href="#JVM上的多语言编程" class="headerlink" title="JVM上的多语言编程"></a>JVM上的多语言编程</h2><ul><li><p>非Java技术的作用可以分为三个层次 特定领域层，动态层，稳定层，多语言编程金字塔：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p178.jpg" alt="p178金字塔" title="">                </div>                <div class="image-caption">p178金字塔</div>            </figure></li><li><p>静态类型语言更倾向于稳定层的任务，能力不是那么强，通用性较低的技术在金字塔的顶部更好用</p></li></ul><blockquote><p><a href="https://www.zhihu.com/question/21740715" target="_blank" rel="noopener">Java 、Groovy、 Scala 的未来会怎样？</a><br><a href="https://www.jianshu.com/p/3d01a98da9f9" target="_blank" rel="noopener">Java &amp; Groovy &amp; Scala &amp; Kotlin - 16.方法，Lambda 与闭包</a></p></blockquote><ol><li>喜欢Ruby =&gt; 用Groovy</li><li>喜欢LISP，喜欢STM功能 =&gt; 用Clojure</li><li>喜欢C++ =&gt; 用Kotlin</li></ol><p>Scala有两个流派：FP和Better Java。FP派喜欢scalaz，喜欢shapeless，喜欢type level programming。这一派特点是程序高度抽象但可读性奇差。<br>适合PL研究者验证概念，适合业余项目自嗨，也适合学习PL概念。不适合多人协作的工程项目。Better Java派以前之所以存在，单纯是因为Java语法设计太烂，烂到无法忍受。<br>而JVM上当时也没有其它更好的选择。<br>那些告诉你“写了n年Java以后，我切换到Scala，现在每天都活在幸福中”的人，基本都是这一派。但Scala as a better Java的工程性也不好，因为特性太多太复杂，除非有高手带队，否则很难只用到它“better java”的那个子集。<br>解决一个问题的同时，往往引入更多的问题。所以会有Java8发布以后Linkedin所有新项目全部回归Java这种事情。</p><p>Groovy是动态语言，工程性比Scala还差。但是因为有Gradle这种被广泛采用的项目，所以会存活下去。但是请记住爱因斯坦曾经说过：“任何超过两百行的新项目，都不应该采用动态语言开发，无论是Ruby，Python，Perl，Groovy还是Clojure”。<br>哦，对了，也不要用Clojure。因为它是动态语言，而且是Lisp系的动态语言。“Lisp系”意味着，读书的时候可以靠它开眼界。毕业工作以后，对于这一类语言，能躲多远就躲多远。</p><p>刚刚发布的Kotlin看上去靠谱。它不讲究FP有多纯，目标就一个：“a better java”。Kotlin在“到底引入多少FP特性”上面做得恰到好处。 看到Kotlin，我马上就想起了这个演讲：“Please stop polluting our imperative languages with pure concepts”。<br>Kotlin有以下好处：</p><ol><li>强大的IDE。而且是JetBrains第一方支持，不是3年更新一次的第三方插件；</li><li>库多生态强。Kotlin的设计者非常重视和Java的互操作，所以Kotlin号称可以无缝衔接所有Java库。</li><li>宇宙第一运行时：JVM。</li><li>Android上不能用Java8的新语法，Kotlin恰逢其时的出现，抓了一波完美的timing。如果Kotlin依靠Android开发爆发，那服务器端，大数据界，也会收益，最后多面开花，势不可挡。<br>但是Kotlin刚出来，到底有没有它自称的那么好用还待观察。另外，Kotlin社区现在集中力量攻坚Android，在服务器和大数据方向没什么靠谱项目。所以还是得用Java8。<br>总之，“魔镜啊魔镜，谁是JVM上最好的语言”之最后决战，将是Java10 vs Kotlin（Java9在语法特性上已经输了）。而在这场最终决战之前，C#已经靠着CoreCLR统一世界了。</li></ol><blockquote><p>最后送上人生经验两则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match comment with</span><br><span class="line">| &quot;X怎么不能Y？人家Z就是这样做的。&quot; -&gt;  reply &quot;卡马克能用haskell移植Wolf 3D，你能？&quot;</span><br><span class="line">| _ -&gt; reply &quot;Thank you&quot;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match location with</span><br><span class="line">| Office -&gt; use whatever your boss chose</span><br><span class="line">| Home   -&gt; use F#</span><br></pre></td></tr></table></figure><h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3><blockquote><p>James Strachan 于2003年发明，可以看作动态层语言，擅长DSL构建</p></blockquote><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><blockquote><p>Martin Odersky 于2003年意外产生，一门支持函数式编程的面向对象语言<br>有一个非常好的ScalaTest测试框架，比Junit更简洁，</p></blockquote><h3 id="Clojure"><a href="#Clojure" class="headerlink" title="Clojure"></a>Clojure</h3><blockquote><p>Rich Hickey设计的属于Lisp家族的语言，动态类型的函数式语言，编译型语言但是通常以源码发布</p></blockquote><h3 id="为什么非要用Java语言"><a href="#为什么非要用Java语言" class="headerlink" title="为什么非要用Java语言"></a>为什么非要用Java语言</h3><ul><li>Java 作为一种通用，静态类型的编译型语言，实现稳定层方便，但是放到金字塔上层就成为负担<ul><li>编译耗时</li><li>静态类型不够灵活，重构时间长</li><li>部署麻烦</li><li>语法不适合生产DSL（领域专用语言 domain specific language）</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p180.jpg" alt="p180 分类" title="">                </div>                <div class="image-caption">p180 分类</div>            </figure><hr><h3 id="JVM对备选语言的支持"><a href="#JVM对备选语言的支持" class="headerlink" title="JVM对备选语言的支持"></a>JVM对备选语言的支持</h3><ul><li>一种语言要在JVM上运行的两种方式：<ul><li>一个产生类文件的编译器</li><li>一个用JVM字节码实现的解释器<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p183.jpg" alt="p183.jpg" title="">                </div>                <div class="image-caption">p183.jpg</div>            </figure></li></ul></li><li>有一种评估语言运行时环境复杂度的简单方法，看运行实现中Jar的大小，Clojure相对较轻量，JRuby就显得重</li></ul><hr><h3 id="编译器小说"><a href="#编译器小说" class="headerlink" title="编译器小说"></a>编译器小说</h3><blockquote><p>语言的某些特性是由编程环境和高层语言合成的，在底层JVM中不存在，这种特性就称为编译器小说</p></blockquote><ul><li>Java中的编译器小说还包括检查型异常和内部类（通常内部类都会转换成带有特殊合成访问方法的顶层类），如果jar -cvf看jar包，能看到很多含<code>$</code>的类，这些就是被取出转换成<code>常规类</code>的内部类<br><code>备选语言的编译器小说</code><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p184.jpg" alt="p184.jpg" title="">                </div>                <div class="image-caption">p184.jpg</div>            </figure></li><li>函数一等值：<ul><li>这个就是说可以将函数当成其他普通值一样操作，Java只能把类当做最小的代码和功能单元。解决这种差异的方法是，因为对象只是把数据和操作数据的方法绑定在一起，只要有一个没有状态只有一个方法的对象。</li><li>这似乎就是Java8的lambda表达式的存在条件，单方法的实现用操作符 <code>-&gt;</code></li></ul></li><li>多继承：<ul><li>在Java和JVM中无法实现多继承，只能使用接口，但是接口又没有任何具体的方法</li><li>在Scala中特性机制 trait 允许将方法的实现混合到类中，所以提供了不同的继承视图，这种行为必须由Scala编译器和运行时合成，在VM层面不提供这种特性</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#jvm上的多语言使用&quot;&gt;JVM上的多语言使用&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#语言生态学&quot;&gt;语言生态学&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#重新实现的语言和
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础语法</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-AdvancedLearning-GrammarAndType/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-AdvancedLearning-GrammarAndType/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#基础语法">基础语法</a><ol><li><a href="#代码风格">代码风格</a></li><li><a href="#结构">结构</a><ol><li><a href="#判断">判断</a></li><li><a href="#循环">循环</a></li></ol></li><li><a href="#用户输入输出">用户输入输出</a></li></ol></li><li><a href="#数据类型">数据类型</a><ol><li><a href="#基础数据类型">基础数据类型</a><ol><li><a href="#byte">byte</a></li><li><a href="#char">char</a></li><li><a href="#boolean">boolean</a></li><li><a href="#short">short</a></li><li><a href="#int">int</a></li><li><a href="#long">long</a></li><li><a href="#float">float</a></li><li><a href="#double">double</a></li></ol></li><li><a href="#包装类型">包装类型</a><ol><li><a href="#string">String</a><ol><li><a href="#stringbuffer和stringbuilder">StringBuffer和StringBuilder</a></li></ol></li><li><a href="#float">Float</a></li><li><a href="#double">Double</a></li><li><a href="#integer">Integer</a></li><li><a href="#long">Long</a></li><li><a href="#boolean">Boolean</a></li><li><a href="#void">Void</a></li></ol></li><li><a href="#枚举类型">枚举类型</a></li><li><a href="#自动拆装箱">自动拆装箱</a></li><li><a href="#内部类">内部类</a></li><li><a href="#类型强转">类型强转</a></li><li><a href="#时间类型">时间类型</a></li></ol></li><li><a href="#类的结构">类的结构</a><ol><li><a href="#修饰符">修饰符</a><ol><li><a href="#权限修饰符">权限修饰符</a></li><li><a href="#其他">其他</a></li></ol></li><li><a href="#成员属性">成员属性</a></li><li><a href="#方法">方法</a></li></ol></li><li><a href="#object">Object</a><ol><li><a href="#vo">VO</a></li><li><a href="#po">PO</a></li><li><a href="#to">TO</a></li><li><a href="#bo">BO</a></li><li><a href="#pojo">POJO</a></li><li><a href="#dao">DAO</a></li></ol></li><li><a href="#关键字">关键字</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><blockquote><p><a href="https://github.com/google/styleguide" target="_blank" rel="noopener">Google Style Guide</a> | <a href="/Java/AlibabaJavaStandard.md">阿里巴巴开发手册</a></p></blockquote><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><ul><li>if</li><li>switch</li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li>while<ul><li><code>while(true){}</code></li><li><code>do{}while(true);</code></li></ul></li><li>for 循环<ul><li><code>for(int a=0; i&lt;10; i++){}</code></li></ul></li><li>for each循环<ul><li><code>for(Object item:list){}</code> 其中list对象如果是通过调用一个对象的方法返回的，那么只会调用一次</li></ul></li></ul><h2 id="用户输入输出"><a href="#用户输入输出" class="headerlink" title="用户输入输出"></a>用户输入输出</h2><ul><li><code>System.out.println(&quot;&quot;)</code> 输出并在末尾追加换行<ul><li>.print() 输出, 行末不换行</li><li>.printf() 格式化输出, 和C语法类似</li></ul></li></ul><hr><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><blockquote><p><a href="https://docs.oracle.com/javase/tutorial/java/generics/types.html" target="_blank" rel="noopener">official guide</a></p></blockquote><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><blockquote><p>八种基本数据类型 byte char boolean short int long float double</p></blockquote><blockquote><p><a href="http://www.yinwang.org/blog-cn/2016/06/08/java-value-type" target="_blank" rel="noopener">参考博客: Java 有值类型吗？</a></p></blockquote><p>确实, 这样来看Java没有值类型才是更统一的, 不过有没有对程序都是一样的, 因为Java没有解引用, 基本数据类型又没有成员, 所以值还是引用, 没差</p><h3 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h3><blockquote><p>字节</p></blockquote><p>Java8以前是使用 char数组 来存放String, Java8开始就是 byte数组 了</p><h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><blockquote><p><a href="https://www.jianshu.com/p/2f663dc820d0" target="_blank" rel="noopener">参考 你真的知道Java中boolean类型占用多少个字节吗？</a></p></blockquote><h3 id="short"><a href="#short" class="headerlink" title="short"></a>short</h3><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><blockquote><p>数值范围 <code>+- 2147483647</code> = 2^31-1 也就说明了int是占四个字节 32位 一位是符号位 (操作系统的不同也会有差异)</p></blockquote><h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><blockquote><p>数值范围 <code>+- 9223372036854775807</code> = 2^63-1 也就是八个字节 64位 一位是符号位</p></blockquote><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><h3 id="double"><a href="#double" class="headerlink" title="double"></a>double</h3><hr><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><blockquote><p><code>wrapper class</code>基本类型和包装类型不能混为一谈 本质上的 class是不同的, 只不过自动拆装箱才让人感觉没差别</p></blockquote><p>Integer.TYPE == int.class<br>Byte.TYPE == byte.class<br>Boolean.TYPE == boolean.class<br>Double.TYPE == double.class<br>Void.TYPE == void.class</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote><p>该类是final修饰的, 原因:<a href="https://www.zhihu.com/question/31345592" target="_blank" rel="noopener">知乎问题</a></p></blockquote><ul><li><p>常量池的实现</p></li><li><p>常见编码转换</p><ul><li>一般Windows文件默认编码：<code>str = new String(str.getBytes(&quot;iso8859-1&quot;), &quot;gb2312&quot;);</code> </li><li>properties文件中获取中文 <code>str = new String(str.getBytes(&quot;utf-8&quot;), &quot;utf-8&quot;);</code></li></ul></li></ul><h4 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h4><blockquote><p><a href="https://blog.csdn.net/rmn190/article/details/1492013" target="_blank" rel="noopener">参考博客</a></p></blockquote><h3 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h3><h3 id="Double"><a href="#Double" class="headerlink" title="Double"></a>Double</h3><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><h3 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h3><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><ul><li>void 的包装类型, 常用于反射时对应上 返回值为void的方法(总得有个类型 Void.TYPE) 该类型在 jdk1.1就有了, 1.5出了泛型后, 又多了一个用途(因为泛型不支持原始类型)</li></ul><blockquote><p>The Void class is an uninstantiable placeholder class to hold a reference to the Class object representing the Java keyword void.</p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/2352447/what-is-the-need-of-void-class-in-java" target="_blank" rel="noopener">参考博客: What is the need of Void class in Java</a></p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/643906/uses-for-the-java-void-reference-type" target="_blank" rel="noopener">参考博客: Uses for the Java Void Reference Type?</a></p></blockquote><ol><li>在AOP中, 增强根据切点的返回值类型, 做出不同的逻辑, 有可能用到Void</li><li>Void 强调 the nothing, null 强调 nothing</li><li>Void 作为方法的返回值时,只能返回 null </li></ol><ul><li>案例:  <ul><li>Future<void></void></li><li>ResponseEntity<void> </void></li><li>A <code>Consumer&lt;T&gt;</code> can be viewed as a <code>Function&lt;T, Void&gt;</code>.</li><li>A <code>Supplier&lt;T&gt;</code> can be viewed as a <code>Function&lt;Void, T&gt;</code></li></ul></li></ul><blockquote><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="noopener">official api</a></p></blockquote><blockquote><p>When you use the visitor pattern it can be cleaner to use Void instead of Object when you want to be sure that the return value will be null. Example:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LeavesVisitor</span>&lt;<span class="title">OUT</span>&gt;</span>&#123;</span><br><span class="line">   <span class="function">OUT <span class="title">visit</span><span class="params">(Leaf1 leaf)</span></span>;</span><br><span class="line">   <span class="function">OUT <span class="title">visit</span><span class="params">(Leaf2 leaf)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>When you will implement your visitor you can explicitly set OUT to be Void so that you know your visitor will always return null, instead of using Object</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyVoidVisitor</span> <span class="keyword">implements</span> <span class="title">LeavesVisitor</span>&lt;<span class="title">Void</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">Void <span class="title">visit</span><span class="params">(Leaf1 leaf)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...do what you want on your leaf</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Void <span class="title">visit</span><span class="params">(Leaf2 leaf)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...do what you want on your leaf</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><blockquote><p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank" rel="noopener">official doc: enum</a></p></blockquote><p>枚举类的构造器必须是private 或者 package private (也就是缺省)</p><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-enum/index.html" target="_blank" rel="noopener">参考博客: Java 语言中 Enum 类型的使用介绍</a><br>从上面的定义形式来看，似乎 Java 中的枚举类型很简单，但实际上 Java 语言规范赋予枚举类型的功能非常的强大，它不仅是简单地将整形数值转换成对象，而是将枚举类型定义转变成一个完整功能的类定义。</p></blockquote><ul><li><p>简单定义</p><ul><li><code>public enum Color {RED, GREEN, GRAY, BLUE, YELLOW, WHITE, PURPLE, BLACK}</code></li></ul></li><li><p>简单单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Tool&#123;</span><br><span class="line">    INSTANCE(<span class="number">12</span>); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num; </span><br><span class="line">    Tool(<span class="keyword">int</span> num)&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用的时候</span></span><br><span class="line">Tool.INSTANCE.getNum();</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><blockquote><p>基本数据类型和包装类型在Java中是可以视为等价的, 就是因为自动拆装箱的存在</p></blockquote><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><blockquote><p>其域可以和其他常见类型一样, 作为类的成员, 也可作为方法的局部变量, 其中包含的各种变量的域都是按原规则生效的</p></blockquote><p><em>但是内部类的属性不能用static修饰</em><br>归根结底，还是类与对象的区别，静态属性不依赖于对象，因为它保存在jvm的静态区，所以访问修改的时候不需要依赖当前有没有存活的对象，在虚拟机加载的时候也是优先于实例生成的。<br>而实例对象则是保存在jvm的堆内存中，想要访问内部类，必须先实例化外部类，然后通过外部类才能访问内部类。内部类其实也可以认为是外部类的一个成员变量，只要是成员变量，<br>各个对象都是不依赖的，静态属性的出现破坏了这一逻辑，所以java语言在语义层面不允许我们那么做，这其实不是技术问题，是一个语言的逻辑和语义问题。</p><blockquote><p><a href="https://my.oschina.net/u/1027043/blog/1823113" target="_blank" rel="noopener">参考博客: 关于Java内部类字段和方法不能使用static修饰的原因</a></p></blockquote><hr><h2 id="类型强转"><a href="#类型强转" class="headerlink" title="类型强转"></a>类型强转</h2><ul><li>Double -&gt; int 直接(int)num;</li></ul><hr><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><ol><li>最早常用是 Date 然后 Calendar 然后 Instant LocalDateTime …</li></ol><p><em>获取指定时间</em> <a href="https://blog.csdn.net/jssongwei/article/details/71403354" target="_blank" rel="noopener">获取指定时间的时间戳</a></p><hr><h1 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h1><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><blockquote><p><a href="https://blog.csdn.net/yan8024/article/details/6426451" target="_blank" rel="noopener">参考博客: java 权限修饰符</a></p></blockquote><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><ul><li><code>public</code>   <strong>任意范围</strong>;</li><li><code>protected</code>  <strong>子类</strong> 与 <strong>同包</strong>;  子类可以是任意包下</li><li><code>缺省(package private)</code> <strong>同包</strong>;  限定了同一个包下, 才能访问 所修饰的属性</li><li><code>private</code>  只能 <strong>当前类</strong> 或者 <strong>内部类</strong> 访问</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h2 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h2><p>作为Java的bean, 或者大多数情况下, 属性都是私有的, 然后提供setter getter 方法,而且 一般来说, setter和getter方法是不能包含逻辑的, 也就是简单的赋值 取值<br>乍一看相比于C语言, 似乎这是多此一举, 但是注意面向对象思想, 一个对象对外提供的应该只是行为, 具有较强的语义性, 什么对象执行了什么方法, 而直接引用就可能将对象属性和静态属性混淆</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法的签名: </p><ul><li style="list-style: none"><input type="checkbox"> 方法签名的详解</li></ul><hr><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><blockquote><p><a href="http://www.cnblogs.com/yxnchinahlj/archive/2012/02/24/2366110.html" target="_blank" rel="noopener">参考博客:  java的(PO,VO,TO,BO,DAO,POJO)解释</a><br>| <a href="https://zhuanlan.zhihu.com/p/35762537?group_id=969493512006373376" target="_blank" rel="noopener">VO DAO BO 等缩写的意义</a></p></blockquote><h2 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h2><blockquote><p>(value object) 值对象</p><ol><li>使用new关键字创建的, 由GC回收的, </li><li>VO是值对象, 业务对象, 存活在业务层的, 是业务逻辑使用的<ul><li>它存在的目的就是为数据提供一个生存的地方</li></ul></li><li>VO的属性是根据当前业务的不同而不同的<ul><li>也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。</li></ul></li></ol></blockquote><h2 id="PO"><a href="#PO" class="headerlink" title="PO"></a>PO</h2><blockquote><p>(persistant object) 持久对象</p><ol><li>PO则是向数据库中添加新数据时创建，删除数据库中数据时削除的。<ul><li>并且它只能存活在一个数据库连接中，断开连接即被销毁。</li></ul></li><li>PO是持久化对象, 是有状态的, 每个属性代表其当前状态, 他是物理数据的对象表示<ul><li>使用它能够让我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。</li></ul></li><li>PO的属性是跟数据库表的字段一一对应的。</li><li>PO对象需要实现序列化接口</li></ol></blockquote><blockquote><p>首先说PO和VO吧，它们的关系应该是相互独立的，一个VO可以只是PO的部分，也可以是多个PO构成，同样也可以等同于一个PO（当然我是指他们的属性）。<br>正因为这样，PO独立出来，数据持久层也就独立出来了，它不会受到任何业务的干涉。又正因为这样，业务逻辑层也独立开来，它不会受到数据持久层的影响，业务层关心的只是业务逻辑的处理，至于怎么存怎么读交给别人吧！<br>不过，另外一点，如果我们没有使用数据持久层，或者说没有使用hibernate，那么PO和VO也可以是同一个东西，虽然这并不好。</p></blockquote><h2 id="TO"><a href="#TO" class="headerlink" title="TO"></a>TO</h2><blockquote><p>(transfer Object) 数据传输对象</p><ul><li>在应用程序不同tie(关系)之间传输的对象</li></ul></blockquote><h2 id="BO"><a href="#BO" class="headerlink" title="BO"></a>BO</h2><blockquote><p>(business object) 业务对象</p><ul><li>从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。</li><li>它装满了业务逻辑的处理，在业务逻辑复杂的应用中有用。</li></ul></blockquote><h2 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h2><blockquote><p><a href="https://en.wikipedia.org/wiki/Plain_old_Java_object" target="_blank" rel="noopener">Wikipedia: POJO</a> <code>Plain Old Java Object</code></p></blockquote><blockquote><p>(plain ordinary java object) 简单无规则java对象</p><ul><li>纯的传统意义的java对象。就是说在一些Object/Relation Mapping工具中，能够做到维护数据库表记录的persisent object完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。我的理解就是最基本的Java Bean，只有属性字段及setter和getter方法！</li></ul></blockquote><h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><blockquote><p>(data access object) 数据访问对象</p><ul><li>通常和PO结合使用，DAO中包含了各种数据库的操作方法</li></ul></blockquote><hr><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><blockquote><p> Java关键字和保留字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract class    extends implements null      strictfp     true</span><br><span class="line">assert   const    false   import     package   super        try</span><br><span class="line">boolean  continue final   instanceof private   switch       void</span><br><span class="line">break    default  finally int        protected synchronized volatile</span><br><span class="line">byte     do       float   interface  public    this         while</span><br><span class="line">case     double   for     long       return    throw</span><br><span class="line">catch    else     goto    native     short     throws</span><br><span class="line">char     enum     if      new        static    transient</span><br></pre></td></tr></table></figure></p></blockquote><ul><li style="list-style: none"><input type="checkbox"> transient 序列化时不进行序列化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#基础语法&quot;&gt;基础语法&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#代码风格&quot;&gt;代码风格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#结构&quot;&gt;结构&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="基础" scheme="http://blog.kuangcp.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="语法" scheme="http://blog.kuangcp.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MIS.md</title>
    <link href="http://blog.kuangcp.top/2018/12/18/Memo-Java-MIS/"/>
    <id>http://blog.kuangcp.top/2018/12/18/Memo-Java-MIS/</id>
    <published>2018-12-18T01:16:56.921Z</published>
    <updated>2018-12-18T01:16:56.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#完整的mis构建经验">完整的MIS构建经验</a><ol><li><a href="#mvc">MVC</a><ol><li><a href="#持久化层">持久化层</a><ol><li><a href="#数据库设计">数据库设计</a></li><li><a href="#domain对象设计">Domain对象设计</a></li></ol></li><li><a href="#控制层">控制层</a><ol><li><a href="#权限控制">权限控制</a><ol><li><a href="#session和token的对比">Session和Token的对比</a></li><li><a href="#统一授权">统一授权</a></li></ol></li></ol></li><li><a href="#视图层">视图层</a></li></ol></li><li><a href="#分布式">分布式</a><ol><li><a href="#cap定理">CAP定理</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="完整的MIS构建经验"><a href="#完整的MIS构建经验" class="headerlink" title="完整的MIS构建经验"></a>完整的MIS构建经验</h1><ul><li><a href="https://github.com/jeansfish/RFC6749.zh-cn/blob/master/index.md" target="_blank" rel="noopener">OAuth 2.0授权框架</a></li></ul><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><h3 id="持久化层"><a href="#持久化层" class="headerlink" title="持久化层"></a>持久化层</h3><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><blockquote><p>一种极端是将业务也放在了数据库里, 使用大量的存储过程和函数<br>一种是将约束都放在了业务层, 数据库没有外键约束</p></blockquote><h4 id="Domain对象设计"><a href="#Domain对象设计" class="headerlink" title="Domain对象设计"></a>Domain对象设计</h4><ol><li>首先名称不能使用Java或者数据库中的的关键字 class group table from 等等<ul><li>班级就用ClassGroup吧</li></ul></li><li>实体间的关系映射注意死循环</li></ol><h3 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h3><blockquote><p>只是映射好URL, 调用对应的Service</p></blockquote><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><h5 id="Session和Token的对比"><a href="#Session和Token的对比" class="headerlink" title="Session和Token的对比"></a>Session和Token的对比</h5><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513566&amp;idx=1&amp;sn=a2688cadbe9c8042ff1abbdf04a8bd5e&amp;chksm=80d67a1db7a1f30b28b93ed2ab29edfbf982b780433e4bfd178e3cc52cb1f9100cc8f923db4f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:干掉状态：从session到token </a></p></blockquote><ul><li>token优势是前后端分离做起来比较简单,session在于实现快,但是容易有CSRF问题,其实token也是会有的<ul><li>如果登录和页面的跳转路由还是由后端控制的，那么Token的实现就有点没有那么必要了。（不过为了安全性能够防范CSRF）</li></ul></li></ul><h5 id="统一授权"><a href="#统一授权" class="headerlink" title="统一授权"></a>统一授权</h5><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513744&amp;idx=1&amp;sn=93d0db97cfd67422bcd21c8afd00f495&amp;chksm=80d67b53b7a1f24537fdc7c10eb2783357c1f8c65ad55601a722216d2293ae3fb7b1c16e5449&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:从密码到token，一个授权的故事</a> | <a href="/API_DOC.md#登录授权">自己收集到的相关文档</a></p></blockquote><h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><p><em>一种比较安全的iframe思路</em></p><ul><li>在主页面上写form iframe页面用来展示,这样的话,截图截不了长图,也不能保存文件,也不能打印出来(试了好多种方式去修改教务系统得到的结论)</li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513560&amp;idx=1&amp;sn=ba861726537c57bd34253cbce010b5fe&amp;chksm=80d67a1bb7a1f30df37905ce979504aa132dcaef59075577ff52f45f057734825a59f6de75c9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:张大胖和CAP定理</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#完整的mis构建经验&quot;&gt;完整的MIS构建经验&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#mvc&quot;&gt;MVC&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#持久化层&quot;&gt;持久化层&lt;/
      
    
    </summary>
    
    
  </entry>
  
</feed>
