<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kuangcp Blog</title>
  
  <subtitle>Javaer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.kuangcp.top/"/>
  <updated>2018-12-21T03:02:53.238Z</updated>
  <id>http://blog.kuangcp.top/</id>
  
  <author>
    <name>Kuangcp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin.md</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Functional-Kotlin/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Functional-Kotlin/</id>
    <published>2018-12-21T02:56:52.000Z</published>
    <updated>2018-12-21T03:02:53.238Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#kotlin">Kotlin</a><ol><li><a href="#教程资源">教程资源</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><blockquote><p><a href="https://kotlinlang.org/" target="_blank" rel="noopener">Kotlin官网</a><br>一个能够跨越多个平台和领域的语言 </p></blockquote><h2 id="教程资源"><a href="#教程资源" class="headerlink" title="教程资源"></a>教程资源</h2><ul><li><a href="https://github.com/wangjiegulu/kotlin-for-android-developers-zh" target="_blank" rel="noopener">Kotlin For Android</a><code>中文教程</code></li><li><a href="https://github.com/EasyKotlin" target="_blank" rel="noopener">EasyKotlin组织</a><ul><li><a href="https://github.com/EasyKotlin/easy_kotlin_chapter_1" target="_blank" rel="noopener">《Kotlin极简教程》书籍第一章</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#kotlin&quot;&gt;Kotlin&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#教程资源&quot;&gt;教程资源&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://blog.kuangcp.top/categories/Kotlin/"/>
    
    
      <category term="基础" scheme="http://blog.kuangcp.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数式编程" scheme="http://blog.kuangcp.top/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Linux-Arch-Manjaro/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Linux-Arch-Manjaro/</id>
    <published>2018-12-21T02:55:08.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#manjaro">Manjaro</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Manjaro"><a href="#Manjaro" class="headerlink" title="Manjaro"></a>Manjaro</h1><blockquote><p><a href="https://gitlab.manjaro.org/explore/groups" target="_blank" rel="noopener">Gitlab source code</a></p></blockquote><blockquote><p>pacman 文档 <a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/ouening/article/details/79633966" target="_blank" rel="noopener">Manjaro 安装配置简要</a><br><a href="https://zhuanlan.zhihu.com/p/43442012" target="_blank" rel="noopener">参考博客: Manjaro Deepin安装使用分享</a></p></blockquote><p>由于是基于arch的, 滚动更新的特性, 所以需要在每次在安装软件前 <code>pacman -Syu</code> 更新整个系统</p><ul><li>这次下载解压运行 VSCode 就是这样, 报错为 <ul><li>error while loading shared libraries: libgconf-2.so.4: cannot open shared object file: No such file or directory</li><li>尝试安装 libgconf libgconf2 …</li><li>其实真正的包是 gconf , 而这个也是尝试过的,  但是还是说找不到package, 更新了下系统,才找到了这个包</li></ul></li></ul><p>安装时候 默认用户名和密码是 manjaro</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#manjaro&quot;&gt;Manjaro&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-13 12:06&lt;/em&gt;| &lt;a
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.kuangcp.top/categories/Linux/"/>
    
    
      <category term="Arch" scheme="http://blog.kuangcp.top/tags/Arch/"/>
    
      <category term="Manjaro" scheme="http://blog.kuangcp.top/tags/Manjaro/"/>
    
  </entry>
  
  <entry>
    <title>Arch</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Linux-Arch-Arch/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Linux-Arch-Arch/</id>
    <published>2018-12-21T02:55:04.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#arch">Arch</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h1><blockquote><p><a href="https://www.tuicool.com/articles/byAFZr" target="_blank" rel="noopener">参考博客: 为什么 Archlinux 不适合服务器使用</a><br><a href="https://www.zhihu.com/question/49439472" target="_blank" rel="noopener">参考博客: Arch Linux的用户都有理想主义倾向吗？</a><br><a href="https://www.viseator.com/2017/07/02/arch_more/" target="_blank" rel="noopener">参考博客: ArchLinux你可能需要知道的操作与软件包推荐</a><br><a href="https://www.zhihu.com/question/37720991?sort=created" target="_blank" rel="noopener">参考博客: 长期使用Arch，Gentoo等滚动更新的发行版是怎样的一种体验？</a></p></blockquote><ul><li><a href="https://www.lulinux.com/archives/2787" target="_blank" rel="noopener">什么Linux发行版软件最多？</a></li><li><a href="http://www.cnblogs.com/bluestorm/p/5929172.html" target="_blank" rel="noopener">Arch Linux 安装、配置、美化和优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#arch&quot;&gt;Arch&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-13 12:06&lt;/em&gt;| &lt;a href=
      
    
    </summary>
    
      <category term="Linux" scheme="http://blog.kuangcp.top/categories/Linux/"/>
    
    
      <category term="基础" scheme="http://blog.kuangcp.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Arch" scheme="http://blog.kuangcp.top/tags/Arch/"/>
    
  </entry>
  
  <entry>
    <title>Thymeleaf</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-TemplateEngine-Thymeleaf/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-TemplateEngine-Thymeleaf/</id>
    <published>2018-12-21T02:54:18.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#thymeleaf">Thymeleaf</a><ol><li><a href="#流程控制">流程控制</a><ol><li><a href="#if">if</a></li></ol></li><li><a href="#集合处理">集合处理</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h1><blockquote><p>辣鸡</p></blockquote><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ul><li>lt 小于 </li><li>eq 等于</li><li>gt 大于</li><li>le 小于等于</li><li><p>ge 大于等于</p></li><li><p>拼接参数：<code>th:href=&quot;@{/student/ChooseTopic/{id} (id=${pageNum}-2)}&quot;</code></p></li><li>判断块<code>&lt;th:block th:if=&quot;${pageNum lt pageTotal}&quot; &gt;&lt;/th:block&gt;</code></li></ul><h2 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h2><ul><li>判断list大小：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">th:if=&quot;$&#123;#lists.size(topicList) == 0&#125;&quot;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#thymeleaf&quot;&gt;Thymeleaf&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#流程控制&quot;&gt;流程控制&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#if&quot;&gt;if&lt;/a&gt;&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="模板引擎" scheme="http://blog.kuangcp.top/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Spring的事务</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-Transactional/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-Transactional/</id>
    <published>2018-12-21T02:54:05.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#事务">事务</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#事务&quot;&gt;事务&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-13 12:06&lt;/em&gt;| &lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://blog.kuangcp.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringWebFlux</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringWebFlux/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringWebFlux/</id>
    <published>2018-12-21T02:53:48.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#webflux">WebFlux</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="WebFlux"><a href="#WebFlux" class="headerlink" title="WebFlux"></a>WebFlux</h1><blockquote><p><a href="http://www.spring4all.com/article/1167" target="_blank" rel="noopener">参考博客: 译：尝试使用Spring WebFlux</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#webflux&quot;&gt;WebFlux&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-13 12:06&lt;/em&gt;| &lt;a
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://blog.kuangcp.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringTest</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringTest/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringTest/</id>
    <published>2018-12-21T02:53:35.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#spring-test">Spring Test</a><ol><li><a href="#注解">注解</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h1><blockquote><p><a href="https://www.baeldung.com/mockito-annotations?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">参考博客: Getting Started with Mockito @Mock, @Spy, @Captor and @InjectMocks</a><br><a href="https://www.baeldung.com/mockito-spy" target="_blank" rel="noopener">参考博客: Mockito – Using Spies</a></p></blockquote><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul><li style="list-style: none"><input type="checkbox"> 学习</li></ul><ol><li>@MockBean </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#spring-test&quot;&gt;Spring Test&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#注解&quot;&gt;注解&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;str
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://blog.kuangcp.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringSecurity/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringSecurity/</id>
    <published>2018-12-21T02:53:23.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#springsecurity">SpringSecurity</a><ol><li><a href="#配置">配置</a><ol><li><a href="#配置静态口令使用">配置静态口令使用</a></li></ol></li></ol></li><li><a href="#使用该配置即可自定义用户名密码">使用该配置即可自定义用户名密码</a><ol><li><a href="#springboot的集成demo">SpringBoot的集成Demo</a><ol><li><a href="#创建单用户单角色的安全控制">创建单用户单角色的安全控制</a></li><li><a href="#多用户多角色的实现思路">多用户多角色的实现思路</a><ol><li><a href="#每个身份都使用一个登录实体类">每个身份都使用一个登录实体类</a></li><li><a href="#另一种思路">另一种思路：</a></li></ol></li></ol></li><li><a href="#jwt">JWT</a><ol><li><a href="#跨域问题">跨域问题</a></li></ol></li><li><a href="#oauth">Oauth</a></li><li><a href="#实现细节">实现细节</a><ol><li><a href="#关于注解的几种使用方式">关于注解的几种使用方式</a><ol><li><a href="#@secured">@Secured</a></li><li><a href="#@rolesallowed">@RolesAllowed</a></li><li><a href="#springsecurity30-开始提供了-spel表达式">SpringSecurity3.0 开始提供了 SpEL表达式</a></li></ol></li><li><a href="#保护方法应用">保护方法应用</a></li></ol></li><li><a href="#社交登录">社交登录</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><blockquote><p><a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle" target="_blank" rel="noopener">Spring Security 5.0.6 doc</a></p></blockquote><p><a href="http://www.spring4all.com/article/428" target="_blank" rel="noopener">参考博客: Spring Security 入门系列</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置静态口令使用"><a href="#配置静态口令使用" class="headerlink" title="配置静态口令使用"></a>配置静态口令使用</h3><p>当添加了Security依赖之后, 只会生成一个默认的随机密码, 如下简单配置:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用该配置即可自定义用户名密码</span></span><br><span class="line">spring.security.user.name=admin</span><br><span class="line">spring.security.user.password=secret</span><br></pre></td></tr></table></figure></p><p>如果要用 curl 访问则是 <code>curl -i  -u admin:secret  http://tomcat.kcp/hi</code>  </p><blockquote><p>注意 : 前提是要关闭 crsf 校验<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.csrf().disable();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="SpringBoot的集成Demo"><a href="#SpringBoot的集成Demo" class="headerlink" title="SpringBoot的集成Demo"></a>SpringBoot的集成Demo</h2><h3 id="创建单用户单角色的安全控制"><a href="#创建单用户单角色的安全控制" class="headerlink" title="创建单用户单角色的安全控制"></a>创建单用户单角色的安全控制</h3><ol><li>Gradle : <code>compile(&#39;org.springframework.boot:spring-boot-starter-security&#39;)</code></li><li><a href="https://gitee.com/kcp1104/codes/n2berl0tfg8wq9s4ko7xa78#SecurityConfig.java" target="_blank" rel="noopener">Security主要配置类</a></li><li><a href="https://gitee.com/kcp1104/codes/n2berl0tfg8wq9s4ko7xa78#Reader.java" target="_blank" rel="noopener">登录实体类</a></li><li>Jpa实现的Dao层 <code>public interface ReaderRepository extends JpaRepository&lt;Reader, String&gt; {}</code></li></ol><hr><h3 id="多用户多角色的实现思路"><a href="#多用户多角色的实现思路" class="headerlink" title="多用户多角色的实现思路"></a>多用户多角色的实现思路</h3><ul><li><p>使用多个实体类（实现了UserDetails接口），一个权限类，再一个多对多连接，就得到了多用户，多权限的控制</p><ul><li>在页面上加上角色的判断来控制数据显示，业务操作等功能</li></ul></li><li><p>根据书上案例代码，可以得出结论，用户表，角色表，用户角色关联表，用户表是可以多张的，角色公用一张即可，然后关联表也对应的多张，就能实现具体的业务需求</p><ul><li>例如：一个网上在线阅读书城，作家和读者以及编辑，网站后台管理员等角色的不同权限对应的页面甚至页面上细分的各个模块</li><li><code>Author</code> <code>Admin</code> <code>Reader</code> 三个类</li></ul></li><li><code>继承了UserDetails接口的实体类的配置</code> <a href="https://gitee.com/kcp1104/codes/n2berl0tfg8wq9s4ko7xa78#Readers.java" target="_blank" rel="noopener">代码片段</a></li></ul><h4 id="每个身份都使用一个登录实体类"><a href="#每个身份都使用一个登录实体类" class="headerlink" title="每个身份都使用一个登录实体类"></a>每个身份都使用一个登录实体类</h4><ul><li>然后使用不同的dao层查询，显然的实体类登录查询的效率及其低且不易扩展</li><li>设置好<code>spirng.jpa.hibernate.ddl-auto=update</code></li><li>第一次运行还会有没有实体对应的表这样的提示,说明了他正在根据多对多映射创建实体表，也体现了这个多种用户模式下需要实体等量的连接表</li><li>所以这个是要查询多张表了<ul><li>（除非UserDetailService接口的loadUserByUsername能收到表类别的参数）</li><li>也可以考虑使用一个字符串，然后用<code>特殊字符</code>把类型放进去，然后正则取出来</li><li>登录页面就需要自定义一个函数进行拼接（或者使用校验来拼接？）</li></ul></li></ul><h4 id="另一种思路："><a href="#另一种思路：" class="headerlink" title="另一种思路："></a>另一种思路：</h4><ul><li>使用一个登录用户表（序列id，用户名，密码，用户编码（对应多张表））<ul><li>角色表（序列id，用户编码，角色） </li><li>这样的话扩展就只要加表，使用同一个主键生成策略就可以了</li></ul></li></ul><blockquote><ul><li>思考：</li><li>其实这个安全框架使用的是角色控制，而不是权限控制，目前的了解，达不到Oracle那样的权限加角色的精细化控制</li></ul></blockquote><hr><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><blockquote><p><a href="/Skills/Base/WebSecurity.md#jwt">JWT相关原理</a> | <a href="https://github.com/Kuangcp/SpringBoot2-Security-Jwt" target="_blank" rel="noopener">Github SpringBoot2使用Security整合Jwt案例项目</a>  </p></blockquote><ul><li><a href="https://gitee.com/kcp1104/codes/kw31qf40iz9p8mt2x7bcd49" target="_blank" rel="noopener">个人代码片段</a>  |</li></ul><blockquote><p><a href="http://www.saily.top/2016/12/08/spring-boot-jwt/" target="_blank" rel="noopener">集成JWT到Spring Boot项目</a> | <a href="https://segmentfault.com/a/1190000009231329" target="_blank" rel="noopener">使用JWT保护你的Spring Boot应用</a><br><a href="https://juejin.im/post/58c29e0b1b69e6006bce02f4" target="_blank" rel="noopener">重拾后端之Spring Boot（四）：使用JWT和Spring Security保护REST API</a><br><a href="http://www.cnblogs.com/grissom007/p/6294746.html" target="_blank" rel="noopener">开箱即用 - jwt 无状态分布式授权</a></p></blockquote><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><blockquote><p><a href="https://segmentfault.com/q/1010000005067552" target="_blank" rel="noopener">跨域(CORS) 解决方案中，为什么 Access-Control-Allow-Methods 不起作用？</a><br><a href="https://bbs.csdn.net/topics/392006333" target="_blank" rel="noopener">WEB应用前后端分离实践 关键词：rest架构+跨域访问+JWT校验</a></p></blockquote><p><a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#csrf" target="_blank" rel="noopener">csrf</a></p><hr><h2 id="Oauth"><a href="#Oauth" class="headerlink" title="Oauth"></a>Oauth</h2><blockquote><p><a href="https://github.com/spring-projects/spring-security-oauth" target="_blank" rel="noopener">oauth</a></p></blockquote><hr><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="关于注解的几种使用方式"><a href="#关于注解的几种使用方式" class="headerlink" title="关于注解的几种使用方式"></a>关于注解的几种使用方式</h3><h4 id="Secured"><a href="#Secured" class="headerlink" title="@Secured"></a>@Secured</h4><ul><li>这是基于Spring特定的注解<h4 id="RolesAllowed"><a href="#RolesAllowed" class="headerlink" title="@RolesAllowed"></a>@RolesAllowed</h4></li><li>JSR-250的@RolesAllowed Java标准定义的注解，与上面的注解是差不多的</li><li><p>但是都是有局限性，只能判断请求是否有权限，不能进行更多的自定义判断</p><h4 id="SpringSecurity3-0-开始提供了-SpEL表达式"><a href="#SpringSecurity3-0-开始提供了-SpEL表达式" class="headerlink" title="SpringSecurity3.0 开始提供了 SpEL表达式"></a>SpringSecurity3.0 开始提供了 SpEL表达式</h4><p><code>需要先配置这个配置类，后面的注解才会生效</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSecurityConfig</span> <span class="keyword">extends</span> <span class="title">GlobalMethodSecurityConfiguration</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@PreAuthorize</code> 方法调用前，基于表达式的计算结果来限制方法的访问</p></li><li><code>@PostAuthorize</code> 允许方法调用，如果表达式是false 抛出安全异常</li><li><code>@PostFilter</code> 允许方法调用，按照表达式来过滤方法的结果</li><li><p><code>@PreFilter</code> 允许方法调用，必须进入方法前过滤输入值</p></li><li><p>方法调用前验证权限，示例:</p><ul><li><code>@PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)</code> 只允许该权限的用户访问</li><li>方法入参user，限定读者用户的text长度小于140，或者是作家用户无限制</li><li><code>@PreAuthorize(&quot;(hasRole(&#39;ROLE_READER&#39;) and #user.text.length()&lt;=140 ) or hasRole(&#39;ROLE_AUTHOR&#39;)&quot;)</code></li></ul></li><li>方法调用之后验证权限，示例;<ul><li><code>@PostAuthorize(&quot;returnObject.spitter.username == principal.username&quot;)</code></li><li>public Spittle getSpittleById(long id){} </li><li>保护方法，只有当返回的对象就是当前登录的用户时，才返回，不然抛出安全异常<br><code>以上是保护方法的调用，但是有时候保护的是数据的输入输出：</code></li></ul></li><li>过滤方法的输入输出<ul><li>事后对方法的返回值进行过滤<ul><li><code>@PreAuthorize(&quot;hasAnyRole({&#39;ROLE_ADMIN&#39;,&#39;ROLE_USER&#39;})&quot;)</code></li><li><code>@PostFilter(&quot;hasRole(&#39;ROLE_ADMIN&#39;) || filterObject.user.username == principal.name&quot;)</code></li><li><code>public List&lt;User&gt; getUsers(){}</code></li><li>该示例就是限制了如果是管理员可以获取到所有数据，普通用户只能看到自己</li><li>但是这种实现是不好的，只是一个例子，只获取自己，重载方法加个id参数就好了，上面的实现，把数据全拿出来再判断，性能上。。。</li></ul></li><li>事先对方法的参数进行过滤<ul><li><code>@PreAuthorize(&quot;hasAnyRole({&#39;ROLE_ADMIN&#39;,&#39;ROLE_USER&#39;})&quot;)</code></li><li><code>@PreFilter(&quot;hasRole(&#39;ROLE_ADMIN&#39;) || targetObject.user.username == principal.name&quot;)</code></li><li><code>public void deleteUsers(){List&lt;User&gt; users}</code></li><li>示例实现了传入一个集合，要删除的用户，但是当前用户只能删除自己，管理员才能删除集合里所有的用户</li></ul></li><li>定义许可计算器<ul><li><code>@PreFilter(&quot;hasPermission(targetObject,&#39;delete&#39;)&quot;)</code> 用户是否有权限删除目标对象？</li><li>使用了自定义的计算器类来实现这个判断，表达式简洁，但是自定义类不好写</li><li>实现PermissionEvaluator接口，新建hasPermission方法，功能就是判断是否有权限，其实就是对比目标对象是不是当前用户</li><li>创建好类后，重载GlobalMethodSecurityConfiguration配置类的createExpressionHalder方法，注册进去</li><li><code>DefaultMethodSecurityExperssionHandler ex = new De...();</code></li><li><code>ex.setPermissionEvaluator(new 自定义类);</code></li><li><code>return ex;</code></li></ul></li></ul></li></ul><h3 id="保护方法应用"><a href="#保护方法应用" class="headerlink" title="保护方法应用"></a>保护方法应用</h3><ul><li>@Secured 注解限制方法调用</li></ul><hr><h2 id="社交登录"><a href="#社交登录" class="headerlink" title="社交登录"></a>社交登录</h2><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDEwMjgwNA==&amp;mid=2247484230&amp;idx=1&amp;sn=358f684bd122888270730f2b102ee1b2&amp;chksm=fb3f1abdcc4893ab9dc400a44edfe7a9d483c070b78db1d81f70c4a3d7870d113d9287d81b0f&amp;mpshare=1&amp;scene=1&amp;srcid=0121kLxdu4ezkmeJAoJcdMZ1&amp;pass_ticket=LGmo8DCbLhUXTV%2FDVv1W9SyGxNSXxxYLrKODVeXD8f3lkWt2HnMB5b7racYt5W6V#rd" target="_blank" rel="noopener">SpringForAll社区:Spring Security源码分析（三）：Spring Social实现QQ社交登录 </a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU0MDEwMjgwNA==&amp;mid=2247484233&amp;idx=1&amp;sn=1e84ffd8c9169db56a0d48ccb31bc842&amp;chksm=fb3f1ab2cc4893a4263799c466d73ee67971ce9deb22a91b8ae8e968621679de3bce83a2c558&amp;mpshare=1&amp;scene=1&amp;srcid=0121cjpvaOeB0nktdOSQNitj&amp;pass_ticket=LGmo8DCbLhUXTV%2FDVv1W9SyGxNSXxxYLrKODVeXD8f3lkWt2HnMB5b7racYt5W6V#rd" target="_blank" rel="noopener">SpringForAll社区:Spring Security 源码分析（四）：Spring Social实现微信社交登录 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#springsecurity&quot;&gt;SpringSecurity&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#配置&quot;&gt;配置&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#配置静态口令
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://blog.kuangcp.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringMVC/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringMVC/</id>
    <published>2018-12-21T02:53:11.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#springmvc">SpringMVC</a><ol><li><a href="#mvc思想">MVC思想</a><ol><li><a href="#原理">原理</a></li></ol></li><li><a href="#api">API</a></li><li><a href="#传统项目配置完整流程">传统项目配置完整流程</a><ol><li><a href="#配置依赖">配置依赖</a><ol><li><a href="#maven">Maven</a></li><li><a href="#gradle">Gradle</a></li></ol></li><li><a href="#webxml">web.xml</a></li><li><a href="#applicationcontextxml">ApplicationContext.xml</a><ol><li><a href="#全局异常处理">全局异常处理</a></li><li><a href="#自定义错误页面">自定义错误页面</a></li><li><a href="#中文编码问题">中文编码问题</a></li></ol></li><li><a href="#创建controller">创建Controller</a></li></ol></li><li><a href="#使用">使用</a><ol><li><a href="#配置类型转换">配置类型转换</a></li><li><a href="#拦截器">拦截器</a><ol><li><a href="#拦截器机制">拦截器机制</a></li><li><a href="#自定义拦截器">自定义拦截器</a></li></ol></li><li><a href="#q&amp;a">Q&amp;A</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-20 10:44</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><blockquote><p><a href="https://legacy.gitbook.com/book/linesh/spring-mvc-documentation-linesh-translation/details" target="_blank" rel="noopener">Spring MVC 4.2.4.RELEASE 中文文档</a></p></blockquote><h2 id="MVC思想"><a href="#MVC思想" class="headerlink" title="MVC思想"></a>MVC思想</h2><blockquote><p><a href="http://blog.csdn.net/besley/article/details/8479943" target="_blank" rel="noopener">参考博客</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/mvc.png" alt="图" title="">                </div>                <div class="image-caption">图</div>            </figure></p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>统一使用一个Servlet 进行请求的收发, 通过配置的URL对应的方法, 进行调用, 然后返回视图解析器进行渲染</p></blockquote><ul><li>核心类是DispatchServlet 由它来接收各种请求</li><li>发出request请求，到controller解析器，得到Model和view等的名字</li><li>发送到controller执行，返回view名字</li><li>发送到视图解析器</li><li>执行视图返回到dispatchServlet</li></ul><hr><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><blockquote><p><a href="http://www.csdn.net/article/2013-05-02/2815115-stop-designing-fragile-web-api" target="_blank" rel="noopener">简洁的API设计</a></p></blockquote><hr><h2 id="传统项目配置完整流程"><a href="#传统项目配置完整流程" class="headerlink" title="传统项目配置完整流程"></a>传统项目配置完整流程</h2><blockquote><p>也就是Maven的Web结构，甚至是Eclipse那样的DynamicWeb项目结构， <a href="https://www.cnblogs.com/Sinte-Beuve/p/5730553.html" target="_blank" rel="noopener">参考 博客</a></p></blockquote><h3 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h3><h4 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.3.9.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果使用JSP作为视图层,还需 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework:spring-web:4.3.9.RELEASE'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework:spring-webmvc:4.3.9.RELEASE'</span>)</span><br></pre></td></tr></table></figure><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ApplicationContext-xml"><a href="#ApplicationContext-xml" class="headerlink" title="ApplicationContext.xml"></a>ApplicationContext.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.sprinControllergframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context/spring-context-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--启用spring的一些annotation --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.test.controller"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--HandlerMapping 无需配置，springmvc可以默认启动--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--静态资源映射--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--本项目把静态资源放在了WEB-INF的statics目录下，资源映射如下--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/css/**" location="/WEB-INF/statics/css/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/js/**" location="/WEB-INF/statics/js/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/image/**" location="/WEB-INF/statics/image/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--但是项目部署到linux下发现WEB-INF的静态资源会出现无法解析的情况，但是本地tomcat访问正常，因此建议还是直接把静态资源放在webapp的statics下，映射配置如下--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/css/**" location="/statics/css/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/js/**" location="/statics/js/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping="/image/**" location="/statics/images/"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置注解驱动 可以将request参数与绑定到controller参数上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀(如果最后一个还是表示文件夹,则最后的斜杠不要漏了) 使用JSP--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;bean id="defaultViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="prefix" value="/WEB-INF/views/"/&gt;&amp;lt;!&amp;ndash;设置JSP文件的目录位置&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="suffix" value=".jsp"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springmvc文件上传需要配置的节点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"20971500"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resolveLazily"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        model.put(<span class="string">"ex"</span>, ex);</span><br><span class="line">        ex.printStackTrace();<span class="comment">//打印异常信息</span></span><br><span class="line">        <span class="comment">// 根据不同错误转向不同页面</span></span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> CSRFException) &#123;<span class="comment">//受到csrf攻击</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"/errorPage/error"</span>, model);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BusinessException) &#123;<span class="comment">//业务逻辑处理出错</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"errorPage/businessError"</span>, model);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> ParameterException) &#123;<span class="comment">//参数处理出错。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"errorPage/parameterError"</span>, model);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//其他数据类型错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"errorPage/error"</span>, model);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者是在 Controller 层直接处理</span></span><br><span class="line">    <span class="meta">@ControllerAdvice</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandle</span></span>&#123;</span><br><span class="line">    <span class="meta">@EXceptionHandler</span>(&#123;Exception.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">dealException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        ModelAndView view = <span class="keyword">new</span> ModelAndView(<span class="string">"exception"</span>;</span><br><span class="line">        Exception e = <span class="keyword">new</span> Exception(<span class="string">"错误信息"</span>);</span><br><span class="line">        view.addObject(<span class="string">""</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>但如果是前后端分离的话， 就只能统一处理异常然后然后对应的错误码和提示信息了<br><a href="http://www.cnblogs.com/exmyth/p/5601288.html" target="_blank" rel="noopener">参考博客</a><br><a href="https://blog.csdn.net/xin917480852/article/details/78023911" target="_blank" rel="noopener">ResponseBody方案</a></p></blockquote><h4 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义错误页面 需要放在静态资源下面</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">containerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (container -&gt; &#123;</span><br><span class="line">        ErrorPage error401Page = <span class="keyword">new</span> ErrorPage(HttpStatus.FORBIDDEN, <span class="string">"/500.html"</span>);</span><br><span class="line">        ErrorPage error404Page = <span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">"/404.html"</span>);</span><br><span class="line">        ErrorPage error500Page = <span class="keyword">new</span> ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, <span class="string">"/500.html"</span>);</span><br><span class="line">        container.addErrorPages(error401Page, error404Page, error500Page);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中文编码问题"><a href="#中文编码问题" class="headerlink" title="中文编码问题"></a>中文编码问题</h4><blockquote><p><a href="http://www.cnblogs.com/dyllove98/p/3180158.html" target="_blank" rel="noopener">参考博客</a> <code>但是奇怪的是某些方法用第二种正常，有些还是要用第一种</code></p><ol><li>单个方法：<code>@GetMapping(value = &quot;/target/all&quot;,  produces = &quot;application/json; charset=utf-8&quot;)</code></li><li>或者整个应用 注意：<code>&lt;/mvc:annotation-driven&gt;</code> 只能有一个，要将上面的覆盖掉<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                   <span class="comment">&lt;!-- 如果是前后端使用JSON作为主要数据交换格式就把JSON列为第一个， 否则就会被认为是Text --&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json; charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/plain; charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html; charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="创建Controller"><a href="#创建Controller" class="headerlink" title="创建Controller"></a>创建Controller</h3><p>包 com.test.controller 下创建一个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hi"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hi"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hi"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>使用上 ResponseEntity 让响应结果规范<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/handle"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  URI location = ...;</span><br><span class="line">  HttpHeaders responseHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">  responseHeaders.setLocation(location);</span><br><span class="line">  responseHeaders.set(<span class="string">"MyResponseHeader"</span>, <span class="string">"MyValue"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;String&gt;(<span class="string">"Hello World"</span>, responseHeaders, HttpStatus.CREATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>在Springboot框架中，static templates 文件夹下分别代表了tomcat管理的静态文件和MVC负责跳转的HTML文件或JSP文件<br>在static中对于路径的使用一定要带上应用路径，而在templates中就只要写相对路径即可</p></blockquote><h3 id="配置类型转换"><a href="#配置类型转换" class="headerlink" title="配置类型转换"></a>配置类型转换</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置ConversionService --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"DateConverter"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><h4 id="拦截器机制"><a href="#拦截器机制" class="headerlink" title="拦截器机制"></a>拦截器机制</h4><p>implements HandleInterceptor 有三个方法</p><p>preHandle 返回true就继续往后，false就被拦截<br>PostHandle 在渲染视图之前，<br>afterCompletion 渲染视图之后调用，释放资源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h4><ul><li><a href="http://www.jianshu.com/p/f14ed6ca4e56" target="_blank" rel="noopener">相关博客</a>|<a href="http://blog.csdn.net/catoop/article/details/50501696" target="_blank" rel="noopener">相关博客</a></li></ul><p><code>定义拦截器类</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MythInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        request.setAttribute(<span class="string">"startTime"</span>,startTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// true就继续跳转，false就停止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = (Long)request.getAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        request.removeAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        log.info(request.getRequestURL()+<span class="string">"发起请求耗时:[ "</span>+ (endTime - startTime) +<span class="string">"  ms]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>配置MVC的配置类</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line">    <span class="comment">//自定义拦截器bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MythInterceptor <span class="title">mythInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MythInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拦截器的URL正则</span></span><br><span class="line">        registry.addInterceptor(mythInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><ul><li><a href="https://gitee.com/kcp1104/codes/14ipgcbjyenxqu6tf9d0543" target="_blank" rel="noopener">Springboot中使用Websocket进行消息推送</a></li><li><a href="https://blog.csdn.net/kangkanglou/article/details/78253747" target="_blank" rel="noopener">SpringBoot 使用WebSocket</a></li><li><a href="https://www.xncoding.com/2017/07/15/spring/sb-websocket.html" target="_blank" rel="noopener">SpringBoot系列 - 集成WebSocket实时通信</a></li></ul><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><blockquote><p>URL 中带了 jsessionid 参数，导致页面各种问题</p><ul><li>一种原因：禁用cookie导致的</li><li>最终解决： chrome中在设置里清除localhost的所有cookie和缓存</li></ul></blockquote><ul><li><a href="https://yq.aliyun.com/articles/101169" target="_blank" rel="noopener">解决问题参考博客</a></li><li><p><a href="http://sxsoft.blog.163.com/blog/static/190412229200911103116773" target="_blank" rel="noopener">jsessionid的作用</a></p></li><li><p>[ ] ModelAndView中的addObject 的值能用js获取到么</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#springmvc&quot;&gt;SpringMVC&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#mvc思想&quot;&gt;MVC思想&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#原理&quot;&gt;原理&lt;/a&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://blog.kuangcp.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringCloud/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringCloud/</id>
    <published>2018-12-21T02:50:56.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#springcloud">SpringCloud</a><ol><li><a href="#集成docker">集成docker</a></li><li><a href="#微服务">微服务</a><ol><li><a href="#通信方式">通信方式</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><blockquote><p><a href="http://www.spring4all.com/article/320" target="_blank" rel="noopener">参考博客: Spring Cloud 入门系列</a></p></blockquote><h2 id="集成docker"><a href="#集成docker" class="headerlink" title="集成docker"></a>集成docker</h2><blockquote><p><a href="https://www.huangyunkun.com/2016/04/03/spring-boot-alpine-linux/" target="_blank" rel="noopener">boot in Alpine Linux</a><br><a href="https://yq.aliyun.com/articles/47344" target="_blank" rel="noopener">SpringBoot+Docker</a></p></blockquote><ul><li>基于此镜像构建小于Ubuntu<code>frolvlad/alpine-oraclejdk8:slim</code></li><li><a href="https://github.com/waylau/docker-demos" target="_blank" rel="noopener">maven 和 gradle两种集成</a></li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><blockquote><p><a href="https://github.com/dyc87112/SpringCloudBook" target="_blank" rel="noopener">《Spring Cloud实战》一书的配套示例代码</a><br><a href="https://github.com/itmuch/spring-cloud-docker-microservice-book-code" target="_blank" rel="noopener">《Spring Cloud与Docker微服务架构实战》1-11章配套代码</a><br><a href="http://www.infoq.com/cn/articles/Microservices-SpringBoot" target="_blank" rel="noopener">使用SpringBoot开启微服务之旅</a></p></blockquote><h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ul><li><a href="https://www.zhihu.com/question/41609070" target="_blank" rel="noopener">知乎:既然有http 请求，为什么还要用rpc调用？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#springcloud&quot;&gt;SpringCloud&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#集成docker&quot;&gt;集成docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="SpringCloud" scheme="http://blog.kuangcp.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot数据库相关</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringbootDatabase/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringbootDatabase/</id>
    <published>2018-12-21T02:50:38.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#数据库模块">数据库模块</a><ol><li><a href="#relational-database">Relational Database</a><ol><li><a href="#多数据源配置">多数据源配置</a></li><li><a href="#连接池">连接池</a><ol><li><a href="#c3p0">c3p0</a></li><li><a href="#druid">druid</a></li><li><a href="#hikaripool">HikariPool</a></li></ol></li><li><a href="#jpa">JPA</a><ol><li><a href="#configuration">Configuration</a></li></ol></li><li><a href="#mybatis">Mybatis</a><ol><li><a href="#自定义查询">自定义查询</a><ol><li><a href="#hql">HQL</a></li><li><a href="#原生sql">原生SQL</a></li></ol></li><li><a href="#mysql">Mysql</a></li><li><a href="#映射关系">映射关系</a><ol><li><a href="#一对一">一对一</a></li><li><a href="#一对多">一对多</a></li><li><a href="#多对多">多对多</a></li></ol></li></ol></li><li><a href="#restful设计">Restful设计</a><ol><li><a href="#特别注意">【特别注意】</a></li></ol></li><li><a href="#jpa数据分页">Jpa数据分页</a></li><li><a href="#数据库上的事务支持">数据库上的事务支持</a></li></ol></li><li><a href="#non-relational-database">Non Relational database</a><ol><li><a href="#jpa">JPA</a><ol><li><a href="#redis的简单使用">Redis的简单使用</a></li><li><a href="#关于stringredistemplate的方法使用">关于StringRedisTemplate的方法使用</a></li><li><a href="#消息订阅和发布">消息订阅和发布</a></li></ol></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="数据库模块"><a href="#数据库模块" class="headerlink" title="数据库模块"></a>数据库模块</h1><blockquote><p>主要是采用的JPA，极大的缩减了代码量，但是要注意不要过度依赖框架，丧失了基本的能力</p></blockquote><h2 id="Relational-Database"><a href="#Relational-Database" class="headerlink" title="Relational Database"></a>Relational Database</h2><h3 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h3><blockquote><p>为什么要有多数据源? 思考</p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/34730e595a8c" target="_blank" rel="noopener">Spring Boot多数据源配置与使用</a></p></blockquote><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h4 id="c3p0"><a href="#c3p0" class="headerlink" title="c3p0"></a>c3p0</h4><ul><li><a href="http://www.cnblogs.com/520playboy/p/7526252.html" target="_blank" rel="noopener">参考博客</a></li></ul><h4 id="druid"><a href="#druid" class="headerlink" title="druid"></a>druid</h4><ul><li><a href="http://makaidong.com/L_Sail/1/40930_11573921.html" target="_blank" rel="noopener">druid连接池的配置</a></li></ul><h4 id="HikariPool"><a href="#HikariPool" class="headerlink" title="HikariPool"></a>HikariPool</h4><blockquote><p>性能最好的数据库连接池</p></blockquote><ul><li style="list-style: none"><input type="checkbox"> 听说代码很精简, 阅读源码学习</li></ul><hr><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><blockquote><p>连接池:1.x 默认是tomcat-jdbc连接池 2.x 是 HikariPool</p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/3b31270a44b1" target="_blank" rel="noopener">参考博客: spring boot2 整合（二）JPA</a></p></blockquote><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/htmlsingle/#howto-configure-jpa-properties" target="_blank" rel="noopener">Official Doc</a><br><strong><code>ddl-auto</code></strong></p><ul><li>JPA 默认是该配置 <code>spring.jpa.hibernate.ddl-auto</code></li><li>但是如上配置没有生效的话就要用 这个 <code>spring.jpa.properties.hibernate.hbm2ddl.auto</code> <ol><li>none 什么都不做</li><li>create-only </li><li>create 先删除, 然后建立新的表</li><li>create-drop 先删除, 然后建立新的表, 然后在SessionFactory实例关闭后再删除</li><li>update 创建和修改</li><li>validate 校验是否一致, 不一致就报错,启动失败</li></ol></li></ul></blockquote><ul><li><p><a href="http://blog.csdn.net/Amy_Queen/article/details/72454099" target="_blank" rel="noopener">Blog: 原生SQL的写法</a></p></li><li><p>[ ] 怎么映射视图到实体上?</p></li></ul><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><blockquote><p><a href="https://blog.csdn.net/juewang_love/article/details/53769906" target="_blank" rel="noopener">IDEA下创建Springboot，thymeleaf，Mybatis，Postgresql，Gradle项目</a></p></blockquote><h4 id="自定义查询"><a href="#自定义查询" class="headerlink" title="自定义查询"></a>自定义查询</h4><h5 id="HQL"><a href="#HQL" class="headerlink" title="HQL"></a>HQL</h5><ul><li>使用Hibernate语法模式,将对象和数据库的表看成一个实体,方便书写SQL,但是在Controller层和Service层<ul><li>进行写代码的时候,参数的传递全是实体对象,要不停的new,这样真的没问题么(当有各种复杂的关联关系的时候,单个对象的CURD基本没有什么问题)</li><li><code>TODO</code> 所以还不如直接写原生SQL! 那么JPA就真的没有使用的必要性了,直接用Mybatis结合插件生成自动的CRUD的代码,这样更为轻量</li><li>待后续使用后再回来填坑</li></ul></li></ul><h5 id="原生SQL"><a href="#原生SQL" class="headerlink" title="原生SQL"></a>原生SQL</h5><ul><li>涉及到数据的修改,就要加上前两个前缀,查询就直接写Query注解即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Query</span>(value = <span class="string">"update a set b=?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><ul><li><p>1.引入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-data-jpa'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-jdbc'</span>)</span><br><span class="line">runtime(<span class="string">'mysql:mysql-connector-java'</span>)</span><br></pre></td></tr></table></figure></li><li><p>2.继承接口，打好实体类的注解 @Entity </p></li><li><p>3.<em>切记 属性名不能使用下划线（数据库风格）不然写声明方法就会报错，jpa只是看下划线前半部分，会说找不到属性</em></p><ul><li>jpa在创建表时会把驼峰命名改成数据库风格的形式</li></ul></li><li><p>4.jpa是声明特定方法的接口，让jpa来实现并自动注入，如果是没有的方法，就可以使用@Query注解</p><ul><li>默认使用的是HQL（HQL是基于类的所以使用的是类的名字不是表的名字），可以设置下使用原生SQL</li></ul></li></ul><h4 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h4><h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><blockquote><p>据说这是性能最好的方式, 但是有一点让人不舒服, A的id是名存实亡的, 数据库都没有这个字段, 实际上就是B的id, 但是对象又一定要保留这个id, 不然约束通不过<br>也就是说, 创建的时候要设置A的id的值, 但是后面却用不到这个值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@OneToOne</span>(fetch = FetchType.LAZY)</span><br><span class="line">  <span class="meta">@MapsId</span></span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h5><ul><li><p>一方的配置是当前类的id，多方则按基本ER的规则来，注解中配置的是外键的名字, 所以当前类中的属性,外键名是不能重复的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 一方</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOne</span></span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String testOneId;</span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"testOneId"</span>)<span class="comment">//这个名字可以重复，最终会有一个随机码生成</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;TestMany&gt; testManySet;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 多方</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMany</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String testManyId;</span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"testOneId"</span>)</span><br><span class="line">    <span class="keyword">private</span> TestOne testOneId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>[ ] 问题: 当两个表互相引用了, 需要修改表结构 ,怎么删除重建两张表结构, 简单的命令会陷入死锁</p></li></ul><hr><h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><hr><h3 id="Restful设计"><a href="#Restful设计" class="headerlink" title="Restful设计"></a>Restful设计</h3><ul><li>1.添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-rest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2.引入自动配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestConfiguration</span> <span class="keyword">extends</span> <span class="title">RepositoryRestMvcConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RepositoryRestConfiguration <span class="title">config</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.config();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProfileResourceProcessor <span class="title">profileResourceProcessor</span><span class="params">(RepositoryRestConfiguration config)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置rest根目录是应用路径下的路径 : localhost:8080/rest</span></span><br><span class="line">        config.setBasePath(<span class="string">"/rest"</span>);</span><br><span class="line">        <span class="comment">// 允许输出id</span></span><br><span class="line">        config.exposeIdsFor(Goods.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.profileResourceProcessor(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3.配置repository的名字例如：（只要配置repository就能用REST了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RepositoryRestResource</span>(path = <span class="string">"book"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Book</span>,<span class="title">Long</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>4.启动应用，控制台有如下输出</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Java/Spring/output.png" alt="输出" title="">                </div>                <div class="image-caption">输出</div>            </figure></li><li><p>所有路径的使用方法：</p><ul><li><code>GET</code> 查询单个 <code>/repo/id</code> 成功：200 失败404</li><li><code>GET</code> 查询所有 <code>/repo</code> 成功200 失败404</li><li><code>POST</code> 新增 <code>/repo</code> json数据发送 成功 201 失败404</li><li><code>DELETE</code> 删除 <code>/repo/id</code> json数据 成功204 失败404</li><li><code>PUT</code> 更新 <code>/repo/id</code> json 更新成功200 没有该id就插入201 失败404（使用主键自动增长就不会遇到404）</li></ul></li></ul><h4 id="【特别注意】"><a href="#【特别注意】" class="headerlink" title="【特别注意】"></a>【特别注意】</h4><ul><li>rest得到的数据没有id<ul><li>添加配置 <code>config.exposeIdsFor(Goods.class);</code> 即可查看到id <a href="http://tommyziegler.com/how-to-expose-the-resourceid-with-spring-data-rest/" target="_blank" rel="noopener">参考博客</a></li></ul></li></ul><h3 id="Jpa数据分页"><a href="#Jpa数据分页" class="headerlink" title="Jpa数据分页"></a>Jpa数据分页</h3><blockquote><p><a href="https://www.tianmaying.com/tutorial/spring-jpa-page-sort" target="_blank" rel="noopener">参考博客</a></p></blockquote><ul><li>分页 page 从0开始 size是个数 sort可以不需要（如果本来就是id排序就没必要了） <ul><li>原理就是 预编译SQL然后查询总数，然后再执行 必须有两条SQL执行</li></ul></li><li>查询的结果不包含实体的id属性</li></ul><h3 id="数据库上的事务支持"><a href="#数据库上的事务支持" class="headerlink" title="数据库上的事务支持"></a>数据库上的事务支持</h3><ul><li>JPA对所有默认方法都开启了事务支持，查询类事务默认启用readOnly=true</li></ul><hr><h2 id="Non-Relational-database"><a href="#Non-Relational-database" class="headerlink" title="Non Relational database"></a>Non Relational database</h2><h3 id="JPA-1"><a href="#JPA-1" class="headerlink" title="JPA"></a>JPA</h3><h4 id="Redis的简单使用"><a href="#Redis的简单使用" class="headerlink" title="Redis的简单使用"></a>Redis的简单使用</h4><p><em>配置连接信息</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=127.0.0.1</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）0不超时</span><br><span class="line">spring.redis.timeout=0</span><br></pre></td></tr></table></figure></p><p><code>在一个配置类中复制如下代码即可使用 StringRedisTemplate RedisTemplate 的实例</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object,Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object,Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 值序列化采用 jackson2JsonRedisSerializer</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 键序列化采用 StringRedisSerializer</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">StringRedisTemplate <span class="title">template</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringRedisTemplate(connectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">`两个对象的简单使用`</span><br><span class="line">```java</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"aaa"</span>, <span class="string">"hello"</span>);</span><br><span class="line">    String result = stringRedisTemplate.opsForValue().get(<span class="string">"aaa"</span>);</span><br><span class="line">    <span class="comment">//获取所有</span></span><br><span class="line">    Set&lt;String&gt; keysList =  stringRedisTemplate.keys(<span class="string">"*"</span>);</span><br><span class="line">    <span class="keyword">for</span>(String temp :keysList)&#123;</span><br><span class="line">        log.info(temp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>以上配置的template都是只是建立在最简单的键值对上，String-String，所以对象使用的是json来存储</li><li>但是使用的时候如同使用MySQL一样，是ORM框架自动处理数据的转换</li></ul><h4 id="关于StringRedisTemplate的方法使用"><a href="#关于StringRedisTemplate的方法使用" class="headerlink" title="关于StringRedisTemplate的方法使用"></a>关于StringRedisTemplate的方法使用</h4><ul><li><p>常见数据类型的中间对象</p><ul><li>opsForValue() 操作简单键值对数据<ul><li>hasKey()</li></ul></li><li>opsForHash() 操作含有hash的数据</li><li>opsForList() 操作含有list的数据</li><li>opsForZSet() 操作含有zset（有序）的数据<ul><li>range()方法返回指定范围的数据 Java中Set类型的（诡异的是顺序保持了一致）</li></ul></li><li>opsForSet() 操作含有set的数据</li></ul></li><li><p>设置超时时间</p><ul><li><code>redisTemplate.expire(&quot;max&quot;,tempTime,TimeUnit.SECONDS);</code></li></ul></li></ul><h4 id="消息订阅和发布"><a href="#消息订阅和发布" class="headerlink" title="消息订阅和发布"></a>消息订阅和发布</h4><p><a href="https://www.tianmaying.com/tutorial/springboot-redis-message" target="_blank" rel="noopener">参考博客: Spring Boot使用Redis进行消息的发布订阅</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#数据库模块&quot;&gt;数据库模块&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#relational-database&quot;&gt;Relational Database&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="SpringBoot" scheme="http://blog.kuangcp.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2 新特性</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringBoot2/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringBoot2/</id>
    <published>2018-12-21T02:49:53.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#sringboot2">SringBoot2</a><ol><li><a href="#从1迁移到2">从1迁移到2</a></li><li><a href="#新特性">新特性</a></li><li><a href="#web模块">Web模块</a><ol><li><a href="#web容器">Web容器</a><ol><li><a href="#tomcat">Tomcat</a></li><li><a href="#jetty">Jetty</a></li></ol></li><li><a href="#跨域">跨域</a></li><li><a href="#springboot上下文事件监听">SpringBoot上下文事件监听</a></li></ol></li><li><a href="#数据库模块">数据库模块</a><ol><li><a href="#relation-database">Relation Database</a><ol><li><a href="#多数据源">多数据源</a></li></ol></li><li><a href="#no-relation-database">No Relation Database</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="SringBoot2"><a href="#SringBoot2" class="headerlink" title="SringBoot2"></a>SringBoot2</h1><p><a href="https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/htmlsingle/" target="_blank" rel="noopener">官方文档</a></p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/gradle-plugin/reference/html/" target="_blank" rel="noopener">springboot gradle </a></p></blockquote><h2 id="从1迁移到2"><a href="#从1迁移到2" class="headerlink" title="从1迁移到2"></a>从1迁移到2</h2><blockquote><p>变化比较大 <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide" target="_blank" rel="noopener">官方说明对比1所更改的文档</a></p></blockquote><p><a href="https://blog.csdn.net/freexyxyz/article/details/79003438" target="_blank" rel="noopener">spring boot 2.0 半月的实战_阶段性总结1</a><br><a href="https://blog.csdn.net/tianyaleixiaowu/article/details/78905149" target="_blank" rel="noopener">SpringBoot2.0 jpa多数据源配置 </a><br><a href="https://my.oschina.net/tangdu/blog/1625336" target="_blank" rel="noopener">Springboot2.0 升级（Gradle工程) </a><br><a href="https://my.oschina.net/go4it/blog/1623004" target="_blank" rel="noopener">使用精简版jdk9在docker上运行springboot2 </a><br><a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener"> Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南 </a></p><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><blockquote><p><a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解 </a><br><a href="https://mp.weixin.qq.com/s/EWmuzsgHueHcSB0WH-3AQw" target="_blank" rel="noopener">参考博客: Spring Boot 2.0 新特性和发展方向 </a></p></blockquote><h2 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h2><h3 id="Web容器"><a href="#Web容器" class="headerlink" title="Web容器"></a>Web容器</h3><h4 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h4><blockquote><p>org.springframework.boot:spring-boot-starter-web 依赖中默认包含了Tomcat</p></blockquote><h4 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h4><blockquote><p><a href="https://howtodoinjava.com/spring/spring-boot/configure-jetty-server/" target="_blank" rel="noopener">Spring Boot – Configure Jetty Server</a></p></blockquote><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><blockquote><p><a href="https://blog.csdn.net/kcp606/article/details/80036420" target="_blank" rel="noopener">SpringBoot2的跨域配置</a><br>最终是采用的Nginx进行反向代理，将后台服务放在前台服务子路径下</p></blockquote><h3 id="SpringBoot上下文事件监听"><a href="#SpringBoot上下文事件监听" class="headerlink" title="SpringBoot上下文事件监听"></a>SpringBoot上下文事件监听</h3><ul><li><p>直接看 源码中 <code>ApplicationContextEvent</code> 类的 继承结构, 就能发现 有四个子类</p><ul><li>ContextCloseEvent </li><li>ContextRefreshEvent</li><li>ContextStopEvent</li><li>ContextStartEvent</li></ul><p><em>在任意的Component中添加如下类似的方法就能监听到如上事件</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleContextClosedEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// todo </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里可以监听到Spring Boot的生命周期</span></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">      System.out.println(<span class="string">"应用刷新"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextStartedEvent) &#123;</span><br><span class="line">      System.out.println(<span class="string">"应用启动"</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextStoppedEvent) &#123;</span><br><span class="line">      System.out.println(<span class="string">"应用停止"</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">      System.out.println(<span class="string">"应用关闭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是只有应用刷新, 应用启动完成, 应用关闭是能够正常监听到的</p></li></ul><h2 id="数据库模块"><a href="#数据库模块" class="headerlink" title="数据库模块"></a>数据库模块</h2><h3 id="Relation-Database"><a href="#Relation-Database" class="headerlink" title="Relation Database"></a>Relation Database</h3><h4 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h4><ul><li><a href="https://my.oschina.net/chinesedragon/blog/1647846" target="_blank" rel="noopener">参考博客: Spring Boot 2.0 多数据源编程 原</a> | <a href="https://gitee.com/shupengluo/SpringBoot2.0-MultiDataSource" target="_blank" rel="noopener">源码</a></li></ul><h3 id="No-Relation-Database"><a href="#No-Relation-Database" class="headerlink" title="No Relation Database"></a>No Relation Database</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#sringboot2&quot;&gt;SringBoot2&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#从1迁移到2&quot;&gt;从1迁移到2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#新特性&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="SpringBoot" scheme="http://blog.kuangcp.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringBoot/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringBoot/</id>
    <published>2018-12-21T02:49:39.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#springboot">SpringBoot</a><ol><li><a href="#思考">思考</a></li><li><a href="#参考教程">参考教程</a><ol><li><a href="#系列">系列</a></li></ol></li><li><a href="#开始使用">开始使用</a></li><li><a href="#安装springbootcli">安装SpringBootCLI</a></li><li><a href="#测试模块">测试模块</a></li><li><a href="#配置文件">配置文件</a><ol><li><a href="#多种配置文件并切换">多种配置文件并切换</a><ol><li><a href="#yml方式">yml方式</a></li><li><a href="#yml和properties结合">yml和Properties结合</a></li></ol></li><li><a href="#应用配置文件">应用配置文件</a></li></ol></li><li><a href="#日志模块">日志模块</a></li><li><a href="#web模块">Web模块</a><ol><li><a href="#lisener">Lisener</a><ol><li><a href="#servletcontextlistener">ServletContextListener</a></li></ol></li><li><a href="#上传下载文件">上传下载文件</a></li><li><a href="#错误页面跳转配置">错误页面跳转配置</a></li><li><a href="#跨域">跨域</a></li></ol></li><li><a href="#全局异常处理">全局异常处理</a></li><li><a href="#https的配置">HTTPS的配置</a></li><li><a href="#线程池">线程池</a></li><li><a href="#项目部署">项目部署</a><ol><li><a href="#生成指定文件">生成指定文件</a><ol><li><a href="#war">war</a></li><li><a href="#jar">jar</a></li></ol></li><li><a href="#构建docker镜像">构建docker镜像</a><ol><li><a href="#手动方式">手动方式</a></li><li><a href="#gradle结合docker">gradle结合docker</a></li></ol></li><li><a href="#热部署">热部署</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><blockquote><p><a href="https://spring.io/projects/spring-boot#learn" target="_blank" rel="noopener">首页</a></p></blockquote><blockquote><p>一个简化Spring开发的框架,微服务SpringCloud的基础<br><a href="https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/htmlsingle/" target="_blank" rel="noopener">1.5.14 官方文档</a></p></blockquote><ul><li><a href="https://github.com/spring-projects/spring-boot/releases" target="_blank" rel="noopener">Github:Springboot</a></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p><a href="https://www.zhihu.com/question/39483566" target="_blank" rel="noopener">SpringBoot优缺点</a> </p><ul><li><code>大大降低编程门槛, 但是, 将大量细节隐藏在默认配置中, 需要详细阅读文档和源码才能更好的玩转SpringBoot, 不然到处是坑</code></li></ul></li><li><p><a href="https://www.cnblogs.com/trgl/p/7353782.html" target="_blank" rel="noopener">SpringBoot启动流程解析</a><code>原理才是王道</code></p></li><li><p><a href="https://yq.aliyun.com/articles/6056" target="_blank" rel="noopener">spring boot应用启动原理分析 </a></p></li><li><p>Spring 是单例模式, 全部使用IOC容器进行管理, 那么怎么处理并发呢, </p><ul><li>答案是 ? 多线程 然后 ThreadLocal 分别存储了各自的数据, 所以才说, 不能在Controller层 放置属性, 使其具有状态, 从而导致并发问题</li><li>那么WebSocket服务器, 处理并发会不会有并发问题?</li></ul></li><li><p><a href="http://www.ityouknow.com/springboot/2018/06/12/spring-boo-java-simple.html" target="_blank" rel="noopener">为什么说 Java 程序员到了必须掌握 Spring Boot 的时候？</a></p></li></ul><blockquote><p><a href="https://spring.io/guides/gs/actuator-service/" target="_blank" rel="noopener">Guide</a></p></blockquote><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><ul><li><a href="http://springboot.fun/" target="_blank" rel="noopener">SpringBoot中文索引</a></li><li><a href="http://www.spring4all.com/article/246" target="_blank" rel="noopener">参考博客: Spring Boot 入门系列</a></li><li><a href="https://juejin.im/post/598dd709f265da3e213f0c57" target="_blank" rel="noopener">Springboot探索</a></li><li><a href="http://blog.csdn.net/jsyxcjw/article/details/46763639" target="_blank" rel="noopener">SpringBoot入门</a></li></ul><h3 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h3><ul><li><a href="https://github.com/guoxiaoxu/guo-projects/tree/master/guns-admin/note" target="_blank" rel="noopener">一系列专栏</a></li><li><a href="http://tengj.top/tags/Spring-Boot/" target="_blank" rel="noopener">个人博客专栏: SpringBoot干货系列</a></li><li><a href="http://www.ityouknow.com/spring-boot" target="_blank" rel="noopener">SpringBoot系列文章</a></li><li><a href="https://www.jianshu.com/u/092df3f77bca" target="_blank" rel="noopener">恒宇少年</a><code>大量Boot博客</code></li></ul><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><blockquote><p>使用Idea的话就可以直接创建项目 使用别的可以下载zip进行导入 | <a href="http://start.spring.io/" target="_blank" rel="noopener">官方初始项目构建 下载地址</a></p></blockquote><p><em>目录结构最好如下</em> <code>*Application类要处于所有用了Springboot注解的类的顶级目录, 这样默认才能扫描到</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── config/</span><br><span class="line">├── controller/</span><br><span class="line">├── dao/</span><br><span class="line">├── domain/</span><br><span class="line">├── GraduateApplication.java</span><br><span class="line">├── service/</span><br><span class="line">├── ServletInitializer.java</span><br><span class="line">└── util/</span><br></pre></td></tr></table></figure></p><h2 id="安装SpringBootCLI"><a href="#安装SpringBootCLI" class="headerlink" title="安装SpringBootCLI"></a>安装SpringBootCLI</h2><ul><li>使用 SDKMAN 进行安装<ul><li>使用git bash运行  <code>curl -s get.sdkman.io | bash</code></li><li><code>source &quot;/Users/{yourname}/.sdkman/bin/sdkman-init.sh&quot;</code>根据实际目录去运行</li><li>spring –version</li></ul></li><li>官方下载地址 <a href="https://repo.spring.io/release/org/springframework/boot/spring-boot-cli/" target="_blank" rel="noopener">所有版本</a></li></ul><h2 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h2><ul><li style="list-style: none"><input type="checkbox"> 了解这些测试注解 的作用和使用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖于Springboot环境的测试类的必备注解</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内存数据库测试</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.github.kuagncp"</span>) <span class="comment">// 如果有类没注入需要手动设置扫面</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br></pre></td></tr></table></figure><ul><li>可以使用MockMvc来测试Controller层的代码</li><li>可以使用MockMvc的SpringSecurity支持来测试安全模块</li><li>使用 WebIntegraionTest 测试运行中的Web容器<ul><li>启动嵌入式的Servlet容器来进行测试，下断言</li></ul></li><li>使用随机端口启动服务器 配置local.server.port=0</li><li>使用Selenium来测试HTML页面，模拟浏览器的动作，查看系统运行状态</li></ul><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote><p>配置文件(<code>application.properties或者yml</code>)加载顺序 <a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config-application-property-files" target="_blank" rel="noopener">官方文档说明</a></p><blockquote><p>1.当前Jar/War目录下的/config目录 <code>file:./config/</code><br>2.当前目录 <code>file:./</code><br>3.classpath 里的/config目录 <code>classpath:/config/</code><br>4.classpath 根目录 <code>classpath:/</code>  </p></blockquote></blockquote><blockquote><p>自定义配置文件名就要运行时加参数  </p><blockquote><p><code>java -jar myproject.jar --spring.config.name=myproject</code><br><code>java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties</code> <br></p></blockquote></blockquote><ul><li><a href="http://www.itwendao.com/article/detail/391009.html" target="_blank" rel="noopener">配置文件的使用</a></li><li><a href="https://www.tuicool.com/articles/veUjQba" target="_blank" rel="noopener">Spring boot配置文件 application.properties</a></li><li><a href="https://my.oschina.net/wangnian/blog/666641" target="_blank" rel="noopener">SpringBoot常用配置</a></li><li><a href="https://segmentfault.com/a/1190000008968295" target="_blank" rel="noopener">使用Gradle整合SpringBoot+Vue.js-开发调试与打包</a></li><li><p><a href="https://yq.aliyun.com/articles/182720" target="_blank" rel="noopener">配置文件加密</a></p></li><li><p><a href="http://www.cnblogs.com/java-zhao/p/5542154.html" target="_blank" rel="noopener">自定义配置文件</a><code>将应用配置外置并注入成bean</code></p></li><li><a href="http://www.cnblogs.com/xiaoqi/p/6955288.html" target="_blank" rel="noopener">配置文件外置</a></li></ul><h3 id="多种配置文件并切换"><a href="#多种配置文件并切换" class="headerlink" title="多种配置文件并切换"></a>多种配置文件并切换</h3><h4 id="yml方式"><a href="#yml方式" class="headerlink" title="yml方式"></a>yml方式</h4><ul><li><p>单文件<code>配置文件 application.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">     profiles:</span></span><br><span class="line"><span class="attr">       active:</span> <span class="string">development</span> <span class="comment"># 选用开发模式</span></span><br><span class="line"><span class="bullet">   -</span><span class="bullet">--</span></span><br><span class="line"><span class="attr">   spring:</span></span><br><span class="line"><span class="attr">     profiles:</span> <span class="string">development</span></span><br><span class="line">     <span class="string">//一系列配置</span></span><br><span class="line"><span class="bullet">   -</span><span class="bullet">--</span></span><br><span class="line"><span class="attr">   spring:</span></span><br><span class="line"><span class="attr">     profiles:</span> <span class="string">production</span></span><br><span class="line">     <span class="string">//一系列配置</span></span><br></pre></td></tr></table></figure></li><li><p>或者 多文件放 <code>application-{profile}.yml</code></p></li></ul><h4 id="yml和Properties结合"><a href="#yml和Properties结合" class="headerlink" title="yml和Properties结合"></a>yml和Properties结合</h4><ul><li>格式：<code>application-{profile}.properties</code></li><li>将上面的开发部分，发行部分的配置创建两个配置文件 <code>application-dev.properties</code> 和 <code>application-prod.properties</code></li><li>在主配置文件<code>application.yml</code>中指明<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev或者是prod</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="应用配置文件"><a href="#应用配置文件" class="headerlink" title="应用配置文件"></a>应用配置文件</h3><blockquote><p>依赖于 <code>org.springframework.boot:spring-boot-configuration-processor</code><br>配置对应的实体类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"graduate.main"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String delimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>应用配置类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MainConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoCustomConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>application.yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">graduate:</span></span><br><span class="line"><span class="attr">  main:</span></span><br><span class="line"><span class="attr">    delimiter:</span> <span class="string">,</span></span><br></pre></td></tr></table></figure></p><hr><h2 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h2><p>默认可以通过 application.properties 配置框架的日志,以及应用具体到包和类的日志等级,日志文件等等</p><blockquote><p><a href="https://www.cnblogs.com/lixuwu/p/5804793.html" target="_blank" rel="noopener">参考博客: Spring boot——logback 基础使用篇（一）</a></p></blockquote><blockquote><p><a href="https://springframework.guru/using-logback-spring-boot/" target="_blank" rel="noopener">参考博客: springboot use logback</a><code>能根据Profile配置,还能写if</code></p></blockquote><p>使用 logback 则需要配置 logback.xml 或者 logback-spring.xml 建议使用后者</p><hr><h2 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h2><h3 id="Lisener"><a href="#Lisener" class="headerlink" title="Lisener"></a>Lisener</h3><h4 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Servlet容器初始化"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Servlet容器销毁"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上传下载文件"><a href="#上传下载文件" class="headerlink" title="上传下载文件"></a>上传下载文件</h3><blockquote><p>第一种直接上传到应用的webroot或者resources目录下，第二种上传到数据库中，第三种使用ftp。</p></blockquote><ul><li><a href="http://www.cnblogs.com/studyCenter/p/6665171.html" target="_blank" rel="noopener">Springboot上传文件</a></li><li>上传文件有大小限制，使用如下方法进行配置 <a href="http://makaidong.com/studyDetail/11882_45833.html" target="_blank" rel="noopener">参考博客</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipartConfigElement <span class="title">multipartConfigElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MultipartConfigFactory factory = <span class="keyword">new</span> MultipartConfigFactory();</span><br><span class="line">    <span class="comment">//单个文件最大</span></span><br><span class="line">    factory.setMaxFileSize(<span class="string">"80MB"</span>); <span class="comment">//KB,MB</span></span><br><span class="line">    <span class="comment">// 设置总上传数据总大小</span></span><br><span class="line">    factory.setMaxRequestSize(<span class="string">"102400KB"</span>);</span><br><span class="line">    <span class="keyword">return</span> factory.createMultipartConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="错误页面跳转配置"><a href="#错误页面跳转配置" class="headerlink" title="错误页面跳转配置"></a>错误页面跳转配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">containerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (container -&gt; &#123;</span><br><span class="line">            ErrorPage error401Page = <span class="keyword">new</span> ErrorPage(HttpStatus.FORBIDDEN, <span class="string">"/403.html"</span>);</span><br><span class="line">            ErrorPage error404Page = <span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">"/404.html"</span>);</span><br><span class="line">            ErrorPage error500Page = <span class="keyword">new</span> ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, <span class="string">"/500.html"</span>);</span><br><span class="line">            container.addErrorPages(error401Page, error404Page, error500Page);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><blockquote><p>不同的域名（主机）端口都会导致跨域问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> CorsConfiguration <span class="title">buildConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>); <span class="comment">// 允许任何域名使用</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>); <span class="comment">// 允许任何头</span></span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">"*"</span>); <span class="comment">// 允许任何方法（post、get等）</span></span><br><span class="line">        <span class="keyword">return</span> corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, buildConfig()); <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><ol><li>新建类, 加上注解 ControllerAdvice</li><li>方法上使用注解 <code>ExceptionHandler(Exception.class)</code> 处理所有异常</li><li>然后返回值的写法和普通Controller一样, 返回JSON就<code>ResponseBody</code></li></ol><hr><h2 id="HTTPS的配置"><a href="#HTTPS的配置" class="headerlink" title="HTTPS的配置"></a>HTTPS的配置</h2><blockquote><p><a href="https://www.drissamri.be/blog/java/enable-https-in-spring-boot/" target="_blank" rel="noopener">参考博客</a></p></blockquote><ul><li>签发证书：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -<span class="built_in">alias</span> tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  context-path:</span> <span class="string">/myth</span></span><br><span class="line"><span class="attr">  ssl:</span></span><br><span class="line"><span class="attr">    key-store:</span> <span class="attr">classpath:keystore.p12</span></span><br><span class="line"><span class="attr">    key-store-password:</span> <span class="string">demo1429336</span></span><br><span class="line"><span class="attr">    key-store-type:</span> <span class="string">PKCS12</span></span><br><span class="line"><span class="attr">    key-alias:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">  session:</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p><code>任意的一个@Configuration注解类里添加</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="title">servletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TomcatEmbeddedServletContainerFactory factory =</span><br><span class="line">        <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//SecurityConstraint必须存在，可以通过其为不同的URL设置不同的重定向策略。</span></span><br><span class="line">                SecurityConstraint securityConstraint = <span class="keyword">new</span> SecurityConstraint();</span><br><span class="line">                securityConstraint.setUserConstraint(<span class="string">"CONFIDENTIAL"</span>);</span><br><span class="line">                SecurityCollection collection = <span class="keyword">new</span> SecurityCollection();</span><br><span class="line">                collection.addPattern(<span class="string">"/*"</span>);</span><br><span class="line">                securityConstraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(securityConstraint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    factory.addAdditionalTomcatConnectors(createHttpConnector());</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connector <span class="title">createHttpConnector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connector connector = <span class="keyword">new</span> Connector(<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>);</span><br><span class="line">    connector.setScheme(<span class="string">"http"</span>);</span><br><span class="line">    connector.setSecure(<span class="keyword">false</span>);</span><br><span class="line">    connector.setPort(<span class="number">8887</span>);<span class="comment">//http端口（这是要新增加的一个端口）</span></span><br><span class="line">    connector.setRedirectPort(<span class="number">8888</span>);<span class="comment">// https 端口配置文件中tomcat启动的默认端口</span></span><br><span class="line">    <span class="keyword">return</span> connector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>另一种方式 <a href="http://www.cnblogs.com/xinzhao/p/4950689.html" target="_blank" rel="noopener">参考博客</a><br><code>方式不一样，没有成功</code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############ 证书颁发机构</span></span><br><span class="line"><span class="comment"># CA机构私钥</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"><span class="comment"># CA证书</span></span><br><span class="line">openssl req -x509 -new -key ca.key -out ca.crt</span><br><span class="line"><span class="comment">############ 服务端</span></span><br><span class="line"><span class="comment"># 生成服务端私钥</span></span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"><span class="comment"># 生成服务端证书请求文件</span></span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line"><span class="comment"># 使用CA证书生成服务端证书  关于sha256，默认使用的是sha1，在新版本的chrome中会被认为是不安全的，因为使用了过时的加密算法。</span></span><br><span class="line">openssl x509 -req -sha256 -<span class="keyword">in</span> server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650 -out server.crt    </span><br><span class="line"><span class="comment"># 打包服务端的资料为pkcs12格式(非必要，只是换一种格式存储上一步生成的证书) 生成过程中，需要创建访问密码，请记录下来。</span></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -<span class="keyword">in</span> server.crt -inkey server.key -out server.pkcs12</span><br><span class="line"><span class="comment"># 生成服务端的keystore（.jks文件, 非必要，Java程序通常使用该格式的证书） 生成过程中，需要创建访问密码，请记录下来。</span></span><br><span class="line">keytool -importkeystore -srckeystore server.pkcs12 -destkeystore server.jks -srcstoretype pkcs12</span><br><span class="line"><span class="comment"># 把ca证书放到keystore中（非必要）</span></span><br><span class="line">keytool -importcert -keystore server.jks -file ca.crt</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li><a href="https://hacpai.com/article/1501152977477?p=1&amp;m=0" target="_blank" rel="noopener">参考博客</a></li><li>多线程以及异常处理 <a href="http://www.liuhaihua.cn/archives/496733.html" target="_blank" rel="noopener">参考博客</a><ul><li>因为多线程的特性，所以异常只能在子线程中处理不能抛出到主线程里，但是 Spring实现的线程池可以返回一个异常信息对象</li></ul></li></ul><hr><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><h3 id="生成指定文件"><a href="#生成指定文件" class="headerlink" title="生成指定文件"></a>生成指定文件</h3><h4 id="war"><a href="#war" class="headerlink" title="war"></a>war</h4><ul><li><p>部署为war必须的类，一般在创建项目时选war就会自动生成，选jar就要手动添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(DemoApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>maven： <code>mvn war</code> 即可 mvn package -DskipTests</p></li><li>gradle: <code>gradle war</code> 然后 <code>gradle bootRepackage</code> 即可</li></ul><h4 id="jar"><a href="#jar" class="headerlink" title="jar"></a>jar</h4><ul><li>没有特殊的配置，打包即用<ul><li>maven: <code>mvn package</code> 即可生成可执行的jar</li><li>gradle:<code>gradle jar</code> 然后 <code>gradle bootRepackage</code> 也生成可执行jar</li></ul></li></ul><h3 id="构建docker镜像"><a href="#构建docker镜像" class="headerlink" title="构建docker镜像"></a>构建docker镜像</h3><blockquote><p>方便监控应用状态，cpu 内存 流量, <a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">官方文档</a></p></blockquote><h4 id="手动方式"><a href="#手动方式" class="headerlink" title="手动方式"></a>手动方式</h4><ul><li>先构建得到war或jar，然后根据dockerfile构建一个镜像<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> frolvlad/alpine-oraclejdk8:slim</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> weixin-1.0.0.war app.war</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.war"</span>]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="gradle结合docker"><a href="#gradle结合docker" class="headerlink" title="gradle结合docker"></a>gradle结合docker</h4><h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><blockquote><p><a href="https://nilzzzz.github.io/2017/11/SpringBoot1/" target="_blank" rel="noopener">参考博客: SpringBoot热部署</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#springboot&quot;&gt;SpringBoot&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#思考&quot;&gt;思考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#参考教程&quot;&gt;参考教程&lt;/a
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="SpringBoot" scheme="http://blog.kuangcp.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringAOP</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringAOP/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-SpringAOP/</id>
    <published>2018-12-21T02:49:23.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#aop">AOP</a><ol><li><a href="#动态代理">动态代理</a><ol><li><a href="#asm">asm</a></li><li><a href="#cglib">cglib</a></li></ol></li><li><a href="#基本概念">基本概念</a></li><li><a href="#基本配置">基本配置</a></li><li><a href="#注意">注意</a><ol><li><a href="#1-spring-aop还是完全用aspectj">1 Spring AOP还是完全用AspectJ？</a></li><li><a href="#2-spring-aop中使用@aspectj还是xml">2 Spring AOP中使用@AspectJ还是XML？</a></li><li><a href="#3-混合切面类型">3 混合切面类型</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><blockquote><p>Aspect Oriented Programming  面向切面编程</p></blockquote><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><blockquote><p>这是AOP的起源, 最初是JDK的动态Proxy -&gt; cglib/asm </p></blockquote><blockquote><p><a href="https://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">参考博客: Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a></p></blockquote><h3 id="asm"><a href="#asm" class="headerlink" title="asm"></a>asm</h3><h3 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h3><blockquote><p>基于asm</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><table><thead><tr><th style="text-align:left">英文</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>JoinPoint</code></td><td style="text-align:left">切入面、连接点、切入点（所有方法）</td></tr><tr><td style="text-align:left"><code>PointCut</code></td><td style="text-align:left">切点（特殊的连接点，需要增强的连接点）</td></tr><tr><td style="text-align:left"><code>Advice</code></td><td style="text-align:left">增强（切入点的逻辑，待添加的功能）</td></tr><tr><td style="text-align:left"><code>Aspect</code></td><td style="text-align:left">切面（切点和增强的合集）</td></tr><tr><td style="text-align:left"><code>Target</code></td><td style="text-align:left">目标对象（被增强的实例）</td></tr><tr><td style="text-align:left"><code>Weave</code></td><td style="text-align:left">织入（增强切点的过程）</td></tr><tr><td style="text-align:left"><code>Proxy</code></td><td style="text-align:left">代理（增强后的类，一般是使用了代理类） 装饰器模式</td></tr><tr><td style="text-align:left"><code>Introduction</code></td><td style="text-align:left">引介（为类添加属性和方法） 用的较少因为破坏了OOP思想</td></tr></tbody></table><hr><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p><code>XML文件头</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>方法级别的添加代理，Servlet中的过滤器也类似（但是那个是类级别的）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基本类 提供切点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"cn.spring.aop.Student"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 增强部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"adder"</span> <span class="attr">class</span>=<span class="string">"cn.spring.aop.NewDeal"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用aop的自动提示也要配置上面的头文件声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aspect表示切面 ref 标明增强方法的类来源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myAop"</span> <span class="attr">ref</span>=<span class="string">"adder"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- execution 是表达式（正则一样的功能）匹配的是具体的切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.spring.aop.Student.run(..))"</span> <span class="attr">id</span>=<span class="string">"needAdd"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 织入 的过程 将增强和切入点结合 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"add"</span> <span class="attr">pointcut-ref</span>=<span class="string">"needAdd"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"af"</span> <span class="attr">pointcut-ref</span>=<span class="string">"needAdd"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"around"</span> <span class="attr">pointcut-ref</span>=<span class="string">"needAdd"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>要注意环绕的写法 <code>public void around(ProceedingJoinPoint m)throws Throwable{</code>  </p><ul><li><a href="https://www.oschina.net/code/snippet_246557_9205" target="_blank" rel="noopener">Spring AOP中的around</a>  </li></ul></li><li><p>然后在test类中直接getBean（基类）但是实际上是获取到的是装饰好的代理对象  </p><ul><li><a href="http://blog.csdn.net/yuqinying112/article/details/7335416" target="_blank" rel="noopener">Spring AOP配置(转)</a>  </li><li><a href="http://www.cnblogs.com/yangy608/archive/2010/11/14/1876833.html" target="_blank" rel="noopener">aop:config详解</a>  </li></ul></li><li><p>善用debug 调试看是否获取到的是代理对象 $proxy</p></li><li><p>在Spring的配置文件中，所有的切面和通知器都必须定义在<code>&lt;aop:config&gt;</code> 元素内部。 一个<code>application context</code>可以包含多个 <code>&lt;aop:config&gt;</code>。 一个<code>&lt;aop:config&gt;</code> 可以包含 <code>pointcut</code>， <code>advisor</code> 和 <code>aspect</code> 元素（注意它们必须按照这样的顺序进行声明）。 </p></li></ul><h3 id="1-Spring-AOP还是完全用AspectJ？"><a href="#1-Spring-AOP还是完全用AspectJ？" class="headerlink" title="1 Spring AOP还是完全用AspectJ？"></a>1 Spring AOP还是完全用AspectJ？</h3><p>做能起作用的最简单的事。Spring AOP比完全使用AspectJ更加简单，因为它不需要引入AspectJ的编译器／织入器到你开发和构建过程中。<br>如果你仅仅需要在Spring bean上通知执行操作，那么Spring AOP是合适的选择。如果你需要通知domain对象或其它没有在Spring容器中<br>管理的任意对象，那么你需要使用AspectJ。如果你想通知除了简单的方法执行之外的连接点（如：调用连接点、字段get或set的连接点等等），<br>也需要使用AspectJ。<br>当使用AspectJ时，你可以选择使用AspectJ语言（也称为“代码风格”）或@AspectJ注解风格。<br>如果切面在你的设计中扮演一个很大的角色，并且你能在Eclipse中使用AspectJ Development Tools (AJDT)， 那么首选AspectJ语言 :-<br>因为该语言专门被设计用来编写切面，所以会更清晰、更简单。如果你没有使用<br>Eclipse，或者在你的应用中只有很少的切面并没有作为一个主要的角色，你或许应该考虑使用@AspectJ风格<br>并在你的IDE中附加一个普通的Java编辑器，并且在你的构建脚本中增加切面织入（链接）的段落。</p><h3 id="2-Spring-AOP中使用-AspectJ还是XML？"><a href="#2-Spring-AOP中使用-AspectJ还是XML？" class="headerlink" title="2 Spring AOP中使用@AspectJ还是XML？"></a>2 Spring AOP中使用@AspectJ还是XML？</h3><p>如果你选择使用Spring AOP，那么你可以选择@AspectJ或者XML风格。总的来说，如果你使用Java 5， 我们建议使用@AspectJ风格。<br>显然如果你不是运行在Java 5上，XML风格是最佳选择。XML和@AspectJ 之间权衡的细节将在下面进行讨论。<br>XML风格对现有的Spring用户来说更加习惯。它可以使用在任何Java级别中（参考连接点表达式内部的命名连接点，虽然它也需要Java 5）<br>并且通过纯粹的POJO来支持。当使用AOP作为工具来配置企业服务时（一个好的例子是当你认为连接点表达式是你的配置中的一部分时，<br>你可能想单独更改它）XML会是一个很好的选择。对于XML风格，从你的配置中可以清晰的表明在系统中存在那些切面。<br>XML风格有两个缺点。第一是它不能完全将需求实现的地方封装到一个位置。DRY原则中说系统中的每一项知识都必须具有单一、无歧义、权威的表示。<br>当使用XML风格时，如何实现一个需求的知识被分割到支撑类的声明中以及XML配置文件中。当使用@AspectJ风格时就只有一个单独的模块 -切面-<br>信息被封装了起来。 第二是XML风格同@AspectJ风格所能表达的内容相比有更多的限制：仅仅支持”singleton”切面实例模型，并且不能在XML中组合命名连接点的声<br>明。 例如，在@AspectJ风格中我们可以编写如下的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(execution(* get*())) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">propertyAccess</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line"><span class="meta">@Pointcut</span>(execution(org.xyz.Account+ *(..)) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationReturningAnAccount</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line"><span class="meta">@Pointcut</span>(propertyAccess() &amp;&amp; operationReturningAnAccount()) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountPropertyAccess</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在XML风格中能声明开头的两个连接点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"propertyAccess"</span> <span class="attr">expression</span>=<span class="string">"execution(* get*())"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"operationReturningAnAccount"</span>  <span class="attr">expression</span>=<span class="string">"execution(org.xyz.Account+ *(..))"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>但是不能通过组合这些来定义accountPropertyAccess连接点</p><ul><li>@AspectJ风格支持其它的实例模型以及更丰富的连接点组合。它具有将将切面保持为一个模块单元的优点。 还有一个优点就是@AspectJ切面能被Spring AOP和AspectJ两者都理解 </li><li>所以如果稍后你认为你需要AspectJ 的能力去实现附加的需求，那么你非常容易转移到基于AspectJ的途径。总而言之，我们更喜欢@AspectJ风格只要你有切面 去做超出简单的“配置”企业服务之外的事情。</li></ul><h3 id="3-混合切面类型"><a href="#3-混合切面类型" class="headerlink" title="3 混合切面类型"></a>3 混合切面类型</h3><p>我们完全可以混合使用以下几种风格的切面定义：使用自动代理的@AspectJ 风格的切面，<code>schema-defined &lt;aop:aspect&gt;</code> 的切面，<br>和用 <code>&lt;aop:advisor&gt;</code> 声明的advisor，甚至是使用Spring 1.2风格的代理和拦截器。<br>由于以上几种风格的切面定义的都使用了相同的底层机制，因此可以很好的共存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#aop&quot;&gt;AOP&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#动态代理&quot;&gt;动态代理&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#asm&quot;&gt;asm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://blog.kuangcp.top/tags/Spring/"/>
    
      <category term="AOP" scheme="http://blog.kuangcp.top/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring5</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-Spring5/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-Spring5/</id>
    <published>2018-12-21T02:46:16.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#spring5">Spring5</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Spring5"><a href="#Spring5" class="headerlink" title="Spring5"></a>Spring5</h1><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-whats-new-in-spring-framework-5-theedom/index.html" target="_blank" rel="noopener">Spring Framework 5 中的新特性</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#spring5&quot;&gt;Spring5&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-13 12:06&lt;/em&gt;| &lt;a
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://blog.kuangcp.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-Spring/"/>
    <id>http://blog.kuangcp.top/2018/12/21/Memo-Java-Spring-Spring/</id>
    <published>2018-12-21T02:46:01.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#spring">Spring</a><ol><li><a href="#配置使用">配置使用</a><ol><li><a href="#通过构建工具">通过构建工具</a></li><li><a href="#注解方式">注解方式</a><ol><li><a href="#xml文件配置">xml文件配置</a></li><li><a href="#常用的注解">常用的注解</a></li></ol></li><li><a href="#xml方式">xml方式</a><ol><li><a href="#xml方式和注解方式的比较">xml方式和注解方式的比较</a></li></ol></li></ol></li><li><a href="#spring技巧">Spring技巧</a><ol><li><a href="#获取context上下文环境">获取Context上下文环境</a><ol><li><a href="#在jsp或servlet中获取">在JSP或Servlet中获取</a></li></ol></li><li><a href="#spring-和-servletcontextlist">Spring 和 ServletContextList</a></li></ol></li></ol></li><li><a href="#基础">基础</a><ol><li><a href="#生命周期">生命周期</a></li><li><a href="#iocdi-控制反转">IOC/DI 控制反转</a></li><li><a href="#scheduling">Scheduling</a></li><li><a href="#websocket">Websocket</a><ol><li><a href="#maven配置">maven配置</a></li></ol></li><li><a href="#web开发上的一些优秀的习惯">Web开发上的一些优秀的习惯</a></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-13 12:06</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><blockquote><p><a href="https://spring.io/" target="_blank" rel="noopener">Spring官网</a> | <a href="http://www.spring4all.com/" target="_blank" rel="noopener">spring4all社区</a></p></blockquote><blockquote><p><a href="http://www.spring4all.com/article/558" target="_blank" rel="noopener">Spring For All 社区 -&gt;  Spring 官方教程翻译</a></p></blockquote><blockquote><p><a href="https://www.tutorialspoint.com/spring/index.htm" target="_blank" rel="noopener">Spring Tutorial</a></p></blockquote><h2 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h2><blockquote><p><strong>通过原始的复制jar方式 :</strong> 官网下载对应的jar, 添加到ide中</p></blockquote><h3 id="通过构建工具"><a href="#通过构建工具" class="headerlink" title="通过构建工具"></a>通过构建工具</h3><p>Maven 中 pom.xml 中, Gradle是 build.gradle 添加以下等依赖:</p><p><em>核心依赖</em></p><ol><li>spring-core</li><li>spring-beans</li><li>spring-context</li></ol><p><em>其他,可选</em></p><ol><li>spring-aop</li><li>spring-websocket</li><li>spring-jdbc </li><li>spring-tx </li><li>spring-web</li><li>spring-webmvc</li><li>spring-test</li></ol><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><blockquote><p>需要在配置文件 xml配置文件 中配置包扫描 才能生效</p></blockquote><h4 id="xml文件配置"><a href="#xml文件配置" class="headerlink" title="xml文件配置"></a>xml文件配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 头部分要添加Context --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对使用了注解的包进行扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.github.kuangcp"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> 只需要这个配置文件就可以使用注解来使用Spring框架</p></blockquote><h4 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h4><ul><li><p>标注为bean</p><ul><li><code>@Component([value=]&quot;id&quot;)</code>不写则默认是当前类名</li><li>@Entity</li><li>@Service</li><li>@Repository</li><li>@Controller 和 @RestController</li></ul></li><li><p>自动注入</p><ul><li><code>@Resource([value=]&quot;id&quot;)</code> 按名字注入</li><li><code>@Autowried</code> 根据类型自动注入（只对单例起作用）和 <code>Resource(类名首字母小写)</code> 等价</li><li><code>@Qualifier(&quot;id&quot;)</code>自动注入后的进一步精确（多个的情况：）</li></ul></li><li><p><strong>注意 :</strong> 关于自动注入, 在属性上打 @Autowried 注解是不建议的, 作者建议采用构造器方式:  <a href="http://olivergierke.de/2013/11/why-field-injection-is-evil/" target="_blank" rel="noopener">Why field injection is evil</a></p><ul><li>如果使用了 lombok 那么可以在类上使用 <ul><li><code>@RequiredArgsConstructor(onConstructor = @__(@Autowired))</code></li><li>然后注入的属性打上 <code>@NonNull</code> 注解</li><li>本质上是帮你自动生成了一个将所有 <code>@NonNull</code> 注解属性作为参数的构造器</li></ul></li></ul></li><li><p>AOP</p><ul><li>@Aspect 注明是切面类</li><li>@Before(“execution(public void com.wjt276.dao.impl.UserDaoImpl.save(com.wjt276.model.User))”) 和xml方式的before对应</li></ul></li><li><p>bean扫描</p><ul><li>ComponentScan 扫描指定包下Spring注解的类</li></ul></li></ul><blockquote><p><a href="http://olivergierke.de/2013/11/why-field-injection-is-evil/" target="_blank" rel="noopener">参考博客: Why field injection is evil</a></p></blockquote><hr><h3 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h3><ul><li>只用到bean的头，主要配置内容：<code>&lt;bean&gt;&lt;property&gt;&lt;/property&gt;&lt;/bean&gt;</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- 对使用了注解的包进行扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.spring.aop"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 一般而言，bean都是单实例的 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"cn.spring.entity.Person"</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"myth"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"addr"</span> <span class="attr">value</span>=<span class="string">"vol"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"construct"</span> <span class="attr">class</span>=<span class="string">"cn.spring.entity.ConstructorEntity"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 如果是不同的类型的参数 顺序可以随意，但是数据类型一样的话就要严格按顺序了--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"String_1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 注意引用类型是要写全路径，基本数据类型是可以直接写小写 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;constructor-arg type="java.lang.String" value="String_2"&gt;&lt;/constructor-arg&gt; --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"TestConstruct"</span> <span class="attr">class</span>=<span class="string">"cn.spring.entity.TestConstruct"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"entity"</span> <span class="attr">ref</span>=<span class="string">"construct"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 加载属性文件 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"property_config"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>cn/spring/entity/db.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 测试获取属性文件 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"show_db"</span> <span class="attr">class</span>=<span class="string">"cn.spring.entity.TestProperties"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 特别注意大小写问题 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="xml方式和注解方式的比较"><a href="#xml方式和注解方式的比较" class="headerlink" title="xml方式和注解方式的比较"></a>xml方式和注解方式的比较</h4><ul><li>当你确定切面是实现一个给定需求的最佳方法时，你如何选择是使用Spring AOP还是AspectJ，以及选择 Aspect语言（代码）风格、@AspectJ声明风格或XML风格？</li><li>这个决定会受到多个因素的影响，包括应用的需求、 开发工具和小组对AOP的精通程度。</li><li><strong>个人理解</strong>：使用bean的时候使用注解，AOP使用xml方式，更直观</li></ul><hr><h2 id="Spring技巧"><a href="#Spring技巧" class="headerlink" title="Spring技巧"></a>Spring技巧</h2><h3 id="获取Context上下文环境"><a href="#获取Context上下文环境" class="headerlink" title="获取Context上下文环境"></a>获取Context上下文环境</h3><h4 id="在JSP或Servlet中获取"><a href="#在JSP或Servlet中获取" class="headerlink" title="在JSP或Servlet中获取"></a>在JSP或Servlet中获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(config.getServletContext());</span><br></pre></td></tr></table></figure><h3 id="Spring-和-ServletContextList"><a href="#Spring-和-ServletContextList" class="headerlink" title="Spring 和 ServletContextList"></a>Spring 和 ServletContextList</h3><ul><li>想要启动Tomcat之后，初始化运行一些方法，把数据从数据库拿出放入redis中，然后使用了ServletContextListener<ul><li>然后还是按照往常一样的使用Spring自动注入的便利，来使用service层获取数据，但是忽略了启动顺序</li><li><strong>context-param -&gt; listener -&gt; filter -&gt; servlet</strong></li><li>所以在启动这个初始化方法的时候，其实Spring的环境是还没有加载的，所以没有扫描，也就没有了自动注入，也就有了空指针异常</li><li>所以要使用如下方法得到Spring的Context（上下文），获取bean，再操作</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123; </span><br><span class="line">        ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(event.getServletContext());</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"># 基础</span><br><span class="line">## 生命周期</span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"></span><br><span class="line">- [ ] 完善</span><br><span class="line"></span><br><span class="line">##  IOC/DI 控制反转</span><br><span class="line">- DI 译为依赖注入 所有的bean都在IOC容器中（单例的）多例的不在该容器中进行管理</span><br><span class="line">- 通过注入 可以注入基本属性 对象属性，集合属性，构造器，properties等</span><br><span class="line">- 不采用Spring的IOC容器使用Java基础来实现：</span><br><span class="line">   - **静态代理** </span><br><span class="line">       - 针对每个具体类分别编写代理类</span><br><span class="line">       - 针对一个接口编写一个代理类</span><br><span class="line">   - **动态代理**</span><br><span class="line">       - 针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类 </span><br><span class="line"></span><br><span class="line">属性上 <span class="meta">@Autowired</span> 即可, 但是现在不建议直接在属性上使用注解, 而是建议在构造器上, 为了避免 手动使用<span class="keyword">new</span> 实例化Bean, 然后里面本该注入的属性全部为<span class="keyword">null</span></span><br><span class="line">可以用lombok来协助</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(onConstructor = @__(<span class="meta">@Autowired</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> look up 方法注入</li></ul><hr><h2 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h2><blockquote><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#scheduling" target="_blank" rel="noopener">Official Doc</a></p></blockquote><blockquote><p><a href="https://www.baeldung.com/spring-scheduled-tasks" target="_blank" rel="noopener">参考博客: The @Scheduled Annotation in Spring</a><br><a href="http://qinghua.github.io/spring-scheduler/" target="_blank" rel="noopener">参考博客: Spring Scheduler的使用与坑</a><br><a href="https://www.cnblogs.com/jingmoxukong/p/5825806.html#%E5%AE%8C%E6%95%B4%E8%8C%83%E4%BE%8B" target="_blank" rel="noopener">参考博客: [Spring]支持注解的Spring调度器</a><br><a href="https://blog.csdn.net/yyx1025988443/article/details/78698046" target="_blank" rel="noopener">参考博客: spring scheduled的动态线程池调度和任务进度的监控</a></p></blockquote><p>其主体是 TaskExecutor 和 TaskScheduler 组成的, 也就是调度和执行</p><ul><li><a href="http://www.cronmaker.com/" target="_blank" rel="noopener">cron maker</a></li><li><a href=""></a></li></ul><hr><h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><h3 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-messaging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> Spring方式, 现在用boot用多了, 都忘了怎么配置Spring了</li></ul><hr><h2 id="Web开发上的一些优秀的习惯"><a href="#Web开发上的一些优秀的习惯" class="headerlink" title="Web开发上的一些优秀的习惯"></a>Web开发上的一些优秀的习惯</h2><ul><li>使用AOP来简化开发MVC的代码</li><li>繁杂的代码如何简化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#spring&quot;&gt;Spring&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#配置使用&quot;&gt;配置使用&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#通过构建工具&quot;&gt;通过构建工具&lt;/a&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://blog.kuangcp.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java处理时间</title>
    <link href="http://blog.kuangcp.top/2018/12/20/Memo-Java-AdvancedLearning-JavaDealWithTime/"/>
    <id>http://blog.kuangcp.top/2018/12/20/Memo-Java-AdvancedLearning-JavaDealWithTime/</id>
    <published>2018-12-20T02:44:57.000Z</published>
    <updated>2018-12-21T03:02:53.350Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#java-处理时间">Java 处理时间</a></li></ol><p><strong>目录 end</strong>|<em>2018-12-20 10:44</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="Java-处理时间"><a href="#Java-处理时间" class="headerlink" title="Java 处理时间"></a>Java 处理时间</h1><ol><li>SimpleDateFormat  <code>YYYY-MM-dd HH:MM:SS</code><ul><li>线程不安全, Java8 中使用 DateTimeFormatter 更好</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#java-处理时间&quot;&gt;Java 处理时间&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;目录 end&lt;/strong&gt;|&lt;em&gt;2018-12-20 10:44&lt;/em&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="Time" scheme="http://blog.kuangcp.top/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://blog.kuangcp.top/2018/12/20/Memo-Java-ZenOfPattern/"/>
    <id>http://blog.kuangcp.top/2018/12/20/Memo-Java-ZenOfPattern/</id>
    <published>2018-12-20T02:43:55.000Z</published>
    <updated>2018-12-21T03:02:53.350Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#设计模式之禅">设计模式之禅</a><ol><li><a href="#软件设计的一些原则">软件设计的一些原则</a><ol><li><a href="#思维原则">思维原则</a><ol><li><a href="#奥卡姆剃刀原理">奥卡姆剃刀原理</a></li></ol></li><li><a href="#首要原则">首要原则</a><ol><li><a href="#勿重复造轮子">勿重复造轮子</a></li><li><a href="#减法优于加法">减法优于加法</a></li><li><a href="#抽象优于实现">抽象优于实现</a></li><li><a href="#组合优于继承">组合优于继承</a></li><li><a href="#查询与命令分离">查询与命令分离</a></li><li><a href="#够用原则">够用原则</a></li><li><a href="#最少知识原则">最少知识原则</a></li></ol></li><li><a href="#面向对象的solid-原则">面向对象的S.O.L.I.D 原则</a><ol><li><a href="#单一职责原则">单一职责原则</a></li><li><a href="#开闭原则">开闭原则</a></li><li><a href="#里氏代换原则">里氏代换原则</a></li><li><a href="#接口隔离原则">接口隔离原则</a></li><li><a href="#依赖倒置原则">依赖倒置原则</a></li></ol></li><li><a href="#其他原则">其他原则</a><ol><li><a href="#共同封闭原则">共同封闭原则</a></li><li><a href="#共同重用原则">共同重用原则</a></li><li><a href="#好莱坞原则">好莱坞原则</a></li><li><a href="#高内聚低耦合">高内聚低耦合</a></li><li><a href="#惯例优于配置原则">惯例优于配置原则</a></li><li><a href="#关注点分离">关注点分离</a></li><li><a href="#契约式设计">契约式设计</a></li><li><a href="#无环依赖原则">无环依赖原则</a></li></ol></li></ol></li><li><a href="#设计模式">设计模式</a><ol><li><a href="#基础">基础</a></li><li><a href="#策略者模式">策略者模式</a></li><li><a href="#1创建型设计模式">1.创建型设计模式</a></li><li><a href="#2结构型设计模式">2.结构型设计模式</a></li><li><a href="#3行为设计模式">3.行为设计模式</a></li><li><a href="#常见设计模式">【常见设计模式】</a><ol><li><a href="#适配器模式">适配器模式</a></li><li><a href="#中介者模式">中介者模式</a></li><li><a href="#观察者模式">观察者模式</a><ol><li><a href="#单例模式">单例模式</a></li><li><a href="#装饰器模式">装饰器模式</a></li></ol></li><li><a href="#原型模式">原型模式</a></li><li><a href="#生成器模式">生成器模式</a></li></ol></li></ol></li><li><a href="#实践">实践</a><ol><li><a href="#经验之谈">经验之谈</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-20 10:44</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h1><h2 id="软件设计的一些原则"><a href="#软件设计的一些原则" class="headerlink" title="软件设计的一些原则"></a>软件设计的一些原则</h2><h3 id="思维原则"><a href="#思维原则" class="headerlink" title="思维原则"></a>思维原则</h3><h4 id="奥卡姆剃刀原理"><a href="#奥卡姆剃刀原理" class="headerlink" title="奥卡姆剃刀原理"></a>奥卡姆剃刀原理</h4><h3 id="首要原则"><a href="#首要原则" class="headerlink" title="首要原则"></a>首要原则</h3><h4 id="勿重复造轮子"><a href="#勿重复造轮子" class="headerlink" title="勿重复造轮子"></a>勿重复造轮子</h4><p>-<code>DRY Don’t Repeat Yourself</code><br>是一个最简单的法则，也是最容易被理解的。但它也可能是最难被应用的（因为要做到这样，我们需要在泛型设计上做相当的努力，这并不是一件容易的事）。它意味着，当我们在两个或多个地方的时候发现一些相似的代码的时候，我们需要把他们的共性抽象出来形一个唯一的新方法，并且改变现有的地方的代码让他们以一些合适的参数调用这个新的方法。</p><h4 id="减法优于加法"><a href="#减法优于加法" class="headerlink" title="减法优于加法"></a>减法优于加法</h4><ul><li><code>KISS Keep It Simple, Stupid</code><br>KISS原则在设计上可能最被推崇的，在家装设计，界面设计 ，操作设计上，复杂的东西越来越被众人所BS了，而简单的东西越来越被人所认可，比如这些UI的设计和我们中国网页（尤其是新浪的网页）者是负面的例子。<br>“宜家”（IKEA）简约、效率的家居设计、生产思路；“微软”（Microsoft）“所见即所得”的理念；“谷歌”（Google)简约、直接的商业风格，无一例外的遵循了“kiss”原则，<br>也正是“kiss”原则，成就了这些看似神奇的商业经典。而苹果公司的iPhone/iPad将这个原则实践到了极至。</li></ul><p>把一个事情搞复杂是一件简单的事，但要把一个复杂的事变简单，这是一件复杂的事。</p><h4 id="抽象优于实现"><a href="#抽象优于实现" class="headerlink" title="抽象优于实现"></a>抽象优于实现</h4><p>-<code>Program to an interface, not an implementation</code></p><ul><li>这是设计模式中最根本的哲学，注重接口，而不是实现，依赖接口，而不是实现。接口是抽象是稳定的，实现则是多种多样的。</li><li>以后面我们会面向对象的SOLID原则中会提到我们的依赖倒置原则，就是这个原则的的另一种样子。</li></ul><h4 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h4><p><code>【Composition over inheritance】</code></p><ul><li>多使用组合而不是继承, 但是这个观点是存在一定的争议的, 还是要有度的,合理搭配最为重要<ul><li>组合就是将原来继承方式中的父类放到子类作为属性?</li></ul></li></ul><p>组合<br>1.（对象）组合是一种通过创建一个组合了其它对象的对象，从而获得新功能的复用方法。<br>2.将功能委托给所组合的一个对象，从而获得新功能。<br>3.有些时候也称之为”聚合”（aggregation）或”包容”（containment），尽管有些作者对这些术语赋予了专门的含义</p><ul><li style="list-style: none"><input type="checkbox"> 再度思考</li></ul><blockquote><p><a href="http://www.cnblogs.com/narutow/p/8117352.html" target="_blank" rel="noopener">参考博客: 组合、委托与继承，面向对象中类之间的基本关系漫游</a><br><a href="https://www.xuebuyuan.com/1639556.html" target="_blank" rel="noopener">参考博客: 优先使用（对象）组合，而非（类）继承</a></p></blockquote><h4 id="查询与命令分离"><a href="#查询与命令分离" class="headerlink" title="查询与命令分离"></a>查询与命令分离</h4><p><code>【CQS Command-Query Separation】</code></p><ul><li>查询命令分离原则<ul><li>查询：当一个方法返回一个值来回应一个问题的时候，它就具有查询的性质；</li><li>命令：当一个方法要改变对象的状态的时候，它就具有命令的性质；</li></ul></li></ul><h4 id="够用原则"><a href="#够用原则" class="headerlink" title="够用原则"></a>够用原则</h4><p><code>【YAGNI  You Ain’t Gonna Need It 】</code></p><ul><li>这个原则简而言之为——只考虑和设计必须的功能，避免过度设计。只实现目前需要的功能，在以后您需要更多功能时，可以再进行添加。<ul><li>如无必要，勿增复杂性。</li><li>软件开发先是一场沟通博弈。 </li></ul></li></ul><h4 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h4><blockquote><p>【Law of Demeter – 迪米特法则】</p><ul><li>迪米特法则(Law of Demeter)，又称“最少知识原则” <code>（Principle of Least Knowledge）</code>，其来源于1987年荷兰大学的一个叫做Demeter的项目。</li><li>Craig Larman把Law of Demeter又称作“不要和陌生人说话”。在《程序员修炼之道》中讲LoD的那一章叫作“解耦合与迪米特法则”。</li><li>关于迪米特法则有一些很形象的比喻：<ul><li>如果你想让你的狗跑的话，你会对狗狗说还是对四条狗腿说？</li><li>如果你去店里买东西，你会把钱交给店员，还是会把钱包交给店员让他自己拿？ </li></ul></li><li>正式表述如下:</li><li>对于对象 ‘O’ 中一个方法’M’，M应该只能够访问以下对象中的方法:<ul><li>对象O；</li><li>与O直接相关的Component Object；</li><li>由方法M创建或者实例化的对象；</li><li>作为方法M的参数的对象。</li></ul></li></ul></blockquote><blockquote><p><a href="http://zhangyi.xyz/demeter-law-and-refactoring/" target="_blank" rel="noopener">参考博客: 迪米特法则与重构</a></p></blockquote><hr><h3 id="面向对象的S-O-L-I-D-原则"><a href="#面向对象的S-O-L-I-D-原则" class="headerlink" title="面向对象的S.O.L.I.D 原则"></a>面向对象的S.O.L.I.D 原则</h3><ul><li>一般来说这是面向对象的五大设计原则，但是，我觉得这些原则可适用于所有的软件开发。</li></ul><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p><code>Single Responsibility Principle (SRP)</code></p><ul><li>关于单一职责原则，其核心的思想是：<code>一个类，只做一件事，并把这件事做好，且只有一个引起它变化的原因。</code><ul><li>Unix/Linux是这一原则的完美体现者。各个程序都独立负责一个单一的事。</li><li>Windows是这一原则的反面示例。几乎所有的程序都交织耦合在一起。 </li></ul></li></ul><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p><code>Open/Closed Principle (OCP)</code></p><ul><li>关于开发封闭原则，其核心的思想是：模块是可扩展的，而不可修改的。也就是说，<code>对扩展是开放的，而对修改是封闭的。</code><ul><li>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li><li>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。</li></ul></li></ul><h4 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h4><p><code>Liskov substitution principle (LSP)</code></p><ul><li>软件工程大师Robert C. Martin把里氏代换原则最终简化为一句话：<code>“Subtypes must be substitutable for their base types”。</code></li><li><p>也就是，子类必须能够替换成它们的基类。</p><blockquote><p>即：子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现if/else之类对子类类型进行判断的条件。<br>里氏替换原则LSP是使代码符合开闭原则的一个重要保证。正是由于子类型的可替换性才使得父类型的模块在无需修改的情况下就可以扩展。</p></blockquote></li><li><p>这么说来，似乎有点教条化，我非常建议大家看看这个原则个两个最经典的案例——<code>“正方形不是长方形”</code>和<code>“鸵鸟不是鸟”</code>。</p></li><li>通过这两个案例，你会明白《墨子小取》中说的——<code>“娣，美人也，爱娣，非爱美人也….盗，人也；恶盗，非恶人也。”</code>——妹妹虽然是美人，但喜欢妹妹并不代表喜欢美人。</li><li>盗贼是人，但讨厌盗贼也并不代表就讨厌人类。这个原则让你考虑的不是语义上对象的间的关系，而是实际需求的环境。</li><li>在很多情况下，在设计初期我们类之间的关系不是很明确，LSP则给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系。</li><li><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><code>Interface Segregation Principle (ISP)</code></li><li>接口隔离原则意思是把功能实现在接口中，而不是类中，使用多个专门的接口比使用单一的总接口要好。</li><li>举个例子，我们对电脑有不同的使用方式，比如：写作，通讯，看电影，打游戏，上网，编程，计算，数据等，如果我们把这些功能都声明在电脑的抽类里面，那么，我们的上网本，PC机，服务器，</li><li>笔记本的实现类都要实现所有的这些接口，这就显得太复杂了。所以，我们可以把其这些功能接口隔离开来，比如：工作学习接口，编程开发接口，上网娱乐接口，计算和数据服务接口，这样，我们的不同功能的电脑就可以有所选择地继承这些接口。</li><li>这个原则可以提升我们“搭积木式”的软件开发。对于设计来说，Java中的各种Event Listener和Adapter，对于软件开发来说，不同的用户权限有不同的功能，不同的版本有不同的功能，都是这个原则的应用。</li></ul><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p><code>Dependency Inversion Principle (DIP)</code><br>高层模块不应该依赖于低层模块的实现，而是依赖于高层抽象。<br>举个例子，墙面的开关不应该依赖于电灯的开关实现，而是应该依赖于一个抽象的开关的标准接口，这样，当我们扩展程序的时候，我们的开关同样可以控制其它不同的灯，甚至不同的电器。<br>也就是说，电灯和其它电器继承并实现我们的标准开关接口，而我们的开关产商就可不需要关于其要控制什么样的设备，只需要关心那个标准的开关标准。这就是依赖倒置原则。<br>这就好像浏览器并不依赖于后面的web服务器，其只依赖于HTTP协议。这个原则实在是太重要了，社会的分工化，标准化都是这个设计原则的体现。</p><blockquote><p>下面有几点指导意见，帮助你避免在面向对象设计中违反依赖倒置原则：  </p><blockquote><p>变量不能持有具体类的引用，就像订单方法代码中，你看不到new一样。<br>不要让派生自具体类，要派生就派生抽象类abstract<br>不要覆盖基类中已实现的方法，除非你要覆盖的是比较特殊的一部分代码。  </p></blockquote></blockquote><h3 id="其他原则"><a href="#其他原则" class="headerlink" title="其他原则"></a>其他原则</h3><h4 id="共同封闭原则"><a href="#共同封闭原则" class="headerlink" title="共同封闭原则"></a>共同封闭原则</h4><p><code>Common Closure Principle（CCP）</code><br>一个包中所有的类应该对同一种类型的变化关闭。一个变化影响一个包，便影响了包中所有的类。一个更简短的说法是：一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。CCP原则就是把因为某个同样的原因而需要修改的所有类组合进一个包里。如果2个类从物理上或者从概念上联系得非常紧密，它们通常一起发生改变，那么它们应该属于同一个包。</p><p>CCP延伸了开闭原则（OCP）的“关闭”概念，当因为某个原因需要修改时，把需要修改的范围限制在一个最小范围内的包里。</p><h4 id="共同重用原则"><a href="#共同重用原则" class="headerlink" title="共同重用原则"></a>共同重用原则</h4><p><code>Common Reuse Principle (CRP)</code><br>包的所有类被一起重用。如果你重用了其中的一个类，就重用全部。换个说法是，没有被一起重用的类不应该被组合在一起。CRP原则帮助我们决定哪些类应该被放到同一个包里。依赖一个包就是依赖这个包所包含的一切。当一个包发生了改变，并发布新的版本，使用这个包的所有用户都必须在新的包环境下验证他们的工作，即使被他们使用的部分没有发生任何改变。因为如果包中包含有未被使用的类，即使用户不关心该类是否改变，但用户还是不得不升级该包并对原来的功能加以重新测试。</p><p>CCP则让系统的维护者受益。CCP让包尽可能大（CCP原则加入功能相关的类），CRP则让包尽可能小（CRP原则剔除不使用的类）。它们的出发点不一样，但不相互冲突。</p><h4 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h4><p><code>Hollywood Principle</code><br>好莱坞原则就是一句话——“don’t call us, we’ll call<br>you.”。意思是，好莱坞的经纪人们不希望你去联系他们，而是他们会在需要的时候来联系你。也就是说，所有的组件都是被动的，所有的组件初始化和调用都由容器负责。组件处在一个容器当中，由容器负责管理。</p><p>简单的来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在：</p><pre><code>不创建对象，而是描述创建对象的方式。在代码中，对象与服务没有直接联系，而是容器负责将这些联系在一起。</code></pre><p>控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。</p><p>好莱坞原则就是IoC（Inversion of Control）或DI（Dependency Injection）的基础原则。这个原则很像依赖倒置原则，依赖接口，而不是实例，但是这个原则要解决的是怎么把这个实例传入调用类中？你可能把其声明成成员，你可以通过构造函数，你可以通过函数参数。但是<br>IoC可以让你通过配置文件，一个由Service Container<br>读取的配置文件来产生实际配置的类。但是程序也有可能变得不易读了，程序的性能也有可能还会下降。</p><h4 id="高内聚低耦合"><a href="#高内聚低耦合" class="headerlink" title="高内聚低耦合"></a>高内聚低耦合</h4><p><code>【 High Cohesion &amp; Low/Loose coupling &amp; – 高内聚， 低耦合 】</code></p><ul><li>这个原则是UNIX操作系统设计的经典原则，把模块间的耦合降到最低，而努力让一个模块做到精益求精。<ul><li>内聚：一个模块内各个元素彼此结合的紧密程度</li><li>耦合：一个软件结构内不同模块之间互连程度的度量</li></ul></li><li>内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身</li></ul><blockquote><p>凝聚&gt;松耦合&gt;重用  <a href="http://www.jdon.com/forum/messageList.shtml?thread=45977#23144139" target="_blank" rel="noopener">参考博客: 为什么我停止使用Spring?</a></p></blockquote><h4 id="惯例优于配置原则"><a href="#惯例优于配置原则" class="headerlink" title="惯例优于配置原则"></a>惯例优于配置原则</h4><p><code>Convention over Configuration（CoC）</code><br>简单点说，就是将一些公认的配置方式和信息作为内部缺省的规则来使用。例如，Hibernate的映射文件，如果约定字段名和类属性一致的话，基本上就可以不要这个配置文件了。你的应用只需要指定不convention的信息即可，从而减少了大量convention而又不得不花时间和精力啰里啰嗦的东东。配置文件很多时候相当的影响开发效率。</p><p>Rails 中很少有配置文件（但不是没有，数据库连接就是一个配置文件），Rails 的fans号称期开发效率是 java 开发的 10<br>倍，估计就是这个原因。Maven也使用了CoC原则，当你执行mvn<br>-compile命令的时候，不需要指源文件放在什么地方，而编译以后的class文件放置在什么地方也没有指定，这就是CoC原则。</p><h4 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a>关注点分离</h4><p><code>Separation of Concerns (SoC)</code></p><blockquote><p>　是计算机科学中最重要的努力目标之一。这个原则，就是在软件开发中，通过各种手段，将问题的各个关注点分开。如果一个问题能分解为独立且较小的问题，就是相对较易解决的。<br>问题太过于复杂，要解决问题需要关注的点太多，而程序员的能力是有限的，不能同时关注于问题的各个方面。正如程序员的记忆力相对于计算机知识来说那么有限一样，<br>程序员解决问题的能力相对于要解决的问题的复杂性也是一样的非常有限。在我们分析问题的时候，如果我们把所有的东西混在一起讨论，那么就只会有一个结果——乱。</p></blockquote><p>我记得在上一家公司有一个项目，讨论就讨论了1年多，项目本来不复杂，但是没有使用SoC，全部的东西混为一谈，再加上一堆程序员注入了各种不同的观点和想法，整个项目一下子就失控了。<br>最后，本来一个1年的项目做了3年。</p><p>实现关注点分离的方法主要有两种，一种是标准化，另一种是抽象与包装。标准化就是制定一套标准，让使用者都遵守它，将人们的行为统一起来，这样使用标准的人就不用担心别人会有很多种不同的实现，使自己的程序不能和别人的配合。<br>JavaEE就是一个标准的大集合。每个开发者只需要关注于标准本身和他所在做的事情就行了。就像是开发镙丝钉的人只专注于开发镙丝钉就行了，而不用关注镙帽是怎么生产的，反正镙帽和镙丝钉按标来就一定能合得上。不断地把程序的某些部分抽像差包装起来，也是实现关注点分离的好方法。<br>一旦一个函数被抽像出来并实现了，那么使用函数的人就不用关心这个函数是如何实现的，同样的，一旦一个类被抽像并实现了，类的使用者也不用再关注于这个类的内部是如何实现的。<br>诸如组件，分层，面向服务，等等这些概念都是在不同的层次上做抽像和包装，以使得使用者不用关心它的内部实现细节。<br>说白了还是“高内聚，低耦合”。</p><blockquote><p><a href="http://www.cnblogs.com/wenhongyu/p/7992028.html" target="_blank" rel="noopener">参考博客: 理论篇：关注点分离(Separation of concerns, SoC)</a></p></blockquote><h4 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h4><p><code>Design by Contract (DbC)</code><br>DbC的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。例如：</p><pre><code>供应商必须提供某种产品（责任），并且他有权期望客户已经付款（权利）。客户必须付款（责任），并且有权得到产品（权利）。契约双方必须履行那些对所有契约都有效的责任，如法律和规定等。</code></pre><p>同样的，如果在程序设计中一个模块提供了某种功能，那么它要：</p><pre><code>期望所有调用它的客户模块都保证一定的进入条件：这就是模块的先验条件（客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况）。保证退出时给出特定的属性：这就是模块的后验条件——（供应商的义务，显然也是客户的权利）。在进入时假定，并在退出时保持一些特定的属性：不变式。</code></pre><p>契约就是这些权利和义务的正式形式。我们可以用“三个问题”来总结DbC，并且作为设计者要经常问：</p><pre><code>它期望的是什么？它要保证的是什么？它要保持的是什么？</code></pre><p>根据Bertrand<br>Meyer氏提出的DBC概念的描述，对于类的一个方法，都有一个前提条件以及一个后续条件，前提条件说明方法接受什么样的参数数据等，只有前提条件得到满足时，这个方法才能被调用；同时后续条件用来说明这个方法完成时的状态，如果一个方法的执行会导致这个方法的后续条件不成立，那么这个方法也不应该正常返回。</p><p>现在把前提条件以及后续条件应用到继承子类中，子类方法应该满足：</p><pre><code>前提条件不强于基类．后续条件不弱于基类．</code></pre><p>换句话说，通过基类的接口调用一个对象时，用户只知道基类前提条件以及后续条件。因此继承类不得要求用户提供比基类方法要求的更强的前提条件，亦即，继承类方法必须接受任何基类方法能接受的任何条件（参数）。同样，继承类必须顺从基类的所有后续条件，亦即，继承类方法的行为和输出不得违反由基类建立起来的任何约束，不能让用户对继承类方法的输出感到困惑。</p><p>这样，我们就有了基于契约的LSP，基于契约的LSP是LSP的一种强化。</p><h4 id="无环依赖原则"><a href="#无环依赖原则" class="headerlink" title="无环依赖原则"></a>无环依赖原则</h4><p><code>Acyclic Dependencies Principle (ADP)</code><br>包之间的依赖结构必须是一个直接的无环图形，也就是说，在依赖结构中不允许出现环（循环依赖）。如果包的依赖形成了环状结构，怎么样打破这种循环依赖呢？有2种方法可以打破这种循环依赖关系：第一种方法是创建新的包，如果A、B、C形成环路依赖，那么把这些共同类抽出来放在一个新的包D里。这样就把C依赖A变成了C依赖D以及A依赖D，从而打破了循环依赖关系。第二种方法是使用DIP（依赖倒置原则）和ISP（接口分隔原则）设计原则。</p><p>无环依赖原则（ADP）为我们解决包之间的关系耦合问题。在设计模块时，不能有循环依赖。</p><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><p><a href="https://java-design-patterns.com/" target="_blank" rel="noopener">java design patterns</a></p></blockquote><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><blockquote><p><a href="http://www.cnblogs.com/x-xk/archive/2013/01/21/2864916.html" target="_blank" rel="noopener">设计模式基础</a><br><a href="http://www.baike.com/wiki/GoF" target="_blank" rel="noopener">参考博客: GoF解释</a><br><a href="http://blog.csdn.net/column/details/zsxdesignpattern.html" target="_blank" rel="noopener">参考博客: 设计模式专栏</a></p></blockquote><blockquote><p><a href="http://blog.csdn.net/u011240877/article/details/45381071" target="_blank" rel="noopener">23种经典设计模式UML类图汇总 </a><br><a href="http://blog.csdn.net/chen4013874/article/details/51347535" target="_blank" rel="noopener">参考博客: 23种设计模式UML表示形式</a><br><a href="http://blog.csdn.net/tingting256/article/details/52534663" target="_blank" rel="noopener">参考博客: 23中设计模式类图和原理详解</a><br><a href="http://blog.csdn.net/qq_25827845/article/details/52510803" target="_blank" rel="noopener">参考博客: 23种设计模式类图总结 </a> </p></blockquote><h3 id="策略者模式"><a href="#策略者模式" class="headerlink" title="策略者模式"></a>策略者模式</h3><blockquote><p>定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。<br><a href="http://blog.csdn.net/hguisu/article/details/7558249" target="_blank" rel="noopener">参考博客: 设计模式 ( 十八 ) 策略模式Strategy（对象行为型） </a><br><a href="http://www.cnblogs.com/zdd-java/p/6143935.html" target="_blank" rel="noopener">参考博客: Java消除ifelse</a></p></blockquote><p>也就是说将一种需求的多种实现算法分别封装起来, 然后利用多态, 让调用方选择任一实现</p><h3 id="1-创建型设计模式"><a href="#1-创建型设计模式" class="headerlink" title="1.创建型设计模式"></a>1.创建型设计模式</h3><blockquote><p>单例模式(Singleton)<br>原型模式(Prototype)<br>建造者(Builder)<br>抽象工厂(Abstract Factory)<br>工厂方法(Factory Method)   </p></blockquote><ul><li>抽象了实例化过程，它们帮助一个系统独立于如何创建，组合和表示它的那些对象。</li><li>一个类创建型模型使用继承改变被实例化的类，而一个对象创建型模型将实例化委托给另一个对象</li><li>将一组固定行为的硬编码转移为定义一个较小的基本行为集，这些行为可以被组合成任意数目的更复杂性的行为。这样创建有特定行为的对象要求的不仅仅是实例化一个类</li></ul><p><em>Builder</em></p><ul><li>生成器 Builder，是一种对象构建模式，模式通常包含Builder，ConcreteBuilder。Director 和 Product四部分</li></ul><p><em>Abstract Factory</em></p><ul><li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</li></ul><p><em>Factory Method</em></p><ul><li>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类</li></ul><p><em>Prototype</em></p><ul><li>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 </li></ul><p><em>Singleton</em></p><ul><li>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li></ul><h3 id="2-结构型设计模式"><a href="#2-结构型设计模式" class="headerlink" title="2.结构型设计模式"></a>2.结构型设计模式</h3><blockquote><p>适配器模式(<strong>Adapter</strong>)<br>桥接模式(<strong>Bridge</strong>)<br>组合模式(<strong>Compontent</strong>)<br>代理模式(<strong>Proxy</strong>)<br>享元模式(<strong>Flyweight</strong>)<br>外观模式(<strong>Facade</strong>)<br>装饰模式(<strong>Decorator</strong>)  </p></blockquote><ul><li>结构型设计模式涉及如何组合类和对象以获得更大的结构</li><li>结构型模式采用继承机制来组合接口或实现。</li><li>结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能</li></ul><hr><ul><li><strong>Composite模式</strong><br>它将对象组合成树形结构以表示“部分-整体”</li><li><strong>Flyweight模式</strong><br>该模式为共享对象定义了一个结构，强调对象的空间效率，自由共享</li><li><p><strong>Facade模式</strong>（外观模式）<br>描述了如何用单个对象表示整个子系统（外部与其内部通信必须通过一个统一的对象进行交互），模式中的facade用来表示一组对象，<br>外观设计模式提供一个高层次的接口是的子系统易于使用。<br><strong>适用情况:</strong></p><blockquote><p> 1.为复杂的子系统提供一个简单的接口<br> 2.客户程序与抽象类的实现部分有很大依赖性<br> 3.构建一个层次结构的子系统时，适用外观模式定义子系统每层的入口</p></blockquote></li><li><p><strong>Bridge模式</strong> 将对象的抽象和实现分离，从而可以独立的改变他们。</p></li><li><strong>Decorator模式</strong><br>描述如何动态地为对象添加职责，模式采用递归方式组合对象，从而允许添加任意多的对象职责。</li></ul><h3 id="3-行为设计模式"><a href="#3-行为设计模式" class="headerlink" title="3.行为设计模式"></a>3.行为设计模式</h3><blockquote><p>策略模式(<strong>Strategy</strong>)<br>命令模式(<strong>Command</strong>)<br>状态模式(<strong>State</strong>)<br>解释器模式(<strong>Interpreter</strong>)<br>模板方法(<strong>Template Method</strong>)<br>责任链模式(<strong>Chain of Responsibility</strong>)<br>迭代器模式(<strong>Iterator</strong>)<br>中介者模式(<strong>Mediator</strong>)<br>备忘录模式(<strong>Memento</strong>)<br>观察者模式(<strong>Observe</strong>)<br>访问者模式(<strong>Visitor</strong>)  </p></blockquote><ul><li>行为设计模式涉及算法和对象间职责的分配，行为模式描述对象和类的模式以及其通信模式</li><li>行为模式使用继承机制在类间派发行为</li></ul><hr><h3 id="【常见设计模式】"><a href="#【常见设计模式】" class="headerlink" title="【常见设计模式】"></a>【常见设计模式】</h3><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><ul><li><strong>适配器 模式</strong>（Adapter）：适配器是的一个接口与其他接口兼容，从而给出了多个不同接口的同一抽象。一般分类结构和对象结构两种：</li><li><em>类适配器</em>：适配器类继承被适配类，实现某个接口，在客户端类中可以根据需求来建立子类</li><li><em>对象适配器</em>：适配器不是继承，是使用直接关联，或称委托方式<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/UML/Adapter.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><ul><li><strong>中介者 模式</strong>：包装了一系列对象相互作用的方式，使得对象间的相互作用是独立变化，但是与中介者紧密联系</li></ul><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ul><li><strong>观察者 模式 Observer</strong>：一个目标物件管理相依于它的管理物件，并且在它本身的状态发生改变时发出通知，这种模式常用来实现事件处理系统。（也称发布-订阅，模型-视图，源-收听者模式）<ul><li>观察者（接口）：更新信息，展示信息，给 <strong>被观察者（形参）</strong> 注册上观察者</li><li>被观察者（接口）：发出更新通知（遍历观察者集合并注册），当自身发生改动时发出通知消息</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Observer.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><blockquote><p>Singleton 一个类只有一个实例易于外界访问 Spring将该模式运用的出神入化</p></blockquote><ul><li><a href="http://www.cnblogs.com/atwanli/articles/5104898.html" target="_blank" rel="noopener">单例模式与高并发</a>当某个单例对象中含有不具有并发性的对象 就会发生并发问题, 由于只有一个对象, 为了确保数据一致, 就需要加锁, 这样就带来了严重的性能下降, 而Spring是怎么做的呢<ul><li><a href="https://blog.csdn.net/java_fancy/article/details/7439657" target="_blank" rel="noopener">参考博客 Spring如何处理线程并发</a></li><li><a href="https://bbs.csdn.net/topics/390873889" target="_blank" rel="noopener">参考博客: springmvc是单例的，开发的时候会不会影响性能呢？</a></li><li><a href="http://www.xuebuyuan.com/1628190.html" target="_blank" rel="noopener">参考博客: Spring并发访问的线程安全性问题</a> <code>Controller或者Service层中定义共享对象, 但是使用线程安全对象</code></li></ul></li></ul><blockquote><p><a href="https://bbs.csdn.net/topics/310136305" target="_blank" rel="noopener">参考博客: 单例模式和Static的区别! </a> </p><ul><li style="list-style: none"><input type="checkbox"> <code>static 有可能被实例化多个出来么</code></li></ul></blockquote><h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h5><ul><li><strong>装饰器模式</strong> 创建一个新类为某一个类动态添加新功能或增强原有的功能，避免代码重复或具体子类的数量增加</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Decorator.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>策略模式</strong> 优点：灵活添加同一问题的不同解决方案</li><li><strong>状态模式</strong> 允许对象在内部状态时变更其行为，并且修改其类：<ul><li>环境类（Context）：定义客户感兴趣的接口，维护一个子类的实例，这个实例就是当前状态</li><li>抽象状态类（State）：定义一个接口以封装与Context的一个特定状态相关的行为</li><li>具体状态类（concreteState）：每一子类实现与Context的一个状态相关的行为</li><li><strong>例题</strong>：纸巾售卖机:有四个状态!<ul><li>【状态图】</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/State_zhijin.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>【类图】</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/State_zhijin2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul></li><li><strong>例题</strong>：TCP连接状态:<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/State_TCP.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul></li><li><strong>命令模式 command</strong>：<ul><li>行为请求者 与 请求实现者 之间 紧耦合 的关系</li><li><strong>将一个请求封装成一个对象</strong>，从而可用不同的请求对客户进行参数化，支持可撤销的操作</li><li>下例：使用了接口来实现多态，子类是多个的，方法同名并功能多样的<ul><li>代码复用好，代码结构清晰【参数类表最好不要出现标志变量，最好分离出另一个方法】</li></ul></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Command.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>桥接模式</strong> ： 便于扩展，实现与抽象分离（解耦）对一个模块修改不影响别的模块</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Bridge.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>抽象工厂模式</strong> ： 提供一个创建一系列相关实例相互依赖的对象。<ul><li>当一个系统要独立于它的产品的创建，组合和表示时</li><li>当一个系统要由多个产品系列中的一个来配置时</li><li>当需强调一系列相关的产品对象的设计以便进行联合使用时</li><li>想提供一组对象而不显示他们的实现过程，只显示他们的接口</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/AbstractFactory.png" alt=""></p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><blockquote><p>struts2 就是采用该模式</p><ul><li><strong>原型模式</strong> ： 对象创建模型： 允许一个对象创建另一个可定制的对象，封装实例化细节。<ul><li>实现Cloneable接口（Java自带接口），重写clone方法（在这里实例化对象，new或反射，按需求来修改）</li><li>该例，组合关系，在对方使用clone来代替构造器来实例化对象，并做好了绑定操作，大量减少代码量</li></ul></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Clone.png" alt=""> </p><h4 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h4><ul><li><strong>生成器模式</strong>：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Model/Builder.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><ul><li><a href="https://www.ibm.com/developerworks/cn/java/design/" target="_blank" rel="noopener">IBM 社区 Java 设计模式专题</a></li><li><a href="http://www.cnblogs.com/x-xk/archive/2012/12/21/2823401.html" target="_blank" rel="noopener">一个鸭子游戏引发的设计（多态，继承，抽象，接口，策略者模式）</a></li><li><p><a href="www.cnblogs.com/x-xk/archive/2013/01/06/2830742.html">不要再盲目的new了！你要学着针对接口编程！（具体方法，Factory，Abstract Factory</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/aGMz1u0Oh4ZHTDBFvgq0lg" target="_blank" rel="noopener">参考博客: 为什么我墙裂建议大家使用枚举来实现单例。</a></p></li><li style="list-style: none"><input type="checkbox"> 自己用Java重写一下这个例子, 并做出自己的总结</li></ul><p>反模式<br>末日金字塔: 多层嵌套</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#设计模式之禅&quot;&gt;设计模式之禅&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#软件设计的一些原则&quot;&gt;软件设计的一些原则&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#思维原则&quot;&gt;思维
      
    
    </summary>
    
      <category term="基础" scheme="http://blog.kuangcp.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="设计模式" scheme="http://blog.kuangcp.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>RESTful</title>
    <link href="http://blog.kuangcp.top/2018/12/20/Memo-Java-RESTful/"/>
    <id>http://blog.kuangcp.top/2018/12/20/Memo-Java-RESTful/</id>
    <published>2018-12-20T02:43:20.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#restful风格">RESTful风格</a><ol><li><a href="#rest">Rest</a><ol><li><a href="#资源-resources">资源 Resources</a></li><li><a href="#表现层-representation">表现层 Representation</a></li><li><a href="#状态转化-state-transfer">状态转化 State Transfer</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-20 10:44</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="RESTful风格"><a href="#RESTful风格" class="headerlink" title="RESTful风格"></a>RESTful风格</h1><blockquote><p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</p></blockquote><h2 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h2><blockquote><p>Representational State Transfer  表现层状态转化<br>如果一个架构符合REST原则，就称它为RESTful架构。</p></blockquote><blockquote><p><a href="http://www.pythondoc.com/flask-restful/first.html" target="_blank" rel="noopener">参考自 使用 Python 和 Flask 设计 RESTful API</a></p><ul><li>六条设计规范定义了一个 REST 系统的特点:<ul><li>客户端-服务器: 客户端和服务器之间隔离，服务器提供服务，客户端进行消费。</li><li>无状态: 从客户端到服务器的每个请求都必须包含理解请求所必需的信息。换句话说， 服务器不会存储客户端上一次请求的信息用来给下一次使用。</li><li>可缓存: 服务器必须明示客户端请求能否缓存。</li><li>分层系统: 客户端和服务器之间的通信应该以一种标准的方式，就是中间层代替服务器做出响应的时候，客户端不需要做任何变动。</li><li>统一的接口: 服务器和客户端的通信方法必须是统一的。</li><li>按需编码: 服务器可以提供可执行代码或脚本，为客户端在它们的环境中执行。这个约束是唯一一个是可选的。</li></ul></li></ul></blockquote><blockquote><p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">参考博客: 理解RESTful架构</a><br>“QuestionSeconds”:1,<br>“Question”:”请按顺序查找数字”,</p></blockquote><blockquote><p><a href="https://segmentfault.com/a/1190000002949234" target="_blank" rel="noopener">RESTful Best Practices</a><br><a href="http://www.infoq.com/cn/articles/understanding-restful-style" target="_blank" rel="noopener">理解本真的REST架构风格</a><br><a href="https://blog.csdn.net/wy5612087/article/details/52149249" target="_blank" rel="noopener">RESTful风格的springMVC</a></p></blockquote><h3 id="资源-Resources"><a href="#资源-Resources" class="headerlink" title="资源 Resources"></a>资源 Resources</h3><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。<br>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。<br>你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。<br>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><h3 id="表现层-Representation"><a href="#表现层-Representation" class="headerlink" title="表现层 Representation"></a>表现层 Representation</h3><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。<br>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。<br>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。<br>它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><h3 id="状态转化-State-Transfer"><a href="#状态转化-State-Transfer" class="headerlink" title="状态转化 State Transfer"></a>状态转化 State Transfer</h3><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。<br>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。<br>而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。<br>它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p><hr><blockquote><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">阮一峰 RESTful API 设计指南</a><code>很细致的说明该规范</code></p></blockquote><ul><li style="list-style: none"><input type="checkbox"> 需要整理和计划如何规范化实现这个接口</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#restful风格&quot;&gt;RESTful风格&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#rest&quot;&gt;Rest&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#资源-resources
      
    
    </summary>
    
      <category term="基础" scheme="http://blog.kuangcp.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Restful" scheme="http://blog.kuangcp.top/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>MIS</title>
    <link href="http://blog.kuangcp.top/2018/12/20/Memo-Java-MIS/"/>
    <id>http://blog.kuangcp.top/2018/12/20/Memo-Java-MIS/</id>
    <published>2018-12-20T02:42:29.000Z</published>
    <updated>2018-12-21T03:02:53.346Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录 start</strong></p><ol><li><a href="#完整的mis构建经验">完整的MIS构建经验</a><ol><li><a href="#mvc">MVC</a><ol><li><a href="#持久化层">持久化层</a><ol><li><a href="#数据库设计">数据库设计</a></li><li><a href="#domain对象设计">Domain对象设计</a></li></ol></li><li><a href="#控制层">控制层</a><ol><li><a href="#权限控制">权限控制</a><ol><li><a href="#session和token的对比">Session和Token的对比</a></li><li><a href="#统一授权">统一授权</a></li></ol></li></ol></li><li><a href="#视图层">视图层</a></li></ol></li><li><a href="#分布式">分布式</a><ol><li><a href="#cap定理">CAP定理</a></li></ol></li></ol></li></ol><p><strong>目录 end</strong>|<em>2018-12-20 10:44</em>| <a href="https://gitee.com/gin9" target="_blank" rel="noopener">码云</a> | <a href="http://blog.csdn.net/kcp606" target="_blank" rel="noopener">CSDN</a> | <a href="https://my.oschina.net/kcp1104" target="_blank" rel="noopener">OSChina</a> | <a href="http://www.cnblogs.com/kuangcp" target="_blank" rel="noopener">cnblogs</a></p><hr><h1 id="完整的MIS构建经验"><a href="#完整的MIS构建经验" class="headerlink" title="完整的MIS构建经验"></a>完整的MIS构建经验</h1><blockquote><p>MIS: Management information system</p></blockquote><ul><li><a href="https://github.com/jeansfish/RFC6749.zh-cn/blob/master/index.md" target="_blank" rel="noopener">OAuth 2.0授权框架</a></li></ul><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><h3 id="持久化层"><a href="#持久化层" class="headerlink" title="持久化层"></a>持久化层</h3><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><blockquote><p>一种极端是将业务也放在了数据库里, 使用大量的存储过程和函数<br>一种是将约束都放在了业务层, 数据库没有外键约束</p></blockquote><h4 id="Domain对象设计"><a href="#Domain对象设计" class="headerlink" title="Domain对象设计"></a>Domain对象设计</h4><ol><li>首先名称不能使用Java或者数据库中的的关键字 class group table from 等等<ul><li>班级就用ClassGroup吧</li></ul></li><li>实体间的关系映射注意死循环</li></ol><h3 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h3><blockquote><p>只是映射好URL, 调用对应的Service</p></blockquote><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><h5 id="Session和Token的对比"><a href="#Session和Token的对比" class="headerlink" title="Session和Token的对比"></a>Session和Token的对比</h5><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513566&amp;idx=1&amp;sn=a2688cadbe9c8042ff1abbdf04a8bd5e&amp;chksm=80d67a1db7a1f30b28b93ed2ab29edfbf982b780433e4bfd178e3cc52cb1f9100cc8f923db4f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:干掉状态：从session到token </a></p></blockquote><ul><li>token优势是前后端分离做起来比较简单,session在于实现快,但是容易有CSRF问题,其实token也是会有的<ul><li>如果登录和页面的跳转路由还是由后端控制的，那么Token的实现就有点没有那么必要了。（不过为了安全性能够防范CSRF）</li></ul></li></ul><h5 id="统一授权"><a href="#统一授权" class="headerlink" title="统一授权"></a>统一授权</h5><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513744&amp;idx=1&amp;sn=93d0db97cfd67422bcd21c8afd00f495&amp;chksm=80d67b53b7a1f24537fdc7c10eb2783357c1f8c65ad55601a722216d2293ae3fb7b1c16e5449&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:从密码到token，一个授权的故事</a> | <a href="/API_DOC.md#登录授权">自己收集到的相关文档</a></p></blockquote><h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><p><em>一种比较安全的iframe思路</em></p><ul><li>在主页面上写form iframe页面用来展示,这样的话,截图截不了长图,也不能保存文件,也不能打印出来(试了好多种方式去修改教务系统得到的结论)</li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513560&amp;idx=1&amp;sn=ba861726537c57bd34253cbce010b5fe&amp;chksm=80d67a1bb7a1f30df37905ce979504aa132dcaef59075577ff52f45f057734825a59f6de75c9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">码农翻身:张大胖和CAP定理</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目录 start&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#完整的mis构建经验&quot;&gt;完整的MIS构建经验&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#mvc&quot;&gt;MVC&lt;/a&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#持久化层&quot;&gt;持久化层&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.kuangcp.top/categories/Java/"/>
    
    
      <category term="MIS" scheme="http://blog.kuangcp.top/tags/MIS/"/>
    
  </entry>
  
</feed>
